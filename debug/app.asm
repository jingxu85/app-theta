
bin/app.elf:     file format elf32-littlearm


Disassembly of section .text:

c0d00000 <main>:
        }
        END_TRY;
    }
}

__attribute__((section(".boot"))) int main(int arg0) {
c0d00000:	b510      	push	{r4, lr}
c0d00002:	4604      	mov	r4, r0
    }
    END_TRY;
    // no return
#else
    // exit critical section
    __asm volatile("cpsie i");
c0d00004:	b662      	cpsie	i

    // ensure exception will work as planned
    os_boot();
c0d00006:	f004 f983 	bl	c0d04310 <os_boot>

    if (!arg0) {
c0d0000a:	2c00      	cmp	r4, #0
c0d0000c:	d00d      	beq.n	c0d0002a <main+0x2a>
c0d0000e:	2001      	movs	r0, #1
c0d00010:	0200      	lsls	r0, r0, #8
        coin_main(NULL);
        return 0;
    }

    struct libargs_s *args = (struct libargs_s *) arg0;
    if (args->id != 0x100) {
c0d00012:	6821      	ldr	r1, [r4, #0]
c0d00014:	4281      	cmp	r1, r0
c0d00016:	d105      	bne.n	c0d00024 <main+0x24>
        app_exit();
        return 0;
    }
    switch (args->command) {
c0d00018:	6860      	ldr	r0, [r4, #4]
c0d0001a:	2801      	cmp	r0, #1
c0d0001c:	d10a      	bne.n	c0d00034 <main+0x34>
        case RUN_APPLICATION:
            // coin application launched from dashboard
            if (args->chain_config == NULL)
c0d0001e:	68a0      	ldr	r0, [r4, #8]
c0d00020:	2800      	cmp	r0, #0
c0d00022:	d103      	bne.n	c0d0002c <main+0x2c>
c0d00024:	f004 f862 	bl	c0d040ec <app_exit>
c0d00028:	e002      	b.n	c0d00030 <main+0x30>
c0d0002a:	2000      	movs	r0, #0
c0d0002c:	f004 f87e 	bl	c0d0412c <coin_main>
c0d00030:	2000      	movs	r0, #0
            // called as bitcoin or altcoin library
            library_main(args);
    }
#endif
    return 0;
}
c0d00032:	bd10      	pop	{r4, pc}
            library_main(args);
c0d00034:	4620      	mov	r0, r4
c0d00036:	f004 f901 	bl	c0d0423c <library_main>
	...

c0d0003c <Base64encode>:

int Base64encode_len(int len) {
    return ((len + 2) / 3 * 4) + 1;
}

int Base64encode(char *encoded, const char *string, int len) {
c0d0003c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0003e:	b082      	sub	sp, #8
c0d00040:	4607      	mov	r7, r0
c0d00042:	9201      	str	r2, [sp, #4]
    int i;
    char *p;

    p = encoded;
    for (i = 0; i < len - 2; i += 3) {
c0d00044:	1e92      	subs	r2, r2, #2
c0d00046:	2400      	movs	r4, #0
c0d00048:	2a01      	cmp	r2, #1
c0d0004a:	db23      	blt.n	c0d00094 <Base64encode+0x58>
c0d0004c:	4e25      	ldr	r6, [pc, #148]	; (c0d000e4 <Base64encode+0xa8>)
c0d0004e:	447e      	add	r6, pc
c0d00050:	9700      	str	r7, [sp, #0]
c0d00052:	463b      	mov	r3, r7
        *p++ = basis_64[(string[i] >> 2) & 0x3F];
c0d00054:	5d0f      	ldrb	r7, [r1, r4]
c0d00056:	08bf      	lsrs	r7, r7, #2
c0d00058:	5df7      	ldrb	r7, [r6, r7]
c0d0005a:	701f      	strb	r7, [r3, #0]
c0d0005c:	190f      	adds	r7, r1, r4
        *p++ = basis_64[((string[i] & 0x3) << 4) | ((int) (string[i + 1] & 0xF0) >> 4)];
c0d0005e:	787d      	ldrb	r5, [r7, #1]
c0d00060:	092d      	lsrs	r5, r5, #4
c0d00062:	5d08      	ldrb	r0, [r1, r4]
c0d00064:	0780      	lsls	r0, r0, #30
c0d00066:	0e80      	lsrs	r0, r0, #26
c0d00068:	1940      	adds	r0, r0, r5
c0d0006a:	5c30      	ldrb	r0, [r6, r0]
c0d0006c:	7058      	strb	r0, [r3, #1]
        *p++ = basis_64[((string[i + 1] & 0xF) << 2) | ((int) (string[i + 2] & 0xC0) >> 6)];
c0d0006e:	78b8      	ldrb	r0, [r7, #2]
c0d00070:	0980      	lsrs	r0, r0, #6
c0d00072:	787d      	ldrb	r5, [r7, #1]
c0d00074:	072d      	lsls	r5, r5, #28
c0d00076:	0ead      	lsrs	r5, r5, #26
c0d00078:	1828      	adds	r0, r5, r0
c0d0007a:	5c30      	ldrb	r0, [r6, r0]
c0d0007c:	7098      	strb	r0, [r3, #2]
        *p++ = basis_64[string[i + 2] & 0x3F];
c0d0007e:	78b8      	ldrb	r0, [r7, #2]
c0d00080:	253f      	movs	r5, #63	; 0x3f
c0d00082:	4005      	ands	r5, r0
c0d00084:	5d70      	ldrb	r0, [r6, r5]
c0d00086:	70d8      	strb	r0, [r3, #3]
c0d00088:	1d1b      	adds	r3, r3, #4
    for (i = 0; i < len - 2; i += 3) {
c0d0008a:	1ce4      	adds	r4, r4, #3
c0d0008c:	4294      	cmp	r4, r2
c0d0008e:	dbe1      	blt.n	c0d00054 <Base64encode+0x18>
c0d00090:	9f00      	ldr	r7, [sp, #0]
c0d00092:	e000      	b.n	c0d00096 <Base64encode+0x5a>
c0d00094:	463b      	mov	r3, r7
c0d00096:	9a01      	ldr	r2, [sp, #4]
    }
    if (i < len) {
c0d00098:	4294      	cmp	r4, r2
c0d0009a:	da1d      	bge.n	c0d000d8 <Base64encode+0x9c>
        *p++ = basis_64[(string[i] >> 2) & 0x3F];
c0d0009c:	5d08      	ldrb	r0, [r1, r4]
c0d0009e:	0880      	lsrs	r0, r0, #2
c0d000a0:	4d11      	ldr	r5, [pc, #68]	; (c0d000e8 <Base64encode+0xac>)
c0d000a2:	447d      	add	r5, pc
c0d000a4:	5c28      	ldrb	r0, [r5, r0]
c0d000a6:	7018      	strb	r0, [r3, #0]
c0d000a8:	5d08      	ldrb	r0, [r1, r4]
c0d000aa:	0780      	lsls	r0, r0, #30
c0d000ac:	0e86      	lsrs	r6, r0, #26
        if (i == (len - 1)) {
c0d000ae:	1e50      	subs	r0, r2, #1
c0d000b0:	4284      	cmp	r4, r0
c0d000b2:	d103      	bne.n	c0d000bc <Base64encode+0x80>
            *p++ = basis_64[((string[i] & 0x3) << 4)];
c0d000b4:	5da8      	ldrb	r0, [r5, r6]
c0d000b6:	7058      	strb	r0, [r3, #1]
c0d000b8:	213d      	movs	r1, #61	; 0x3d
c0d000ba:	e009      	b.n	c0d000d0 <Base64encode+0x94>
            *p++ = '=';
        } else {
            *p++ = basis_64[((string[i] & 0x3) << 4) | ((int) (string[i + 1] & 0xF0) >> 4)];
c0d000bc:	1908      	adds	r0, r1, r4
c0d000be:	7841      	ldrb	r1, [r0, #1]
c0d000c0:	0909      	lsrs	r1, r1, #4
c0d000c2:	4331      	orrs	r1, r6
c0d000c4:	5c69      	ldrb	r1, [r5, r1]
c0d000c6:	7059      	strb	r1, [r3, #1]
            *p++ = basis_64[((string[i + 1] & 0xF) << 2)];
c0d000c8:	7840      	ldrb	r0, [r0, #1]
c0d000ca:	0700      	lsls	r0, r0, #28
c0d000cc:	0e80      	lsrs	r0, r0, #26
c0d000ce:	5c29      	ldrb	r1, [r5, r0]
c0d000d0:	203d      	movs	r0, #61	; 0x3d
        }
        *p++ = '=';
c0d000d2:	70d8      	strb	r0, [r3, #3]
            *p++ = basis_64[((string[i + 1] & 0xF) << 2)];
c0d000d4:	7099      	strb	r1, [r3, #2]
        *p++ = '=';
c0d000d6:	1d1b      	adds	r3, r3, #4
c0d000d8:	2000      	movs	r0, #0
    }

    *p++ = '\0';
c0d000da:	7018      	strb	r0, [r3, #0]
c0d000dc:	1c58      	adds	r0, r3, #1
    return p - encoded;
c0d000de:	1bc0      	subs	r0, r0, r7
c0d000e0:	b002      	add	sp, #8
c0d000e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d000e4:	0000ab12 	.word	0x0000ab12
c0d000e8:	0000aabe 	.word	0x0000aabe

c0d000ec <check_audited_app>:

// This function is called at the end of the seph initialization.
// It checks the install parameters of the application to be run, and if this area contains the
// CHECK_NOT_AUDITED_TLV_TAG tag with the CHECK_NOT_AUDITED_TLV_VAL value, a specific display
// is triggered before the actual application's splash screen.
void check_audited_app(void) {
c0d000ec:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d000ee:	b089      	sub	sp, #36	; 0x24
c0d000f0:	ac08      	add	r4, sp, #32
c0d000f2:	2055      	movs	r0, #85	; 0x55
  unsigned char     data = BOLOS_FALSE;
c0d000f4:	7020      	strb	r0, [r4, #0]
  unsigned char*    buffer = &data;
c0d000f6:	9407      	str	r4, [sp, #28]
c0d000f8:	2001      	movs	r0, #1
  unsigned int      length = os_parse_bertlv((unsigned char*)(&_install_parameters),
c0d000fa:	4669      	mov	r1, sp
c0d000fc:	6088      	str	r0, [r1, #8]
c0d000fe:	a807      	add	r0, sp, #28
c0d00100:	6048      	str	r0, [r1, #4]
c0d00102:	2600      	movs	r6, #0
c0d00104:	600e      	str	r6, [r1, #0]
c0d00106:	4872      	ldr	r0, [pc, #456]	; (c0d002d0 <check_audited_app+0x1e4>)
c0d00108:	4478      	add	r0, pc
c0d0010a:	2140      	movs	r1, #64	; 0x40
c0d0010c:	239f      	movs	r3, #159	; 0x9f
c0d0010e:	4632      	mov	r2, r6
c0d00110:	f004 f964 	bl	c0d043dc <os_parse_bertlv>
                                             sizeof(data));

  // We trigger the associated behaviour only when the tag was present and the value corresponds to
  // the expected one.
  if (   (length)
      && (CHECK_NOT_AUDITED_TLV_VAL == data))
c0d00114:	2800      	cmp	r0, #0
c0d00116:	d100      	bne.n	c0d0011a <check_audited_app+0x2e>
c0d00118:	e0d2      	b.n	c0d002c0 <check_audited_app+0x1d4>
c0d0011a:	7820      	ldrb	r0, [r4, #0]
c0d0011c:	2801      	cmp	r0, #1
c0d0011e:	d000      	beq.n	c0d00122 <check_audited_app+0x36>
c0d00120:	e0ce      	b.n	c0d002c0 <check_audited_app+0x1d4>
  {
    // We reserve the first slot for this display.
    ux_stack_push();
c0d00122:	f00a f935 	bl	c0d0a390 <ux_stack_push>
    ux_stack_init(0);
c0d00126:	4630      	mov	r0, r6
c0d00128:	f00a f9a2 	bl	c0d0a470 <ux_stack_init>
c0d0012c:	21d0      	movs	r1, #208	; 0xd0

    // We trigger the additional display and wait for it to be completed.
    UX_DISPLAY(ui_audited_elements, NULL);
c0d0012e:	4d65      	ldr	r5, [pc, #404]	; (c0d002c4 <check_audited_app+0x1d8>)
c0d00130:	4868      	ldr	r0, [pc, #416]	; (c0d002d4 <check_audited_app+0x1e8>)
c0d00132:	4478      	add	r0, pc
c0d00134:	9103      	str	r1, [sp, #12]
c0d00136:	5068      	str	r0, [r5, r1]
c0d00138:	27c4      	movs	r7, #196	; 0xc4
c0d0013a:	2303      	movs	r3, #3
c0d0013c:	55eb      	strb	r3, [r5, r7]
c0d0013e:	22c0      	movs	r2, #192	; 0xc0
c0d00140:	4965      	ldr	r1, [pc, #404]	; (c0d002d8 <check_audited_app+0x1ec>)
c0d00142:	4479      	add	r1, pc
c0d00144:	9204      	str	r2, [sp, #16]
c0d00146:	50a9      	str	r1, [r5, r2]
c0d00148:	21cc      	movs	r1, #204	; 0xcc
c0d0014a:	9106      	str	r1, [sp, #24]
c0d0014c:	506e      	str	r6, [r5, r1]
c0d0014e:	485e      	ldr	r0, [pc, #376]	; (c0d002c8 <check_audited_app+0x1dc>)
c0d00150:	6046      	str	r6, [r0, #4]
c0d00152:	7003      	strb	r3, [r0, #0]
c0d00154:	4604      	mov	r4, r0
c0d00156:	f006 fc9f 	bl	c0d06a98 <os_ux>
c0d0015a:	2004      	movs	r0, #4
c0d0015c:	9005      	str	r0, [sp, #20]
c0d0015e:	f006 fd23 	bl	c0d06ba8 <os_sched_last_status>
c0d00162:	6060      	str	r0, [r4, #4]
c0d00164:	f004 fb6c 	bl	c0d04840 <io_seproxyhal_init_ux>
c0d00168:	f004 fb6c 	bl	c0d04844 <io_seproxyhal_init_button>
c0d0016c:	24be      	movs	r4, #190	; 0xbe
c0d0016e:	532e      	strh	r6, [r5, r4]
c0d00170:	9805      	ldr	r0, [sp, #20]
c0d00172:	f006 fd19 	bl	c0d06ba8 <os_sched_last_status>
c0d00176:	4954      	ldr	r1, [pc, #336]	; (c0d002c8 <check_audited_app+0x1dc>)
c0d00178:	6048      	str	r0, [r1, #4]
c0d0017a:	2800      	cmp	r0, #0
c0d0017c:	d032      	beq.n	c0d001e4 <check_audited_app+0xf8>
c0d0017e:	2897      	cmp	r0, #151	; 0x97
c0d00180:	d030      	beq.n	c0d001e4 <check_audited_app+0xf8>
c0d00182:	9804      	ldr	r0, [sp, #16]
c0d00184:	5828      	ldr	r0, [r5, r0]
c0d00186:	2800      	cmp	r0, #0
c0d00188:	d02c      	beq.n	c0d001e4 <check_audited_app+0xf8>
c0d0018a:	5b28      	ldrh	r0, [r5, r4]
c0d0018c:	5de9      	ldrb	r1, [r5, r7]
c0d0018e:	b280      	uxth	r0, r0
c0d00190:	4288      	cmp	r0, r1
c0d00192:	d227      	bcs.n	c0d001e4 <check_audited_app+0xf8>
c0d00194:	f006 fcd4 	bl	c0d06b40 <io_seph_is_status_sent>
c0d00198:	2800      	cmp	r0, #0
c0d0019a:	d123      	bne.n	c0d001e4 <check_audited_app+0xf8>
c0d0019c:	f006 fc46 	bl	c0d06a2c <os_perso_isonboarded>
c0d001a0:	28aa      	cmp	r0, #170	; 0xaa
c0d001a2:	d103      	bne.n	c0d001ac <check_audited_app+0xc0>
c0d001a4:	f006 fc6c 	bl	c0d06a80 <os_global_pin_is_validated>
c0d001a8:	28aa      	cmp	r0, #170	; 0xaa
c0d001aa:	d11b      	bne.n	c0d001e4 <check_audited_app+0xf8>
c0d001ac:	9804      	ldr	r0, [sp, #16]
c0d001ae:	5828      	ldr	r0, [r5, r0]
c0d001b0:	5b29      	ldrh	r1, [r5, r4]
c0d001b2:	0149      	lsls	r1, r1, #5
c0d001b4:	1840      	adds	r0, r0, r1
c0d001b6:	9906      	ldr	r1, [sp, #24]
c0d001b8:	5869      	ldr	r1, [r5, r1]
c0d001ba:	2900      	cmp	r1, #0
c0d001bc:	d002      	beq.n	c0d001c4 <check_audited_app+0xd8>
c0d001be:	4788      	blx	r1
c0d001c0:	2800      	cmp	r0, #0
c0d001c2:	d008      	beq.n	c0d001d6 <check_audited_app+0xea>
c0d001c4:	2801      	cmp	r0, #1
c0d001c6:	d104      	bne.n	c0d001d2 <check_audited_app+0xe6>
c0d001c8:	9804      	ldr	r0, [sp, #16]
c0d001ca:	5828      	ldr	r0, [r5, r0]
c0d001cc:	5b29      	ldrh	r1, [r5, r4]
c0d001ce:	0149      	lsls	r1, r1, #5
c0d001d0:	1840      	adds	r0, r0, r1
c0d001d2:	f003 fdad 	bl	c0d03d30 <io_seproxyhal_display>
c0d001d6:	5b28      	ldrh	r0, [r5, r4]
c0d001d8:	1c40      	adds	r0, r0, #1
c0d001da:	5328      	strh	r0, [r5, r4]
c0d001dc:	9904      	ldr	r1, [sp, #16]
c0d001de:	5869      	ldr	r1, [r5, r1]
c0d001e0:	2900      	cmp	r1, #0
c0d001e2:	d1d3      	bne.n	c0d0018c <check_audited_app+0xa0>
    UX_WAIT_DISPLAYED();
c0d001e4:	5dee      	ldrb	r6, [r5, r7]
c0d001e6:	5b28      	ldrh	r0, [r5, r4]
c0d001e8:	9005      	str	r0, [sp, #20]
c0d001ea:	4838      	ldr	r0, [pc, #224]	; (c0d002cc <check_audited_app+0x1e0>)
c0d001ec:	2148      	movs	r1, #72	; 0x48
c0d001ee:	2200      	movs	r2, #0
c0d001f0:	f006 fcb2 	bl	c0d06b58 <io_seph_recv>
c0d001f4:	f004 fac4 	bl	c0d04780 <io_seproxyhal_handle_event>
c0d001f8:	9805      	ldr	r0, [sp, #20]
c0d001fa:	42b0      	cmp	r0, r6
c0d001fc:	d23c      	bcs.n	c0d00278 <check_audited_app+0x18c>
c0d001fe:	9e04      	ldr	r6, [sp, #16]
c0d00200:	59a8      	ldr	r0, [r5, r6]
c0d00202:	2800      	cmp	r0, #0
c0d00204:	d029      	beq.n	c0d0025a <check_audited_app+0x16e>
c0d00206:	5b28      	ldrh	r0, [r5, r4]
c0d00208:	5de9      	ldrb	r1, [r5, r7]
c0d0020a:	b280      	uxth	r0, r0
c0d0020c:	4288      	cmp	r0, r1
c0d0020e:	d224      	bcs.n	c0d0025a <check_audited_app+0x16e>
c0d00210:	f006 fc96 	bl	c0d06b40 <io_seph_is_status_sent>
c0d00214:	2800      	cmp	r0, #0
c0d00216:	d120      	bne.n	c0d0025a <check_audited_app+0x16e>
c0d00218:	f006 fc08 	bl	c0d06a2c <os_perso_isonboarded>
c0d0021c:	28aa      	cmp	r0, #170	; 0xaa
c0d0021e:	d103      	bne.n	c0d00228 <check_audited_app+0x13c>
c0d00220:	f006 fc2e 	bl	c0d06a80 <os_global_pin_is_validated>
c0d00224:	28aa      	cmp	r0, #170	; 0xaa
c0d00226:	d118      	bne.n	c0d0025a <check_audited_app+0x16e>
c0d00228:	59a8      	ldr	r0, [r5, r6]
c0d0022a:	5b29      	ldrh	r1, [r5, r4]
c0d0022c:	0149      	lsls	r1, r1, #5
c0d0022e:	1840      	adds	r0, r0, r1
c0d00230:	9906      	ldr	r1, [sp, #24]
c0d00232:	5869      	ldr	r1, [r5, r1]
c0d00234:	2900      	cmp	r1, #0
c0d00236:	d002      	beq.n	c0d0023e <check_audited_app+0x152>
c0d00238:	4788      	blx	r1
c0d0023a:	2800      	cmp	r0, #0
c0d0023c:	d007      	beq.n	c0d0024e <check_audited_app+0x162>
c0d0023e:	2801      	cmp	r0, #1
c0d00240:	d103      	bne.n	c0d0024a <check_audited_app+0x15e>
c0d00242:	59a8      	ldr	r0, [r5, r6]
c0d00244:	5b29      	ldrh	r1, [r5, r4]
c0d00246:	0149      	lsls	r1, r1, #5
c0d00248:	1840      	adds	r0, r0, r1
c0d0024a:	f003 fd71 	bl	c0d03d30 <io_seproxyhal_display>
c0d0024e:	5b28      	ldrh	r0, [r5, r4]
c0d00250:	1c40      	adds	r0, r0, #1
c0d00252:	5328      	strh	r0, [r5, r4]
c0d00254:	59a9      	ldr	r1, [r5, r6]
c0d00256:	2900      	cmp	r1, #0
c0d00258:	d1d6      	bne.n	c0d00208 <check_audited_app+0x11c>
c0d0025a:	5de8      	ldrb	r0, [r5, r7]
c0d0025c:	9005      	str	r0, [sp, #20]
c0d0025e:	463e      	mov	r6, r7
c0d00260:	5b2f      	ldrh	r7, [r5, r4]
c0d00262:	2148      	movs	r1, #72	; 0x48
c0d00264:	2200      	movs	r2, #0
c0d00266:	4819      	ldr	r0, [pc, #100]	; (c0d002cc <check_audited_app+0x1e0>)
c0d00268:	f006 fc76 	bl	c0d06b58 <io_seph_recv>
c0d0026c:	f004 fa88 	bl	c0d04780 <io_seproxyhal_handle_event>
c0d00270:	9805      	ldr	r0, [sp, #20]
c0d00272:	4287      	cmp	r7, r0
c0d00274:	4637      	mov	r7, r6
c0d00276:	d3c2      	bcc.n	c0d001fe <check_audited_app+0x112>
c0d00278:	f004 f99c 	bl	c0d045b4 <io_seproxyhal_general_status>
c0d0027c:	4c13      	ldr	r4, [pc, #76]	; (c0d002cc <check_audited_app+0x1e0>)
c0d0027e:	2148      	movs	r1, #72	; 0x48
c0d00280:	2200      	movs	r2, #0
c0d00282:	4620      	mov	r0, r4
c0d00284:	f006 fc68 	bl	c0d06b58 <io_seph_recv>

    io_seproxyhal_general_status();
c0d00288:	f004 f994 	bl	c0d045b4 <io_seproxyhal_general_status>
c0d0028c:	9e03      	ldr	r6, [sp, #12]
c0d0028e:	2148      	movs	r1, #72	; 0x48
c0d00290:	2200      	movs	r2, #0

    // We wait for the button callback pointer to wiped, and we process the incoming MCU events in the
    // meantime. This callback will be wiped within the actual 'ui_audited_elements_button' function,
    // as soon as the user presses both buttons.
    do {
      io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d00292:	4620      	mov	r0, r4
c0d00294:	f006 fc60 	bl	c0d06b58 <io_seph_recv>
      io_seproxyhal_handle_event();
c0d00298:	f004 fa72 	bl	c0d04780 <io_seproxyhal_handle_event>
    } while (io_seproxyhal_spi_is_status_sent() && G_ux.stack[0].button_push_callback);
c0d0029c:	f006 fc50 	bl	c0d06b40 <io_seph_is_status_sent>
c0d002a0:	2800      	cmp	r0, #0
c0d002a2:	d002      	beq.n	c0d002aa <check_audited_app+0x1be>
c0d002a4:	59a8      	ldr	r0, [r5, r6]
c0d002a6:	2800      	cmp	r0, #0
c0d002a8:	d1f1      	bne.n	c0d0028e <check_audited_app+0x1a2>

    // We pop the reserved slot but we do not care about the returned value (since we do not need it for
    // further displays at the moment) and reinitialize the UX and buttons.
    ux_stack_pop();
c0d002aa:	f00a f88d 	bl	c0d0a3c8 <ux_stack_pop>
    io_seproxyhal_init_ux();
c0d002ae:	f004 fac7 	bl	c0d04840 <io_seproxyhal_init_ux>
    io_seproxyhal_init_button();
c0d002b2:	f004 fac7 	bl	c0d04844 <io_seproxyhal_init_button>

    // Now we can wait for the next MCU status and exit.
    io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d002b6:	4805      	ldr	r0, [pc, #20]	; (c0d002cc <check_audited_app+0x1e0>)
c0d002b8:	2148      	movs	r1, #72	; 0x48
c0d002ba:	2200      	movs	r2, #0
c0d002bc:	f006 fc4c 	bl	c0d06b58 <io_seph_recv>
  }
}
c0d002c0:	b009      	add	sp, #36	; 0x24
c0d002c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d002c4:	20001a00 	.word	0x20001a00
c0d002c8:	20001b48 	.word	0x20001b48
c0d002cc:	20001b00 	.word	0x20001b00
c0d002d0:	0000d6f4 	.word	0x0000d6f4
c0d002d4:	000001a7 	.word	0x000001a7
c0d002d8:	0000aa76 	.word	0x0000aa76

c0d002dc <ui_audited_elements_button>:
static unsigned int ui_audited_elements_button(unsigned int button_mask, unsigned int button_mask_counter) {
c0d002dc:	4904      	ldr	r1, [pc, #16]	; (c0d002f0 <ui_audited_elements_button+0x14>)
  if ((button_mask & (BUTTON_EVT_RELEASED | BUTTON_LEFT | BUTTON_RIGHT)) == (BUTTON_EVT_RELEASED | BUTTON_LEFT | BUTTON_RIGHT)) {
c0d002de:	4008      	ands	r0, r1
c0d002e0:	4288      	cmp	r0, r1
c0d002e2:	d103      	bne.n	c0d002ec <ui_audited_elements_button+0x10>
c0d002e4:	20d0      	movs	r0, #208	; 0xd0
    G_ux.stack[0].button_push_callback = NULL;
c0d002e6:	4903      	ldr	r1, [pc, #12]	; (c0d002f4 <ui_audited_elements_button+0x18>)
c0d002e8:	2200      	movs	r2, #0
c0d002ea:	500a      	str	r2, [r1, r0]
c0d002ec:	2000      	movs	r0, #0
  return 0;
c0d002ee:	4770      	bx	lr
c0d002f0:	80000003 	.word	0x80000003
c0d002f4:	20001a00 	.word	0x20001a00

c0d002f8 <handleGetAppConfiguration>:
    UNUSED(p1);
    UNUSED(p2);
    UNUSED(workBuffer);
    UNUSED(dataLength);
    UNUSED(flags);
    G_io_apdu_buffer[0] = (N_storage.dataAllowed ? APP_FLAG_DATA_ALLOWED : 0x00);
c0d002f8:	480c      	ldr	r0, [pc, #48]	; (c0d0032c <handleGetAppConfiguration+0x34>)
c0d002fa:	4478      	add	r0, pc
c0d002fc:	f005 fa1c 	bl	c0d05738 <pic>
c0d00300:	7801      	ldrb	r1, [r0, #0]
#ifndef HAVE_TOKENS_LIST
    G_io_apdu_buffer[0] |= APP_FLAG_EXTERNAL_TOKEN_NEEDED;
#endif
#ifdef HAVE_STARKWARE
    G_io_apdu_buffer[0] |= APP_FLAG_STARKWARE;
    G_io_apdu_buffer[0] |= APP_FLAG_STARKWARE_V2;
c0d00302:	4809      	ldr	r0, [pc, #36]	; (c0d00328 <handleGetAppConfiguration+0x30>)
c0d00304:	2200      	movs	r2, #0
#endif
    G_io_apdu_buffer[1] = LEDGER_MAJOR_VERSION;
    G_io_apdu_buffer[2] = LEDGER_MINOR_VERSION;
    G_io_apdu_buffer[3] = LEDGER_PATCH_VERSION;
c0d00306:	70c2      	strb	r2, [r0, #3]
    G_io_apdu_buffer[2] = LEDGER_MINOR_VERSION;
c0d00308:	7082      	strb	r2, [r0, #2]
c0d0030a:	2201      	movs	r2, #1
    G_io_apdu_buffer[1] = LEDGER_MAJOR_VERSION;
c0d0030c:	7042      	strb	r2, [r0, #1]
    G_io_apdu_buffer[0] = (N_storage.dataAllowed ? APP_FLAG_DATA_ALLOWED : 0x00);
c0d0030e:	2900      	cmp	r1, #0
c0d00310:	d100      	bne.n	c0d00314 <handleGetAppConfiguration+0x1c>
c0d00312:	460a      	mov	r2, r1
    G_io_apdu_buffer[0] |= APP_FLAG_STARKWARE_V2;
c0d00314:	320e      	adds	r2, #14
c0d00316:	7002      	strb	r2, [r0, #0]
c0d00318:	9801      	ldr	r0, [sp, #4]
c0d0031a:	2104      	movs	r1, #4
    *tx = 4;
c0d0031c:	6001      	str	r1, [r0, #0]
c0d0031e:	2009      	movs	r0, #9
c0d00320:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0d00322:	f004 f82f 	bl	c0d04384 <os_longjmp>
c0d00326:	46c0      	nop			; (mov r8, r8)
c0d00328:	20001f09 	.word	0x20001f09
c0d0032c:	0000d4c2 	.word	0x0000d4c2

c0d00330 <handleGetPublicKey>:
void handleGetPublicKey(uint8_t p1,
                        uint8_t p2,
                        uint8_t *dataBuffer,
                        uint16_t dataLength,
                        unsigned int *flags,
                        unsigned int *tx) {
c0d00330:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00332:	b0a1      	sub	sp, #132	; 0x84
c0d00334:	4617      	mov	r7, r2
c0d00336:	460e      	mov	r6, r1
c0d00338:	4604      	mov	r4, r0
    UNUSED(dataLength);
    uint8_t privateKeyData[32];
    uint32_t bip32Path[MAX_BIP32_PATH];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer++);
c0d0033a:	7815      	ldrb	r5, [r2, #0]
    cx_ecfp_private_key_t privateKey;
    if (!called_from_swap) {
c0d0033c:	4846      	ldr	r0, [pc, #280]	; (c0d00458 <handleGetPublicKey+0x128>)
c0d0033e:	7800      	ldrb	r0, [r0, #0]
c0d00340:	2800      	cmp	r0, #0
c0d00342:	d101      	bne.n	c0d00348 <handleGetPublicKey+0x18>
        reset_app_context();
c0d00344:	f003 fa82 	bl	c0d0384c <reset_app_context>
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0d00348:	1e68      	subs	r0, r5, #1
c0d0034a:	b2c0      	uxtb	r0, r0
c0d0034c:	280a      	cmp	r0, #10
c0d0034e:	d272      	bcs.n	c0d00436 <handleGetPublicKey+0x106>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0d00350:	2c02      	cmp	r4, #2
c0d00352:	d26b      	bcs.n	c0d0042c <handleGetPublicKey+0xfc>
c0d00354:	9403      	str	r4, [sp, #12]
        THROW(0x6B00);
    }
    if ((p2 != P2_CHAINCODE) && (p2 != P2_NO_CHAINCODE)) {
c0d00356:	2e01      	cmp	r6, #1
c0d00358:	d868      	bhi.n	c0d0042c <handleGetPublicKey+0xfc>
c0d0035a:	1c78      	adds	r0, r7, #1
c0d0035c:	9927      	ldr	r1, [sp, #156]	; 0x9c
c0d0035e:	9101      	str	r1, [sp, #4]
c0d00360:	9926      	ldr	r1, [sp, #152]	; 0x98
c0d00362:	9104      	str	r1, [sp, #16]
c0d00364:	a90f      	add	r1, sp, #60	; 0x3c
c0d00366:	462a      	mov	r2, r5
        THROW(0x6B00);
    }
    for (i = 0; i < bip32PathLength; i++) {
        bip32Path[i] = U4BE(dataBuffer, 0);
c0d00368:	78c3      	ldrb	r3, [r0, #3]
c0d0036a:	7884      	ldrb	r4, [r0, #2]
c0d0036c:	0224      	lsls	r4, r4, #8
c0d0036e:	18e3      	adds	r3, r4, r3
c0d00370:	7844      	ldrb	r4, [r0, #1]
c0d00372:	7807      	ldrb	r7, [r0, #0]
c0d00374:	023f      	lsls	r7, r7, #8
c0d00376:	193c      	adds	r4, r7, r4
c0d00378:	0424      	lsls	r4, r4, #16
c0d0037a:	191b      	adds	r3, r3, r4
c0d0037c:	c108      	stmia	r1!, {r3}
    for (i = 0; i < bip32PathLength; i++) {
c0d0037e:	1d00      	adds	r0, r0, #4
c0d00380:	1e52      	subs	r2, r2, #1
c0d00382:	d1f1      	bne.n	c0d00368 <handleGetPublicKey+0x38>
        dataBuffer += 4;
    }
    tmpCtx.publicKeyContext.getChaincode = (p2 == P2_CHAINCODE);
c0d00384:	1e70      	subs	r0, r6, #1
c0d00386:	4241      	negs	r1, r0
c0d00388:	4141      	adcs	r1, r0
c0d0038a:	2495      	movs	r4, #149	; 0x95
c0d0038c:	4e33      	ldr	r6, [pc, #204]	; (c0d0045c <handleGetPublicKey+0x12c>)
c0d0038e:	5531      	strb	r1, [r6, r4]
    io_seproxyhal_io_heartbeat();
c0d00390:	f004 fce8 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(
        CX_CURVE_256K1,
        bip32Path,
        bip32PathLength,
        privateKeyData,
        (tmpCtx.publicKeyContext.getChaincode ? tmpCtx.publicKeyContext.chainCode : NULL));
c0d00394:	5d30      	ldrb	r0, [r6, r4]
c0d00396:	2800      	cmp	r0, #0
c0d00398:	d001      	beq.n	c0d0039e <handleGetPublicKey+0x6e>
c0d0039a:	4630      	mov	r0, r6
c0d0039c:	3075      	adds	r0, #117	; 0x75
    os_perso_derive_node_bip32(
c0d0039e:	4669      	mov	r1, sp
c0d003a0:	6008      	str	r0, [r1, #0]
c0d003a2:	2421      	movs	r4, #33	; 0x21
c0d003a4:	a90f      	add	r1, sp, #60	; 0x3c
c0d003a6:	af19      	add	r7, sp, #100	; 0x64
c0d003a8:	4620      	mov	r0, r4
c0d003aa:	462a      	mov	r2, r5
c0d003ac:	463b      	mov	r3, r7
c0d003ae:	f006 fb49 	bl	c0d06a44 <os_perso_derive_node_bip32>
c0d003b2:	2220      	movs	r2, #32
c0d003b4:	9202      	str	r2, [sp, #8]
c0d003b6:	ae05      	add	r6, sp, #20
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d003b8:	4620      	mov	r0, r4
c0d003ba:	4639      	mov	r1, r7
c0d003bc:	4633      	mov	r3, r6
c0d003be:	f006 faad 	bl	c0d0691c <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d003c2:	f004 fccf 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d003c6:	2301      	movs	r3, #1
    cx_ecfp_generate_pair(CX_CURVE_256K1, &tmpCtx.publicKeyContext.publicKey, &privateKey, 1);
c0d003c8:	4620      	mov	r0, r4
c0d003ca:	4d24      	ldr	r5, [pc, #144]	; (c0d0045c <handleGetPublicKey+0x12c>)
c0d003cc:	4629      	mov	r1, r5
c0d003ce:	4632      	mov	r2, r6
c0d003d0:	f006 fab4 	bl	c0d0693c <cx_ecfp_generate_pair>
c0d003d4:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d003d6:	4630      	mov	r0, r6
c0d003d8:	f00a f95e 	bl	c0d0a698 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d003dc:	4638      	mov	r0, r7
c0d003de:	9902      	ldr	r1, [sp, #8]
c0d003e0:	f00a f95a 	bl	c0d0a698 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0d003e4:	f004 fcbe 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
                               tmpCtx.publicKeyContext.address,
                               &global_sha3,
                               chainConfig);
c0d003e8:	481d      	ldr	r0, [pc, #116]	; (c0d00460 <handleGetPublicKey+0x130>)
c0d003ea:	6803      	ldr	r3, [r0, #0]
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
c0d003ec:	462c      	mov	r4, r5
c0d003ee:	344c      	adds	r4, #76	; 0x4c
c0d003f0:	4a1c      	ldr	r2, [pc, #112]	; (c0d00464 <handleGetPublicKey+0x134>)
c0d003f2:	4628      	mov	r0, r5
c0d003f4:	4621      	mov	r1, r4
c0d003f6:	f002 f857 	bl	c0d024a8 <getEthAddressStringFromKey>
#ifndef NO_CONSENT
    if (p1 == P1_NON_CONFIRM)
c0d003fa:	9803      	ldr	r0, [sp, #12]
c0d003fc:	2800      	cmp	r0, #0
c0d003fe:	d022      	beq.n	c0d00446 <handleGetPublicKey+0x116>
        *tx = set_result_get_publicKey();
        THROW(0x9000);
    }
#ifndef NO_CONSENT
    else {
        snprintf(strings.common.fullAddress,
c0d00400:	4668      	mov	r0, sp
c0d00402:	6004      	str	r4, [r0, #0]
c0d00404:	4818      	ldr	r0, [pc, #96]	; (c0d00468 <handleGetPublicKey+0x138>)
c0d00406:	212b      	movs	r1, #43	; 0x2b
c0d00408:	4a18      	ldr	r2, [pc, #96]	; (c0d0046c <handleGetPublicKey+0x13c>)
c0d0040a:	447a      	add	r2, pc
c0d0040c:	2328      	movs	r3, #40	; 0x28
c0d0040e:	f004 ffbf 	bl	c0d05390 <snprintf>
                 sizeof(strings.common.fullAddress),
                 "0x%.*s",
                 40,
                 tmpCtx.publicKeyContext.address);
        ux_flow_init(0, ux_display_public_flow, NULL);
c0d00412:	4917      	ldr	r1, [pc, #92]	; (c0d00470 <handleGetPublicKey+0x140>)
c0d00414:	4479      	add	r1, pc
c0d00416:	2000      	movs	r0, #0
c0d00418:	4602      	mov	r2, r0
c0d0041a:	f009 fbfd 	bl	c0d09c18 <ux_flow_init>
c0d0041e:	9a04      	ldr	r2, [sp, #16]

        *flags |= IO_ASYNCH_REPLY;
c0d00420:	6810      	ldr	r0, [r2, #0]
c0d00422:	2110      	movs	r1, #16
c0d00424:	4301      	orrs	r1, r0
c0d00426:	6011      	str	r1, [r2, #0]
    }
#endif  // NO_CONSENT
}
c0d00428:	b021      	add	sp, #132	; 0x84
c0d0042a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0042c:	20d5      	movs	r0, #213	; 0xd5
c0d0042e:	01c0      	lsls	r0, r0, #7
c0d00430:	3080      	adds	r0, #128	; 0x80
c0d00432:	f003 ffa7 	bl	c0d04384 <os_longjmp>
        PRINTF("Invalid path\n");
c0d00436:	480f      	ldr	r0, [pc, #60]	; (c0d00474 <handleGetPublicKey+0x144>)
c0d00438:	4478      	add	r0, pc
c0d0043a:	f004 fdff 	bl	c0d0503c <mcu_usb_printf>
c0d0043e:	20d5      	movs	r0, #213	; 0xd5
c0d00440:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0d00442:	f003 ff9f 	bl	c0d04384 <os_longjmp>
        *tx = set_result_get_publicKey();
c0d00446:	f002 fe67 	bl	c0d03118 <set_result_get_publicKey>
c0d0044a:	9901      	ldr	r1, [sp, #4]
c0d0044c:	6008      	str	r0, [r1, #0]
c0d0044e:	2009      	movs	r0, #9
c0d00450:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0d00452:	f003 ff97 	bl	c0d04384 <os_longjmp>
c0d00456:	46c0      	nop			; (mov r8, r8)
c0d00458:	2000189c 	.word	0x2000189c
c0d0045c:	20001804 	.word	0x20001804
c0d00460:	20001be0 	.word	0x20001be0
c0d00464:	20001d60 	.word	0x20001d60
c0d00468:	20001cca 	.word	0x20001cca
c0d0046c:	0000a81c 	.word	0x0000a81c
c0d00470:	0000c424 	.word	0x0000c424
c0d00474:	0000a7e0 	.word	0x0000a7e0

c0d00478 <handleProvideErc20TokenInformation>:
void handleProvideErc20TokenInformation(uint8_t p1,
                                        uint8_t p2,
                                        uint8_t *workBuffer,
                                        uint16_t dataLength,
                                        unsigned int *flags,
                                        unsigned int *tx) {
c0d00478:	b0a4      	sub	sp, #144	; 0x90
c0d0047a:	461c      	mov	r4, r3
c0d0047c:	4616      	mov	r6, r2
c0d0047e:	2590      	movs	r5, #144	; 0x90
    uint32_t chainId;
    uint8_t hash[32];
    cx_ecfp_public_key_t tokenKey;

    tmpCtx.transactionContext.currentTokenIndex =
        (tmpCtx.transactionContext.currentTokenIndex + 1) % MAX_TOKEN;
c0d00480:	4940      	ldr	r1, [pc, #256]	; (c0d00584 <handleProvideErc20TokenInformation+0x10c>)
c0d00482:	5d48      	ldrb	r0, [r1, r5]
c0d00484:	2701      	movs	r7, #1
c0d00486:	4387      	bics	r7, r0
    tmpCtx.transactionContext.currentTokenIndex =
c0d00488:	554f      	strb	r7, [r1, r5]
    tokenDefinition_t *token =
        &tmpCtx.transactionContext.tokens[tmpCtx.transactionContext.currentTokenIndex];

    PRINTF("Provisioning currentTokenIndex %d\n", tmpCtx.transactionContext.currentTokenIndex);
c0d0048a:	4840      	ldr	r0, [pc, #256]	; (c0d0058c <handleProvideErc20TokenInformation+0x114>)
c0d0048c:	4478      	add	r0, pc
c0d0048e:	4639      	mov	r1, r7
c0d00490:	f004 fdd4 	bl	c0d0503c <mcu_usb_printf>

    if (dataLength < 1) {
c0d00494:	2c00      	cmp	r4, #0
c0d00496:	d071      	beq.n	c0d0057c <handleProvideErc20TokenInformation+0x104>
        THROW(0x6A80);
    }
    tickerLength = workBuffer[offset++];
c0d00498:	7833      	ldrb	r3, [r6, #0]
    dataLength--;
    if ((tickerLength + 1) >= sizeof(token->ticker)) {
c0d0049a:	2b0b      	cmp	r3, #11
c0d0049c:	d26e      	bcs.n	c0d0057c <handleProvideErc20TokenInformation+0x104>
        THROW(0x6A80);
    }
    if (dataLength < tickerLength + 20 + 4 + 4) {
c0d0049e:	4619      	mov	r1, r3
c0d004a0:	311c      	adds	r1, #28
    dataLength--;
c0d004a2:	1e60      	subs	r0, r4, #1
    if (dataLength < tickerLength + 20 + 4 + 4) {
c0d004a4:	b280      	uxth	r0, r0
c0d004a6:	4281      	cmp	r1, r0
c0d004a8:	d868      	bhi.n	c0d0057c <handleProvideErc20TokenInformation+0x104>
c0d004aa:	1c58      	adds	r0, r3, #1
        THROW(0x6A80);
    }
    cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash, 32);
c0d004ac:	9005      	str	r0, [sp, #20]
c0d004ae:	1c72      	adds	r2, r6, #1
c0d004b0:	9204      	str	r2, [sp, #16]
c0d004b2:	a81c      	add	r0, sp, #112	; 0x70
c0d004b4:	9006      	str	r0, [sp, #24]
c0d004b6:	2020      	movs	r0, #32
c0d004b8:	9007      	str	r0, [sp, #28]
c0d004ba:	4610      	mov	r0, r2
c0d004bc:	9308      	str	r3, [sp, #32]
c0d004be:	9103      	str	r1, [sp, #12]
c0d004c0:	9a06      	ldr	r2, [sp, #24]
c0d004c2:	9b07      	ldr	r3, [sp, #28]
c0d004c4:	f006 f9d8 	bl	c0d06878 <cx_hash_sha256>
c0d004c8:	2021      	movs	r0, #33	; 0x21
    memmove(token->ticker, workBuffer + offset, tickerLength);
c0d004ca:	4378      	muls	r0, r7
c0d004cc:	492d      	ldr	r1, [pc, #180]	; (c0d00584 <handleProvideErc20TokenInformation+0x10c>)
c0d004ce:	180f      	adds	r7, r1, r0
c0d004d0:	9706      	str	r7, [sp, #24]
c0d004d2:	3760      	adds	r7, #96	; 0x60
c0d004d4:	4638      	mov	r0, r7
c0d004d6:	9904      	ldr	r1, [sp, #16]
c0d004d8:	9a08      	ldr	r2, [sp, #32]
c0d004da:	f00a f8d1 	bl	c0d0a680 <__aeabi_memmove>
    token->ticker[tickerLength] = ' ';
c0d004de:	9808      	ldr	r0, [sp, #32]
c0d004e0:	9907      	ldr	r1, [sp, #28]
c0d004e2:	5439      	strb	r1, [r7, r0]
c0d004e4:	2000      	movs	r0, #0
c0d004e6:	9905      	ldr	r1, [sp, #20]
    token->ticker[tickerLength + 1] = '\0';
c0d004e8:	5478      	strb	r0, [r7, r1]
    offset += tickerLength;
    dataLength -= tickerLength;
    memmove(token->address, workBuffer + offset, 20);
c0d004ea:	1871      	adds	r1, r6, r1
    memmove(token->ticker, workBuffer + offset, tickerLength);
c0d004ec:	9806      	ldr	r0, [sp, #24]
c0d004ee:	304c      	adds	r0, #76	; 0x4c
c0d004f0:	2214      	movs	r2, #20
    memmove(token->address, workBuffer + offset, 20);
c0d004f2:	f00a f8c5 	bl	c0d0a680 <__aeabi_memmove>
    cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash, 32);
c0d004f6:	9808      	ldr	r0, [sp, #32]
c0d004f8:	1837      	adds	r7, r6, r0
    offset += 20;
    dataLength -= 20;
    token->decimals = U4BE(workBuffer, offset);
c0d004fa:	7e38      	ldrb	r0, [r7, #24]
c0d004fc:	216c      	movs	r1, #108	; 0x6c
c0d004fe:	9a06      	ldr	r2, [sp, #24]
c0d00500:	5450      	strb	r0, [r2, r1]
    offset += 4;
    dataLength -= 4;
    chainId = U4BE(workBuffer, offset);
    if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
c0d00502:	4821      	ldr	r0, [pc, #132]	; (c0d00588 <handleProvideErc20TokenInformation+0x110>)
c0d00504:	6800      	ldr	r0, [r0, #0]
c0d00506:	6940      	ldr	r0, [r0, #20]
c0d00508:	2800      	cmp	r0, #0
c0d0050a:	d00c      	beq.n	c0d00526 <handleProvideErc20TokenInformation+0xae>
    chainId = U4BE(workBuffer, offset);
c0d0050c:	9903      	ldr	r1, [sp, #12]
c0d0050e:	5c71      	ldrb	r1, [r6, r1]
c0d00510:	7efa      	ldrb	r2, [r7, #27]
c0d00512:	0212      	lsls	r2, r2, #8
c0d00514:	1851      	adds	r1, r2, r1
c0d00516:	7eba      	ldrb	r2, [r7, #26]
c0d00518:	7e7b      	ldrb	r3, [r7, #25]
c0d0051a:	021b      	lsls	r3, r3, #8
c0d0051c:	189a      	adds	r2, r3, r2
c0d0051e:	0412      	lsls	r2, r2, #16
c0d00520:	1889      	adds	r1, r1, r2
    if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
c0d00522:	4288      	cmp	r0, r1
c0d00524:	d126      	bne.n	c0d00574 <handleProvideErc20TokenInformation+0xfc>
c0d00526:	2021      	movs	r0, #33	; 0x21
        }
    }

#else

    cx_ecfp_init_public_key(CX_CURVE_256K1,
c0d00528:	491a      	ldr	r1, [pc, #104]	; (c0d00594 <handleProvideErc20TokenInformation+0x11c>)
c0d0052a:	4479      	add	r1, pc
c0d0052c:	2241      	movs	r2, #65	; 0x41
c0d0052e:	ae09      	add	r6, sp, #36	; 0x24
c0d00530:	4633      	mov	r3, r6
c0d00532:	f006 f9e3 	bl	c0d068fc <cx_ecfp_init_public_key>
    dataLength -= tickerLength;
c0d00536:	3c1d      	subs	r4, #29
    dataLength -= 4;
c0d00538:	9808      	ldr	r0, [sp, #32]
c0d0053a:	1a20      	subs	r0, r4, r0
                         CX_LAST,
                         CX_SHA256,
                         hash,
                         32,
                         workBuffer + offset,
                         dataLength)) {
c0d0053c:	b280      	uxth	r0, r0
    if (!cx_ecdsa_verify(&tokenKey,
c0d0053e:	4669      	mov	r1, sp
                         workBuffer + offset,
c0d00540:	371d      	adds	r7, #29
    if (!cx_ecdsa_verify(&tokenKey,
c0d00542:	9a07      	ldr	r2, [sp, #28]
c0d00544:	c184      	stmia	r1!, {r2, r7}
c0d00546:	6008      	str	r0, [r1, #0]
c0d00548:	2401      	movs	r4, #1
c0d0054a:	2203      	movs	r2, #3
c0d0054c:	ab1c      	add	r3, sp, #112	; 0x70
c0d0054e:	4630      	mov	r0, r6
c0d00550:	4621      	mov	r1, r4
c0d00552:	f006 fa1b 	bl	c0d0698c <cx_ecdsa_verify>
c0d00556:	2800      	cmp	r0, #0
c0d00558:	d102      	bne.n	c0d00560 <handleProvideErc20TokenInformation+0xe8>
        PRINTF("Invalid token signature\n");
c0d0055a:	480f      	ldr	r0, [pc, #60]	; (c0d00598 <handleProvideErc20TokenInformation+0x120>)
c0d0055c:	4478      	add	r0, pc
c0d0055e:	e00b      	b.n	c0d00578 <handleProvideErc20TokenInformation+0x100>
c0d00560:	4808      	ldr	r0, [pc, #32]	; (c0d00584 <handleProvideErc20TokenInformation+0x10c>)
c0d00562:	4601      	mov	r1, r0
        THROW(0x6A80);
    }
#endif

    tmpCtx.transactionContext.tokenSet[tmpCtx.transactionContext.currentTokenIndex] = 1;
c0d00564:	5d40      	ldrb	r0, [r0, r5]
c0d00566:	1808      	adds	r0, r1, r0
c0d00568:	218e      	movs	r1, #142	; 0x8e
c0d0056a:	5444      	strb	r4, [r0, r1]
c0d0056c:	2009      	movs	r0, #9
c0d0056e:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0d00570:	f003 ff08 	bl	c0d04384 <os_longjmp>
        PRINTF("ChainId token mismatch\n");
c0d00574:	4806      	ldr	r0, [pc, #24]	; (c0d00590 <handleProvideErc20TokenInformation+0x118>)
c0d00576:	4478      	add	r0, pc
c0d00578:	f004 fd60 	bl	c0d0503c <mcu_usb_printf>
c0d0057c:	20d5      	movs	r0, #213	; 0xd5
c0d0057e:	01c0      	lsls	r0, r0, #7
c0d00580:	f003 ff00 	bl	c0d04384 <os_longjmp>
c0d00584:	20001804 	.word	0x20001804
c0d00588:	20001be0 	.word	0x20001be0
c0d0058c:	0000a7a1 	.word	0x0000a7a1
c0d00590:	0000a6da 	.word	0x0000a6da
c0d00594:	0000a757 	.word	0x0000a757
c0d00598:	0000a70c 	.word	0x0000a70c

c0d0059c <handleSignPersonalMessage>:
void handleSignPersonalMessage(uint8_t p1,
                               uint8_t p2,
                               uint8_t *workBuffer,
                               uint16_t dataLength,
                               unsigned int *flags,
                               unsigned int *tx) {
c0d0059c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0059e:	b091      	sub	sp, #68	; 0x44
c0d005a0:	461d      	mov	r5, r3
c0d005a2:	4614      	mov	r4, r2
c0d005a4:	460f      	mov	r7, r1
c0d005a6:	4606      	mov	r6, r0
    UNUSED(tx);
    uint8_t hashMessage[32];
    if (p1 == P1_FIRST) {
c0d005a8:	2880      	cmp	r0, #128	; 0x80
c0d005aa:	d100      	bne.n	c0d005ae <handleSignPersonalMessage+0x12>
c0d005ac:	e0a0      	b.n	c0d006f0 <handleSignPersonalMessage+0x154>
c0d005ae:	2e00      	cmp	r6, #0
c0d005b0:	d000      	beq.n	c0d005b4 <handleSignPersonalMessage+0x18>
c0d005b2:	e0f8      	b.n	c0d007a6 <handleSignPersonalMessage+0x20a>
        char tmp[11];
        uint32_t index;
        uint32_t base = 10;
        uint8_t pos = 0;
        uint32_t i;
        if (dataLength < 1) {
c0d005b4:	2d00      	cmp	r5, #0
c0d005b6:	d100      	bne.n	c0d005ba <handleSignPersonalMessage+0x1e>
c0d005b8:	e0ed      	b.n	c0d00796 <handleSignPersonalMessage+0x1fa>
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        if (appState != APP_STATE_IDLE) {
c0d005ba:	4985      	ldr	r1, [pc, #532]	; (c0d007d0 <handleSignPersonalMessage+0x234>)
c0d005bc:	7808      	ldrb	r0, [r1, #0]
c0d005be:	2800      	cmp	r0, #0
c0d005c0:	d002      	beq.n	c0d005c8 <handleSignPersonalMessage+0x2c>
            reset_app_context();
c0d005c2:	f003 f943 	bl	c0d0384c <reset_app_context>
c0d005c6:	4982      	ldr	r1, [pc, #520]	; (c0d007d0 <handleSignPersonalMessage+0x234>)
c0d005c8:	2002      	movs	r0, #2
        }
        appState = APP_STATE_SIGNING_MESSAGE;
c0d005ca:	7008      	strb	r0, [r1, #0]
        tmpCtx.messageSigningContext.pathLength = workBuffer[0];
c0d005cc:	7820      	ldrb	r0, [r4, #0]
c0d005ce:	4a81      	ldr	r2, [pc, #516]	; (c0d007d4 <handleSignPersonalMessage+0x238>)
c0d005d0:	7010      	strb	r0, [r2, #0]
c0d005d2:	9006      	str	r0, [sp, #24]
        if ((tmpCtx.messageSigningContext.pathLength < 0x01) ||
c0d005d4:	1e40      	subs	r0, r0, #1
c0d005d6:	b2c0      	uxtb	r0, r0
c0d005d8:	280a      	cmp	r0, #10
c0d005da:	d300      	bcc.n	c0d005de <handleSignPersonalMessage+0x42>
c0d005dc:	e0f4      	b.n	c0d007c8 <handleSignPersonalMessage+0x22c>
            (tmpCtx.messageSigningContext.pathLength > MAX_BIP32_PATH)) {
            PRINTF("Invalid path\n");
            THROW(0x6a80);
        }
        workBuffer++;
        dataLength--;
c0d005de:	1e6b      	subs	r3, r5, #1
c0d005e0:	b298      	uxth	r0, r3
c0d005e2:	2100      	movs	r1, #0
c0d005e4:	2804      	cmp	r0, #4
c0d005e6:	9604      	str	r6, [sp, #16]
c0d005e8:	9703      	str	r7, [sp, #12]
c0d005ea:	d301      	bcc.n	c0d005f0 <handleSignPersonalMessage+0x54>
c0d005ec:	460f      	mov	r7, r1
c0d005ee:	e000      	b.n	c0d005f2 <handleSignPersonalMessage+0x56>
c0d005f0:	2701      	movs	r7, #1
c0d005f2:	1d15      	adds	r5, r2, #4
        for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
            if (dataLength < 4) {
c0d005f4:	1d64      	adds	r4, r4, #5
c0d005f6:	2003      	movs	r0, #3
c0d005f8:	43c0      	mvns	r0, r0
c0d005fa:	9008      	str	r0, [sp, #32]
c0d005fc:	07f8      	lsls	r0, r7, #31
c0d005fe:	d000      	beq.n	c0d00602 <handleSignPersonalMessage+0x66>
c0d00600:	e0c9      	b.n	c0d00796 <handleSignPersonalMessage+0x1fa>
c0d00602:	9808      	ldr	r0, [sp, #32]
c0d00604:	1820      	adds	r0, r4, r0
c0d00606:	9307      	str	r3, [sp, #28]
                PRINTF("Invalid data\n");
                THROW(0x6a80);
            }
            tmpCtx.messageSigningContext.bip32Path[i] = U4BE(workBuffer, 0);
            workBuffer += 4;
            dataLength -= 4;
c0d00608:	1f1b      	subs	r3, r3, #4
c0d0060a:	b29a      	uxth	r2, r3
c0d0060c:	9205      	str	r2, [sp, #20]
c0d0060e:	4626      	mov	r6, r4
c0d00610:	2a04      	cmp	r2, #4
c0d00612:	d301      	bcc.n	c0d00618 <handleSignPersonalMessage+0x7c>
c0d00614:	2700      	movs	r7, #0
c0d00616:	e000      	b.n	c0d0061a <handleSignPersonalMessage+0x7e>
c0d00618:	2701      	movs	r7, #1
            tmpCtx.messageSigningContext.bip32Path[i] = U4BE(workBuffer, 0);
c0d0061a:	78c2      	ldrb	r2, [r0, #3]
c0d0061c:	7884      	ldrb	r4, [r0, #2]
c0d0061e:	0224      	lsls	r4, r4, #8
c0d00620:	18a2      	adds	r2, r4, r2
c0d00622:	7844      	ldrb	r4, [r0, #1]
c0d00624:	7800      	ldrb	r0, [r0, #0]
c0d00626:	0200      	lsls	r0, r0, #8
c0d00628:	1900      	adds	r0, r0, r4
c0d0062a:	0400      	lsls	r0, r0, #16
c0d0062c:	1810      	adds	r0, r2, r0
c0d0062e:	c501      	stmia	r5!, {r0}
c0d00630:	4634      	mov	r4, r6
        for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0d00632:	1d34      	adds	r4, r6, #4
c0d00634:	1c49      	adds	r1, r1, #1
c0d00636:	9806      	ldr	r0, [sp, #24]
c0d00638:	4281      	cmp	r1, r0
c0d0063a:	d3df      	bcc.n	c0d005fc <handleSignPersonalMessage+0x60>
        }
        if (dataLength < 4) {
c0d0063c:	9805      	ldr	r0, [sp, #20]
c0d0063e:	2803      	cmp	r0, #3
c0d00640:	d800      	bhi.n	c0d00644 <handleSignPersonalMessage+0xa8>
c0d00642:	e0a8      	b.n	c0d00796 <handleSignPersonalMessage+0x1fa>
c0d00644:	9b08      	ldr	r3, [sp, #32]
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        tmpCtx.messageSigningContext.remainingLength = U4BE(workBuffer, 0);
c0d00646:	18e0      	adds	r0, r4, r3
c0d00648:	78c1      	ldrb	r1, [r0, #3]
c0d0064a:	7882      	ldrb	r2, [r0, #2]
c0d0064c:	0212      	lsls	r2, r2, #8
c0d0064e:	1851      	adds	r1, r2, r1
c0d00650:	7840      	ldrb	r0, [r0, #1]
c0d00652:	5ce2      	ldrb	r2, [r4, r3]
c0d00654:	0212      	lsls	r2, r2, #8
c0d00656:	1810      	adds	r0, r2, r0
c0d00658:	0400      	lsls	r0, r0, #16
c0d0065a:	1808      	adds	r0, r1, r0
c0d0065c:	4f5d      	ldr	r7, [pc, #372]	; (c0d007d4 <handleSignPersonalMessage+0x238>)
c0d0065e:	64f8      	str	r0, [r7, #76]	; 0x4c
c0d00660:	2601      	movs	r6, #1
c0d00662:	0231      	lsls	r1, r6, #8
        workBuffer += 4;
        dataLength -= 4;
        // Initialize message header + length
        cx_keccak_init(&global_sha3, 256);
c0d00664:	4d5c      	ldr	r5, [pc, #368]	; (c0d007d8 <handleSignPersonalMessage+0x23c>)
c0d00666:	4628      	mov	r0, r5
c0d00668:	f006 f916 	bl	c0d06898 <cx_keccak_init>
c0d0066c:	2100      	movs	r1, #0
        cx_hash((cx_hash_t *) &global_sha3,
c0d0066e:	4668      	mov	r0, sp
c0d00670:	6001      	str	r1, [r0, #0]
c0d00672:	6041      	str	r1, [r0, #4]
c0d00674:	4a5d      	ldr	r2, [pc, #372]	; (c0d007ec <handleSignPersonalMessage+0x250>)
c0d00676:	447a      	add	r2, pc
c0d00678:	231a      	movs	r3, #26
c0d0067a:	4628      	mov	r0, r5
c0d0067c:	9106      	str	r1, [sp, #24]
c0d0067e:	f006 f8db 	bl	c0d06838 <cx_hash>
c0d00682:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
c0d00684:	4637      	mov	r7, r6
c0d00686:	210a      	movs	r1, #10
                0,
                (uint8_t *) SIGN_MAGIC,
                sizeof(SIGN_MAGIC) - 1,
                NULL,
                0);
        for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
c0d00688:	460e      	mov	r6, r1
c0d0068a:	437e      	muls	r6, r7
                         (((index * base) / base) == index));
c0d0068c:	4630      	mov	r0, r6
c0d0068e:	f009 ff49 	bl	c0d0a524 <__udivsi3>
        for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
c0d00692:	42ae      	cmp	r6, r5
c0d00694:	d801      	bhi.n	c0d0069a <handleSignPersonalMessage+0xfe>
c0d00696:	42b8      	cmp	r0, r7
c0d00698:	d0f4      	beq.n	c0d00684 <handleSignPersonalMessage+0xe8>
             index *= base)
            ;
        for (; index; index /= base) {
c0d0069a:	2f00      	cmp	r7, #0
c0d0069c:	9b06      	ldr	r3, [sp, #24]
c0d0069e:	d017      	beq.n	c0d006d0 <handleSignPersonalMessage+0x134>
c0d006a0:	9508      	str	r5, [sp, #32]
c0d006a2:	2500      	movs	r5, #0
            tmp[pos++] = '0' + ((tmpCtx.messageSigningContext.remainingLength / index) % base);
c0d006a4:	9808      	ldr	r0, [sp, #32]
c0d006a6:	4639      	mov	r1, r7
c0d006a8:	f009 ff3c 	bl	c0d0a524 <__udivsi3>
c0d006ac:	260a      	movs	r6, #10
c0d006ae:	4631      	mov	r1, r6
c0d006b0:	f009 ffbe 	bl	c0d0a630 <__aeabi_uidivmod>
c0d006b4:	2030      	movs	r0, #48	; 0x30
c0d006b6:	4308      	orrs	r0, r1
c0d006b8:	b2e9      	uxtb	r1, r5
c0d006ba:	aa09      	add	r2, sp, #36	; 0x24
c0d006bc:	5450      	strb	r0, [r2, r1]
        for (; index; index /= base) {
c0d006be:	4638      	mov	r0, r7
c0d006c0:	4631      	mov	r1, r6
c0d006c2:	f009 ff2f 	bl	c0d0a524 <__udivsi3>
            tmp[pos++] = '0' + ((tmpCtx.messageSigningContext.remainingLength / index) % base);
c0d006c6:	1c6d      	adds	r5, r5, #1
        for (; index; index /= base) {
c0d006c8:	2f09      	cmp	r7, #9
c0d006ca:	4607      	mov	r7, r0
c0d006cc:	d8ea      	bhi.n	c0d006a4 <handleSignPersonalMessage+0x108>
        }
        tmp[pos] = '\0';
c0d006ce:	b2eb      	uxtb	r3, r5
c0d006d0:	9d07      	ldr	r5, [sp, #28]
c0d006d2:	3d08      	subs	r5, #8
c0d006d4:	aa09      	add	r2, sp, #36	; 0x24
c0d006d6:	9906      	ldr	r1, [sp, #24]
c0d006d8:	54d1      	strb	r1, [r2, r3]
        cx_hash((cx_hash_t *) &global_sha3, 0, (uint8_t *) tmp, pos, NULL, 0);
c0d006da:	4668      	mov	r0, sp
c0d006dc:	6001      	str	r1, [r0, #0]
c0d006de:	6041      	str	r1, [r0, #4]
c0d006e0:	483d      	ldr	r0, [pc, #244]	; (c0d007d8 <handleSignPersonalMessage+0x23c>)
c0d006e2:	f006 f8a9 	bl	c0d06838 <cx_hash>
        cx_sha256_init(&tmpContent.sha2);
c0d006e6:	483d      	ldr	r0, [pc, #244]	; (c0d007dc <handleSignPersonalMessage+0x240>)
c0d006e8:	f006 f8ba 	bl	c0d06860 <cx_sha256_init>
c0d006ec:	9e04      	ldr	r6, [sp, #16]
c0d006ee:	9f03      	ldr	r7, [sp, #12]
    } else if (p1 != P1_MORE) {
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0d006f0:	2f00      	cmp	r7, #0
c0d006f2:	d158      	bne.n	c0d007a6 <handleSignPersonalMessage+0x20a>
        THROW(0x6B00);
    }
    if ((p1 == P1_MORE) && (appState != APP_STATE_SIGNING_MESSAGE)) {
c0d006f4:	2e80      	cmp	r6, #128	; 0x80
c0d006f6:	d103      	bne.n	c0d00700 <handleSignPersonalMessage+0x164>
c0d006f8:	4835      	ldr	r0, [pc, #212]	; (c0d007d0 <handleSignPersonalMessage+0x234>)
c0d006fa:	7800      	ldrb	r0, [r0, #0]
c0d006fc:	2802      	cmp	r0, #2
c0d006fe:	d156      	bne.n	c0d007ae <handleSignPersonalMessage+0x212>
        PRINTF("Signature not initialized\n");
        THROW(0x6985);
    }
    if (dataLength > tmpCtx.messageSigningContext.remainingLength) {
c0d00700:	b2ad      	uxth	r5, r5
c0d00702:	4f34      	ldr	r7, [pc, #208]	; (c0d007d4 <handleSignPersonalMessage+0x238>)
c0d00704:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
c0d00706:	42a8      	cmp	r0, r5
c0d00708:	d349      	bcc.n	c0d0079e <handleSignPersonalMessage+0x202>
c0d0070a:	2600      	movs	r6, #0
        THROW(0x6A80);
    }
    cx_hash((cx_hash_t *) &global_sha3, 0, workBuffer, dataLength, NULL, 0);
c0d0070c:	4668      	mov	r0, sp
c0d0070e:	6006      	str	r6, [r0, #0]
c0d00710:	6046      	str	r6, [r0, #4]
c0d00712:	4831      	ldr	r0, [pc, #196]	; (c0d007d8 <handleSignPersonalMessage+0x23c>)
c0d00714:	4631      	mov	r1, r6
c0d00716:	4622      	mov	r2, r4
c0d00718:	462b      	mov	r3, r5
c0d0071a:	f006 f88d 	bl	c0d06838 <cx_hash>
    cx_hash((cx_hash_t *) &tmpContent.sha2, 0, workBuffer, dataLength, NULL, 0);
c0d0071e:	4668      	mov	r0, sp
c0d00720:	6006      	str	r6, [r0, #0]
c0d00722:	6046      	str	r6, [r0, #4]
c0d00724:	482d      	ldr	r0, [pc, #180]	; (c0d007dc <handleSignPersonalMessage+0x240>)
c0d00726:	4631      	mov	r1, r6
c0d00728:	4622      	mov	r2, r4
c0d0072a:	462b      	mov	r3, r5
c0d0072c:	f006 f884 	bl	c0d06838 <cx_hash>
    tmpCtx.messageSigningContext.remainingLength -= dataLength;
c0d00730:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
c0d00732:	1b40      	subs	r0, r0, r5
c0d00734:	64f8      	str	r0, [r7, #76]	; 0x4c
    if (tmpCtx.messageSigningContext.remainingLength == 0) {
c0d00736:	d143      	bne.n	c0d007c0 <handleSignPersonalMessage+0x224>
c0d00738:	9816      	ldr	r0, [sp, #88]	; 0x58
        cx_hash((cx_hash_t *) &global_sha3,
c0d0073a:	9008      	str	r0, [sp, #32]
c0d0073c:	2520      	movs	r5, #32
c0d0073e:	4668      	mov	r0, sp
c0d00740:	372c      	adds	r7, #44	; 0x2c
c0d00742:	6007      	str	r7, [r0, #0]
c0d00744:	6045      	str	r5, [r0, #4]
c0d00746:	4824      	ldr	r0, [pc, #144]	; (c0d007d8 <handleSignPersonalMessage+0x23c>)
c0d00748:	2701      	movs	r7, #1
c0d0074a:	2600      	movs	r6, #0
c0d0074c:	4639      	mov	r1, r7
c0d0074e:	4622      	mov	r2, r4
c0d00750:	4633      	mov	r3, r6
c0d00752:	f006 f871 	bl	c0d06838 <cx_hash>
                CX_LAST,
                workBuffer,
                0,
                tmpCtx.messageSigningContext.hash,
                32);
        cx_hash((cx_hash_t *) &tmpContent.sha2, CX_LAST, workBuffer, 0, hashMessage, 32);
c0d00756:	4668      	mov	r0, sp
c0d00758:	6045      	str	r5, [r0, #4]
c0d0075a:	4622      	mov	r2, r4
c0d0075c:	ac09      	add	r4, sp, #36	; 0x24
c0d0075e:	6004      	str	r4, [r0, #0]
c0d00760:	481e      	ldr	r0, [pc, #120]	; (c0d007dc <handleSignPersonalMessage+0x240>)
c0d00762:	4639      	mov	r1, r7
c0d00764:	4633      	mov	r3, r6
c0d00766:	f006 f867 	bl	c0d06838 <cx_hash>
        snprintf(strings.tmp.tmp,
c0d0076a:	4668      	mov	r0, sp
c0d0076c:	6004      	str	r4, [r0, #0]
c0d0076e:	481c      	ldr	r0, [pc, #112]	; (c0d007e0 <handleSignPersonalMessage+0x244>)
c0d00770:	2164      	movs	r1, #100	; 0x64
c0d00772:	4a20      	ldr	r2, [pc, #128]	; (c0d007f4 <handleSignPersonalMessage+0x258>)
c0d00774:	447a      	add	r2, pc
c0d00776:	462b      	mov	r3, r5
c0d00778:	f004 fe0a 	bl	c0d05390 <snprintf>
                 hashMessage);

#ifdef NO_CONSENT
        io_seproxyhal_touch_signMessage_ok(NULL);
#else   // NO_CONSENT
        ux_flow_init(0, ux_sign_flow, NULL);
c0d0077c:	491e      	ldr	r1, [pc, #120]	; (c0d007f8 <handleSignPersonalMessage+0x25c>)
c0d0077e:	4479      	add	r1, pc
c0d00780:	4630      	mov	r0, r6
c0d00782:	4632      	mov	r2, r6
c0d00784:	f009 fa48 	bl	c0d09c18 <ux_flow_init>
c0d00788:	9a08      	ldr	r2, [sp, #32]
#endif  // NO_CONSENT

        *flags |= IO_ASYNCH_REPLY;
c0d0078a:	6810      	ldr	r0, [r2, #0]
c0d0078c:	2110      	movs	r1, #16
c0d0078e:	4301      	orrs	r1, r0
c0d00790:	6011      	str	r1, [r2, #0]

    } else {
        THROW(0x9000);
    }
}
c0d00792:	b011      	add	sp, #68	; 0x44
c0d00794:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00796:	4813      	ldr	r0, [pc, #76]	; (c0d007e4 <handleSignPersonalMessage+0x248>)
c0d00798:	4478      	add	r0, pc
c0d0079a:	f004 fc4f 	bl	c0d0503c <mcu_usb_printf>
c0d0079e:	20d5      	movs	r0, #213	; 0xd5
c0d007a0:	01c0      	lsls	r0, r0, #7
c0d007a2:	f003 fdef 	bl	c0d04384 <os_longjmp>
c0d007a6:	206b      	movs	r0, #107	; 0x6b
c0d007a8:	0200      	lsls	r0, r0, #8
c0d007aa:	f003 fdeb 	bl	c0d04384 <os_longjmp>
        PRINTF("Signature not initialized\n");
c0d007ae:	4810      	ldr	r0, [pc, #64]	; (c0d007f0 <handleSignPersonalMessage+0x254>)
c0d007b0:	4478      	add	r0, pc
c0d007b2:	f004 fc43 	bl	c0d0503c <mcu_usb_printf>
c0d007b6:	20d5      	movs	r0, #213	; 0xd5
c0d007b8:	01c0      	lsls	r0, r0, #7
        THROW(0x6985);
c0d007ba:	38fb      	subs	r0, #251	; 0xfb
c0d007bc:	f003 fde2 	bl	c0d04384 <os_longjmp>
c0d007c0:	2009      	movs	r0, #9
c0d007c2:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0d007c4:	f003 fdde 	bl	c0d04384 <os_longjmp>
            PRINTF("Invalid path\n");
c0d007c8:	4807      	ldr	r0, [pc, #28]	; (c0d007e8 <handleSignPersonalMessage+0x24c>)
c0d007ca:	4478      	add	r0, pc
c0d007cc:	e7e5      	b.n	c0d0079a <handleSignPersonalMessage+0x1fe>
c0d007ce:	46c0      	nop			; (mov r8, r8)
c0d007d0:	20001800 	.word	0x20001800
c0d007d4:	20001804 	.word	0x20001804
c0d007d8:	20001d60 	.word	0x20001d60
c0d007dc:	200018dc 	.word	0x200018dc
c0d007e0:	20001cca 	.word	0x20001cca
c0d007e4:	0000a52a 	.word	0x0000a52a
c0d007e8:	0000a44e 	.word	0x0000a44e
c0d007ec:	0000a675 	.word	0x0000a675
c0d007f0:	0000a520 	.word	0x0000a520
c0d007f4:	0000a693 	.word	0x0000a693
c0d007f8:	0000c18a 	.word	0x0000c18a

c0d007fc <handleSignEIP712Message>:
void handleSignEIP712Message(uint8_t p1,
                             uint8_t p2,
                             uint8_t *workBuffer,
                             uint16_t dataLength,
                             unsigned int *flags,
                             unsigned int *tx) {
c0d007fc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d007fe:	b083      	sub	sp, #12
    uint8_t i;

    UNUSED(tx);
    if ((p1 != 00) || (p2 != 00)) {
c0d00800:	4308      	orrs	r0, r1
c0d00802:	2800      	cmp	r0, #0
c0d00804:	d154      	bne.n	c0d008b0 <handleSignEIP712Message+0xb4>
c0d00806:	461e      	mov	r6, r3
c0d00808:	4614      	mov	r4, r2
        THROW(0x6B00);
    }
    if (appState != APP_STATE_IDLE) {
c0d0080a:	482d      	ldr	r0, [pc, #180]	; (c0d008c0 <handleSignEIP712Message+0xc4>)
c0d0080c:	7800      	ldrb	r0, [r0, #0]
c0d0080e:	2800      	cmp	r0, #0
c0d00810:	d001      	beq.n	c0d00816 <handleSignEIP712Message+0x1a>
        reset_app_context();
c0d00812:	f003 f81b 	bl	c0d0384c <reset_app_context>
    }
    if (dataLength < 1) {
c0d00816:	2e00      	cmp	r6, #0
c0d00818:	d042      	beq.n	c0d008a0 <handleSignEIP712Message+0xa4>
        PRINTF("Invalid data\n");
        THROW(0x6a80);
    }
    tmpCtx.messageSigningContext712.pathLength = workBuffer[0];
c0d0081a:	7820      	ldrb	r0, [r4, #0]
c0d0081c:	4a29      	ldr	r2, [pc, #164]	; (c0d008c4 <handleSignEIP712Message+0xc8>)
c0d0081e:	7010      	strb	r0, [r2, #0]
c0d00820:	9002      	str	r0, [sp, #8]
    if ((tmpCtx.messageSigningContext712.pathLength < 0x01) ||
c0d00822:	1e41      	subs	r1, r0, #1
c0d00824:	b2c9      	uxtb	r1, r1
c0d00826:	290a      	cmp	r1, #10
c0d00828:	d247      	bcs.n	c0d008ba <handleSignEIP712Message+0xbe>
c0d0082a:	9808      	ldr	r0, [sp, #32]
c0d0082c:	9001      	str	r0, [sp, #4]
c0d0082e:	1d12      	adds	r2, r2, #4
        THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
        if (dataLength < 4) {
c0d00830:	3421      	adds	r4, #33	; 0x21
    dataLength--;
c0d00832:	1e73      	subs	r3, r6, #1
c0d00834:	211f      	movs	r1, #31
c0d00836:	43c9      	mvns	r1, r1
c0d00838:	2600      	movs	r6, #0
        if (dataLength < 4) {
c0d0083a:	b29f      	uxth	r7, r3
c0d0083c:	2f03      	cmp	r7, #3
c0d0083e:	d92f      	bls.n	c0d008a0 <handleSignEIP712Message+0xa4>
c0d00840:	1867      	adds	r7, r4, r1
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        tmpCtx.messageSigningContext712.bip32Path[i] = U4BE(workBuffer, 0);
c0d00842:	78fd      	ldrb	r5, [r7, #3]
c0d00844:	78b8      	ldrb	r0, [r7, #2]
c0d00846:	0200      	lsls	r0, r0, #8
c0d00848:	1940      	adds	r0, r0, r5
c0d0084a:	787d      	ldrb	r5, [r7, #1]
c0d0084c:	783f      	ldrb	r7, [r7, #0]
c0d0084e:	023f      	lsls	r7, r7, #8
c0d00850:	197d      	adds	r5, r7, r5
c0d00852:	042d      	lsls	r5, r5, #16
c0d00854:	1940      	adds	r0, r0, r5
c0d00856:	c201      	stmia	r2!, {r0}
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
c0d00858:	1d24      	adds	r4, r4, #4
c0d0085a:	1c76      	adds	r6, r6, #1
        workBuffer += 4;
        dataLength -= 4;
c0d0085c:	1f1b      	subs	r3, r3, #4
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
c0d0085e:	9802      	ldr	r0, [sp, #8]
c0d00860:	4286      	cmp	r6, r0
c0d00862:	d3ea      	bcc.n	c0d0083a <handleSignEIP712Message+0x3e>
    }
    if (dataLength < 32 + 32) {
c0d00864:	b298      	uxth	r0, r3
c0d00866:	283f      	cmp	r0, #63	; 0x3f
c0d00868:	d91a      	bls.n	c0d008a0 <handleSignEIP712Message+0xa4>
c0d0086a:	1861      	adds	r1, r4, r1
c0d0086c:	4d15      	ldr	r5, [pc, #84]	; (c0d008c4 <handleSignEIP712Message+0xc8>)
        PRINTF("Invalid data\n");
        THROW(0x6a80);
    }
    memmove(tmpCtx.messageSigningContext712.domainHash, workBuffer, 32);
c0d0086e:	4628      	mov	r0, r5
c0d00870:	302c      	adds	r0, #44	; 0x2c
c0d00872:	2620      	movs	r6, #32
c0d00874:	4632      	mov	r2, r6
c0d00876:	f009 ff03 	bl	c0d0a680 <__aeabi_memmove>
    memmove(tmpCtx.messageSigningContext712.messageHash, workBuffer + 32, 32);
c0d0087a:	354c      	adds	r5, #76	; 0x4c
c0d0087c:	4628      	mov	r0, r5
c0d0087e:	4621      	mov	r1, r4
c0d00880:	4632      	mov	r2, r6
c0d00882:	f009 fefd 	bl	c0d0a680 <__aeabi_memmove>

#ifdef NO_CONSENT
    io_seproxyhal_touch_signMessage_ok(NULL);
#else   // NO_CONSENT
    ux_flow_init(0, ux_sign_712_v0_flow, NULL);
c0d00886:	4912      	ldr	r1, [pc, #72]	; (c0d008d0 <handleSignEIP712Message+0xd4>)
c0d00888:	4479      	add	r1, pc
c0d0088a:	2000      	movs	r0, #0
c0d0088c:	4602      	mov	r2, r0
c0d0088e:	f009 f9c3 	bl	c0d09c18 <ux_flow_init>
c0d00892:	9a01      	ldr	r2, [sp, #4]
#endif  // NO_CONSENT

    *flags |= IO_ASYNCH_REPLY;
c0d00894:	6810      	ldr	r0, [r2, #0]
c0d00896:	2110      	movs	r1, #16
c0d00898:	4301      	orrs	r1, r0
c0d0089a:	6011      	str	r1, [r2, #0]
}
c0d0089c:	b003      	add	sp, #12
c0d0089e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d008a0:	4809      	ldr	r0, [pc, #36]	; (c0d008c8 <handleSignEIP712Message+0xcc>)
c0d008a2:	4478      	add	r0, pc
c0d008a4:	f004 fbca 	bl	c0d0503c <mcu_usb_printf>
c0d008a8:	20d5      	movs	r0, #213	; 0xd5
c0d008aa:	01c0      	lsls	r0, r0, #7
c0d008ac:	f003 fd6a 	bl	c0d04384 <os_longjmp>
c0d008b0:	20d5      	movs	r0, #213	; 0xd5
c0d008b2:	01c0      	lsls	r0, r0, #7
        THROW(0x6B00);
c0d008b4:	3080      	adds	r0, #128	; 0x80
c0d008b6:	f003 fd65 	bl	c0d04384 <os_longjmp>
        PRINTF("Invalid path\n");
c0d008ba:	4804      	ldr	r0, [pc, #16]	; (c0d008cc <handleSignEIP712Message+0xd0>)
c0d008bc:	4478      	add	r0, pc
c0d008be:	e7f1      	b.n	c0d008a4 <handleSignEIP712Message+0xa8>
c0d008c0:	20001800 	.word	0x20001800
c0d008c4:	20001804 	.word	0x20001804
c0d008c8:	0000a420 	.word	0x0000a420
c0d008cc:	0000a35c 	.word	0x0000a35c
c0d008d0:	0000c164 	.word	0x0000c164

c0d008d4 <handleSign>:
void handleSign(uint8_t p1,
                uint8_t p2,
                uint8_t *workBuffer,
                uint16_t dataLength,
                unsigned int *flags,
                unsigned int *tx) {
c0d008d4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d008d6:	b083      	sub	sp, #12
c0d008d8:	461d      	mov	r5, r3
c0d008da:	4614      	mov	r4, r2
c0d008dc:	460f      	mov	r7, r1
c0d008de:	4606      	mov	r6, r0
    PRINTF("jxlog21: length %d\n", dataLength);
c0d008e0:	484f      	ldr	r0, [pc, #316]	; (c0d00a20 <handleSign+0x14c>)
c0d008e2:	4478      	add	r0, pc
c0d008e4:	4619      	mov	r1, r3
c0d008e6:	f004 fba9 	bl	c0d0503c <mcu_usb_printf>

    UNUSED(tx);
    parserStatus_e txResult;
    uint32_t i;
    if (p1 == P1_FIRST) {
c0d008ea:	2e80      	cmp	r6, #128	; 0x80
c0d008ec:	d03b      	beq.n	c0d00966 <handleSign+0x92>
c0d008ee:	2e00      	cmp	r6, #0
c0d008f0:	d16d      	bne.n	c0d009ce <handleSign+0xfa>
c0d008f2:	9701      	str	r7, [sp, #4]
        if (dataLength < 1) {
c0d008f4:	2d00      	cmp	r5, #0
c0d008f6:	d062      	beq.n	c0d009be <handleSign+0xea>
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        if (appState != APP_STATE_IDLE) {
c0d008f8:	4f41      	ldr	r7, [pc, #260]	; (c0d00a00 <handleSign+0x12c>)
c0d008fa:	7838      	ldrb	r0, [r7, #0]
c0d008fc:	2800      	cmp	r0, #0
c0d008fe:	d001      	beq.n	c0d00904 <handleSign+0x30>
            reset_app_context();
c0d00900:	f002 ffa4 	bl	c0d0384c <reset_app_context>
c0d00904:	9602      	str	r6, [sp, #8]
c0d00906:	2001      	movs	r0, #1
        }
        appState = APP_STATE_SIGNING_TX;
c0d00908:	7038      	strb	r0, [r7, #0]
        tmpCtx.transactionContext.pathLength = workBuffer[0];
c0d0090a:	7820      	ldrb	r0, [r4, #0]
c0d0090c:	493d      	ldr	r1, [pc, #244]	; (c0d00a04 <handleSign+0x130>)
c0d0090e:	7008      	strb	r0, [r1, #0]
        if ((tmpCtx.transactionContext.pathLength < 0x01) ||
c0d00910:	1e42      	subs	r2, r0, #1
c0d00912:	b2d2      	uxtb	r2, r2
c0d00914:	2a0a      	cmp	r2, #10
c0d00916:	d26f      	bcs.n	c0d009f8 <handleSign+0x124>
c0d00918:	1d09      	adds	r1, r1, #4
            (tmpCtx.transactionContext.pathLength > MAX_BIP32_PATH)) {
            PRINTF("Invalid path\n");
            THROW(0x6a80);
        }
        workBuffer++;
        dataLength--;
c0d0091a:	1e6d      	subs	r5, r5, #1
        workBuffer++;
c0d0091c:	1c64      	adds	r4, r4, #1
c0d0091e:	2200      	movs	r2, #0
        for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
            if (dataLength < 4) {
c0d00920:	b2ab      	uxth	r3, r5
c0d00922:	2b03      	cmp	r3, #3
c0d00924:	d94b      	bls.n	c0d009be <handleSign+0xea>
                PRINTF("Invalid data\n");
                THROW(0x6a80);
            }
            tmpCtx.transactionContext.bip32Path[i] = U4BE(workBuffer, 0);
c0d00926:	78e3      	ldrb	r3, [r4, #3]
c0d00928:	78a7      	ldrb	r7, [r4, #2]
c0d0092a:	023f      	lsls	r7, r7, #8
c0d0092c:	18fb      	adds	r3, r7, r3
c0d0092e:	7867      	ldrb	r7, [r4, #1]
c0d00930:	7826      	ldrb	r6, [r4, #0]
c0d00932:	0236      	lsls	r6, r6, #8
c0d00934:	19f6      	adds	r6, r6, r7
c0d00936:	0436      	lsls	r6, r6, #16
c0d00938:	199b      	adds	r3, r3, r6
c0d0093a:	c108      	stmia	r1!, {r3}
            workBuffer += 4;
c0d0093c:	1d24      	adds	r4, r4, #4
        for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
c0d0093e:	1c52      	adds	r2, r2, #1
            dataLength -= 4;
c0d00940:	1f2d      	subs	r5, r5, #4
        for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
c0d00942:	4282      	cmp	r2, r0
c0d00944:	d3ec      	bcc.n	c0d00920 <handleSign+0x4c>
        }
        dataPresent = false;
        dataContext.tokenContext.pluginAvailable = 0;
c0d00946:	4830      	ldr	r0, [pc, #192]	; (c0d00a08 <handleSign+0x134>)
c0d00948:	2100      	movs	r1, #0
c0d0094a:	7781      	strb	r1, [r0, #30]
        dataPresent = false;
c0d0094c:	482f      	ldr	r0, [pc, #188]	; (c0d00a0c <handleSign+0x138>)
c0d0094e:	7001      	strb	r1, [r0, #0]
        initTx(&txContext, &global_sha3, &tmpContent.txContent, customProcessor, NULL);
c0d00950:	4668      	mov	r0, sp
c0d00952:	6001      	str	r1, [r0, #0]
c0d00954:	482e      	ldr	r0, [pc, #184]	; (c0d00a10 <handleSign+0x13c>)
c0d00956:	492f      	ldr	r1, [pc, #188]	; (c0d00a14 <handleSign+0x140>)
c0d00958:	4a2f      	ldr	r2, [pc, #188]	; (c0d00a18 <handleSign+0x144>)
c0d0095a:	4b34      	ldr	r3, [pc, #208]	; (c0d00a2c <handleSign+0x158>)
c0d0095c:	447b      	add	r3, pc
c0d0095e:	f001 f9e1 	bl	c0d01d24 <initTx>
c0d00962:	9e02      	ldr	r6, [sp, #8]
c0d00964:	9f01      	ldr	r7, [sp, #4]
    } else if (p1 != P1_MORE) {
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0d00966:	2f00      	cmp	r7, #0
c0d00968:	d131      	bne.n	c0d009ce <handleSign+0xfa>
        THROW(0x6B00);
    }
    if ((p1 == P1_MORE) && (appState != APP_STATE_SIGNING_TX)) {
c0d0096a:	2e80      	cmp	r6, #128	; 0x80
c0d0096c:	d103      	bne.n	c0d00976 <handleSign+0xa2>
c0d0096e:	4824      	ldr	r0, [pc, #144]	; (c0d00a00 <handleSign+0x12c>)
c0d00970:	7800      	ldrb	r0, [r0, #0]
c0d00972:	2801      	cmp	r0, #1
c0d00974:	d12f      	bne.n	c0d009d6 <handleSign+0x102>
        PRINTF("Signature not initialized\n");
        THROW(0x6985);
    }
    if (txContext.currentField == TX_RLP_NONE) {
c0d00976:	4826      	ldr	r0, [pc, #152]	; (c0d00a10 <handleSign+0x13c>)
c0d00978:	7800      	ldrb	r0, [r0, #0]
c0d0097a:	2800      	cmp	r0, #0
c0d0097c:	d02e      	beq.n	c0d009dc <handleSign+0x108>
        THROW(0x6985);
    }
    txResult = processTx(&txContext,
                         workBuffer,
                         dataLength,
                         (chainConfig->kind == CHAIN_KIND_WANCHAIN ? TX_FLAG_TYPE : 0));
c0d0097e:	4827      	ldr	r0, [pc, #156]	; (c0d00a1c <handleSign+0x148>)
c0d00980:	6800      	ldr	r0, [r0, #0]
c0d00982:	7e00      	ldrb	r0, [r0, #24]
c0d00984:	1f80      	subs	r0, r0, #6
c0d00986:	4243      	negs	r3, r0
c0d00988:	4143      	adcs	r3, r0
                         dataLength,
c0d0098a:	b2aa      	uxth	r2, r5
    txResult = processTx(&txContext,
c0d0098c:	4820      	ldr	r0, [pc, #128]	; (c0d00a10 <handleSign+0x13c>)
c0d0098e:	4621      	mov	r1, r4
c0d00990:	f001 fa84 	bl	c0d01e9c <processTx>
    switch (txResult) {
c0d00994:	2801      	cmp	r0, #1
c0d00996:	dc06      	bgt.n	c0d009a6 <handleSign+0xd2>
c0d00998:	d00a      	beq.n	c0d009b0 <handleSign+0xdc>
c0d0099a:	2800      	cmp	r0, #0
c0d0099c:	d129      	bne.n	c0d009f2 <handleSign+0x11e>
c0d0099e:	2009      	movs	r0, #9
c0d009a0:	0300      	lsls	r0, r0, #12
        case USTREAM_SUSPENDED:
            break;
        case USTREAM_FINISHED:
            break;
        case USTREAM_PROCESSING:
            THROW(0x9000);
c0d009a2:	f003 fcef 	bl	c0d04384 <os_longjmp>
    switch (txResult) {
c0d009a6:	2802      	cmp	r0, #2
c0d009a8:	d121      	bne.n	c0d009ee <handleSign+0x11a>
c0d009aa:	2000      	movs	r0, #0
            PRINTF("Unexpected parser status\n");
            THROW(0x6A80);
    }

    if (txResult == USTREAM_FINISHED) {
        finalizeParsing(false);
c0d009ac:	f002 fdaa 	bl	c0d03504 <finalizeParsing>
c0d009b0:	9808      	ldr	r0, [sp, #32]
    }

    *flags |= IO_ASYNCH_REPLY;
c0d009b2:	6801      	ldr	r1, [r0, #0]
c0d009b4:	2210      	movs	r2, #16
c0d009b6:	430a      	orrs	r2, r1
c0d009b8:	6002      	str	r2, [r0, #0]
}
c0d009ba:	b003      	add	sp, #12
c0d009bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d009be:	4819      	ldr	r0, [pc, #100]	; (c0d00a24 <handleSign+0x150>)
c0d009c0:	4478      	add	r0, pc
c0d009c2:	f004 fb3b 	bl	c0d0503c <mcu_usb_printf>
c0d009c6:	20d5      	movs	r0, #213	; 0xd5
c0d009c8:	01c0      	lsls	r0, r0, #7
c0d009ca:	f003 fcdb 	bl	c0d04384 <os_longjmp>
c0d009ce:	206b      	movs	r0, #107	; 0x6b
c0d009d0:	0200      	lsls	r0, r0, #8
c0d009d2:	f003 fcd7 	bl	c0d04384 <os_longjmp>
        PRINTF("Signature not initialized\n");
c0d009d6:	4816      	ldr	r0, [pc, #88]	; (c0d00a30 <handleSign+0x15c>)
c0d009d8:	4478      	add	r0, pc
c0d009da:	e001      	b.n	c0d009e0 <handleSign+0x10c>
        PRINTF("Parser not initialized\n");
c0d009dc:	4815      	ldr	r0, [pc, #84]	; (c0d00a34 <handleSign+0x160>)
c0d009de:	4478      	add	r0, pc
c0d009e0:	f004 fb2c 	bl	c0d0503c <mcu_usb_printf>
c0d009e4:	20d5      	movs	r0, #213	; 0xd5
c0d009e6:	01c0      	lsls	r0, r0, #7
c0d009e8:	38fb      	subs	r0, #251	; 0xfb
c0d009ea:	f003 fccb 	bl	c0d04384 <os_longjmp>
    switch (txResult) {
c0d009ee:	2803      	cmp	r0, #3
c0d009f0:	d0e9      	beq.n	c0d009c6 <handleSign+0xf2>
            PRINTF("Unexpected parser status\n");
c0d009f2:	4811      	ldr	r0, [pc, #68]	; (c0d00a38 <handleSign+0x164>)
c0d009f4:	4478      	add	r0, pc
c0d009f6:	e7e4      	b.n	c0d009c2 <handleSign+0xee>
            PRINTF("Invalid path\n");
c0d009f8:	480b      	ldr	r0, [pc, #44]	; (c0d00a28 <handleSign+0x154>)
c0d009fa:	4478      	add	r0, pc
c0d009fc:	e7e1      	b.n	c0d009c2 <handleSign+0xee>
c0d009fe:	46c0      	nop			; (mov r8, r8)
c0d00a00:	20001800 	.word	0x20001800
c0d00a04:	20001804 	.word	0x20001804
c0d00a08:	20001be4 	.word	0x20001be4
c0d00a0c:	20001f08 	.word	0x20001f08
c0d00a10:	200018a0 	.word	0x200018a0
c0d00a14:	20001d60 	.word	0x20001d60
c0d00a18:	200018dc 	.word	0x200018dc
c0d00a1c:	20001be0 	.word	0x20001be0
c0d00a20:	0000a424 	.word	0x0000a424
c0d00a24:	0000a302 	.word	0x0000a302
c0d00a28:	0000a21e 	.word	0x0000a21e
c0d00a2c:	00002835 	.word	0x00002835
c0d00a30:	0000a2f8 	.word	0x0000a2f8
c0d00a34:	0000a33c 	.word	0x0000a33c
c0d00a38:	0000a33e 	.word	0x0000a33e

c0d00a3c <handleStarkwareGetPublicKey>:
void handleStarkwareGetPublicKey(uint8_t p1,
                                 uint8_t p2,
                                 uint8_t *dataBuffer,
                                 uint16_t dataLength,
                                 unsigned int *flags,
                                 unsigned int *tx) {
c0d00a3c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00a3e:	b0a1      	sub	sp, #132	; 0x84
c0d00a40:	4616      	mov	r6, r2
c0d00a42:	460c      	mov	r4, r1
c0d00a44:	4607      	mov	r7, r0
    UNUSED(dataLength);
    uint8_t privateKeyData[32];
    uint32_t bip32Path[MAX_BIP32_PATH];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer++);
c0d00a46:	7815      	ldrb	r5, [r2, #0]
    cx_ecfp_private_key_t privateKey;
    reset_app_context();
c0d00a48:	f002 ff00 	bl	c0d0384c <reset_app_context>
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0d00a4c:	1e68      	subs	r0, r5, #1
c0d00a4e:	b2c0      	uxtb	r0, r0
c0d00a50:	280a      	cmp	r0, #10
c0d00a52:	d25c      	bcs.n	c0d00b0e <handleStarkwareGetPublicKey+0xd2>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0d00a54:	2f02      	cmp	r7, #2
c0d00a56:	d255      	bcs.n	c0d00b04 <handleStarkwareGetPublicKey+0xc8>
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0d00a58:	2c00      	cmp	r4, #0
c0d00a5a:	d153      	bne.n	c0d00b04 <handleStarkwareGetPublicKey+0xc8>
c0d00a5c:	9703      	str	r7, [sp, #12]
c0d00a5e:	1c70      	adds	r0, r6, #1
c0d00a60:	9927      	ldr	r1, [sp, #156]	; 0x9c
c0d00a62:	9101      	str	r1, [sp, #4]
c0d00a64:	9926      	ldr	r1, [sp, #152]	; 0x98
c0d00a66:	9104      	str	r1, [sp, #16]
c0d00a68:	a90f      	add	r1, sp, #60	; 0x3c
c0d00a6a:	462a      	mov	r2, r5
        THROW(0x6B00);
    }
    for (i = 0; i < bip32PathLength; i++) {
        bip32Path[i] = U4BE(dataBuffer, 0);
c0d00a6c:	78c3      	ldrb	r3, [r0, #3]
c0d00a6e:	7884      	ldrb	r4, [r0, #2]
c0d00a70:	0224      	lsls	r4, r4, #8
c0d00a72:	18e3      	adds	r3, r4, r3
c0d00a74:	7844      	ldrb	r4, [r0, #1]
c0d00a76:	7806      	ldrb	r6, [r0, #0]
c0d00a78:	0236      	lsls	r6, r6, #8
c0d00a7a:	1934      	adds	r4, r6, r4
c0d00a7c:	0424      	lsls	r4, r4, #16
c0d00a7e:	191b      	adds	r3, r3, r4
c0d00a80:	c108      	stmia	r1!, {r3}
    for (i = 0; i < bip32PathLength; i++) {
c0d00a82:	1d00      	adds	r0, r0, #4
c0d00a84:	1e52      	subs	r2, r2, #1
c0d00a86:	d1f1      	bne.n	c0d00a6c <handleStarkwareGetPublicKey+0x30>
        dataBuffer += 4;
    }
    io_seproxyhal_io_heartbeat();
c0d00a88:	f004 f96c 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d00a8c:	a80f      	add	r0, sp, #60	; 0x3c
c0d00a8e:	ae19      	add	r6, sp, #100	; 0x64
    starkDerivePrivateKey(bip32Path, bip32PathLength, privateKeyData);
c0d00a90:	4629      	mov	r1, r5
c0d00a92:	4632      	mov	r2, r6
c0d00a94:	f004 fede 	bl	c0d05854 <starkDerivePrivateKey>
c0d00a98:	272e      	movs	r7, #46	; 0x2e
c0d00a9a:	2220      	movs	r2, #32
c0d00a9c:	9202      	str	r2, [sp, #8]
c0d00a9e:	ac05      	add	r4, sp, #20
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d00aa0:	4638      	mov	r0, r7
c0d00aa2:	4631      	mov	r1, r6
c0d00aa4:	4623      	mov	r3, r4
c0d00aa6:	f005 ff39 	bl	c0d0691c <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d00aaa:	f004 f95b 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    cx_ecfp_generate_pair(CX_CURVE_Stark256, &tmpCtx.publicKeyContext.publicKey, &privateKey, 1);
c0d00aae:	4d20      	ldr	r5, [pc, #128]	; (c0d00b30 <handleStarkwareGetPublicKey+0xf4>)
c0d00ab0:	2301      	movs	r3, #1
c0d00ab2:	4638      	mov	r0, r7
c0d00ab4:	4629      	mov	r1, r5
c0d00ab6:	4622      	mov	r2, r4
c0d00ab8:	f005 ff40 	bl	c0d0693c <cx_ecfp_generate_pair>
c0d00abc:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d00abe:	4620      	mov	r0, r4
c0d00ac0:	f009 fdea 	bl	c0d0a698 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d00ac4:	4630      	mov	r0, r6
c0d00ac6:	9902      	ldr	r1, [sp, #8]
c0d00ac8:	f009 fde6 	bl	c0d0a698 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0d00acc:	f004 f94a 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
#ifndef NO_CONSENT
    if (p1 == P1_NON_CONFIRM)
c0d00ad0:	9803      	ldr	r0, [sp, #12]
c0d00ad2:	2800      	cmp	r0, #0
c0d00ad4:	d023      	beq.n	c0d00b1e <handleStarkwareGetPublicKey+0xe2>
        THROW(0x9000);
    }
#ifndef NO_CONSENT
    else {
        // prepare for a UI based reply
        snprintf(strings.tmp.tmp,
c0d00ad6:	3509      	adds	r5, #9
c0d00ad8:	4668      	mov	r0, sp
c0d00ada:	6005      	str	r5, [r0, #0]
c0d00adc:	4815      	ldr	r0, [pc, #84]	; (c0d00b34 <handleStarkwareGetPublicKey+0xf8>)
c0d00ade:	2164      	movs	r1, #100	; 0x64
c0d00ae0:	4a15      	ldr	r2, [pc, #84]	; (c0d00b38 <handleStarkwareGetPublicKey+0xfc>)
c0d00ae2:	447a      	add	r2, pc
c0d00ae4:	2320      	movs	r3, #32
c0d00ae6:	f004 fc53 	bl	c0d05390 <snprintf>
                 sizeof(strings.tmp.tmp),
                 "0x%.*H",
                 32,
                 tmpCtx.publicKeyContext.publicKey.W + 1);
        ux_flow_init(0, ux_display_stark_public_flow, NULL);
c0d00aea:	4914      	ldr	r1, [pc, #80]	; (c0d00b3c <handleStarkwareGetPublicKey+0x100>)
c0d00aec:	4479      	add	r1, pc
c0d00aee:	2000      	movs	r0, #0
c0d00af0:	4602      	mov	r2, r0
c0d00af2:	f009 f891 	bl	c0d09c18 <ux_flow_init>
c0d00af6:	9a04      	ldr	r2, [sp, #16]

        *flags |= IO_ASYNCH_REPLY;
c0d00af8:	6810      	ldr	r0, [r2, #0]
c0d00afa:	2110      	movs	r1, #16
c0d00afc:	4301      	orrs	r1, r0
c0d00afe:	6011      	str	r1, [r2, #0]
    }
#endif  // NO_CONSENT
}
c0d00b00:	b021      	add	sp, #132	; 0x84
c0d00b02:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00b04:	20d5      	movs	r0, #213	; 0xd5
c0d00b06:	01c0      	lsls	r0, r0, #7
c0d00b08:	3080      	adds	r0, #128	; 0x80
c0d00b0a:	f003 fc3b 	bl	c0d04384 <os_longjmp>
        PRINTF("Invalid path\n");
c0d00b0e:	480c      	ldr	r0, [pc, #48]	; (c0d00b40 <handleStarkwareGetPublicKey+0x104>)
c0d00b10:	4478      	add	r0, pc
c0d00b12:	f004 fa93 	bl	c0d0503c <mcu_usb_printf>
c0d00b16:	20d5      	movs	r0, #213	; 0xd5
c0d00b18:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0d00b1a:	f003 fc33 	bl	c0d04384 <os_longjmp>
        *tx = set_result_get_stark_publicKey();
c0d00b1e:	f002 fe87 	bl	c0d03830 <set_result_get_stark_publicKey>
c0d00b22:	9901      	ldr	r1, [sp, #4]
c0d00b24:	6008      	str	r0, [r1, #0]
c0d00b26:	2009      	movs	r0, #9
c0d00b28:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0d00b2a:	f003 fc2b 	bl	c0d04384 <os_longjmp>
c0d00b2e:	46c0      	nop			; (mov r8, r8)
c0d00b30:	20001804 	.word	0x20001804
c0d00b34:	20001cca 	.word	0x20001cca
c0d00b38:	0000a26a 	.word	0x0000a26a
c0d00b3c:	0000c268 	.word	0x0000c268
c0d00b40:	0000a108 	.word	0x0000a108

c0d00b44 <handleStarkwareProvideQuantum>:
void handleStarkwareProvideQuantum(uint8_t p1,
                                   uint8_t p2,
                                   uint8_t *dataBuffer,
                                   uint16_t dataLength,
                                   unsigned int *flags,
                                   unsigned int *tx) {
c0d00b44:	b082      	sub	sp, #8
c0d00b46:	461e      	mov	r6, r3
c0d00b48:	4615      	mov	r5, r2
c0d00b4a:	4604      	mov	r4, r0
    size_t i = 0;
    uint8_t expectedDataSize = 20 + 32;
    uint8_t addressZero = 0;
    tokenDefinition_t *currentToken = NULL;
    if (appState != APP_STATE_IDLE) {
c0d00b4c:	4831      	ldr	r0, [pc, #196]	; (c0d00c14 <handleStarkwareProvideQuantum+0xd0>)
c0d00b4e:	7800      	ldrb	r0, [r0, #0]
c0d00b50:	2800      	cmp	r0, #0
c0d00b52:	d001      	beq.n	c0d00b58 <handleStarkwareProvideQuantum+0x14>
        reset_app_context();
c0d00b54:	f002 fe7a 	bl	c0d0384c <reset_app_context>
    }
    switch (p1) {
c0d00b58:	1e60      	subs	r0, r4, #1
c0d00b5a:	2805      	cmp	r0, #5
c0d00b5c:	d24c      	bcs.n	c0d00bf8 <handleStarkwareProvideQuantum+0xb4>
c0d00b5e:	2054      	movs	r0, #84	; 0x54
            expectedDataSize += 32;
            break;
        default:
            THROW(0x6B00);
    }
    if (dataLength != expectedDataSize) {
c0d00b60:	42b0      	cmp	r0, r6
c0d00b62:	d14d      	bne.n	c0d00c00 <handleStarkwareProvideQuantum+0xbc>
        THROW(0x6700);
    }
    if (p1 == STARK_QUANTUM_LEGACY) {
c0d00b64:	2c00      	cmp	r4, #0
c0d00b66:	9401      	str	r4, [sp, #4]
c0d00b68:	d108      	bne.n	c0d00b7c <handleStarkwareProvideQuantum+0x38>
c0d00b6a:	2000      	movs	r0, #0
                    uint32_t targetLength,
                    uint8_t decimals);

__attribute__((no_instrument_function)) inline int allzeroes(uint8_t *buf, int n) {
    for (int i = 0; i < n; ++i) {
        if (buf[i]) {
c0d00b6c:	5c29      	ldrb	r1, [r5, r0]
c0d00b6e:	2900      	cmp	r1, #0
c0d00b70:	d104      	bne.n	c0d00b7c <handleStarkwareProvideQuantum+0x38>
c0d00b72:	1c40      	adds	r0, r0, #1
    for (int i = 0; i < n; ++i) {
c0d00b74:	2813      	cmp	r0, #19
c0d00b76:	d9f9      	bls.n	c0d00b6c <handleStarkwareProvideQuantum+0x28>
c0d00b78:	2602      	movs	r6, #2
c0d00b7a:	e020      	b.n	c0d00bbe <handleStarkwareProvideQuantum+0x7a>
        addressZero = allzeroes(dataBuffer, 20);
    }
    if ((p1 != STARK_QUANTUM_ETH) && !addressZero) {
c0d00b7c:	2c01      	cmp	r4, #1
c0d00b7e:	d0fb      	beq.n	c0d00b78 <handleStarkwareProvideQuantum+0x34>
c0d00b80:	2041      	movs	r0, #65	; 0x41
c0d00b82:	43c7      	mvns	r7, r0
c0d00b84:	2600      	movs	r6, #0
c0d00b86:	4c24      	ldr	r4, [pc, #144]	; (c0d00c18 <handleStarkwareProvideQuantum+0xd4>)
        for (i = 0; i < MAX_TOKEN; i++) {
            currentToken = &tmpCtx.transactionContext.tokens[i];
            if (tmpCtx.transactionContext.tokenSet[i] &&
c0d00b88:	19a0      	adds	r0, r4, r6
c0d00b8a:	218e      	movs	r1, #142	; 0x8e
c0d00b8c:	5c40      	ldrb	r0, [r0, r1]
c0d00b8e:	2800      	cmp	r0, #0
c0d00b90:	d007      	beq.n	c0d00ba2 <handleStarkwareProvideQuantum+0x5e>
                (memcmp(currentToken->address, dataBuffer, 20) == 0)) {
c0d00b92:	19e0      	adds	r0, r4, r7
c0d00b94:	308e      	adds	r0, #142	; 0x8e
c0d00b96:	2214      	movs	r2, #20
c0d00b98:	4629      	mov	r1, r5
c0d00b9a:	f009 fd81 	bl	c0d0a6a0 <memcmp>
            if (tmpCtx.transactionContext.tokenSet[i] &&
c0d00b9e:	2800      	cmp	r0, #0
c0d00ba0:	d00d      	beq.n	c0d00bbe <handleStarkwareProvideQuantum+0x7a>
        for (i = 0; i < MAX_TOKEN; i++) {
c0d00ba2:	3721      	adds	r7, #33	; 0x21
c0d00ba4:	1c76      	adds	r6, r6, #1
c0d00ba6:	2e02      	cmp	r6, #2
c0d00ba8:	d3ee      	bcc.n	c0d00b88 <handleStarkwareProvideQuantum+0x44>
                break;
            }
        }
        if (i == MAX_TOKEN) {
c0d00baa:	2f00      	cmp	r7, #0
c0d00bac:	d107      	bne.n	c0d00bbe <handleStarkwareProvideQuantum+0x7a>
            PRINTF("Associated token not found\n");
c0d00bae:	481d      	ldr	r0, [pc, #116]	; (c0d00c24 <handleStarkwareProvideQuantum+0xe0>)
c0d00bb0:	4478      	add	r0, pc
c0d00bb2:	f004 fa43 	bl	c0d0503c <mcu_usb_printf>
c0d00bb6:	20d5      	movs	r0, #213	; 0xd5
c0d00bb8:	01c0      	lsls	r0, r0, #7
            THROW(0x6A80);
c0d00bba:	f003 fbe3 	bl	c0d04384 <os_longjmp>
        }
    } else {
        i = MAX_TOKEN;
    }
    memmove(dataContext.tokenContext.quantum, dataBuffer + 20, 32);
c0d00bbe:	4c17      	ldr	r4, [pc, #92]	; (c0d00c1c <handleStarkwareProvideQuantum+0xd8>)
c0d00bc0:	4620      	mov	r0, r4
c0d00bc2:	30a4      	adds	r0, #164	; 0xa4
c0d00bc4:	4629      	mov	r1, r5
c0d00bc6:	3114      	adds	r1, #20
c0d00bc8:	2220      	movs	r2, #32
c0d00bca:	f009 fd59 	bl	c0d0a680 <__aeabi_memmove>
c0d00bce:	9f01      	ldr	r7, [sp, #4]
    if (p1 != STARK_QUANTUM_LEGACY) {
c0d00bd0:	2f00      	cmp	r7, #0
c0d00bd2:	d006      	beq.n	c0d00be2 <handleStarkwareProvideQuantum+0x9e>
        memmove(dataContext.tokenContext.mintingBlob, dataBuffer + 20 + 32, 32);
c0d00bd4:	4620      	mov	r0, r4
c0d00bd6:	30c4      	adds	r0, #196	; 0xc4
c0d00bd8:	3534      	adds	r5, #52	; 0x34
c0d00bda:	2220      	movs	r2, #32
c0d00bdc:	4629      	mov	r1, r5
c0d00bde:	f009 fd4f 	bl	c0d0a680 <__aeabi_memmove>
c0d00be2:	20e5      	movs	r0, #229	; 0xe5
    }
    dataContext.tokenContext.quantumIndex = i;
    dataContext.tokenContext.quantumType = p1;
c0d00be4:	5427      	strb	r7, [r4, r0]
c0d00be6:	20e4      	movs	r0, #228	; 0xe4
    dataContext.tokenContext.quantumIndex = i;
c0d00be8:	5426      	strb	r6, [r4, r0]
    quantumSet = true;
c0d00bea:	480d      	ldr	r0, [pc, #52]	; (c0d00c20 <handleStarkwareProvideQuantum+0xdc>)
c0d00bec:	2101      	movs	r1, #1
c0d00bee:	7001      	strb	r1, [r0, #0]
c0d00bf0:	2009      	movs	r0, #9
c0d00bf2:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0d00bf4:	f003 fbc6 	bl	c0d04384 <os_longjmp>
    switch (p1) {
c0d00bf8:	2c00      	cmp	r4, #0
c0d00bfa:	d105      	bne.n	c0d00c08 <handleStarkwareProvideQuantum+0xc4>
c0d00bfc:	2034      	movs	r0, #52	; 0x34
c0d00bfe:	e7af      	b.n	c0d00b60 <handleStarkwareProvideQuantum+0x1c>
c0d00c00:	2067      	movs	r0, #103	; 0x67
c0d00c02:	0200      	lsls	r0, r0, #8
        THROW(0x6700);
c0d00c04:	f003 fbbe 	bl	c0d04384 <os_longjmp>
c0d00c08:	20d5      	movs	r0, #213	; 0xd5
c0d00c0a:	01c0      	lsls	r0, r0, #7
            THROW(0x6B00);
c0d00c0c:	3080      	adds	r0, #128	; 0x80
c0d00c0e:	f003 fbb9 	bl	c0d04384 <os_longjmp>
c0d00c12:	46c0      	nop			; (mov r8, r8)
c0d00c14:	20001800 	.word	0x20001800
c0d00c18:	20001804 	.word	0x20001804
c0d00c1c:	20001be4 	.word	0x20001be4
c0d00c20:	2000189d 	.word	0x2000189d
c0d00c24:	0000a1a3 	.word	0x0000a1a3

c0d00c28 <handleStarkwareSignMessage>:
void handleStarkwareSignMessage(uint8_t p1,
                                uint8_t p2,
                                uint8_t *dataBuffer,
                                uint16_t dataLength,
                                unsigned int *flags,
                                unsigned int *tx) {
c0d00c28:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00c2a:	b0c1      	sub	sp, #260	; 0x104
c0d00c2c:	9311      	str	r3, [sp, #68]	; 0x44
c0d00c2e:	4614      	mov	r4, r2
c0d00c30:	460f      	mov	r7, r1
c0d00c32:	4606      	mov	r6, r0
    uint8_t privateKeyData[32];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer);
c0d00c34:	7815      	ldrb	r5, [r2, #0]
    uint8_t order = 1;
    uint8_t protocol = 2;
    uint8_t preOffset, postOffset;
    uint8_t zeroTest;
    // Initial checks
    if (appState != APP_STATE_IDLE) {
c0d00c36:	48d6      	ldr	r0, [pc, #856]	; (c0d00f90 <handleStarkwareSignMessage+0x368>)
c0d00c38:	7800      	ldrb	r0, [r0, #0]
c0d00c3a:	2800      	cmp	r0, #0
c0d00c3c:	d001      	beq.n	c0d00c42 <handleStarkwareSignMessage+0x1a>
        reset_app_context();
c0d00c3e:	f002 fe05 	bl	c0d0384c <reset_app_context>
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0d00c42:	1e68      	subs	r0, r5, #1
c0d00c44:	b2c0      	uxtb	r0, r0
c0d00c46:	280a      	cmp	r0, #10
c0d00c48:	d300      	bcc.n	c0d00c4c <handleStarkwareSignMessage+0x24>
c0d00c4a:	e302      	b.n	c0d01252 <handleStarkwareSignMessage+0x62a>
c0d00c4c:	2301      	movs	r3, #1
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    switch (p1) {
c0d00c4e:	2e03      	cmp	r6, #3
c0d00c50:	dc0c      	bgt.n	c0d00c6c <handleStarkwareSignMessage+0x44>
c0d00c52:	2e01      	cmp	r6, #1
c0d00c54:	d020      	beq.n	c0d00c98 <handleStarkwareSignMessage+0x70>
c0d00c56:	2200      	movs	r2, #0
c0d00c58:	2e02      	cmp	r6, #2
c0d00c5a:	920e      	str	r2, [sp, #56]	; 0x38
c0d00c5c:	d00c      	beq.n	c0d00c78 <handleStarkwareSignMessage+0x50>
c0d00c5e:	2e03      	cmp	r6, #3
c0d00c60:	d000      	beq.n	c0d00c64 <handleStarkwareSignMessage+0x3c>
c0d00c62:	e2f1      	b.n	c0d01248 <handleStarkwareSignMessage+0x620>
c0d00c64:	9714      	str	r7, [sp, #80]	; 0x50
c0d00c66:	2221      	movs	r2, #33	; 0x21
c0d00c68:	930e      	str	r3, [sp, #56]	; 0x38
c0d00c6a:	e018      	b.n	c0d00c9e <handleStarkwareSignMessage+0x76>
c0d00c6c:	1f30      	subs	r0, r6, #4
c0d00c6e:	2802      	cmp	r0, #2
c0d00c70:	d300      	bcc.n	c0d00c74 <handleStarkwareSignMessage+0x4c>
c0d00c72:	e2e9      	b.n	c0d01248 <handleStarkwareSignMessage+0x620>
c0d00c74:	2221      	movs	r2, #33	; 0x21
c0d00c76:	930e      	str	r3, [sp, #56]	; 0x38
        if (dataLength != (20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4 + 1 + 4 * bip32PathLength +
                           2 * postOffset)) {
            THROW(0x6700);
        }
    } else {
        if (dataLength != (20 + 32 + 32 + 4 + 4 + 8 + 4 + 4 + 1 + 4 * bip32PathLength + postOffset +
c0d00c78:	2e05      	cmp	r6, #5
c0d00c7a:	d001      	beq.n	c0d00c80 <handleStarkwareSignMessage+0x58>
c0d00c7c:	206d      	movs	r0, #109	; 0x6d
c0d00c7e:	e000      	b.n	c0d00c82 <handleStarkwareSignMessage+0x5a>
c0d00c80:	20a1      	movs	r0, #161	; 0xa1
c0d00c82:	00a9      	lsls	r1, r5, #2
c0d00c84:	1840      	adds	r0, r0, r1
c0d00c86:	1880      	adds	r0, r0, r2
c0d00c88:	9911      	ldr	r1, [sp, #68]	; 0x44
c0d00c8a:	4288      	cmp	r0, r1
c0d00c8c:	d000      	beq.n	c0d00c90 <handleStarkwareSignMessage+0x68>
c0d00c8e:	e2e5      	b.n	c0d0125c <handleStarkwareSignMessage+0x634>
c0d00c90:	2000      	movs	r0, #0
c0d00c92:	2101      	movs	r1, #1
c0d00c94:	9013      	str	r0, [sp, #76]	; 0x4c
c0d00c96:	e00e      	b.n	c0d00cb6 <handleStarkwareSignMessage+0x8e>
c0d00c98:	9714      	str	r7, [sp, #80]	; 0x50
c0d00c9a:	2200      	movs	r2, #0
c0d00c9c:	920e      	str	r2, [sp, #56]	; 0x38
                           2 * postOffset)) {
c0d00c9e:	0050      	lsls	r0, r2, #1
c0d00ca0:	00a9      	lsls	r1, r5, #2
        if (dataLength != (20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4 + 1 + 4 * bip32PathLength +
c0d00ca2:	1808      	adds	r0, r1, r0
c0d00ca4:	3089      	adds	r0, #137	; 0x89
c0d00ca6:	2100      	movs	r1, #0
c0d00ca8:	9f11      	ldr	r7, [sp, #68]	; 0x44
c0d00caa:	42b8      	cmp	r0, r7
c0d00cac:	9313      	str	r3, [sp, #76]	; 0x4c
c0d00cae:	4608      	mov	r0, r1
c0d00cb0:	9f14      	ldr	r7, [sp, #80]	; 0x50
c0d00cb2:	d000      	beq.n	c0d00cb6 <handleStarkwareSignMessage+0x8e>
c0d00cb4:	e2d2      	b.n	c0d0125c <handleStarkwareSignMessage+0x634>
c0d00cb6:	9310      	str	r3, [sp, #64]	; 0x40
c0d00cb8:	9008      	str	r0, [sp, #32]
c0d00cba:	9109      	str	r1, [sp, #36]	; 0x24
c0d00cbc:	960f      	str	r6, [sp, #60]	; 0x3c
c0d00cbe:	9212      	str	r2, [sp, #72]	; 0x48
                           (p1 == P1_STARK_CONDITIONAL_TRANSFER ? 32 + 20 : 0))) {
            THROW(0x6700);
        }
    }
    if (p2 != 0) {
c0d00cc0:	2f00      	cmp	r7, #0
c0d00cc2:	d000      	beq.n	c0d00cc6 <handleStarkwareSignMessage+0x9e>
c0d00cc4:	e2c0      	b.n	c0d01248 <handleStarkwareSignMessage+0x620>
c0d00cc6:	9846      	ldr	r0, [sp, #280]	; 0x118
        THROW(0x6B00);
    }
    tmpCtx.transactionContext.pathLength = bip32PathLength;
c0d00cc8:	900c      	str	r0, [sp, #48]	; 0x30
c0d00cca:	48b2      	ldr	r0, [pc, #712]	; (c0d00f94 <handleStarkwareSignMessage+0x36c>)
c0d00ccc:	7005      	strb	r5, [r0, #0]
c0d00cce:	9514      	str	r5, [sp, #80]	; 0x50
c0d00cd0:	1d05      	adds	r5, r0, #4
c0d00cd2:	1c61      	adds	r1, r4, #1
c0d00cd4:	2001      	movs	r0, #1
c0d00cd6:	2700      	movs	r7, #0
c0d00cd8:	4606      	mov	r6, r0
    for (i = 0; i < bip32PathLength; i++) {
        tmpCtx.transactionContext.bip32Path[i] = U4BE(dataBuffer, offset);
c0d00cda:	1820      	adds	r0, r4, r0
c0d00cdc:	78c2      	ldrb	r2, [r0, #3]
c0d00cde:	7883      	ldrb	r3, [r0, #2]
c0d00ce0:	021b      	lsls	r3, r3, #8
c0d00ce2:	189a      	adds	r2, r3, r2
c0d00ce4:	7840      	ldrb	r0, [r0, #1]
c0d00ce6:	7809      	ldrb	r1, [r1, #0]
c0d00ce8:	0209      	lsls	r1, r1, #8
c0d00cea:	1808      	adds	r0, r1, r0
c0d00cec:	0400      	lsls	r0, r0, #16
c0d00cee:	1812      	adds	r2, r2, r0
c0d00cf0:	c504      	stmia	r5!, {r2}
        PRINTF("Storing path %d %d\n", i, tmpCtx.transactionContext.bip32Path[i]);
c0d00cf2:	48a9      	ldr	r0, [pc, #676]	; (c0d00f98 <handleStarkwareSignMessage+0x370>)
c0d00cf4:	4478      	add	r0, pc
c0d00cf6:	4639      	mov	r1, r7
c0d00cf8:	f004 f9a0 	bl	c0d0503c <mcu_usb_printf>
        offset += 4;
c0d00cfc:	1d36      	adds	r6, r6, #4
c0d00cfe:	b2f0      	uxtb	r0, r6
c0d00d00:	1821      	adds	r1, r4, r0
    for (i = 0; i < bip32PathLength; i++) {
c0d00d02:	1c7f      	adds	r7, r7, #1
c0d00d04:	9a14      	ldr	r2, [sp, #80]	; 0x50
c0d00d06:	42ba      	cmp	r2, r7
c0d00d08:	d1e7      	bne.n	c0d00cda <handleStarkwareSignMessage+0xb2>
    }
    // Discard the path to use part of dataBuffer as a temporary buffer
    memmove(dataBuffer, dataBuffer + offset, dataLength - offset);
c0d00d0a:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d00d0c:	1a12      	subs	r2, r2, r0
c0d00d0e:	4620      	mov	r0, r4
c0d00d10:	f009 fcb6 	bl	c0d0a680 <__aeabi_memmove>
c0d00d14:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    dataContext.starkContext.conditional = (p1 == P1_STARK_CONDITIONAL_TRANSFER);
c0d00d16:	1f58      	subs	r0, r3, #5
c0d00d18:	4241      	negs	r1, r0
c0d00d1a:	4141      	adcs	r1, r0
c0d00d1c:	2080      	movs	r0, #128	; 0x80
c0d00d1e:	4a9f      	ldr	r2, [pc, #636]	; (c0d00f9c <handleStarkwareSignMessage+0x374>)
c0d00d20:	900d      	str	r0, [sp, #52]	; 0x34
c0d00d22:	5411      	strb	r1, [r2, r0]
    if (dataContext.starkContext.conditional) {
c0d00d24:	2b05      	cmp	r3, #5
c0d00d26:	d11f      	bne.n	c0d00d68 <handleStarkwareSignMessage+0x140>
        memmove(dataContext.starkContext.fact,
                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4 + 8 + 4 + 4,
c0d00d28:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d00d2a:	1827      	adds	r7, r4, r0
c0d00d2c:	4639      	mov	r1, r7
c0d00d2e:	316c      	adds	r1, #108	; 0x6c
        memmove(dataContext.starkContext.fact,
c0d00d30:	4e9a      	ldr	r6, [pc, #616]	; (c0d00f9c <handleStarkwareSignMessage+0x374>)
c0d00d32:	36a1      	adds	r6, #161	; 0xa1
c0d00d34:	2220      	movs	r2, #32
c0d00d36:	9211      	str	r2, [sp, #68]	; 0x44
c0d00d38:	4630      	mov	r0, r6
c0d00d3a:	f009 fca1 	bl	c0d0a680 <__aeabi_memmove>
                32);
        memmove(dataContext.starkContext.conditionAddress,
                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4 + 8 + 4 + 4 + 32,
c0d00d3e:	378c      	adds	r7, #140	; 0x8c
        memmove(dataContext.starkContext.conditionAddress,
c0d00d40:	4d96      	ldr	r5, [pc, #600]	; (c0d00f9c <handleStarkwareSignMessage+0x374>)
c0d00d42:	35c1      	adds	r5, #193	; 0xc1
c0d00d44:	2214      	movs	r2, #20
c0d00d46:	4628      	mov	r0, r5
c0d00d48:	4639      	mov	r1, r7
c0d00d4a:	4617      	mov	r7, r2
c0d00d4c:	f009 fc98 	bl	c0d0a680 <__aeabi_memmove>
                20);
        PRINTF("Fact %.*H\n", 32, dataContext.starkContext.fact);
c0d00d50:	4893      	ldr	r0, [pc, #588]	; (c0d00fa0 <handleStarkwareSignMessage+0x378>)
c0d00d52:	4478      	add	r0, pc
c0d00d54:	9911      	ldr	r1, [sp, #68]	; 0x44
c0d00d56:	4632      	mov	r2, r6
c0d00d58:	f004 f970 	bl	c0d0503c <mcu_usb_printf>
        PRINTF("Address %.*H\n", 20, dataContext.starkContext.conditionAddress);
c0d00d5c:	4891      	ldr	r0, [pc, #580]	; (c0d00fa4 <handleStarkwareSignMessage+0x37c>)
c0d00d5e:	4478      	add	r0, pc
c0d00d60:	4639      	mov	r1, r7
c0d00d62:	462a      	mov	r2, r5
c0d00d64:	f004 f96a 	bl	c0d0503c <mcu_usb_printf>
c0d00d68:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    }

    zeroTest = allzeroes(dataBuffer + preOffset, 20);
c0d00d6a:	19e6      	adds	r6, r4, r7
c0d00d6c:	2000      	movs	r0, #0
c0d00d6e:	9d12      	ldr	r5, [sp, #72]	; 0x48
c0d00d70:	9b10      	ldr	r3, [sp, #64]	; 0x40
        if (buf[i]) {
c0d00d72:	5c31      	ldrb	r1, [r6, r0]
c0d00d74:	2900      	cmp	r1, #0
c0d00d76:	d10a      	bne.n	c0d00d8e <handleStarkwareSignMessage+0x166>
c0d00d78:	1c40      	adds	r0, r0, #1
    for (int i = 0; i < n; ++i) {
c0d00d7a:	2813      	cmp	r0, #19
c0d00d7c:	d9f9      	bls.n	c0d00d72 <handleStarkwareSignMessage+0x14a>
    if (zeroTest && (protocol == 2) && (dataBuffer[0] != STARK_QUANTUM_ETH)) {
c0d00d7e:	2f00      	cmp	r7, #0
c0d00d80:	d00d      	beq.n	c0d00d9e <handleStarkwareSignMessage+0x176>
c0d00d82:	7821      	ldrb	r1, [r4, #0]
c0d00d84:	2901      	cmp	r1, #1
c0d00d86:	d000      	beq.n	c0d00d8a <handleStarkwareSignMessage+0x162>
c0d00d88:	e273      	b.n	c0d01272 <handleStarkwareSignMessage+0x64a>
c0d00d8a:	2300      	movs	r3, #0
c0d00d8c:	e007      	b.n	c0d00d9e <handleStarkwareSignMessage+0x176>
        PRINTF("stark - unexpected quantum descriptor type for null first address %d\n",
               dataBuffer[0]);
        THROW(0x6A80);
    }
    if (!zeroTest && getKnownToken(dataBuffer + preOffset) == NULL) {
c0d00d8e:	4630      	mov	r0, r6
c0d00d90:	f002 fdf2 	bl	c0d03978 <getKnownToken>
c0d00d94:	2800      	cmp	r0, #0
c0d00d96:	d100      	bne.n	c0d00d9a <handleStarkwareSignMessage+0x172>
c0d00d98:	e264      	b.n	c0d01264 <handleStarkwareSignMessage+0x63c>
c0d00d9a:	2301      	movs	r3, #1
c0d00d9c:	407b      	eors	r3, r7
c0d00d9e:	9610      	str	r6, [sp, #64]	; 0x40
        PRINTF("stark - cannot process unknown token %.*H", 20, dataBuffer + preOffset);
        THROW(0x6A80);
    }
    if (order) {
c0d00da0:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d00da2:	2800      	cmp	r0, #0
c0d00da4:	d01b      	beq.n	c0d00dde <handleStarkwareSignMessage+0x1b6>
c0d00da6:	19e8      	adds	r0, r5, r7
        zeroTest = allzeroes(dataBuffer + 20 + 32 + postOffset + preOffset, 20);
c0d00da8:	1820      	adds	r0, r4, r0
c0d00daa:	3034      	adds	r0, #52	; 0x34
c0d00dac:	1961      	adds	r1, r4, r5
c0d00dae:	19ce      	adds	r6, r1, r7
c0d00db0:	3634      	adds	r6, #52	; 0x34
c0d00db2:	2100      	movs	r1, #0
        if (buf[i]) {
c0d00db4:	5c42      	ldrb	r2, [r0, r1]
c0d00db6:	2a00      	cmp	r2, #0
c0d00db8:	d10b      	bne.n	c0d00dd2 <handleStarkwareSignMessage+0x1aa>
c0d00dba:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d00dbc:	2913      	cmp	r1, #19
c0d00dbe:	d9f9      	bls.n	c0d00db4 <handleStarkwareSignMessage+0x18c>
        if (zeroTest && (protocol == 2) && (dataBuffer[1 + 20 + 32 + 32] != STARK_QUANTUM_ETH)) {
c0d00dc0:	2b00      	cmp	r3, #0
c0d00dc2:	d10c      	bne.n	c0d00dde <handleStarkwareSignMessage+0x1b6>
c0d00dc4:	2055      	movs	r0, #85	; 0x55
c0d00dc6:	5c21      	ldrb	r1, [r4, r0]
c0d00dc8:	2901      	cmp	r1, #1
c0d00dca:	d008      	beq.n	c0d00dde <handleStarkwareSignMessage+0x1b6>
            PRINTF("stark - unexpected quantum descriptor type for null second address %d\n",
c0d00dcc:	4876      	ldr	r0, [pc, #472]	; (c0d00fa8 <handleStarkwareSignMessage+0x380>)
c0d00dce:	4478      	add	r0, pc
c0d00dd0:	e251      	b.n	c0d01276 <handleStarkwareSignMessage+0x64e>
                   dataBuffer[1 + 20 + 32 + 32]);
            THROW(0x6A80);
        }
        if (!zeroTest && getKnownToken(dataBuffer + 20 + 32 + postOffset + preOffset) == NULL) {
c0d00dd2:	4630      	mov	r0, r6
c0d00dd4:	f002 fdd0 	bl	c0d03978 <getKnownToken>
c0d00dd8:	2800      	cmp	r0, #0
c0d00dda:	d100      	bne.n	c0d00dde <handleStarkwareSignMessage+0x1b6>
c0d00ddc:	e242      	b.n	c0d01264 <handleStarkwareSignMessage+0x63c>
                   dataBuffer + 20 + 32 + postOffset + preOffset);
            THROW(0x6A80);
        }
    }
    // Prepare the Stark parameters
    io_seproxyhal_io_heartbeat();
c0d00dde:	f003 ffc1 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d00de2:	2100      	movs	r1, #0
    compute_token_id(&global_sha3,
                     dataBuffer + preOffset,
                     (protocol == 2 ? dataBuffer[0] : STARK_QUANTUM_LEGACY),
c0d00de4:	2f00      	cmp	r7, #0
c0d00de6:	460a      	mov	r2, r1
c0d00de8:	d000      	beq.n	c0d00dec <handleStarkwareSignMessage+0x1c4>
c0d00dea:	7822      	ldrb	r2, [r4, #0]
    compute_token_id(&global_sha3,
c0d00dec:	4668      	mov	r0, sp
c0d00dee:	6041      	str	r1, [r0, #4]
c0d00df0:	4e6a      	ldr	r6, [pc, #424]	; (c0d00f9c <handleStarkwareSignMessage+0x374>)
c0d00df2:	6086      	str	r6, [r0, #8]
                     dataBuffer + preOffset + 20,
                     (protocol == 2 ? dataBuffer + 1 + 20 + 32 : NULL),
c0d00df4:	2f00      	cmp	r7, #0
c0d00df6:	d101      	bne.n	c0d00dfc <handleStarkwareSignMessage+0x1d4>
c0d00df8:	4639      	mov	r1, r7
c0d00dfa:	e001      	b.n	c0d00e00 <handleStarkwareSignMessage+0x1d8>
c0d00dfc:	4621      	mov	r1, r4
c0d00dfe:	3135      	adds	r1, #53	; 0x35
    compute_token_id(&global_sha3,
c0d00e00:	6001      	str	r1, [r0, #0]
c0d00e02:	9910      	ldr	r1, [sp, #64]	; 0x40
                     dataBuffer + preOffset + 20,
c0d00e04:	460b      	mov	r3, r1
c0d00e06:	3314      	adds	r3, #20
    compute_token_id(&global_sha3,
c0d00e08:	4868      	ldr	r0, [pc, #416]	; (c0d00fac <handleStarkwareSignMessage+0x384>)
c0d00e0a:	930b      	str	r3, [sp, #44]	; 0x2c
c0d00e0c:	f004 fef2 	bl	c0d05bf4 <compute_token_id>
                     false,
                     dataContext.starkContext.w1);
    if (order) {
c0d00e10:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d00e12:	2800      	cmp	r0, #0
c0d00e14:	9411      	str	r4, [sp, #68]	; 0x44
c0d00e16:	d013      	beq.n	c0d00e40 <handleStarkwareSignMessage+0x218>
        io_seproxyhal_io_heartbeat();
        compute_token_id(&global_sha3,
                         dataBuffer + 20 + 32 + postOffset + preOffset,
c0d00e18:	1960      	adds	r0, r4, r5
c0d00e1a:	19c6      	adds	r6, r0, r7
        io_seproxyhal_io_heartbeat();
c0d00e1c:	f003 ffa2 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d00e20:	2000      	movs	r0, #0
                         (protocol == 2 ? dataBuffer[1 + 20 + 32 + 32] : STARK_QUANTUM_LEGACY),
c0d00e22:	2f00      	cmp	r7, #0
c0d00e24:	4602      	mov	r2, r0
c0d00e26:	d001      	beq.n	c0d00e2c <handleStarkwareSignMessage+0x204>
c0d00e28:	2155      	movs	r1, #85	; 0x55
c0d00e2a:	5c62      	ldrb	r2, [r4, r1]
c0d00e2c:	3634      	adds	r6, #52	; 0x34
        compute_token_id(&global_sha3,
c0d00e2e:	4b5b      	ldr	r3, [pc, #364]	; (c0d00f9c <handleStarkwareSignMessage+0x374>)
c0d00e30:	3320      	adds	r3, #32
c0d00e32:	4669      	mov	r1, sp
c0d00e34:	6048      	str	r0, [r1, #4]
c0d00e36:	608b      	str	r3, [r1, #8]
                         dataBuffer + 20 + 32 + postOffset + preOffset + 20,
                         (protocol == 2 ? dataBuffer + 1 + 20 + 32 + 32 + 1 + 20 + 32 : NULL),
c0d00e38:	2f00      	cmp	r7, #0
c0d00e3a:	d10c      	bne.n	c0d00e56 <handleStarkwareSignMessage+0x22e>
c0d00e3c:	463c      	mov	r4, r7
c0d00e3e:	e00b      	b.n	c0d00e58 <handleStarkwareSignMessage+0x230>
                         false,
                         dataContext.starkContext.w2);
        offset = 20 + 32 + postOffset + 20 + 32 + postOffset;
    } else {
        memmove(dataContext.starkContext.w2, dataBuffer + 20 + 32 + postOffset, 32);
c0d00e40:	1961      	adds	r1, r4, r5
c0d00e42:	3134      	adds	r1, #52	; 0x34
c0d00e44:	4630      	mov	r0, r6
c0d00e46:	3020      	adds	r0, #32
c0d00e48:	2220      	movs	r2, #32
c0d00e4a:	f009 fc19 	bl	c0d0a680 <__aeabi_memmove>
c0d00e4e:	2054      	movs	r0, #84	; 0x54
        offset = 20 + 32 + postOffset + 32;
c0d00e50:	4328      	orrs	r0, r5
c0d00e52:	4605      	mov	r5, r0
c0d00e54:	e00c      	b.n	c0d00e70 <handleStarkwareSignMessage+0x248>
c0d00e56:	348a      	adds	r4, #138	; 0x8a
        compute_token_id(&global_sha3,
c0d00e58:	600c      	str	r4, [r1, #0]
                         dataBuffer + 20 + 32 + postOffset + preOffset + 20,
c0d00e5a:	4633      	mov	r3, r6
c0d00e5c:	3314      	adds	r3, #20
        compute_token_id(&global_sha3,
c0d00e5e:	4853      	ldr	r0, [pc, #332]	; (c0d00fac <handleStarkwareSignMessage+0x384>)
c0d00e60:	4631      	mov	r1, r6
c0d00e62:	f004 fec7 	bl	c0d05bf4 <compute_token_id>
c0d00e66:	2048      	movs	r0, #72	; 0x48
        offset = 20 + 32 + postOffset + 20 + 32 + postOffset;
c0d00e68:	4328      	orrs	r0, r5
c0d00e6a:	182d      	adds	r5, r5, r0
c0d00e6c:	3520      	adds	r5, #32
c0d00e6e:	4e4b      	ldr	r6, [pc, #300]	; (c0d00f9c <handleStarkwareSignMessage+0x374>)
    }

    poorstream_init(&bitstream, dataContext.starkContext.w3);
c0d00e70:	4631      	mov	r1, r6
c0d00e72:	3140      	adds	r1, #64	; 0x40
c0d00e74:	ae28      	add	r6, sp, #160	; 0xa0
c0d00e76:	4630      	mov	r0, r6
c0d00e78:	910a      	str	r1, [sp, #40]	; 0x28
c0d00e7a:	f004 fc73 	bl	c0d05764 <poorstream_init>
c0d00e7e:	200b      	movs	r0, #11
    poorstream_write_bits(&bitstream, 0, 11);  // padding
c0d00e80:	4669      	mov	r1, sp
c0d00e82:	6008      	str	r0, [r1, #0]
c0d00e84:	2400      	movs	r4, #0
c0d00e86:	4630      	mov	r0, r6
c0d00e88:	4622      	mov	r2, r4
c0d00e8a:	4623      	mov	r3, r4
c0d00e8c:	f004 fc8c 	bl	c0d057a8 <poorstream_write_bits>
c0d00e90:	2004      	movs	r0, #4
    poorstream_write_bits(
c0d00e92:	4669      	mov	r1, sp
c0d00e94:	6008      	str	r0, [r1, #0]
c0d00e96:	980f      	ldr	r0, [sp, #60]	; 0x3c
        &bitstream,
        (p1 == P1_STARK_CONDITIONAL_TRANSFER ? STARK_CONDITIONAL_TRANSFER_TYPE
c0d00e98:	2805      	cmp	r0, #5
c0d00e9a:	d001      	beq.n	c0d00ea0 <handleStarkwareSignMessage+0x278>
c0d00e9c:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0d00e9e:	e000      	b.n	c0d00ea2 <handleStarkwareSignMessage+0x27a>
c0d00ea0:	2202      	movs	r2, #2
c0d00ea2:	2805      	cmp	r0, #5
c0d00ea4:	4623      	mov	r3, r4
c0d00ea6:	d000      	beq.n	c0d00eaa <handleStarkwareSignMessage+0x282>
c0d00ea8:	9b08      	ldr	r3, [sp, #32]
    poorstream_write_bits(
c0d00eaa:	4630      	mov	r0, r6
c0d00eac:	f004 fc7c 	bl	c0d057a8 <poorstream_write_bits>
c0d00eb0:	950f      	str	r5, [sp, #60]	; 0x3c
                                             : order ? STARK_ORDER_TYPE : STARK_TRANSFER_TYPE),
        4);
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset), 31);
c0d00eb2:	b2e8      	uxtb	r0, r5
c0d00eb4:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d00eb6:	1815      	adds	r5, r2, r0
c0d00eb8:	7869      	ldrb	r1, [r5, #1]
c0d00eba:	9109      	str	r1, [sp, #36]	; 0x24
c0d00ebc:	5c11      	ldrb	r1, [r2, r0]
c0d00ebe:	78ea      	ldrb	r2, [r5, #3]
c0d00ec0:	78ab      	ldrb	r3, [r5, #2]
c0d00ec2:	271f      	movs	r7, #31
c0d00ec4:	4630      	mov	r0, r6
c0d00ec6:	9604      	str	r6, [sp, #16]
c0d00ec8:	466e      	mov	r6, sp
c0d00eca:	6037      	str	r7, [r6, #0]
c0d00ecc:	021b      	lsls	r3, r3, #8
c0d00ece:	189a      	adds	r2, r3, r2
c0d00ed0:	0209      	lsls	r1, r1, #8
c0d00ed2:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0d00ed4:	18c9      	adds	r1, r1, r3
c0d00ed6:	0409      	lsls	r1, r1, #16
c0d00ed8:	1852      	adds	r2, r2, r1
c0d00eda:	4623      	mov	r3, r4
c0d00edc:	f004 fc64 	bl	c0d057a8 <poorstream_write_bits>
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset + 4), 31);
c0d00ee0:	7968      	ldrb	r0, [r5, #5]
c0d00ee2:	7929      	ldrb	r1, [r5, #4]
c0d00ee4:	79ea      	ldrb	r2, [r5, #7]
c0d00ee6:	79ab      	ldrb	r3, [r5, #6]
c0d00ee8:	466e      	mov	r6, sp
c0d00eea:	9709      	str	r7, [sp, #36]	; 0x24
c0d00eec:	6037      	str	r7, [r6, #0]
c0d00eee:	021b      	lsls	r3, r3, #8
c0d00ef0:	189a      	adds	r2, r3, r2
c0d00ef2:	0209      	lsls	r1, r1, #8
c0d00ef4:	1808      	adds	r0, r1, r0
c0d00ef6:	0400      	lsls	r0, r0, #16
c0d00ef8:	1812      	adds	r2, r2, r0
c0d00efa:	9e04      	ldr	r6, [sp, #16]
c0d00efc:	4630      	mov	r0, r6
c0d00efe:	4623      	mov	r3, r4
c0d00f00:	f004 fc52 	bl	c0d057a8 <poorstream_write_bits>
    poorstream_write_bits(&bitstream, U8BE(dataBuffer, offset + 4 + 4), 63);
c0d00f04:	7a68      	ldrb	r0, [r5, #9]
c0d00f06:	9007      	str	r0, [sp, #28]
c0d00f08:	7a28      	ldrb	r0, [r5, #8]
c0d00f0a:	9006      	str	r0, [sp, #24]
c0d00f0c:	7ae8      	ldrb	r0, [r5, #11]
c0d00f0e:	9005      	str	r0, [sp, #20]
c0d00f10:	7aa8      	ldrb	r0, [r5, #10]
c0d00f12:	9003      	str	r0, [sp, #12]
c0d00f14:	7b6c      	ldrb	r4, [r5, #13]
c0d00f16:	7b2a      	ldrb	r2, [r5, #12]
c0d00f18:	7bef      	ldrb	r7, [r5, #15]
c0d00f1a:	7ba9      	ldrb	r1, [r5, #14]
c0d00f1c:	203f      	movs	r0, #63	; 0x3f
c0d00f1e:	466b      	mov	r3, sp
c0d00f20:	9008      	str	r0, [sp, #32]
c0d00f22:	6018      	str	r0, [r3, #0]
c0d00f24:	0208      	lsls	r0, r1, #8
c0d00f26:	19c0      	adds	r0, r0, r7
c0d00f28:	0211      	lsls	r1, r2, #8
c0d00f2a:	1909      	adds	r1, r1, r4
c0d00f2c:	0409      	lsls	r1, r1, #16
c0d00f2e:	1842      	adds	r2, r0, r1
c0d00f30:	9803      	ldr	r0, [sp, #12]
c0d00f32:	0200      	lsls	r0, r0, #8
c0d00f34:	9905      	ldr	r1, [sp, #20]
c0d00f36:	1840      	adds	r0, r0, r1
c0d00f38:	9906      	ldr	r1, [sp, #24]
c0d00f3a:	0209      	lsls	r1, r1, #8
c0d00f3c:	9b07      	ldr	r3, [sp, #28]
c0d00f3e:	18c9      	adds	r1, r1, r3
c0d00f40:	0409      	lsls	r1, r1, #16
c0d00f42:	1843      	adds	r3, r0, r1
c0d00f44:	4630      	mov	r0, r6
c0d00f46:	f004 fc2f 	bl	c0d057a8 <poorstream_write_bits>
    if (order) {
c0d00f4a:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d00f4c:	2800      	cmp	r0, #0
c0d00f4e:	d02f      	beq.n	c0d00fb0 <handleStarkwareSignMessage+0x388>
        poorstream_write_bits(&bitstream, U8BE(dataBuffer, offset + 4 + 4 + 8), 63);
c0d00f50:	7c68      	ldrb	r0, [r5, #17]
c0d00f52:	9007      	str	r0, [sp, #28]
c0d00f54:	7c28      	ldrb	r0, [r5, #16]
c0d00f56:	9006      	str	r0, [sp, #24]
c0d00f58:	7ceb      	ldrb	r3, [r5, #19]
c0d00f5a:	7cae      	ldrb	r6, [r5, #18]
c0d00f5c:	7d6a      	ldrb	r2, [r5, #21]
c0d00f5e:	7d2f      	ldrb	r7, [r5, #20]
c0d00f60:	7de8      	ldrb	r0, [r5, #23]
c0d00f62:	7dad      	ldrb	r5, [r5, #22]
c0d00f64:	4669      	mov	r1, sp
c0d00f66:	9c08      	ldr	r4, [sp, #32]
c0d00f68:	600c      	str	r4, [r1, #0]
c0d00f6a:	0229      	lsls	r1, r5, #8
c0d00f6c:	1808      	adds	r0, r1, r0
c0d00f6e:	0239      	lsls	r1, r7, #8
c0d00f70:	1889      	adds	r1, r1, r2
c0d00f72:	0409      	lsls	r1, r1, #16
c0d00f74:	1842      	adds	r2, r0, r1
c0d00f76:	0230      	lsls	r0, r6, #8
c0d00f78:	18c0      	adds	r0, r0, r3
c0d00f7a:	9906      	ldr	r1, [sp, #24]
c0d00f7c:	0209      	lsls	r1, r1, #8
c0d00f7e:	9b07      	ldr	r3, [sp, #28]
c0d00f80:	18c9      	adds	r1, r1, r3
c0d00f82:	0409      	lsls	r1, r1, #16
c0d00f84:	1843      	adds	r3, r0, r1
c0d00f86:	a828      	add	r0, sp, #160	; 0xa0
c0d00f88:	f004 fc0e 	bl	c0d057a8 <poorstream_write_bits>
c0d00f8c:	2018      	movs	r0, #24
c0d00f8e:	e018      	b.n	c0d00fc2 <handleStarkwareSignMessage+0x39a>
c0d00f90:	20001800 	.word	0x20001800
c0d00f94:	20001804 	.word	0x20001804
c0d00f98:	0000a07b 	.word	0x0000a07b
c0d00f9c:	20001be4 	.word	0x20001be4
c0d00fa0:	0000a031 	.word	0x0000a031
c0d00fa4:	0000a030 	.word	0x0000a030
c0d00fa8:	0000a03e 	.word	0x0000a03e
c0d00fac:	20001d60 	.word	0x20001d60
        offset += 4 + 4 + 8 + 8;
    } else {
        poorstream_write_bits(&bitstream, 0, 63);
c0d00fb0:	4668      	mov	r0, sp
c0d00fb2:	9908      	ldr	r1, [sp, #32]
c0d00fb4:	6001      	str	r1, [r0, #0]
c0d00fb6:	a828      	add	r0, sp, #160	; 0xa0
c0d00fb8:	2200      	movs	r2, #0
c0d00fba:	4613      	mov	r3, r2
c0d00fbc:	f004 fbf4 	bl	c0d057a8 <poorstream_write_bits>
c0d00fc0:	2010      	movs	r0, #16
c0d00fc2:	990f      	ldr	r1, [sp, #60]	; 0x3c
c0d00fc4:	1808      	adds	r0, r1, r0
        offset += 4 + 4 + 8;
    }
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset), 31);
c0d00fc6:	b2c0      	uxtb	r0, r0
c0d00fc8:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d00fca:	1815      	adds	r5, r2, r0
c0d00fcc:	7869      	ldrb	r1, [r5, #1]
c0d00fce:	5c10      	ldrb	r0, [r2, r0]
c0d00fd0:	78ea      	ldrb	r2, [r5, #3]
c0d00fd2:	78ab      	ldrb	r3, [r5, #2]
c0d00fd4:	466e      	mov	r6, sp
c0d00fd6:	9c09      	ldr	r4, [sp, #36]	; 0x24
c0d00fd8:	6034      	str	r4, [r6, #0]
c0d00fda:	021b      	lsls	r3, r3, #8
c0d00fdc:	189a      	adds	r2, r3, r2
c0d00fde:	0200      	lsls	r0, r0, #8
c0d00fe0:	1840      	adds	r0, r0, r1
c0d00fe2:	0400      	lsls	r0, r0, #16
c0d00fe4:	1812      	adds	r2, r2, r0
c0d00fe6:	ae28      	add	r6, sp, #160	; 0xa0
c0d00fe8:	2400      	movs	r4, #0
c0d00fea:	4630      	mov	r0, r6
c0d00fec:	4623      	mov	r3, r4
c0d00fee:	f004 fbdb 	bl	c0d057a8 <poorstream_write_bits>
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset + 4), 22);
c0d00ff2:	7968      	ldrb	r0, [r5, #5]
c0d00ff4:	7929      	ldrb	r1, [r5, #4]
c0d00ff6:	79ea      	ldrb	r2, [r5, #7]
c0d00ff8:	79ab      	ldrb	r3, [r5, #6]
c0d00ffa:	2516      	movs	r5, #22
c0d00ffc:	466f      	mov	r7, sp
c0d00ffe:	603d      	str	r5, [r7, #0]
c0d01000:	021b      	lsls	r3, r3, #8
c0d01002:	189a      	adds	r2, r3, r2
c0d01004:	0209      	lsls	r1, r1, #8
c0d01006:	1808      	adds	r0, r1, r0
c0d01008:	0400      	lsls	r0, r0, #16
c0d0100a:	1812      	adds	r2, r2, r0
c0d0100c:	4630      	mov	r0, r6
c0d0100e:	4623      	mov	r3, r4
c0d01010:	f004 fbca 	bl	c0d057a8 <poorstream_write_bits>

    PRINTF("stark w1 %.*H\n", 32, dataContext.starkContext.w1);
c0d01014:	48a3      	ldr	r0, [pc, #652]	; (c0d012a4 <handleStarkwareSignMessage+0x67c>)
c0d01016:	4478      	add	r0, pc
c0d01018:	2620      	movs	r6, #32
c0d0101a:	4631      	mov	r1, r6
c0d0101c:	4d9a      	ldr	r5, [pc, #616]	; (c0d01288 <handleStarkwareSignMessage+0x660>)
c0d0101e:	462a      	mov	r2, r5
c0d01020:	f004 f80c 	bl	c0d0503c <mcu_usb_printf>
    PRINTF("stark w2 %.*H\n", 32, dataContext.starkContext.w2);
c0d01024:	462a      	mov	r2, r5
c0d01026:	3220      	adds	r2, #32
c0d01028:	489f      	ldr	r0, [pc, #636]	; (c0d012a8 <handleStarkwareSignMessage+0x680>)
c0d0102a:	4478      	add	r0, pc
c0d0102c:	4631      	mov	r1, r6
c0d0102e:	f004 f805 	bl	c0d0503c <mcu_usb_printf>
    PRINTF("stark w3 %.*H\n", 32, dataContext.starkContext.w3);
c0d01032:	489e      	ldr	r0, [pc, #632]	; (c0d012ac <handleStarkwareSignMessage+0x684>)
c0d01034:	4478      	add	r0, pc
c0d01036:	4631      	mov	r1, r6
c0d01038:	9a0a      	ldr	r2, [sp, #40]	; 0x28
c0d0103a:	f003 ffff 	bl	c0d0503c <mcu_usb_printf>

    if (dataContext.starkContext.conditional) {
c0d0103e:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d01040:	5c28      	ldrb	r0, [r5, r0]
c0d01042:	2800      	cmp	r0, #0
c0d01044:	d027      	beq.n	c0d01096 <handleStarkwareSignMessage+0x46e>
c0d01046:	2001      	movs	r0, #1
c0d01048:	900f      	str	r0, [sp, #60]	; 0x3c
c0d0104a:	0201      	lsls	r1, r0, #8
        cx_keccak_init(&global_sha3, 256);
c0d0104c:	4f8f      	ldr	r7, [pc, #572]	; (c0d0128c <handleStarkwareSignMessage+0x664>)
c0d0104e:	4638      	mov	r0, r7
c0d01050:	f005 fc22 	bl	c0d06898 <cx_keccak_init>
        cx_hash((cx_hash_t *) &global_sha3,
c0d01054:	4668      	mov	r0, sp
c0d01056:	6004      	str	r4, [r0, #0]
c0d01058:	6044      	str	r4, [r0, #4]
c0d0105a:	462a      	mov	r2, r5
c0d0105c:	32c1      	adds	r2, #193	; 0xc1
c0d0105e:	2314      	movs	r3, #20
c0d01060:	4638      	mov	r0, r7
c0d01062:	4621      	mov	r1, r4
c0d01064:	f005 fbe8 	bl	c0d06838 <cx_hash>
                0,
                dataContext.starkContext.conditionAddress,
                20,
                NULL,
                0);
        cx_hash((cx_hash_t *) &global_sha3,
c0d01068:	4668      	mov	r0, sp
c0d0106a:	462f      	mov	r7, r5
c0d0106c:	3760      	adds	r7, #96	; 0x60
c0d0106e:	6007      	str	r7, [r0, #0]
c0d01070:	6046      	str	r6, [r0, #4]
c0d01072:	462a      	mov	r2, r5
c0d01074:	32a1      	adds	r2, #161	; 0xa1
c0d01076:	4885      	ldr	r0, [pc, #532]	; (c0d0128c <handleStarkwareSignMessage+0x664>)
c0d01078:	990f      	ldr	r1, [sp, #60]	; 0x3c
c0d0107a:	4633      	mov	r3, r6
c0d0107c:	f005 fbdc 	bl	c0d06838 <cx_hash>
c0d01080:	2060      	movs	r0, #96	; 0x60
                CX_LAST,
                dataContext.starkContext.fact,
                32,
                dataContext.starkContext.w4,
                32);
        dataContext.starkContext.w4[0] &= 0x03;
c0d01082:	5c29      	ldrb	r1, [r5, r0]
c0d01084:	2203      	movs	r2, #3
c0d01086:	400a      	ands	r2, r1
c0d01088:	542a      	strb	r2, [r5, r0]
        PRINTF("stark w4 %.*H\n", 32, dataContext.starkContext.w4);
c0d0108a:	4889      	ldr	r0, [pc, #548]	; (c0d012b0 <handleStarkwareSignMessage+0x688>)
c0d0108c:	4478      	add	r0, pc
c0d0108e:	4631      	mov	r1, r6
c0d01090:	463a      	mov	r2, r7
c0d01092:	f003 ffd3 	bl	c0d0503c <mcu_usb_printf>
    }
    // Prepare the UI
    if (order) {
c0d01096:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d01098:	2800      	cmp	r0, #0
c0d0109a:	9d14      	ldr	r5, [sp, #80]	; 0x50
c0d0109c:	d044      	beq.n	c0d01128 <handleStarkwareSignMessage+0x500>
        io_seproxyhal_io_heartbeat();
c0d0109e:	f003 fe61 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
        // amount to sell
        stark_get_amount_string(dataBuffer + preOffset,
c0d010a2:	487c      	ldr	r0, [pc, #496]	; (c0d01294 <handleStarkwareSignMessage+0x66c>)
c0d010a4:	302b      	adds	r0, #43	; 0x2b
c0d010a6:	4669      	mov	r1, sp
c0d010a8:	6008      	str	r0, [r1, #0]
c0d010aa:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d010ac:	9614      	str	r6, [sp, #80]	; 0x50
c0d010ae:	9c11      	ldr	r4, [sp, #68]	; 0x44
                                dataBuffer + preOffset + 20,
                                dataBuffer + 20 + 32 + postOffset + 20 + 32 + postOffset + 4 + 4,
c0d010b0:	1826      	adds	r6, r4, r0
c0d010b2:	3634      	adds	r6, #52	; 0x34
c0d010b4:	1837      	adds	r7, r6, r0
c0d010b6:	463a      	mov	r2, r7
c0d010b8:	323c      	adds	r2, #60	; 0x3c
                                (char *) (dataBuffer + TMP_OFFSET),
c0d010ba:	4625      	mov	r5, r4
c0d010bc:	358c      	adds	r5, #140	; 0x8c
        stark_get_amount_string(dataBuffer + preOffset,
c0d010be:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d010c0:	990b      	ldr	r1, [sp, #44]	; 0x2c
c0d010c2:	462b      	mov	r3, r5
c0d010c4:	f004 fc2c 	bl	c0d05920 <stark_get_amount_string>
                                strings.common.fullAmount);
        io_seproxyhal_io_heartbeat();
c0d010c8:	f003 fe4c 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
        // amount to buy
        stark_get_amount_string(
c0d010cc:	4871      	ldr	r0, [pc, #452]	; (c0d01294 <handleStarkwareSignMessage+0x66c>)
c0d010ce:	305d      	adds	r0, #93	; 0x5d
c0d010d0:	4669      	mov	r1, sp
c0d010d2:	6008      	str	r0, [r1, #0]
            dataBuffer + 20 + 32 + postOffset + preOffset,
c0d010d4:	980e      	ldr	r0, [sp, #56]	; 0x38
c0d010d6:	1830      	adds	r0, r6, r0
            dataBuffer + 20 + 32 + postOffset + preOffset + 20,
c0d010d8:	4601      	mov	r1, r0
c0d010da:	3114      	adds	r1, #20
            dataBuffer + 20 + 32 + postOffset + 20 + 32 + postOffset + 4 + 4 + 8,
c0d010dc:	3744      	adds	r7, #68	; 0x44
        stark_get_amount_string(
c0d010de:	463a      	mov	r2, r7
c0d010e0:	462b      	mov	r3, r5
c0d010e2:	f004 fc1d 	bl	c0d05920 <stark_get_amount_string>
c0d010e6:	2048      	movs	r0, #72	; 0x48
c0d010e8:	9912      	ldr	r1, [sp, #72]	; 0x48
            strings.common.maxFee);
        // src vault ID
        snprintf(strings.common.fullAddress,
                 sizeof(strings.common.fullAddress),
                 "%d",
                 U4BE(dataBuffer, 20 + 32 + postOffset + 20 + 32 + postOffset));
c0d010ea:	4308      	orrs	r0, r1
c0d010ec:	1808      	adds	r0, r1, r0
                                dataBuffer + 20 + 32 + postOffset + 20 + 32 + postOffset + 4 + 4,
c0d010ee:	1820      	adds	r0, r4, r0
c0d010f0:	2123      	movs	r1, #35	; 0x23
                 U4BE(dataBuffer, 20 + 32 + postOffset + 20 + 32 + postOffset));
c0d010f2:	5c41      	ldrb	r1, [r0, r1]
c0d010f4:	2222      	movs	r2, #34	; 0x22
c0d010f6:	5c82      	ldrb	r2, [r0, r2]
c0d010f8:	0212      	lsls	r2, r2, #8
c0d010fa:	1851      	adds	r1, r2, r1
c0d010fc:	2221      	movs	r2, #33	; 0x21
c0d010fe:	5c82      	ldrb	r2, [r0, r2]
c0d01100:	9b14      	ldr	r3, [sp, #80]	; 0x50
c0d01102:	5cc0      	ldrb	r0, [r0, r3]
c0d01104:	0200      	lsls	r0, r0, #8
c0d01106:	1880      	adds	r0, r0, r2
c0d01108:	0400      	lsls	r0, r0, #16
c0d0110a:	180b      	adds	r3, r1, r0
c0d0110c:	212b      	movs	r1, #43	; 0x2b
        snprintf(strings.common.fullAddress,
c0d0110e:	4a70      	ldr	r2, [pc, #448]	; (c0d012d0 <handleStarkwareSignMessage+0x6a8>)
c0d01110:	447a      	add	r2, pc
c0d01112:	4860      	ldr	r0, [pc, #384]	; (c0d01294 <handleStarkwareSignMessage+0x66c>)
c0d01114:	f004 f93c 	bl	c0d05390 <snprintf>
                     32,
                     dataBuffer + 20 + 32 + postOffset);
        }
    }
    if (order) {
        ux_flow_init(0, ux_stark_limit_order_flow, NULL);
c0d01118:	496e      	ldr	r1, [pc, #440]	; (c0d012d4 <handleStarkwareSignMessage+0x6ac>)
c0d0111a:	4479      	add	r1, pc
c0d0111c:	2000      	movs	r0, #0
c0d0111e:	4602      	mov	r2, r0
c0d01120:	f008 fd7a 	bl	c0d09c18 <ux_flow_init>
c0d01124:	9c0c      	ldr	r4, [sp, #48]	; 0x30
c0d01126:	e089      	b.n	c0d0123c <handleStarkwareSignMessage+0x614>
        io_seproxyhal_io_heartbeat();
c0d01128:	f003 fe1c 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
        starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path, bip32PathLength, privateKeyData);
c0d0112c:	4855      	ldr	r0, [pc, #340]	; (c0d01284 <handleStarkwareSignMessage+0x65c>)
c0d0112e:	1d00      	adds	r0, r0, #4
c0d01130:	ac39      	add	r4, sp, #228	; 0xe4
c0d01132:	9413      	str	r4, [sp, #76]	; 0x4c
c0d01134:	4629      	mov	r1, r5
c0d01136:	4622      	mov	r2, r4
c0d01138:	f004 fb8c 	bl	c0d05854 <starkDerivePrivateKey>
c0d0113c:	262e      	movs	r6, #46	; 0x2e
c0d0113e:	2220      	movs	r2, #32
c0d01140:	ad2f      	add	r5, sp, #188	; 0xbc
        cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d01142:	4630      	mov	r0, r6
c0d01144:	4621      	mov	r1, r4
c0d01146:	4614      	mov	r4, r2
c0d01148:	462b      	mov	r3, r5
c0d0114a:	f005 fbe7 	bl	c0d0691c <cx_ecfp_init_private_key>
        io_seproxyhal_io_heartbeat();
c0d0114e:	f003 fe09 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d01152:	af15      	add	r7, sp, #84	; 0x54
c0d01154:	2301      	movs	r3, #1
        cx_ecfp_generate_pair(CX_CURVE_Stark256, &publicKey, &privateKey, 1);
c0d01156:	4630      	mov	r0, r6
c0d01158:	4639      	mov	r1, r7
c0d0115a:	462a      	mov	r2, r5
c0d0115c:	f005 fbee 	bl	c0d0693c <cx_ecfp_generate_pair>
c0d01160:	2128      	movs	r1, #40	; 0x28
        explicit_bzero(&privateKey, sizeof(privateKey));
c0d01162:	9114      	str	r1, [sp, #80]	; 0x50
c0d01164:	4628      	mov	r0, r5
c0d01166:	f009 fa97 	bl	c0d0a698 <explicit_bzero>
        explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d0116a:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d0116c:	4621      	mov	r1, r4
c0d0116e:	4626      	mov	r6, r4
c0d01170:	f009 fa92 	bl	c0d0a698 <explicit_bzero>
c0d01174:	9c11      	ldr	r4, [sp, #68]	; 0x44
        selfTransfer = (memcmp(publicKey.W + 1, dataBuffer + 20 + 32 + postOffset, 32) == 0);
c0d01176:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d01178:	1825      	adds	r5, r4, r0
        io_seproxyhal_io_heartbeat();
c0d0117a:	f003 fdf3 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
        selfTransfer = (memcmp(publicKey.W + 1, dataBuffer + 20 + 32 + postOffset, 32) == 0);
c0d0117e:	4629      	mov	r1, r5
c0d01180:	3134      	adds	r1, #52	; 0x34
c0d01182:	3709      	adds	r7, #9
c0d01184:	4638      	mov	r0, r7
c0d01186:	9113      	str	r1, [sp, #76]	; 0x4c
c0d01188:	4632      	mov	r2, r6
c0d0118a:	f009 fa89 	bl	c0d0a6a0 <memcmp>
c0d0118e:	4607      	mov	r7, r0
c0d01190:	4241      	negs	r1, r0
c0d01192:	4141      	adcs	r1, r0
        PRINTF("self transfer %d\n", selfTransfer);
c0d01194:	4847      	ldr	r0, [pc, #284]	; (c0d012b4 <handleStarkwareSignMessage+0x68c>)
c0d01196:	4478      	add	r0, pc
c0d01198:	f003 ff50 	bl	c0d0503c <mcu_usb_printf>
        io_seproxyhal_io_heartbeat();
c0d0119c:	f003 fde2 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
        stark_get_amount_string(dataBuffer + preOffset,
c0d011a0:	483b      	ldr	r0, [pc, #236]	; (c0d01290 <handleStarkwareSignMessage+0x668>)
c0d011a2:	4669      	mov	r1, sp
c0d011a4:	6008      	str	r0, [r1, #0]
                                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4,
c0d011a6:	355c      	adds	r5, #92	; 0x5c
                                (char *) (dataBuffer + TMP_OFFSET),
c0d011a8:	4623      	mov	r3, r4
c0d011aa:	338c      	adds	r3, #140	; 0x8c
        stark_get_amount_string(dataBuffer + preOffset,
c0d011ac:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d011ae:	990b      	ldr	r1, [sp, #44]	; 0x2c
c0d011b0:	462a      	mov	r2, r5
c0d011b2:	f004 fbb5 	bl	c0d05920 <stark_get_amount_string>
c0d011b6:	2054      	movs	r0, #84	; 0x54
                 U4BE(dataBuffer, 20 + 32 + postOffset + 32 + 4));
c0d011b8:	9912      	ldr	r1, [sp, #72]	; 0x48
c0d011ba:	4308      	orrs	r0, r1
        selfTransfer = (memcmp(publicKey.W + 1, dataBuffer + 20 + 32 + postOffset, 32) == 0);
c0d011bc:	1820      	adds	r0, r4, r0
                 U4BE(dataBuffer, 20 + 32 + postOffset + 32 + 4));
c0d011be:	79c1      	ldrb	r1, [r0, #7]
c0d011c0:	7982      	ldrb	r2, [r0, #6]
c0d011c2:	0212      	lsls	r2, r2, #8
c0d011c4:	1851      	adds	r1, r2, r1
c0d011c6:	7942      	ldrb	r2, [r0, #5]
c0d011c8:	7900      	ldrb	r0, [r0, #4]
c0d011ca:	0200      	lsls	r0, r0, #8
c0d011cc:	1880      	adds	r0, r0, r2
c0d011ce:	0400      	lsls	r0, r0, #16
c0d011d0:	180b      	adds	r3, r1, r0
        snprintf(strings.tmp.tmp2,
c0d011d2:	4830      	ldr	r0, [pc, #192]	; (c0d01294 <handleStarkwareSignMessage+0x66c>)
c0d011d4:	3064      	adds	r0, #100	; 0x64
c0d011d6:	4a38      	ldr	r2, [pc, #224]	; (c0d012b8 <handleStarkwareSignMessage+0x690>)
c0d011d8:	447a      	add	r2, pc
c0d011da:	9914      	ldr	r1, [sp, #80]	; 0x50
c0d011dc:	f004 f8d8 	bl	c0d05390 <snprintf>
        if (!selfTransfer) {
c0d011e0:	2f00      	cmp	r7, #0
c0d011e2:	d018      	beq.n	c0d01216 <handleStarkwareSignMessage+0x5ee>
c0d011e4:	4d28      	ldr	r5, [pc, #160]	; (c0d01288 <handleStarkwareSignMessage+0x660>)
            memmove(dataContext.starkContext.transferDestination,
c0d011e6:	4628      	mov	r0, r5
c0d011e8:	3081      	adds	r0, #129	; 0x81
c0d011ea:	2420      	movs	r4, #32
c0d011ec:	9e13      	ldr	r6, [sp, #76]	; 0x4c
c0d011ee:	4631      	mov	r1, r6
c0d011f0:	4622      	mov	r2, r4
c0d011f2:	f009 fa45 	bl	c0d0a680 <__aeabi_memmove>
            snprintf(strings.tmp.tmp,
c0d011f6:	4668      	mov	r0, sp
c0d011f8:	6006      	str	r6, [r0, #0]
c0d011fa:	4826      	ldr	r0, [pc, #152]	; (c0d01294 <handleStarkwareSignMessage+0x66c>)
c0d011fc:	2164      	movs	r1, #100	; 0x64
c0d011fe:	4a31      	ldr	r2, [pc, #196]	; (c0d012c4 <handleStarkwareSignMessage+0x69c>)
c0d01200:	447a      	add	r2, pc
c0d01202:	4623      	mov	r3, r4
c0d01204:	f004 f8c4 	bl	c0d05390 <snprintf>
c0d01208:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d0120a:	5c28      	ldrb	r0, [r5, r0]
                (dataContext.starkContext.conditional ? ux_stark_self_transfer_conditional_flow
                                                      : ux_stark_self_transfer_flow),
                NULL);
        } else {
            ux_flow_init(0,
                         (dataContext.starkContext.conditional ? ux_stark_transfer_conditional_flow
c0d0120c:	2800      	cmp	r0, #0
c0d0120e:	d00b      	beq.n	c0d01228 <handleStarkwareSignMessage+0x600>
c0d01210:	492e      	ldr	r1, [pc, #184]	; (c0d012cc <handleStarkwareSignMessage+0x6a4>)
c0d01212:	4479      	add	r1, pc
c0d01214:	e00a      	b.n	c0d0122c <handleStarkwareSignMessage+0x604>
c0d01216:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d01218:	491b      	ldr	r1, [pc, #108]	; (c0d01288 <handleStarkwareSignMessage+0x660>)
c0d0121a:	5c08      	ldrb	r0, [r1, r0]
                (dataContext.starkContext.conditional ? ux_stark_self_transfer_conditional_flow
c0d0121c:	2800      	cmp	r0, #0
c0d0121e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
c0d01220:	d006      	beq.n	c0d01230 <handleStarkwareSignMessage+0x608>
c0d01222:	4927      	ldr	r1, [pc, #156]	; (c0d012c0 <handleStarkwareSignMessage+0x698>)
c0d01224:	4479      	add	r1, pc
c0d01226:	e005      	b.n	c0d01234 <handleStarkwareSignMessage+0x60c>
c0d01228:	4927      	ldr	r1, [pc, #156]	; (c0d012c8 <handleStarkwareSignMessage+0x6a0>)
c0d0122a:	4479      	add	r1, pc
c0d0122c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
c0d0122e:	e001      	b.n	c0d01234 <handleStarkwareSignMessage+0x60c>
c0d01230:	4922      	ldr	r1, [pc, #136]	; (c0d012bc <handleStarkwareSignMessage+0x694>)
c0d01232:	4479      	add	r1, pc
c0d01234:	2000      	movs	r0, #0
c0d01236:	4602      	mov	r2, r0
c0d01238:	f008 fcee 	bl	c0d09c18 <ux_flow_init>
                                                               : ux_stark_transfer_flow),
                         NULL);
        }
    }

    *flags |= IO_ASYNCH_REPLY;
c0d0123c:	6820      	ldr	r0, [r4, #0]
c0d0123e:	2110      	movs	r1, #16
c0d01240:	4301      	orrs	r1, r0
c0d01242:	6021      	str	r1, [r4, #0]
}
c0d01244:	b041      	add	sp, #260	; 0x104
c0d01246:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01248:	20d5      	movs	r0, #213	; 0xd5
c0d0124a:	01c0      	lsls	r0, r0, #7
c0d0124c:	3080      	adds	r0, #128	; 0x80
c0d0124e:	f003 f899 	bl	c0d04384 <os_longjmp>
        PRINTF("Invalid path\n");
c0d01252:	4811      	ldr	r0, [pc, #68]	; (c0d01298 <handleStarkwareSignMessage+0x670>)
c0d01254:	4478      	add	r0, pc
c0d01256:	f003 fef1 	bl	c0d0503c <mcu_usb_printf>
c0d0125a:	e00e      	b.n	c0d0127a <handleStarkwareSignMessage+0x652>
c0d0125c:	2067      	movs	r0, #103	; 0x67
c0d0125e:	0200      	lsls	r0, r0, #8
c0d01260:	f003 f890 	bl	c0d04384 <os_longjmp>
c0d01264:	480e      	ldr	r0, [pc, #56]	; (c0d012a0 <handleStarkwareSignMessage+0x678>)
c0d01266:	4478      	add	r0, pc
c0d01268:	2114      	movs	r1, #20
c0d0126a:	4632      	mov	r2, r6
c0d0126c:	f003 fee6 	bl	c0d0503c <mcu_usb_printf>
c0d01270:	e003      	b.n	c0d0127a <handleStarkwareSignMessage+0x652>
        PRINTF("stark - unexpected quantum descriptor type for null first address %d\n",
c0d01272:	480a      	ldr	r0, [pc, #40]	; (c0d0129c <handleStarkwareSignMessage+0x674>)
c0d01274:	4478      	add	r0, pc
c0d01276:	f003 fee1 	bl	c0d0503c <mcu_usb_printf>
c0d0127a:	20d5      	movs	r0, #213	; 0xd5
c0d0127c:	01c0      	lsls	r0, r0, #7
c0d0127e:	f003 f881 	bl	c0d04384 <os_longjmp>
c0d01282:	46c0      	nop			; (mov r8, r8)
c0d01284:	20001804 	.word	0x20001804
c0d01288:	20001be4 	.word	0x20001be4
c0d0128c:	20001d60 	.word	0x20001d60
c0d01290:	200018dc 	.word	0x200018dc
c0d01294:	20001cca 	.word	0x20001cca
c0d01298:	000099c4 	.word	0x000099c4
c0d0129c:	00009b28 	.word	0x00009b28
c0d012a0:	00009b7c 	.word	0x00009b7c
c0d012a4:	00009e3d 	.word	0x00009e3d
c0d012a8:	00009e38 	.word	0x00009e38
c0d012ac:	00009e3d 	.word	0x00009e3d
c0d012b0:	00009df4 	.word	0x00009df4
c0d012b4:	00009cf9 	.word	0x00009cf9
c0d012b8:	0000ab62 	.word	0x0000ab62
c0d012bc:	0000be5a 	.word	0x0000be5a
c0d012c0:	0000beac 	.word	0x0000beac
c0d012c4:	00009b4c 	.word	0x00009b4c
c0d012c8:	0000be42 	.word	0x0000be42
c0d012cc:	0000be96 	.word	0x0000be96
c0d012d0:	0000ac2a 	.word	0x0000ac2a
c0d012d4:	0000bdbe 	.word	0x0000bdbe

c0d012d8 <handleStarkwareUnsafeSign>:
void handleStarkwareUnsafeSign(uint8_t p1,
                               uint8_t p2,
                               uint8_t *dataBuffer,
                               uint16_t dataLength,
                               unsigned int *flags,
                               unsigned int *tx) {
c0d012d8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d012da:	b0a9      	sub	sp, #164	; 0xa4
c0d012dc:	4615      	mov	r5, r2
c0d012de:	460f      	mov	r7, r1
c0d012e0:	4606      	mov	r6, r0
    uint32_t i;
    uint8_t privateKeyData[32];
    cx_ecfp_public_key_t publicKey;
    cx_ecfp_private_key_t privateKey;
    uint8_t bip32PathLength = *(dataBuffer);
c0d012e2:	7814      	ldrb	r4, [r2, #0]
    uint8_t offset = 1;
    // Initial checks
    if (appState != APP_STATE_IDLE) {
c0d012e4:	4942      	ldr	r1, [pc, #264]	; (c0d013f0 <handleStarkwareUnsafeSign+0x118>)
c0d012e6:	7809      	ldrb	r1, [r1, #0]
c0d012e8:	2900      	cmp	r1, #0
c0d012ea:	d003      	beq.n	c0d012f4 <handleStarkwareUnsafeSign+0x1c>
c0d012ec:	9303      	str	r3, [sp, #12]
        reset_app_context();
c0d012ee:	f002 faad 	bl	c0d0384c <reset_app_context>
c0d012f2:	9b03      	ldr	r3, [sp, #12]
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0d012f4:	1e61      	subs	r1, r4, #1
c0d012f6:	b2c9      	uxtb	r1, r1
c0d012f8:	290a      	cmp	r1, #10
c0d012fa:	d268      	bcs.n	c0d013ce <handleStarkwareUnsafeSign+0xf6>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != 0) || (p2 != 0)) {
c0d012fc:	4337      	orrs	r7, r6
c0d012fe:	2f00      	cmp	r7, #0
c0d01300:	d16d      	bne.n	c0d013de <handleStarkwareUnsafeSign+0x106>
        THROW(0x6B00);
    }

    if (dataLength != 32 + 4 * bip32PathLength + 1) {
c0d01302:	00a0      	lsls	r0, r4, #2
c0d01304:	3021      	adds	r0, #33	; 0x21
c0d01306:	4298      	cmp	r0, r3
c0d01308:	d16e      	bne.n	c0d013e8 <handleStarkwareUnsafeSign+0x110>
c0d0130a:	982e      	ldr	r0, [sp, #184]	; 0xb8
        THROW(0x6700);
    }

    tmpCtx.transactionContext.pathLength = bip32PathLength;
c0d0130c:	9001      	str	r0, [sp, #4]
c0d0130e:	4839      	ldr	r0, [pc, #228]	; (c0d013f4 <handleStarkwareUnsafeSign+0x11c>)
c0d01310:	7004      	strb	r4, [r0, #0]
c0d01312:	9403      	str	r4, [sp, #12]
c0d01314:	1d04      	adds	r4, r0, #4
c0d01316:	1c69      	adds	r1, r5, #1
c0d01318:	2600      	movs	r6, #0
c0d0131a:	2701      	movs	r7, #1
c0d0131c:	4837      	ldr	r0, [pc, #220]	; (c0d013fc <handleStarkwareUnsafeSign+0x124>)
c0d0131e:	4478      	add	r0, pc
c0d01320:	9002      	str	r0, [sp, #8]
    for (i = 0; i < bip32PathLength; i++) {
        tmpCtx.transactionContext.bip32Path[i] = U4BE(dataBuffer, offset);
c0d01322:	19e8      	adds	r0, r5, r7
c0d01324:	78c2      	ldrb	r2, [r0, #3]
c0d01326:	7883      	ldrb	r3, [r0, #2]
c0d01328:	021b      	lsls	r3, r3, #8
c0d0132a:	189a      	adds	r2, r3, r2
c0d0132c:	7840      	ldrb	r0, [r0, #1]
c0d0132e:	7809      	ldrb	r1, [r1, #0]
c0d01330:	0209      	lsls	r1, r1, #8
c0d01332:	1808      	adds	r0, r1, r0
c0d01334:	0400      	lsls	r0, r0, #16
c0d01336:	1812      	adds	r2, r2, r0
c0d01338:	c404      	stmia	r4!, {r2}
        PRINTF("Storing path %d %d\n", i, tmpCtx.transactionContext.bip32Path[i]);
c0d0133a:	9802      	ldr	r0, [sp, #8]
c0d0133c:	4631      	mov	r1, r6
c0d0133e:	f003 fe7d 	bl	c0d0503c <mcu_usb_printf>
        offset += 4;
c0d01342:	1d38      	adds	r0, r7, #4
c0d01344:	b2c7      	uxtb	r7, r0
c0d01346:	19e9      	adds	r1, r5, r7
    for (i = 0; i < bip32PathLength; i++) {
c0d01348:	1c76      	adds	r6, r6, #1
c0d0134a:	9803      	ldr	r0, [sp, #12]
c0d0134c:	42b0      	cmp	r0, r6
c0d0134e:	d1e8      	bne.n	c0d01322 <handleStarkwareUnsafeSign+0x4a>
    }
    memmove(dataContext.starkContext.w2, dataBuffer + offset, 32);
c0d01350:	4829      	ldr	r0, [pc, #164]	; (c0d013f8 <handleStarkwareUnsafeSign+0x120>)
c0d01352:	3020      	adds	r0, #32
c0d01354:	2420      	movs	r4, #32
c0d01356:	4622      	mov	r2, r4
c0d01358:	9402      	str	r4, [sp, #8]
c0d0135a:	f009 f991 	bl	c0d0a680 <__aeabi_memmove>
    io_seproxyhal_io_heartbeat();
c0d0135e:	f003 fd01 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path, bip32PathLength, privateKeyData);
c0d01362:	4824      	ldr	r0, [pc, #144]	; (c0d013f4 <handleStarkwareUnsafeSign+0x11c>)
c0d01364:	1d00      	adds	r0, r0, #4
c0d01366:	af21      	add	r7, sp, #132	; 0x84
c0d01368:	9903      	ldr	r1, [sp, #12]
c0d0136a:	463a      	mov	r2, r7
c0d0136c:	f004 fa72 	bl	c0d05854 <starkDerivePrivateKey>
c0d01370:	262e      	movs	r6, #46	; 0x2e
c0d01372:	ad04      	add	r5, sp, #16
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d01374:	4630      	mov	r0, r6
c0d01376:	4639      	mov	r1, r7
c0d01378:	4622      	mov	r2, r4
c0d0137a:	462b      	mov	r3, r5
c0d0137c:	f005 face 	bl	c0d0691c <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d01380:	f003 fcf0 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d01384:	ac0e      	add	r4, sp, #56	; 0x38
c0d01386:	2301      	movs	r3, #1
    cx_ecfp_generate_pair(CX_CURVE_Stark256, &publicKey, &privateKey, 1);
c0d01388:	4630      	mov	r0, r6
c0d0138a:	4621      	mov	r1, r4
c0d0138c:	462a      	mov	r2, r5
c0d0138e:	f005 fad5 	bl	c0d0693c <cx_ecfp_generate_pair>
c0d01392:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d01394:	4628      	mov	r0, r5
c0d01396:	f009 f97f 	bl	c0d0a698 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d0139a:	4638      	mov	r0, r7
c0d0139c:	9d02      	ldr	r5, [sp, #8]
c0d0139e:	4629      	mov	r1, r5
c0d013a0:	f009 f97a 	bl	c0d0a698 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0d013a4:	f003 fcde 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    memmove(dataContext.starkContext.w1, publicKey.W + 1, 32);
c0d013a8:	3409      	adds	r4, #9
c0d013aa:	4813      	ldr	r0, [pc, #76]	; (c0d013f8 <handleStarkwareUnsafeSign+0x120>)
c0d013ac:	4621      	mov	r1, r4
c0d013ae:	462a      	mov	r2, r5
c0d013b0:	f009 f962 	bl	c0d0a678 <__aeabi_memcpy>
    ux_flow_init(0, ux_stark_unsafe_sign_flow, NULL);
c0d013b4:	4912      	ldr	r1, [pc, #72]	; (c0d01400 <handleStarkwareUnsafeSign+0x128>)
c0d013b6:	4479      	add	r1, pc
c0d013b8:	2000      	movs	r0, #0
c0d013ba:	4602      	mov	r2, r0
c0d013bc:	f008 fc2c 	bl	c0d09c18 <ux_flow_init>
c0d013c0:	9a01      	ldr	r2, [sp, #4]

    *flags |= IO_ASYNCH_REPLY;
c0d013c2:	6810      	ldr	r0, [r2, #0]
c0d013c4:	2110      	movs	r1, #16
c0d013c6:	4301      	orrs	r1, r0
c0d013c8:	6011      	str	r1, [r2, #0]
}
c0d013ca:	b029      	add	sp, #164	; 0xa4
c0d013cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        PRINTF("Invalid path\n");
c0d013ce:	480d      	ldr	r0, [pc, #52]	; (c0d01404 <handleStarkwareUnsafeSign+0x12c>)
c0d013d0:	4478      	add	r0, pc
c0d013d2:	f003 fe33 	bl	c0d0503c <mcu_usb_printf>
c0d013d6:	20d5      	movs	r0, #213	; 0xd5
c0d013d8:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0d013da:	f002 ffd3 	bl	c0d04384 <os_longjmp>
c0d013de:	20d5      	movs	r0, #213	; 0xd5
c0d013e0:	01c0      	lsls	r0, r0, #7
        THROW(0x6B00);
c0d013e2:	3080      	adds	r0, #128	; 0x80
c0d013e4:	f002 ffce 	bl	c0d04384 <os_longjmp>
c0d013e8:	2067      	movs	r0, #103	; 0x67
c0d013ea:	0200      	lsls	r0, r0, #8
        THROW(0x6700);
c0d013ec:	f002 ffca 	bl	c0d04384 <os_longjmp>
c0d013f0:	20001800 	.word	0x20001800
c0d013f4:	20001804 	.word	0x20001804
c0d013f8:	20001be4 	.word	0x20001be4
c0d013fc:	00009a51 	.word	0x00009a51
c0d01400:	0000be12 	.word	0x0000be12
c0d01404:	00009848 	.word	0x00009848

c0d01408 <get_underlying_asset_decimals>:
    {"CBAT", 18},
    {"CREP", 18},
    {"cSAI", 18},
};

bool get_underlying_asset_decimals(char *compound_ticker, uint8_t *out_decimals) {
c0d01408:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0140a:	b081      	sub	sp, #4
c0d0140c:	9100      	str	r1, [sp, #0]
c0d0140e:	4605      	mov	r5, r0
c0d01410:	2400      	movs	r4, #0
c0d01412:	4e0e      	ldr	r6, [pc, #56]	; (c0d0144c <get_underlying_asset_decimals+0x44>)
c0d01414:	447e      	add	r6, pc
    for (size_t i = 0; i < NUM_COMPOUND_BINDINGS; i++) {
        underlying_asset_decimals_t *binding =
            (underlying_asset_decimals_t *) PIC(&UNDERLYING_ASSET_DECIMALS[i]);
c0d01416:	4630      	mov	r0, r6
c0d01418:	f004 f98e 	bl	c0d05738 <pic>
c0d0141c:	4607      	mov	r7, r0
c0d0141e:	210c      	movs	r1, #12
        if (strncmp(binding->c_ticker,
                    compound_ticker,
                    strnlen(binding->c_ticker, MAX_TICKER_LEN)) == 0) {
c0d01420:	f009 fb88 	bl	c0d0ab34 <strnlen>
c0d01424:	4602      	mov	r2, r0
        if (strncmp(binding->c_ticker,
c0d01426:	4638      	mov	r0, r7
c0d01428:	4629      	mov	r1, r5
c0d0142a:	f009 fb13 	bl	c0d0aa54 <strncmp>
c0d0142e:	2800      	cmp	r0, #0
c0d01430:	d005      	beq.n	c0d0143e <get_underlying_asset_decimals+0x36>
c0d01432:	1c64      	adds	r4, r4, #1
    for (size_t i = 0; i < NUM_COMPOUND_BINDINGS; i++) {
c0d01434:	360d      	adds	r6, #13
c0d01436:	2c08      	cmp	r4, #8
c0d01438:	d9ed      	bls.n	c0d01416 <get_underlying_asset_decimals+0xe>
c0d0143a:	2000      	movs	r0, #0
c0d0143c:	e003      	b.n	c0d01446 <get_underlying_asset_decimals+0x3e>
            *out_decimals = binding->decimals;
c0d0143e:	7b38      	ldrb	r0, [r7, #12]
c0d01440:	9900      	ldr	r1, [sp, #0]
c0d01442:	7008      	strb	r0, [r1, #0]
c0d01444:	2001      	movs	r0, #1
            return true;
        }
    }
    return false;
}
c0d01446:	b001      	add	sp, #4
c0d01448:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0144a:	46c0      	nop			; (mov r8, r8)
c0d0144c:	00009a8d 	.word	0x00009a8d

c0d01450 <compound_plugin_call>:

void compound_plugin_call(int message, void *parameters) {
c0d01450:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01452:	b083      	sub	sp, #12
c0d01454:	460c      	mov	r4, r1
c0d01456:	4601      	mov	r1, r0
c0d01458:	20ff      	movs	r0, #255	; 0xff
c0d0145a:	4602      	mov	r2, r0
c0d0145c:	3204      	adds	r2, #4
    switch (message) {
c0d0145e:	4291      	cmp	r1, r2
c0d01460:	dc18      	bgt.n	c0d01494 <compound_plugin_call+0x44>
c0d01462:	3002      	adds	r0, #2
c0d01464:	4281      	cmp	r1, r0
c0d01466:	d03c      	beq.n	c0d014e2 <compound_plugin_call+0x92>
c0d01468:	2081      	movs	r0, #129	; 0x81
c0d0146a:	0040      	lsls	r0, r0, #1
c0d0146c:	4281      	cmp	r1, r0
c0d0146e:	d05c      	beq.n	c0d0152a <compound_plugin_call+0xda>
c0d01470:	4291      	cmp	r1, r2
c0d01472:	d000      	beq.n	c0d01476 <compound_plugin_call+0x26>
c0d01474:	e09c      	b.n	c0d015b0 <compound_plugin_call+0x160>
            }
        } break;

        case ETH_PLUGIN_FINALIZE: {
            ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
            PRINTF("compound plugin finalize\n");
c0d01476:	4899      	ldr	r0, [pc, #612]	; (c0d016dc <compound_plugin_call+0x28c>)
c0d01478:	4478      	add	r0, pc
c0d0147a:	f003 fddf 	bl	c0d0503c <mcu_usb_printf>
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d0147e:	6860      	ldr	r0, [r4, #4]
c0d01480:	6800      	ldr	r0, [r0, #0]
c0d01482:	2101      	movs	r1, #1
            msg->numScreens = 2;
            msg->uiType = ETH_UI_TYPE_GENERIC;
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d01484:	77a1      	strb	r1, [r4, #30]
c0d01486:	4994      	ldr	r1, [pc, #592]	; (c0d016d8 <compound_plugin_call+0x288>)
            msg->uiType = ETH_UI_TYPE_GENERIC;
c0d01488:	83a1      	strh	r1, [r4, #28]
c0d0148a:	2121      	movs	r1, #33	; 0x21
c0d0148c:	00c9      	lsls	r1, r1, #3
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d0148e:	1840      	adds	r0, r0, r1
c0d01490:	60e0      	str	r0, [r4, #12]
c0d01492:	e11e      	b.n	c0d016d2 <compound_plugin_call+0x282>
c0d01494:	2641      	movs	r6, #65	; 0x41
c0d01496:	00b2      	lsls	r2, r6, #2
    switch (message) {
c0d01498:	4291      	cmp	r1, r2
c0d0149a:	d054      	beq.n	c0d01546 <compound_plugin_call+0xf6>
c0d0149c:	3006      	adds	r0, #6
c0d0149e:	4281      	cmp	r1, r0
c0d014a0:	d074      	beq.n	c0d0158c <compound_plugin_call+0x13c>
c0d014a2:	2083      	movs	r0, #131	; 0x83
c0d014a4:	0040      	lsls	r0, r0, #1
c0d014a6:	4281      	cmp	r1, r0
c0d014a8:	d000      	beq.n	c0d014ac <compound_plugin_call+0x5c>
c0d014aa:	e081      	b.n	c0d015b0 <compound_plugin_call+0x160>
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0d014ac:	7b20      	ldrb	r0, [r4, #12]
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d014ae:	68a5      	ldr	r5, [r4, #8]
            switch (msg->screenIndex) {
c0d014b0:	2801      	cmp	r0, #1
c0d014b2:	d100      	bne.n	c0d014b6 <compound_plugin_call+0x66>
c0d014b4:	e0db      	b.n	c0d0166e <compound_plugin_call+0x21e>
c0d014b6:	2800      	cmp	r0, #0
c0d014b8:	d000      	beq.n	c0d014bc <compound_plugin_call+0x6c>
c0d014ba:	e10a      	b.n	c0d016d2 <compound_plugin_call+0x282>
                case 0: {
                    strcpy(msg->title, "Amount");
c0d014bc:	6920      	ldr	r0, [r4, #16]
c0d014be:	4995      	ldr	r1, [pc, #596]	; (c0d01714 <compound_plugin_call+0x2c4>)
c0d014c0:	4479      	add	r1, pc
c0d014c2:	2207      	movs	r2, #7
c0d014c4:	f009 f8d8 	bl	c0d0a678 <__aeabi_memcpy>
c0d014c8:	202d      	movs	r0, #45	; 0x2d
                    if (context->selectorIndex != COMPOUND_REDEEM) {
                        ticker_ptr++;
                    }
                    amountToString(context->amount,
                                   sizeof(context->amount),
                                   context->decimals,
c0d014ca:	5c2a      	ldrb	r2, [r5, r0]
                    if (context->selectorIndex != COMPOUND_REDEEM) {
c0d014cc:	7828      	ldrb	r0, [r5, #0]
                                   ticker_ptr,
                                   msg->msg,
c0d014ce:	69a1      	ldr	r1, [r4, #24]
c0d014d0:	2364      	movs	r3, #100	; 0x64
                    amountToString(context->amount,
c0d014d2:	466e      	mov	r6, sp
c0d014d4:	c60a      	stmia	r6!, {r1, r3}
c0d014d6:	462b      	mov	r3, r5
                    if (context->selectorIndex != COMPOUND_REDEEM) {
c0d014d8:	2801      	cmp	r0, #1
c0d014da:	d100      	bne.n	c0d014de <compound_plugin_call+0x8e>
c0d014dc:	e0e9      	b.n	c0d016b2 <compound_plugin_call+0x262>
c0d014de:	3322      	adds	r3, #34	; 0x22
c0d014e0:	e0e8      	b.n	c0d016b4 <compound_plugin_call+0x264>
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d014e2:	68a0      	ldr	r0, [r4, #8]
c0d014e4:	9002      	str	r0, [sp, #8]
c0d014e6:	2600      	movs	r6, #0
c0d014e8:	4f7e      	ldr	r7, [pc, #504]	; (c0d016e4 <compound_plugin_call+0x294>)
c0d014ea:	447f      	add	r7, pc
                if (memcmp((uint8_t *) PIC(COMPOUND_SELECTORS[i]), msg->selector, SELECTOR_SIZE) ==
c0d014ec:	6838      	ldr	r0, [r7, #0]
c0d014ee:	f004 f923 	bl	c0d05738 <pic>
c0d014f2:	7801      	ldrb	r1, [r0, #0]
c0d014f4:	7842      	ldrb	r2, [r0, #1]
c0d014f6:	0212      	lsls	r2, r2, #8
c0d014f8:	1851      	adds	r1, r2, r1
c0d014fa:	7882      	ldrb	r2, [r0, #2]
c0d014fc:	78c0      	ldrb	r0, [r0, #3]
c0d014fe:	0200      	lsls	r0, r0, #8
c0d01500:	1880      	adds	r0, r0, r2
c0d01502:	0400      	lsls	r0, r0, #16
c0d01504:	1840      	adds	r0, r0, r1
c0d01506:	6922      	ldr	r2, [r4, #16]
c0d01508:	7811      	ldrb	r1, [r2, #0]
c0d0150a:	7853      	ldrb	r3, [r2, #1]
c0d0150c:	021b      	lsls	r3, r3, #8
c0d0150e:	1859      	adds	r1, r3, r1
c0d01510:	7893      	ldrb	r3, [r2, #2]
c0d01512:	78d5      	ldrb	r5, [r2, #3]
c0d01514:	022d      	lsls	r5, r5, #8
c0d01516:	18eb      	adds	r3, r5, r3
c0d01518:	041b      	lsls	r3, r3, #16
c0d0151a:	1859      	adds	r1, r3, r1
c0d0151c:	4288      	cmp	r0, r1
c0d0151e:	d04c      	beq.n	c0d015ba <compound_plugin_call+0x16a>
            for (i = 0; i < NUM_COMPOUND_SELECTORS; i++) {
c0d01520:	1d3f      	adds	r7, r7, #4
c0d01522:	1c76      	adds	r6, r6, #1
c0d01524:	2e04      	cmp	r6, #4
c0d01526:	d3e1      	bcc.n	c0d014ec <compound_plugin_call+0x9c>
c0d01528:	e049      	b.n	c0d015be <compound_plugin_call+0x16e>
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d0152a:	68a5      	ldr	r5, [r4, #8]
                   msg->parameter);
c0d0152c:	68e3      	ldr	r3, [r4, #12]
                   msg->parameterOffset,
c0d0152e:	6921      	ldr	r1, [r4, #16]
            PRINTF("compound plugin provide parameter %d %.*H\n",
c0d01530:	4871      	ldr	r0, [pc, #452]	; (c0d016f8 <compound_plugin_call+0x2a8>)
c0d01532:	4478      	add	r0, pc
c0d01534:	2220      	movs	r2, #32
c0d01536:	f003 fd81 	bl	c0d0503c <mcu_usb_printf>
            if (context->selectorIndex != CETH_MINT) {
c0d0153a:	7828      	ldrb	r0, [r5, #0]
c0d0153c:	2803      	cmp	r0, #3
c0d0153e:	d155      	bne.n	c0d015ec <compound_plugin_call+0x19c>
                PRINTF("CETH contract expects no parameters\n");
c0d01540:	486f      	ldr	r0, [pc, #444]	; (c0d01700 <compound_plugin_call+0x2b0>)
c0d01542:	4478      	add	r0, pc
c0d01544:	e0aa      	b.n	c0d0169c <compound_plugin_call+0x24c>
            PRINTF("compound plugin provide token: %d\n", (msg->token1 != NULL));
c0d01546:	68e1      	ldr	r1, [r4, #12]
c0d01548:	2900      	cmp	r1, #0
c0d0154a:	d000      	beq.n	c0d0154e <compound_plugin_call+0xfe>
c0d0154c:	2101      	movs	r1, #1
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d0154e:	68a5      	ldr	r5, [r4, #8]
            PRINTF("compound plugin provide token: %d\n", (msg->token1 != NULL));
c0d01550:	486c      	ldr	r0, [pc, #432]	; (c0d01704 <compound_plugin_call+0x2b4>)
c0d01552:	4478      	add	r0, pc
c0d01554:	f003 fd72 	bl	c0d0503c <mcu_usb_printf>
            if (msg->token1 != NULL) {
c0d01558:	68e1      	ldr	r1, [r4, #12]
c0d0155a:	2900      	cmp	r1, #0
c0d0155c:	d014      	beq.n	c0d01588 <compound_plugin_call+0x138>
                strcpy((char *) context->ticker_1, (char *) msg->token1->ticker);
c0d0155e:	4628      	mov	r0, r5
c0d01560:	3021      	adds	r0, #33	; 0x21
c0d01562:	3114      	adds	r1, #20
c0d01564:	f009 fa40 	bl	c0d0a9e8 <strcpy>
                switch (context->selectorIndex) {
c0d01568:	7829      	ldrb	r1, [r5, #0]
c0d0156a:	1e8a      	subs	r2, r1, #2
c0d0156c:	2a02      	cmp	r2, #2
c0d0156e:	d304      	bcc.n	c0d0157a <compound_plugin_call+0x12a>
c0d01570:	2901      	cmp	r1, #1
c0d01572:	d100      	bne.n	c0d01576 <compound_plugin_call+0x126>
c0d01574:	e0a6      	b.n	c0d016c4 <compound_plugin_call+0x274>
c0d01576:	2900      	cmp	r1, #0
c0d01578:	d106      	bne.n	c0d01588 <compound_plugin_call+0x138>
                            get_underlying_asset_decimals(context->ticker_1, &context->decimals)
c0d0157a:	352d      	adds	r5, #45	; 0x2d
c0d0157c:	4629      	mov	r1, r5
c0d0157e:	f7ff ff43 	bl	c0d01408 <get_underlying_asset_decimals>
c0d01582:	2800      	cmp	r0, #0
c0d01584:	d000      	beq.n	c0d01588 <compound_plugin_call+0x138>
c0d01586:	e0a2      	b.n	c0d016ce <compound_plugin_call+0x27e>
c0d01588:	2003      	movs	r0, #3
c0d0158a:	e0a1      	b.n	c0d016d0 <compound_plugin_call+0x280>
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d0158c:	68a5      	ldr	r5, [r4, #8]
            strcpy(msg->name, "Type");
c0d0158e:	68e0      	ldr	r0, [r4, #12]
c0d01590:	495d      	ldr	r1, [pc, #372]	; (c0d01708 <compound_plugin_call+0x2b8>)
c0d01592:	4479      	add	r1, pc
c0d01594:	2205      	movs	r2, #5
c0d01596:	f009 f86f 	bl	c0d0a678 <__aeabi_memcpy>
            switch (context->selectorIndex) {
c0d0159a:	7828      	ldrb	r0, [r5, #0]
c0d0159c:	1e81      	subs	r1, r0, #2
c0d0159e:	2902      	cmp	r1, #2
c0d015a0:	d32d      	bcc.n	c0d015fe <compound_plugin_call+0x1ae>
c0d015a2:	2801      	cmp	r0, #1
c0d015a4:	d831      	bhi.n	c0d0160a <compound_plugin_call+0x1ba>
                    strcpy(msg->version, "Redeem");
c0d015a6:	6960      	ldr	r0, [r4, #20]
c0d015a8:	4958      	ldr	r1, [pc, #352]	; (c0d0170c <compound_plugin_call+0x2bc>)
c0d015aa:	4479      	add	r1, pc
c0d015ac:	2207      	movs	r2, #7
c0d015ae:	e02a      	b.n	c0d01606 <compound_plugin_call+0x1b6>
                    break;
            }
        } break;

        default:
            PRINTF("Unhandled message %d\n", message);
c0d015b0:	484b      	ldr	r0, [pc, #300]	; (c0d016e0 <compound_plugin_call+0x290>)
c0d015b2:	4478      	add	r0, pc
c0d015b4:	f003 fd42 	bl	c0d0503c <mcu_usb_printf>
c0d015b8:	e08b      	b.n	c0d016d2 <compound_plugin_call+0x282>
                    context->selectorIndex = i;
c0d015ba:	9802      	ldr	r0, [sp, #8]
c0d015bc:	7006      	strb	r6, [r0, #0]
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d015be:	6860      	ldr	r0, [r4, #4]
c0d015c0:	6800      	ldr	r0, [r0, #0]
c0d015c2:	3042      	adds	r0, #66	; 0x42
c0d015c4:	2100      	movs	r1, #0
        if (buf[i]) {
c0d015c6:	5c43      	ldrb	r3, [r0, r1]
c0d015c8:	2b00      	cmp	r3, #0
c0d015ca:	d103      	bne.n	c0d015d4 <compound_plugin_call+0x184>
c0d015cc:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d015ce:	291f      	cmp	r1, #31
c0d015d0:	d9f9      	bls.n	c0d015c6 <compound_plugin_call+0x176>
c0d015d2:	e003      	b.n	c0d015dc <compound_plugin_call+0x18c>
                if (context->selectorIndex != CETH_MINT) {
c0d015d4:	9802      	ldr	r0, [sp, #8]
c0d015d6:	7800      	ldrb	r0, [r0, #0]
c0d015d8:	2803      	cmp	r0, #3
c0d015da:	d167      	bne.n	c0d016ac <compound_plugin_call+0x25c>
            if (i == NUM_COMPOUND_SELECTORS) {
c0d015dc:	2e04      	cmp	r6, #4
c0d015de:	d128      	bne.n	c0d01632 <compound_plugin_call+0x1e2>
                PRINTF("Unknown selector %.*H\n", SELECTOR_SIZE, msg->selector);
c0d015e0:	4841      	ldr	r0, [pc, #260]	; (c0d016e8 <compound_plugin_call+0x298>)
c0d015e2:	4478      	add	r0, pc
c0d015e4:	2104      	movs	r1, #4
c0d015e6:	f003 fd29 	bl	c0d0503c <mcu_usb_printf>
c0d015ea:	e05f      	b.n	c0d016ac <compound_plugin_call+0x25c>
                switch (msg->parameterOffset) {
c0d015ec:	6920      	ldr	r0, [r4, #16]
c0d015ee:	2804      	cmp	r0, #4
c0d015f0:	d152      	bne.n	c0d01698 <compound_plugin_call+0x248>
                        memmove(context->amount, msg->parameter, 32);
c0d015f2:	68e1      	ldr	r1, [r4, #12]
c0d015f4:	1c68      	adds	r0, r5, #1
c0d015f6:	2220      	movs	r2, #32
c0d015f8:	f009 f842 	bl	c0d0a680 <__aeabi_memmove>
c0d015fc:	e067      	b.n	c0d016ce <compound_plugin_call+0x27e>
                    strcpy(msg->version, "Lend");
c0d015fe:	6960      	ldr	r0, [r4, #20]
c0d01600:	4943      	ldr	r1, [pc, #268]	; (c0d01710 <compound_plugin_call+0x2c0>)
c0d01602:	4479      	add	r1, pc
c0d01604:	2205      	movs	r2, #5
c0d01606:	f009 f837 	bl	c0d0a678 <__aeabi_memcpy>
            strcat(msg->version, " Assets");
c0d0160a:	6965      	ldr	r5, [r4, #20]
c0d0160c:	4628      	mov	r0, r5
c0d0160e:	f009 f9f3 	bl	c0d0a9f8 <strlen>
c0d01612:	2120      	movs	r1, #32
c0d01614:	5429      	strb	r1, [r5, r0]
c0d01616:	1828      	adds	r0, r5, r0
c0d01618:	2100      	movs	r1, #0
c0d0161a:	71c1      	strb	r1, [r0, #7]
c0d0161c:	2173      	movs	r1, #115	; 0x73
c0d0161e:	7181      	strb	r1, [r0, #6]
c0d01620:	2274      	movs	r2, #116	; 0x74
c0d01622:	7142      	strb	r2, [r0, #5]
c0d01624:	2265      	movs	r2, #101	; 0x65
c0d01626:	7102      	strb	r2, [r0, #4]
c0d01628:	70c1      	strb	r1, [r0, #3]
c0d0162a:	7081      	strb	r1, [r0, #2]
c0d0162c:	7046      	strb	r6, [r0, #1]
c0d0162e:	2001      	movs	r0, #1
c0d01630:	e03d      	b.n	c0d016ae <compound_plugin_call+0x25e>
            if (msg->dataSize != COMPOUND_EXPECTED_DATA_SIZE[context->selectorIndex]) {
c0d01632:	9802      	ldr	r0, [sp, #8]
c0d01634:	7801      	ldrb	r1, [r0, #0]
c0d01636:	482d      	ldr	r0, [pc, #180]	; (c0d016ec <compound_plugin_call+0x29c>)
c0d01638:	4478      	add	r0, pc
c0d0163a:	5c42      	ldrb	r2, [r0, r1]
c0d0163c:	6963      	ldr	r3, [r4, #20]
c0d0163e:	4293      	cmp	r3, r2
c0d01640:	d130      	bne.n	c0d016a4 <compound_plugin_call+0x254>
            if (context->selectorIndex == CETH_MINT) {
c0d01642:	2903      	cmp	r1, #3
c0d01644:	d10e      	bne.n	c0d01664 <compound_plugin_call+0x214>
                memset(context->amount, 0, sizeof(context->amount));
c0d01646:	9802      	ldr	r0, [sp, #8]
c0d01648:	1c45      	adds	r5, r0, #1
c0d0164a:	2120      	movs	r1, #32
c0d0164c:	4628      	mov	r0, r5
c0d0164e:	f009 f80d 	bl	c0d0a66c <__aeabi_memclr>
                            msg->pluginSharedRO->txContent->value.length,
c0d01652:	6860      	ldr	r0, [r4, #4]
c0d01654:	6801      	ldr	r1, [r0, #0]
c0d01656:	2062      	movs	r0, #98	; 0x62
c0d01658:	5c0a      	ldrb	r2, [r1, r0]
                memmove(context->amount + sizeof(context->amount) -
c0d0165a:	1aa8      	subs	r0, r5, r2
c0d0165c:	3020      	adds	r0, #32
                            msg->pluginSharedRO->txContent->value.length,
c0d0165e:	3142      	adds	r1, #66	; 0x42
                memmove(context->amount + sizeof(context->amount) -
c0d01660:	f009 f80e 	bl	c0d0a680 <__aeabi_memmove>
            PRINTF("compound plugin inititialized\n");
c0d01664:	4823      	ldr	r0, [pc, #140]	; (c0d016f4 <compound_plugin_call+0x2a4>)
c0d01666:	4478      	add	r0, pc
c0d01668:	f003 fce8 	bl	c0d0503c <mcu_usb_printf>
c0d0166c:	e7df      	b.n	c0d0162e <compound_plugin_call+0x1de>
                    strcpy(msg->title, "Contract");
c0d0166e:	6920      	ldr	r0, [r4, #16]
c0d01670:	4929      	ldr	r1, [pc, #164]	; (c0d01718 <compound_plugin_call+0x2c8>)
c0d01672:	4479      	add	r1, pc
c0d01674:	2209      	movs	r2, #9
c0d01676:	f008 ffff 	bl	c0d0a678 <__aeabi_memcpy>
                    strcpy(msg->msg, "Compound ");
c0d0167a:	69a0      	ldr	r0, [r4, #24]
c0d0167c:	4927      	ldr	r1, [pc, #156]	; (c0d0171c <compound_plugin_call+0x2cc>)
c0d0167e:	4479      	add	r1, pc
c0d01680:	220a      	movs	r2, #10
c0d01682:	f008 fff9 	bl	c0d0a678 <__aeabi_memcpy>
                    strcat(msg->msg,
c0d01686:	69a0      	ldr	r0, [r4, #24]
                           (char *) context->ticker_1 +
c0d01688:	3522      	adds	r5, #34	; 0x22
                    strcat(msg->msg,
c0d0168a:	4629      	mov	r1, r5
c0d0168c:	f009 f942 	bl	c0d0a914 <strcat>
c0d01690:	2020      	movs	r0, #32
c0d01692:	2101      	movs	r1, #1
                    msg->result = ETH_PLUGIN_RESULT_OK;
c0d01694:	5421      	strb	r1, [r4, r0]
c0d01696:	e01c      	b.n	c0d016d2 <compound_plugin_call+0x282>
                        PRINTF("Unhandled parameter offset\n");
c0d01698:	4818      	ldr	r0, [pc, #96]	; (c0d016fc <compound_plugin_call+0x2ac>)
c0d0169a:	4478      	add	r0, pc
c0d0169c:	f003 fcce 	bl	c0d0503c <mcu_usb_printf>
c0d016a0:	2000      	movs	r0, #0
c0d016a2:	e015      	b.n	c0d016d0 <compound_plugin_call+0x280>
                PRINTF("Unexpected data size for command %d expected %d got %d\n",
c0d016a4:	4812      	ldr	r0, [pc, #72]	; (c0d016f0 <compound_plugin_call+0x2a0>)
c0d016a6:	4478      	add	r0, pc
c0d016a8:	f003 fcc8 	bl	c0d0503c <mcu_usb_printf>
c0d016ac:	2000      	movs	r0, #0
c0d016ae:	7720      	strb	r0, [r4, #28]
c0d016b0:	e00f      	b.n	c0d016d2 <compound_plugin_call+0x282>
c0d016b2:	3321      	adds	r3, #33	; 0x21
                    amountToString(context->amount,
c0d016b4:	1c68      	adds	r0, r5, #1
c0d016b6:	2520      	movs	r5, #32
c0d016b8:	4629      	mov	r1, r5
c0d016ba:	f008 f8eb 	bl	c0d09894 <amountToString>
c0d016be:	2001      	movs	r0, #1
                    msg->result = ETH_PLUGIN_RESULT_OK;
c0d016c0:	5560      	strb	r0, [r4, r5]
c0d016c2:	e006      	b.n	c0d016d2 <compound_plugin_call+0x282>
                        context->decimals = msg->token1->decimals;
c0d016c4:	68e0      	ldr	r0, [r4, #12]
c0d016c6:	2120      	movs	r1, #32
c0d016c8:	5c40      	ldrb	r0, [r0, r1]
c0d016ca:	212d      	movs	r1, #45	; 0x2d
c0d016cc:	5468      	strb	r0, [r5, r1]
c0d016ce:	2001      	movs	r0, #1
c0d016d0:	7520      	strb	r0, [r4, #20]
c0d016d2:	b003      	add	sp, #12
c0d016d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d016d6:	46c0      	nop			; (mov r8, r8)
c0d016d8:	00000202 	.word	0x00000202
c0d016dc:	00009b78 	.word	0x00009b78
c0d016e0:	00009a93 	.word	0x00009a93
c0d016e4:	0000a276 	.word	0x0000a276
c0d016e8:	00009934 	.word	0x00009934
c0d016ec:	00009a23 	.word	0x00009a23
c0d016f0:	00009887 	.word	0x00009887
c0d016f4:	000098ff 	.word	0x000098ff
c0d016f8:	00009a52 	.word	0x00009a52
c0d016fc:	00009915 	.word	0x00009915
c0d01700:	00009a89 	.word	0x00009a89
c0d01704:	00009ab8 	.word	0x00009ab8
c0d01708:	00009a9b 	.word	0x00009a9b
c0d0170c:	00009a88 	.word	0x00009a88
c0d01710:	00009a37 	.word	0x00009a37
c0d01714:	00009b7e 	.word	0x00009b7e
c0d01718:	00009c9e 	.word	0x00009c9e
c0d0171c:	000099e2 	.word	0x000099e2

c0d01720 <check_token_binding>:
};

bool check_token_binding(char *ticker1,
                         char *ticker2,
                         const ticker_binding_t *bindings,
                         size_t num_bindings) {
c0d01720:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01722:	b083      	sub	sp, #12
c0d01724:	9101      	str	r1, [sp, #4]
c0d01726:	9002      	str	r0, [sp, #8]
    for (size_t i = 0; i < num_bindings; i++) {
c0d01728:	2b00      	cmp	r3, #0
c0d0172a:	d020      	beq.n	c0d0176e <check_token_binding+0x4e>
c0d0172c:	461c      	mov	r4, r3
c0d0172e:	4615      	mov	r5, r2
c0d01730:	2700      	movs	r7, #0
        ticker_binding_t *binding = (ticker_binding_t *) PIC(&bindings[i]);
c0d01732:	4628      	mov	r0, r5
c0d01734:	f004 f800 	bl	c0d05738 <pic>
c0d01738:	4606      	mov	r6, r0
c0d0173a:	210c      	movs	r1, #12
        if (strncmp(binding->ticker1, ticker1, strnlen(binding->ticker1, MAX_TICKER_LEN)) == 0 &&
c0d0173c:	f009 f9fa 	bl	c0d0ab34 <strnlen>
c0d01740:	4602      	mov	r2, r0
c0d01742:	4630      	mov	r0, r6
c0d01744:	9902      	ldr	r1, [sp, #8]
c0d01746:	f009 f985 	bl	c0d0aa54 <strncmp>
c0d0174a:	2800      	cmp	r0, #0
c0d0174c:	d10b      	bne.n	c0d01766 <check_token_binding+0x46>
            strncmp(binding->ticker2, ticker2, strnlen(binding->ticker2, MAX_TICKER_LEN)) == 0) {
c0d0174e:	360c      	adds	r6, #12
c0d01750:	210c      	movs	r1, #12
c0d01752:	4630      	mov	r0, r6
c0d01754:	f009 f9ee 	bl	c0d0ab34 <strnlen>
c0d01758:	4602      	mov	r2, r0
c0d0175a:	4630      	mov	r0, r6
c0d0175c:	9901      	ldr	r1, [sp, #4]
c0d0175e:	f009 f979 	bl	c0d0aa54 <strncmp>
        if (strncmp(binding->ticker1, ticker1, strnlen(binding->ticker1, MAX_TICKER_LEN)) == 0 &&
c0d01762:	2800      	cmp	r0, #0
c0d01764:	d006      	beq.n	c0d01774 <check_token_binding+0x54>
    for (size_t i = 0; i < num_bindings; i++) {
c0d01766:	3518      	adds	r5, #24
c0d01768:	1c7f      	adds	r7, r7, #1
c0d0176a:	42a7      	cmp	r7, r4
c0d0176c:	d3e1      	bcc.n	c0d01732 <check_token_binding+0x12>
c0d0176e:	2000      	movs	r0, #0
            return true;
        }
    }
    return false;
}
c0d01770:	b003      	add	sp, #12
c0d01772:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01774:	2001      	movs	r0, #1
c0d01776:	e7fb      	b.n	c0d01770 <check_token_binding+0x50>

c0d01778 <erc20_plugin_available_check>:

bool erc20_plugin_available_check() {
#ifdef HAVE_STARKWARE
    if (quantumSet) {
c0d01778:	4807      	ldr	r0, [pc, #28]	; (c0d01798 <erc20_plugin_available_check+0x20>)
c0d0177a:	7801      	ldrb	r1, [r0, #0]
c0d0177c:	2001      	movs	r0, #1
c0d0177e:	2900      	cmp	r1, #0
c0d01780:	d006      	beq.n	c0d01790 <erc20_plugin_available_check+0x18>
c0d01782:	21e5      	movs	r1, #229	; 0xe5
        switch (dataContext.tokenContext.quantumType) {
c0d01784:	4a05      	ldr	r2, [pc, #20]	; (c0d0179c <erc20_plugin_available_check+0x24>)
c0d01786:	5c51      	ldrb	r1, [r2, r1]
c0d01788:	2904      	cmp	r1, #4
c0d0178a:	d802      	bhi.n	c0d01792 <erc20_plugin_available_check+0x1a>
c0d0178c:	2903      	cmp	r1, #3
c0d0178e:	d000      	beq.n	c0d01792 <erc20_plugin_available_check+0x1a>
                return false;
        }
    }
#endif
    return true;
}
c0d01790:	4770      	bx	lr
c0d01792:	2000      	movs	r0, #0
c0d01794:	4770      	bx	lr
c0d01796:	46c0      	nop			; (mov r8, r8)
c0d01798:	2000189d 	.word	0x2000189d
c0d0179c:	20001be4 	.word	0x20001be4

c0d017a0 <erc20_plugin_call>:

void erc20_plugin_call(int message, void *parameters) {
c0d017a0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d017a2:	b083      	sub	sp, #12
c0d017a4:	460c      	mov	r4, r1
c0d017a6:	4601      	mov	r1, r0
c0d017a8:	20ff      	movs	r0, #255	; 0xff
c0d017aa:	4602      	mov	r2, r0
c0d017ac:	3204      	adds	r2, #4
    switch (message) {
c0d017ae:	4291      	cmp	r1, r2
c0d017b0:	dc24      	bgt.n	c0d017fc <erc20_plugin_call+0x5c>
c0d017b2:	3002      	adds	r0, #2
c0d017b4:	4281      	cmp	r1, r0
c0d017b6:	d04f      	beq.n	c0d01858 <erc20_plugin_call+0xb8>
c0d017b8:	2081      	movs	r0, #129	; 0x81
c0d017ba:	0040      	lsls	r0, r0, #1
c0d017bc:	4281      	cmp	r1, r0
c0d017be:	d100      	bne.n	c0d017c2 <erc20_plugin_call+0x22>
c0d017c0:	e081      	b.n	c0d018c6 <erc20_plugin_call+0x126>
c0d017c2:	4291      	cmp	r1, r2
c0d017c4:	d000      	beq.n	c0d017c8 <erc20_plugin_call+0x28>
c0d017c6:	e0e4      	b.n	c0d01992 <erc20_plugin_call+0x1f2>
            }
        } break;

        case ETH_PLUGIN_FINALIZE: {
            ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d017c8:	68a5      	ldr	r5, [r4, #8]
            PRINTF("erc20 plugin finalize\n");
c0d017ca:	48b3      	ldr	r0, [pc, #716]	; (c0d01a98 <erc20_plugin_call+0x2f8>)
c0d017cc:	4478      	add	r0, pc
c0d017ce:	f003 fc35 	bl	c0d0503c <mcu_usb_printf>
            if (context->selectorIndex == ERC20_TRANSFER) {
c0d017d2:	7828      	ldrb	r0, [r5, #0]
c0d017d4:	2801      	cmp	r0, #1
c0d017d6:	d100      	bne.n	c0d017da <erc20_plugin_call+0x3a>
c0d017d8:	e0e8      	b.n	c0d019ac <erc20_plugin_call+0x20c>
c0d017da:	2800      	cmp	r0, #0
c0d017dc:	d000      	beq.n	c0d017e0 <erc20_plugin_call+0x40>
c0d017de:	e155      	b.n	c0d01a8c <erc20_plugin_call+0x2ec>
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d017e0:	6860      	ldr	r0, [r4, #4]
c0d017e2:	6800      	ldr	r0, [r0, #0]
c0d017e4:	2101      	movs	r1, #1
                msg->amount = context->amount;
                msg->address = context->destinationAddress;
                msg->uiType = ETH_UI_TYPE_AMOUNT_ADDRESS;
                msg->result = ETH_PLUGIN_RESULT_OK;
c0d017e6:	77a1      	strb	r1, [r4, #30]
                msg->uiType = ETH_UI_TYPE_AMOUNT_ADDRESS;
c0d017e8:	7721      	strb	r1, [r4, #28]
                msg->address = context->destinationAddress;
c0d017ea:	1c69      	adds	r1, r5, #1
                msg->amount = context->amount;
c0d017ec:	3516      	adds	r5, #22
c0d017ee:	6165      	str	r5, [r4, #20]
                msg->address = context->destinationAddress;
c0d017f0:	61a1      	str	r1, [r4, #24]
c0d017f2:	2121      	movs	r1, #33	; 0x21
c0d017f4:	00c9      	lsls	r1, r1, #3
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d017f6:	1840      	adds	r0, r0, r1
c0d017f8:	60e0      	str	r0, [r4, #12]
c0d017fa:	e147      	b.n	c0d01a8c <erc20_plugin_call+0x2ec>
c0d017fc:	2641      	movs	r6, #65	; 0x41
c0d017fe:	00b2      	lsls	r2, r6, #2
    switch (message) {
c0d01800:	4291      	cmp	r1, r2
c0d01802:	d074      	beq.n	c0d018ee <erc20_plugin_call+0x14e>
c0d01804:	3006      	adds	r0, #6
c0d01806:	4281      	cmp	r1, r0
c0d01808:	d100      	bne.n	c0d0180c <erc20_plugin_call+0x6c>
c0d0180a:	e0ac      	b.n	c0d01966 <erc20_plugin_call+0x1c6>
c0d0180c:	2083      	movs	r0, #131	; 0x83
c0d0180e:	0040      	lsls	r0, r0, #1
c0d01810:	4281      	cmp	r1, r0
c0d01812:	d000      	beq.n	c0d01816 <erc20_plugin_call+0x76>
c0d01814:	e0bd      	b.n	c0d01992 <erc20_plugin_call+0x1f2>
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0d01816:	7b20      	ldrb	r0, [r4, #12]
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d01818:	68a5      	ldr	r5, [r4, #8]
            switch (msg->screenIndex) {
c0d0181a:	2801      	cmp	r0, #1
c0d0181c:	d100      	bne.n	c0d01820 <erc20_plugin_call+0x80>
c0d0181e:	e0d2      	b.n	c0d019c6 <erc20_plugin_call+0x226>
c0d01820:	2800      	cmp	r0, #0
c0d01822:	d000      	beq.n	c0d01826 <erc20_plugin_call+0x86>
c0d01824:	e132      	b.n	c0d01a8c <erc20_plugin_call+0x2ec>
                case 0:
                    strcpy(msg->title, "Amount");
c0d01826:	6920      	ldr	r0, [r4, #16]
c0d01828:	49a6      	ldr	r1, [pc, #664]	; (c0d01ac4 <erc20_plugin_call+0x324>)
c0d0182a:	4479      	add	r1, pc
c0d0182c:	2207      	movs	r2, #7
c0d0182e:	f008 ff23 	bl	c0d0a678 <__aeabi_memcpy>
                    if (ismaxint(context->amount, sizeof(context->amount))) {
c0d01832:	4628      	mov	r0, r5
c0d01834:	3016      	adds	r0, #22
c0d01836:	2100      	movs	r1, #0
    }
    return 1;
}
__attribute__((no_instrument_function)) inline int ismaxint(uint8_t *buf, int n) {
    for (int i = 0; i < n; ++i) {
        if (buf[i] != 0xff) {
c0d01838:	5c42      	ldrb	r2, [r0, r1]
c0d0183a:	2aff      	cmp	r2, #255	; 0xff
c0d0183c:	d000      	beq.n	c0d01840 <erc20_plugin_call+0xa0>
c0d0183e:	e0f5      	b.n	c0d01a2c <erc20_plugin_call+0x28c>
c0d01840:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d01842:	291f      	cmp	r1, #31
c0d01844:	d9f8      	bls.n	c0d01838 <erc20_plugin_call+0x98>
                        strcpy(msg->msg, "Unlimited ");
c0d01846:	69a0      	ldr	r0, [r4, #24]
c0d01848:	49a1      	ldr	r1, [pc, #644]	; (c0d01ad0 <erc20_plugin_call+0x330>)
c0d0184a:	4479      	add	r1, pc
c0d0184c:	220b      	movs	r2, #11
c0d0184e:	f008 ff13 	bl	c0d0a678 <__aeabi_memcpy>
                        strcat(msg->msg, (char *) context->ticker_1);
c0d01852:	69a0      	ldr	r0, [r4, #24]
c0d01854:	3536      	adds	r5, #54	; 0x36
c0d01856:	e0cd      	b.n	c0d019f4 <erc20_plugin_call+0x254>
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d01858:	6860      	ldr	r0, [r4, #4]
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d0185a:	68a3      	ldr	r3, [r4, #8]
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d0185c:	6800      	ldr	r0, [r0, #0]
c0d0185e:	3042      	adds	r0, #66	; 0x42
c0d01860:	2100      	movs	r1, #0
        if (buf[i]) {
c0d01862:	5c42      	ldrb	r2, [r0, r1]
c0d01864:	2a00      	cmp	r2, #0
c0d01866:	d000      	beq.n	c0d0186a <erc20_plugin_call+0xca>
c0d01868:	e098      	b.n	c0d0199c <erc20_plugin_call+0x1fc>
c0d0186a:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d0186c:	2920      	cmp	r1, #32
c0d0186e:	d3f8      	bcc.n	c0d01862 <erc20_plugin_call+0xc2>
c0d01870:	9302      	str	r3, [sp, #8]
c0d01872:	2600      	movs	r6, #0
c0d01874:	4f8a      	ldr	r7, [pc, #552]	; (c0d01aa0 <erc20_plugin_call+0x300>)
c0d01876:	447f      	add	r7, pc
                    if (memcmp((uint8_t *) PIC(ERC20_SELECTORS[i]), msg->selector, SELECTOR_SIZE) ==
c0d01878:	6838      	ldr	r0, [r7, #0]
c0d0187a:	f003 ff5d 	bl	c0d05738 <pic>
c0d0187e:	7801      	ldrb	r1, [r0, #0]
c0d01880:	7842      	ldrb	r2, [r0, #1]
c0d01882:	0212      	lsls	r2, r2, #8
c0d01884:	1851      	adds	r1, r2, r1
c0d01886:	7882      	ldrb	r2, [r0, #2]
c0d01888:	78c0      	ldrb	r0, [r0, #3]
c0d0188a:	0200      	lsls	r0, r0, #8
c0d0188c:	1880      	adds	r0, r0, r2
c0d0188e:	0400      	lsls	r0, r0, #16
c0d01890:	1840      	adds	r0, r0, r1
c0d01892:	6922      	ldr	r2, [r4, #16]
c0d01894:	7811      	ldrb	r1, [r2, #0]
c0d01896:	7853      	ldrb	r3, [r2, #1]
c0d01898:	021b      	lsls	r3, r3, #8
c0d0189a:	1859      	adds	r1, r3, r1
c0d0189c:	7893      	ldrb	r3, [r2, #2]
c0d0189e:	78d5      	ldrb	r5, [r2, #3]
c0d018a0:	022d      	lsls	r5, r5, #8
c0d018a2:	18eb      	adds	r3, r5, r3
c0d018a4:	041b      	lsls	r3, r3, #16
c0d018a6:	1859      	adds	r1, r3, r1
c0d018a8:	4288      	cmp	r0, r1
c0d018aa:	d100      	bne.n	c0d018ae <erc20_plugin_call+0x10e>
c0d018ac:	e0b5      	b.n	c0d01a1a <erc20_plugin_call+0x27a>
                for (i = 0; i < NUM_ERC20_SELECTORS; i++) {
c0d018ae:	1d3f      	adds	r7, r7, #4
c0d018b0:	1c76      	adds	r6, r6, #1
c0d018b2:	2e02      	cmp	r6, #2
c0d018b4:	d3e0      	bcc.n	c0d01878 <erc20_plugin_call+0xd8>
c0d018b6:	d000      	beq.n	c0d018ba <erc20_plugin_call+0x11a>
c0d018b8:	e0b1      	b.n	c0d01a1e <erc20_plugin_call+0x27e>
                    PRINTF("Unknown selector %.*H\n", SELECTOR_SIZE, msg->selector);
c0d018ba:	487c      	ldr	r0, [pc, #496]	; (c0d01aac <erc20_plugin_call+0x30c>)
c0d018bc:	4478      	add	r0, pc
c0d018be:	2104      	movs	r1, #4
c0d018c0:	f003 fbbc 	bl	c0d0503c <mcu_usb_printf>
c0d018c4:	e06e      	b.n	c0d019a4 <erc20_plugin_call+0x204>
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d018c6:	68a5      	ldr	r5, [r4, #8]
                   msg->parameter);
c0d018c8:	68e3      	ldr	r3, [r4, #12]
                   msg->parameterOffset,
c0d018ca:	6921      	ldr	r1, [r4, #16]
            PRINTF("erc20 plugin provide parameter %d %.*H\n",
c0d018cc:	4878      	ldr	r0, [pc, #480]	; (c0d01ab0 <erc20_plugin_call+0x310>)
c0d018ce:	4478      	add	r0, pc
c0d018d0:	2220      	movs	r2, #32
c0d018d2:	f003 fbb3 	bl	c0d0503c <mcu_usb_printf>
            switch (msg->parameterOffset) {
c0d018d6:	6920      	ldr	r0, [r4, #16]
c0d018d8:	2824      	cmp	r0, #36	; 0x24
c0d018da:	d100      	bne.n	c0d018de <erc20_plugin_call+0x13e>
c0d018dc:	e08e      	b.n	c0d019fc <erc20_plugin_call+0x25c>
c0d018de:	2804      	cmp	r0, #4
c0d018e0:	d000      	beq.n	c0d018e4 <erc20_plugin_call+0x144>
c0d018e2:	e093      	b.n	c0d01a0c <erc20_plugin_call+0x26c>
                    memmove(context->destinationAddress, msg->parameter + 12, 20);
c0d018e4:	68e1      	ldr	r1, [r4, #12]
c0d018e6:	1c68      	adds	r0, r5, #1
c0d018e8:	310c      	adds	r1, #12
c0d018ea:	2214      	movs	r2, #20
c0d018ec:	e08a      	b.n	c0d01a04 <erc20_plugin_call+0x264>
                   (msg->token1 != NULL),
c0d018ee:	68e0      	ldr	r0, [r4, #12]
c0d018f0:	2201      	movs	r2, #1
c0d018f2:	2800      	cmp	r0, #0
c0d018f4:	4611      	mov	r1, r2
c0d018f6:	d100      	bne.n	c0d018fa <erc20_plugin_call+0x15a>
c0d018f8:	4601      	mov	r1, r0
                   (msg->token2 != NULL));
c0d018fa:	6920      	ldr	r0, [r4, #16]
c0d018fc:	2800      	cmp	r0, #0
c0d018fe:	d100      	bne.n	c0d01902 <erc20_plugin_call+0x162>
c0d01900:	4602      	mov	r2, r0
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d01902:	68a5      	ldr	r5, [r4, #8]
            PRINTF("erc20 plugin provide token 1: %d - 2: %d\n",
c0d01904:	486c      	ldr	r0, [pc, #432]	; (c0d01ab8 <erc20_plugin_call+0x318>)
c0d01906:	4478      	add	r0, pc
c0d01908:	f003 fb98 	bl	c0d0503c <mcu_usb_printf>
            if (msg->token1 != NULL) {
c0d0190c:	68e1      	ldr	r1, [r4, #12]
c0d0190e:	2900      	cmp	r1, #0
c0d01910:	d04a      	beq.n	c0d019a8 <erc20_plugin_call+0x208>
c0d01912:	204f      	movs	r0, #79	; 0x4f
c0d01914:	2200      	movs	r2, #0
                context->target = TARGET_ADDRESS;
c0d01916:	542a      	strb	r2, [r5, r0]
                strcpy((char *) context->ticker_1, (char *) msg->token1->ticker);
c0d01918:	4628      	mov	r0, r5
c0d0191a:	3036      	adds	r0, #54	; 0x36
c0d0191c:	3114      	adds	r1, #20
c0d0191e:	f009 f863 	bl	c0d0a9e8 <strcpy>
                context->decimals = msg->token1->decimals;
c0d01922:	68e0      	ldr	r0, [r4, #12]
c0d01924:	2120      	movs	r1, #32
c0d01926:	5c40      	ldrb	r0, [r0, r1]
c0d01928:	214e      	movs	r1, #78	; 0x4e
c0d0192a:	5468      	strb	r0, [r5, r1]
                if (context->selectorIndex == ERC20_APPROVE) {
c0d0192c:	7828      	ldrb	r0, [r5, #0]
c0d0192e:	2801      	cmp	r0, #1
c0d01930:	d16a      	bne.n	c0d01a08 <erc20_plugin_call+0x268>
                    if (msg->token2 != NULL) {
c0d01932:	6921      	ldr	r1, [r4, #16]
c0d01934:	2900      	cmp	r1, #0
c0d01936:	d067      	beq.n	c0d01a08 <erc20_plugin_call+0x268>
c0d01938:	462e      	mov	r6, r5
c0d0193a:	364f      	adds	r6, #79	; 0x4f
c0d0193c:	2001      	movs	r0, #1
                        context->target = TARGET_CONTRACT;
c0d0193e:	7030      	strb	r0, [r6, #0]
                        strcpy((char *) context->ticker_2, (char *) msg->token2->ticker);
c0d01940:	3542      	adds	r5, #66	; 0x42
c0d01942:	3114      	adds	r1, #20
c0d01944:	4628      	mov	r0, r5
c0d01946:	f009 f84f 	bl	c0d0a9e8 <strcpy>
                        if (check_token_binding((char *) msg->token1->ticker,
c0d0194a:	68e0      	ldr	r0, [r4, #12]
                                                (char *) msg->token2->ticker,
c0d0194c:	6921      	ldr	r1, [r4, #16]
                        if (check_token_binding((char *) msg->token1->ticker,
c0d0194e:	3014      	adds	r0, #20
                                                (char *) msg->token2->ticker,
c0d01950:	3114      	adds	r1, #20
                        if (check_token_binding((char *) msg->token1->ticker,
c0d01952:	4a5a      	ldr	r2, [pc, #360]	; (c0d01abc <erc20_plugin_call+0x31c>)
c0d01954:	447a      	add	r2, pc
c0d01956:	2309      	movs	r3, #9
c0d01958:	f7ff fee2 	bl	c0d01720 <check_token_binding>
c0d0195c:	2800      	cmp	r0, #0
c0d0195e:	d053      	beq.n	c0d01a08 <erc20_plugin_call+0x268>
c0d01960:	2002      	movs	r0, #2
                            context->target = TARGET_COMPOUND;
c0d01962:	7030      	strb	r0, [r6, #0]
c0d01964:	e050      	b.n	c0d01a08 <erc20_plugin_call+0x268>
            strcpy(msg->name, "Type");
c0d01966:	68e0      	ldr	r0, [r4, #12]
c0d01968:	4955      	ldr	r1, [pc, #340]	; (c0d01ac0 <erc20_plugin_call+0x320>)
c0d0196a:	4479      	add	r1, pc
c0d0196c:	2205      	movs	r2, #5
c0d0196e:	f008 fe83 	bl	c0d0a678 <__aeabi_memcpy>
            strcpy(msg->version, "Approve");
c0d01972:	6960      	ldr	r0, [r4, #20]
c0d01974:	2100      	movs	r1, #0
c0d01976:	71c1      	strb	r1, [r0, #7]
c0d01978:	2165      	movs	r1, #101	; 0x65
c0d0197a:	7181      	strb	r1, [r0, #6]
c0d0197c:	2176      	movs	r1, #118	; 0x76
c0d0197e:	7141      	strb	r1, [r0, #5]
c0d01980:	216f      	movs	r1, #111	; 0x6f
c0d01982:	7101      	strb	r1, [r0, #4]
c0d01984:	2172      	movs	r1, #114	; 0x72
c0d01986:	70c1      	strb	r1, [r0, #3]
c0d01988:	2170      	movs	r1, #112	; 0x70
c0d0198a:	7081      	strb	r1, [r0, #2]
c0d0198c:	7041      	strb	r1, [r0, #1]
c0d0198e:	7006      	strb	r6, [r0, #0]
c0d01990:	e049      	b.n	c0d01a26 <erc20_plugin_call+0x286>
                    break;
            }
        } break;

        default:
            PRINTF("Unhandled message %d\n", message);
c0d01992:	4842      	ldr	r0, [pc, #264]	; (c0d01a9c <erc20_plugin_call+0x2fc>)
c0d01994:	4478      	add	r0, pc
c0d01996:	f003 fb51 	bl	c0d0503c <mcu_usb_printf>
c0d0199a:	e077      	b.n	c0d01a8c <erc20_plugin_call+0x2ec>
                PRINTF("Err: Transaction amount is not 0\n");
c0d0199c:	4842      	ldr	r0, [pc, #264]	; (c0d01aa8 <erc20_plugin_call+0x308>)
c0d0199e:	4478      	add	r0, pc
c0d019a0:	f003 fb4c 	bl	c0d0503c <mcu_usb_printf>
c0d019a4:	2000      	movs	r0, #0
c0d019a6:	e03f      	b.n	c0d01a28 <erc20_plugin_call+0x288>
c0d019a8:	2003      	movs	r0, #3
c0d019aa:	e034      	b.n	c0d01a16 <erc20_plugin_call+0x276>
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d019ac:	6860      	ldr	r0, [r4, #4]
c0d019ae:	6800      	ldr	r0, [r0, #0]
                msg->tokenLookup2 = context->destinationAddress;
c0d019b0:	1c69      	adds	r1, r5, #1
c0d019b2:	2201      	movs	r2, #1
                msg->result = ETH_PLUGIN_RESULT_OK;
c0d019b4:	77a2      	strb	r2, [r4, #30]
c0d019b6:	4a37      	ldr	r2, [pc, #220]	; (c0d01a94 <erc20_plugin_call+0x2f4>)
                msg->uiType = ETH_UI_TYPE_GENERIC;
c0d019b8:	83a2      	strh	r2, [r4, #28]
c0d019ba:	2221      	movs	r2, #33	; 0x21
c0d019bc:	00d2      	lsls	r2, r2, #3
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d019be:	1880      	adds	r0, r0, r2
c0d019c0:	60e0      	str	r0, [r4, #12]
                msg->tokenLookup2 = context->destinationAddress;
c0d019c2:	6121      	str	r1, [r4, #16]
c0d019c4:	e062      	b.n	c0d01a8c <erc20_plugin_call+0x2ec>
c0d019c6:	204f      	movs	r0, #79	; 0x4f
                    if (context->target >= TARGET_CONTRACT) {
c0d019c8:	5c29      	ldrb	r1, [r5, r0]
c0d019ca:	6920      	ldr	r0, [r4, #16]
c0d019cc:	2900      	cmp	r1, #0
c0d019ce:	d039      	beq.n	c0d01a44 <erc20_plugin_call+0x2a4>
c0d019d0:	462e      	mov	r6, r5
c0d019d2:	364f      	adds	r6, #79	; 0x4f
                        strcpy(msg->title, "Contract");
c0d019d4:	493c      	ldr	r1, [pc, #240]	; (c0d01ac8 <erc20_plugin_call+0x328>)
c0d019d6:	4479      	add	r1, pc
c0d019d8:	2209      	movs	r2, #9
c0d019da:	f008 fe4d 	bl	c0d0a678 <__aeabi_memcpy>
c0d019de:	69a0      	ldr	r0, [r4, #24]
                        if (context->target == TARGET_COMPOUND) {
c0d019e0:	7831      	ldrb	r1, [r6, #0]
c0d019e2:	2902      	cmp	r1, #2
c0d019e4:	d14b      	bne.n	c0d01a7e <erc20_plugin_call+0x2de>
                            strcpy(msg->msg, "Compound ");
c0d019e6:	4939      	ldr	r1, [pc, #228]	; (c0d01acc <erc20_plugin_call+0x32c>)
c0d019e8:	4479      	add	r1, pc
c0d019ea:	220a      	movs	r2, #10
c0d019ec:	f008 fe44 	bl	c0d0a678 <__aeabi_memcpy>
                            strcat(msg->msg,
c0d019f0:	69a0      	ldr	r0, [r4, #24]
                                   (char *) context->ticker_2 +
c0d019f2:	3543      	adds	r5, #67	; 0x43
c0d019f4:	4629      	mov	r1, r5
c0d019f6:	f008 ff8d 	bl	c0d0a914 <strcat>
c0d019fa:	e044      	b.n	c0d01a86 <erc20_plugin_call+0x2e6>
                    memmove(context->amount, msg->parameter, 32);
c0d019fc:	68e1      	ldr	r1, [r4, #12]
c0d019fe:	3516      	adds	r5, #22
c0d01a00:	2220      	movs	r2, #32
c0d01a02:	4628      	mov	r0, r5
c0d01a04:	f008 fe3c 	bl	c0d0a680 <__aeabi_memmove>
c0d01a08:	2001      	movs	r0, #1
c0d01a0a:	e004      	b.n	c0d01a16 <erc20_plugin_call+0x276>
                    PRINTF("Unhandled parameter offset\n");
c0d01a0c:	4829      	ldr	r0, [pc, #164]	; (c0d01ab4 <erc20_plugin_call+0x314>)
c0d01a0e:	4478      	add	r0, pc
c0d01a10:	f003 fb14 	bl	c0d0503c <mcu_usb_printf>
c0d01a14:	2000      	movs	r0, #0
c0d01a16:	7520      	strb	r0, [r4, #20]
c0d01a18:	e038      	b.n	c0d01a8c <erc20_plugin_call+0x2ec>
                        context->selectorIndex = i;
c0d01a1a:	9802      	ldr	r0, [sp, #8]
c0d01a1c:	7006      	strb	r6, [r0, #0]
                PRINTF("erc20 plugin init\n");
c0d01a1e:	4821      	ldr	r0, [pc, #132]	; (c0d01aa4 <erc20_plugin_call+0x304>)
c0d01a20:	4478      	add	r0, pc
c0d01a22:	f003 fb0b 	bl	c0d0503c <mcu_usb_printf>
c0d01a26:	2001      	movs	r0, #1
c0d01a28:	7720      	strb	r0, [r4, #28]
c0d01a2a:	e02f      	b.n	c0d01a8c <erc20_plugin_call+0x2ec>
c0d01a2c:	214e      	movs	r1, #78	; 0x4e
                                       context->decimals,
c0d01a2e:	5c6a      	ldrb	r2, [r5, r1]
                                       msg->msg,
c0d01a30:	69a1      	ldr	r1, [r4, #24]
c0d01a32:	2364      	movs	r3, #100	; 0x64
                        amountToString(context->amount,
c0d01a34:	466e      	mov	r6, sp
c0d01a36:	c60a      	stmia	r6!, {r1, r3}
                                       (char *) context->ticker_1,
c0d01a38:	3536      	adds	r5, #54	; 0x36
c0d01a3a:	2120      	movs	r1, #32
                        amountToString(context->amount,
c0d01a3c:	462b      	mov	r3, r5
c0d01a3e:	f007 ff29 	bl	c0d09894 <amountToString>
c0d01a42:	e020      	b.n	c0d01a86 <erc20_plugin_call+0x2e6>
c0d01a44:	2100      	movs	r1, #0
                        strcpy(msg->title, "Address");
c0d01a46:	71c1      	strb	r1, [r0, #7]
c0d01a48:	2173      	movs	r1, #115	; 0x73
c0d01a4a:	7181      	strb	r1, [r0, #6]
c0d01a4c:	7141      	strb	r1, [r0, #5]
c0d01a4e:	2165      	movs	r1, #101	; 0x65
c0d01a50:	7101      	strb	r1, [r0, #4]
c0d01a52:	2172      	movs	r1, #114	; 0x72
c0d01a54:	70c1      	strb	r1, [r0, #3]
c0d01a56:	2164      	movs	r1, #100	; 0x64
c0d01a58:	7081      	strb	r1, [r0, #2]
c0d01a5a:	7041      	strb	r1, [r0, #1]
c0d01a5c:	7006      	strb	r6, [r0, #0]
                        msg->msg[0] = '0';
c0d01a5e:	69a0      	ldr	r0, [r4, #24]
c0d01a60:	2130      	movs	r1, #48	; 0x30
c0d01a62:	7001      	strb	r1, [r0, #0]
                        msg->msg[1] = 'x';
c0d01a64:	69a0      	ldr	r0, [r4, #24]
c0d01a66:	2178      	movs	r1, #120	; 0x78
c0d01a68:	7041      	strb	r1, [r0, #1]
                                                      chainConfig);
c0d01a6a:	4809      	ldr	r0, [pc, #36]	; (c0d01a90 <erc20_plugin_call+0x2f0>)
c0d01a6c:	6803      	ldr	r3, [r0, #0]
                                                      msg->pluginSharedRW->sha3,
c0d01a6e:	6820      	ldr	r0, [r4, #0]
c0d01a70:	6802      	ldr	r2, [r0, #0]
                        getEthAddressStringFromBinary(context->destinationAddress,
c0d01a72:	1c68      	adds	r0, r5, #1
                                                      (uint8_t *) msg->msg + 2,
c0d01a74:	69a1      	ldr	r1, [r4, #24]
c0d01a76:	1c89      	adds	r1, r1, #2
                        getEthAddressStringFromBinary(context->destinationAddress,
c0d01a78:	f000 fd36 	bl	c0d024e8 <getEthAddressStringFromBinary>
c0d01a7c:	e003      	b.n	c0d01a86 <erc20_plugin_call+0x2e6>
                            strcpy(msg->msg, (char *) context->ticker_2);
c0d01a7e:	3542      	adds	r5, #66	; 0x42
c0d01a80:	4629      	mov	r1, r5
c0d01a82:	f008 ffb1 	bl	c0d0a9e8 <strcpy>
c0d01a86:	2020      	movs	r0, #32
c0d01a88:	2101      	movs	r1, #1
c0d01a8a:	5421      	strb	r1, [r4, r0]
c0d01a8c:	b003      	add	sp, #12
c0d01a8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01a90:	20001be0 	.word	0x20001be0
c0d01a94:	00000202 	.word	0x00000202
c0d01a98:	000099d3 	.word	0x000099d3
c0d01a9c:	000096b1 	.word	0x000096b1
c0d01aa0:	00009eca 	.word	0x00009eca
c0d01aa4:	00009744 	.word	0x00009744
c0d01aa8:	000097a4 	.word	0x000097a4
c0d01aac:	0000965a 	.word	0x0000965a
c0d01ab0:	000098a9 	.word	0x000098a9
c0d01ab4:	000095a1 	.word	0x000095a1
c0d01ab8:	000098b0 	.word	0x000098b0
c0d01abc:	00009716 	.word	0x00009716
c0d01ac0:	000096c3 	.word	0x000096c3
c0d01ac4:	00009814 	.word	0x00009814
c0d01ac8:	0000993a 	.word	0x0000993a
c0d01acc:	00009678 	.word	0x00009678
c0d01ad0:	00009996 	.word	0x00009996

c0d01ad4 <erc721_plugin_available_check>:
    // tokenDefinition_t *tokenAddress;
} erc721_parameters_t;

bool erc721_plugin_available_check() {
#ifdef HAVE_STARKWARE
    if (quantumSet) {
c0d01ad4:	4807      	ldr	r0, [pc, #28]	; (c0d01af4 <erc721_plugin_available_check+0x20>)
c0d01ad6:	7800      	ldrb	r0, [r0, #0]
c0d01ad8:	2100      	movs	r1, #0
c0d01ada:	2800      	cmp	r0, #0
c0d01adc:	d008      	beq.n	c0d01af0 <erc721_plugin_available_check+0x1c>
c0d01ade:	20e5      	movs	r0, #229	; 0xe5
        switch (dataContext.tokenContext.quantumType) {
c0d01ae0:	4a05      	ldr	r2, [pc, #20]	; (c0d01af8 <erc721_plugin_available_check+0x24>)
c0d01ae2:	5c12      	ldrb	r2, [r2, r0]
c0d01ae4:	2001      	movs	r0, #1
c0d01ae6:	2a03      	cmp	r2, #3
c0d01ae8:	d001      	beq.n	c0d01aee <erc721_plugin_available_check+0x1a>
c0d01aea:	2a05      	cmp	r2, #5
c0d01aec:	d100      	bne.n	c0d01af0 <erc721_plugin_available_check+0x1c>
                return false;
        }
    }
    return false;
#endif
}
c0d01aee:	4770      	bx	lr
c0d01af0:	4608      	mov	r0, r1
c0d01af2:	4770      	bx	lr
c0d01af4:	2000189d 	.word	0x2000189d
c0d01af8:	20001be4 	.word	0x20001be4

c0d01afc <erc721_plugin_call>:

void erc721_plugin_call(int message, void *parameters) {
c0d01afc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01afe:	b081      	sub	sp, #4
c0d01b00:	460c      	mov	r4, r1
c0d01b02:	4601      	mov	r1, r0
c0d01b04:	20ff      	movs	r0, #255	; 0xff
c0d01b06:	4602      	mov	r2, r0
c0d01b08:	3204      	adds	r2, #4
    switch (message) {
c0d01b0a:	4291      	cmp	r1, r2
c0d01b0c:	dc1b      	bgt.n	c0d01b46 <erc721_plugin_call+0x4a>
c0d01b0e:	3002      	adds	r0, #2
c0d01b10:	4281      	cmp	r1, r0
c0d01b12:	d03a      	beq.n	c0d01b8a <erc721_plugin_call+0x8e>
c0d01b14:	2081      	movs	r0, #129	; 0x81
c0d01b16:	0040      	lsls	r0, r0, #1
c0d01b18:	4281      	cmp	r1, r0
c0d01b1a:	d06c      	beq.n	c0d01bf6 <erc721_plugin_call+0xfa>
c0d01b1c:	4291      	cmp	r1, r2
c0d01b1e:	d000      	beq.n	c0d01b22 <erc721_plugin_call+0x26>
c0d01b20:	e097      	b.n	c0d01c52 <erc721_plugin_call+0x156>
            }
        } break;

        case ETH_PLUGIN_FINALIZE: {
            ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
c0d01b22:	68a5      	ldr	r5, [r4, #8]
            PRINTF("erc721 plugin finalize\n");
c0d01b24:	4872      	ldr	r0, [pc, #456]	; (c0d01cf0 <erc721_plugin_call+0x1f4>)
c0d01b26:	4478      	add	r0, pc
c0d01b28:	f003 fa88 	bl	c0d0503c <mcu_usb_printf>
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d01b2c:	6860      	ldr	r0, [r4, #4]
c0d01b2e:	6800      	ldr	r0, [r0, #0]
            msg->tokenLookup2 = context->address;
c0d01b30:	1c69      	adds	r1, r5, #1
c0d01b32:	2201      	movs	r2, #1
            msg->numScreens = 3;
            msg->uiType = ETH_UI_TYPE_GENERIC;
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d01b34:	77a2      	strb	r2, [r4, #30]
c0d01b36:	4a6d      	ldr	r2, [pc, #436]	; (c0d01cec <erc721_plugin_call+0x1f0>)
            msg->uiType = ETH_UI_TYPE_GENERIC;
c0d01b38:	83a2      	strh	r2, [r4, #28]
c0d01b3a:	2221      	movs	r2, #33	; 0x21
c0d01b3c:	00d2      	lsls	r2, r2, #3
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d01b3e:	1880      	adds	r0, r0, r2
c0d01b40:	60e0      	str	r0, [r4, #12]
            msg->tokenLookup2 = context->address;
c0d01b42:	6121      	str	r1, [r4, #16]
c0d01b44:	e0ca      	b.n	c0d01cdc <erc721_plugin_call+0x1e0>
c0d01b46:	2241      	movs	r2, #65	; 0x41
c0d01b48:	0092      	lsls	r2, r2, #2
    switch (message) {
c0d01b4a:	4291      	cmp	r1, r2
c0d01b4c:	d065      	beq.n	c0d01c1a <erc721_plugin_call+0x11e>
c0d01b4e:	3006      	adds	r0, #6
c0d01b50:	4281      	cmp	r1, r0
c0d01b52:	d073      	beq.n	c0d01c3c <erc721_plugin_call+0x140>
c0d01b54:	2083      	movs	r0, #131	; 0x83
c0d01b56:	0040      	lsls	r0, r0, #1
c0d01b58:	4281      	cmp	r1, r0
c0d01b5a:	d17a      	bne.n	c0d01c52 <erc721_plugin_call+0x156>
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0d01b5c:	7b20      	ldrb	r0, [r4, #12]
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
c0d01b5e:	68a5      	ldr	r5, [r4, #8]
            switch (msg->screenIndex) {
c0d01b60:	2802      	cmp	r0, #2
c0d01b62:	d100      	bne.n	c0d01b66 <erc721_plugin_call+0x6a>
c0d01b64:	e096      	b.n	c0d01c94 <erc721_plugin_call+0x198>
c0d01b66:	2801      	cmp	r0, #1
c0d01b68:	d100      	bne.n	c0d01b6c <erc721_plugin_call+0x70>
c0d01b6a:	e0aa      	b.n	c0d01cc2 <erc721_plugin_call+0x1c6>
c0d01b6c:	2800      	cmp	r0, #0
c0d01b6e:	d000      	beq.n	c0d01b72 <erc721_plugin_call+0x76>
c0d01b70:	e0b4      	b.n	c0d01cdc <erc721_plugin_call+0x1e0>
                case 0:
                    strcpy(msg->title, "Contract Name");
c0d01b72:	6920      	ldr	r0, [r4, #16]
c0d01b74:	4968      	ldr	r1, [pc, #416]	; (c0d01d18 <erc721_plugin_call+0x21c>)
c0d01b76:	4479      	add	r1, pc
c0d01b78:	220e      	movs	r2, #14
c0d01b7a:	f008 fd7d 	bl	c0d0a678 <__aeabi_memcpy>
c0d01b7e:	2021      	movs	r0, #33	; 0x21
c0d01b80:	00c0      	lsls	r0, r0, #3
                    starkware_print_eth_address(tmpContent.txContent.destination, msg->msg);
c0d01b82:	4959      	ldr	r1, [pc, #356]	; (c0d01ce8 <erc721_plugin_call+0x1ec>)
c0d01b84:	1808      	adds	r0, r1, r0
c0d01b86:	69a1      	ldr	r1, [r4, #24]
c0d01b88:	e0a3      	b.n	c0d01cd2 <erc721_plugin_call+0x1d6>
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d01b8a:	6860      	ldr	r0, [r4, #4]
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
c0d01b8c:	68a5      	ldr	r5, [r4, #8]
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d01b8e:	6800      	ldr	r0, [r0, #0]
c0d01b90:	3042      	adds	r0, #66	; 0x42
c0d01b92:	2100      	movs	r1, #0
        if (buf[i]) {
c0d01b94:	5c42      	ldrb	r2, [r0, r1]
c0d01b96:	2a00      	cmp	r2, #0
c0d01b98:	d160      	bne.n	c0d01c5c <erc721_plugin_call+0x160>
c0d01b9a:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d01b9c:	2920      	cmp	r1, #32
c0d01b9e:	d3f9      	bcc.n	c0d01b94 <erc721_plugin_call+0x98>
c0d01ba0:	2000      	movs	r0, #0
c0d01ba2:	4e55      	ldr	r6, [pc, #340]	; (c0d01cf8 <erc721_plugin_call+0x1fc>)
c0d01ba4:	447e      	add	r6, pc
                for (i = 0; i < NUM_ERC721_SELECTORS; i++) {
c0d01ba6:	2801      	cmp	r0, #1
c0d01ba8:	d05f      	beq.n	c0d01c6a <erc721_plugin_call+0x16e>
c0d01baa:	4607      	mov	r7, r0
                    if (memcmp((uint8_t *) PIC(ERC721_SELECTORS[i]),
c0d01bac:	0080      	lsls	r0, r0, #2
c0d01bae:	5830      	ldr	r0, [r6, r0]
c0d01bb0:	f003 fdc2 	bl	c0d05738 <pic>
c0d01bb4:	7801      	ldrb	r1, [r0, #0]
c0d01bb6:	7842      	ldrb	r2, [r0, #1]
c0d01bb8:	0212      	lsls	r2, r2, #8
c0d01bba:	1851      	adds	r1, r2, r1
c0d01bbc:	7882      	ldrb	r2, [r0, #2]
c0d01bbe:	78c0      	ldrb	r0, [r0, #3]
c0d01bc0:	0200      	lsls	r0, r0, #8
c0d01bc2:	1880      	adds	r0, r0, r2
c0d01bc4:	0400      	lsls	r0, r0, #16
c0d01bc6:	1841      	adds	r1, r0, r1
                               msg->selector,
c0d01bc8:	6920      	ldr	r0, [r4, #16]
                    if (memcmp((uint8_t *) PIC(ERC721_SELECTORS[i]),
c0d01bca:	7802      	ldrb	r2, [r0, #0]
c0d01bcc:	7843      	ldrb	r3, [r0, #1]
c0d01bce:	021b      	lsls	r3, r3, #8
c0d01bd0:	189a      	adds	r2, r3, r2
c0d01bd2:	7883      	ldrb	r3, [r0, #2]
c0d01bd4:	78c0      	ldrb	r0, [r0, #3]
c0d01bd6:	0200      	lsls	r0, r0, #8
c0d01bd8:	18c0      	adds	r0, r0, r3
c0d01bda:	0400      	lsls	r0, r0, #16
c0d01bdc:	1882      	adds	r2, r0, r2
c0d01bde:	2001      	movs	r0, #1
c0d01be0:	4291      	cmp	r1, r2
c0d01be2:	d1e0      	bne.n	c0d01ba6 <erc721_plugin_call+0xaa>
                        context->selectorIndex = i;
c0d01be4:	702f      	strb	r7, [r5, #0]
                if (msg->dataSize != 4 + 32 + 32) {
c0d01be6:	6961      	ldr	r1, [r4, #20]
c0d01be8:	2944      	cmp	r1, #68	; 0x44
c0d01bea:	d179      	bne.n	c0d01ce0 <erc721_plugin_call+0x1e4>
                PRINTF("erc721 plugin init\n");
c0d01bec:	4845      	ldr	r0, [pc, #276]	; (c0d01d04 <erc721_plugin_call+0x208>)
c0d01bee:	4478      	add	r0, pc
c0d01bf0:	f003 fa24 	bl	c0d0503c <mcu_usb_printf>
c0d01bf4:	e02b      	b.n	c0d01c4e <erc721_plugin_call+0x152>
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
c0d01bf6:	68a5      	ldr	r5, [r4, #8]
                   msg->parameter);
c0d01bf8:	68e3      	ldr	r3, [r4, #12]
                   msg->parameterOffset,
c0d01bfa:	6921      	ldr	r1, [r4, #16]
            PRINTF("erc721 plugin provide parameter %d %.*H\n",
c0d01bfc:	4842      	ldr	r0, [pc, #264]	; (c0d01d08 <erc721_plugin_call+0x20c>)
c0d01bfe:	4478      	add	r0, pc
c0d01c00:	2220      	movs	r2, #32
c0d01c02:	f003 fa1b 	bl	c0d0503c <mcu_usb_printf>
            switch (msg->parameterOffset) {
c0d01c06:	6920      	ldr	r0, [r4, #16]
c0d01c08:	2824      	cmp	r0, #36	; 0x24
c0d01c0a:	d035      	beq.n	c0d01c78 <erc721_plugin_call+0x17c>
c0d01c0c:	2804      	cmp	r0, #4
c0d01c0e:	d13c      	bne.n	c0d01c8a <erc721_plugin_call+0x18e>
                    memmove(context->address, msg->parameter + 32 - 20, 20);
c0d01c10:	68e1      	ldr	r1, [r4, #12]
c0d01c12:	1c68      	adds	r0, r5, #1
c0d01c14:	310c      	adds	r1, #12
c0d01c16:	2214      	movs	r2, #20
c0d01c18:	e032      	b.n	c0d01c80 <erc721_plugin_call+0x184>
                   (msg->token1 != NULL),
c0d01c1a:	68e0      	ldr	r0, [r4, #12]
c0d01c1c:	2501      	movs	r5, #1
c0d01c1e:	2800      	cmp	r0, #0
c0d01c20:	4629      	mov	r1, r5
c0d01c22:	d100      	bne.n	c0d01c26 <erc721_plugin_call+0x12a>
c0d01c24:	4601      	mov	r1, r0
                   (msg->token2 != NULL));
c0d01c26:	6920      	ldr	r0, [r4, #16]
c0d01c28:	2800      	cmp	r0, #0
c0d01c2a:	462a      	mov	r2, r5
c0d01c2c:	d100      	bne.n	c0d01c30 <erc721_plugin_call+0x134>
c0d01c2e:	4602      	mov	r2, r0
            PRINTF("erc721 plugin provide token dest: %d - address: %d\n",
c0d01c30:	4837      	ldr	r0, [pc, #220]	; (c0d01d10 <erc721_plugin_call+0x214>)
c0d01c32:	4478      	add	r0, pc
c0d01c34:	f003 fa02 	bl	c0d0503c <mcu_usb_printf>
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d01c38:	7525      	strb	r5, [r4, #20]
c0d01c3a:	e04f      	b.n	c0d01cdc <erc721_plugin_call+0x1e0>
            strcpy(msg->name, "Allowance");
c0d01c3c:	68e0      	ldr	r0, [r4, #12]
c0d01c3e:	4935      	ldr	r1, [pc, #212]	; (c0d01d14 <erc721_plugin_call+0x218>)
c0d01c40:	4479      	add	r1, pc
c0d01c42:	220a      	movs	r2, #10
c0d01c44:	f008 fd18 	bl	c0d0a678 <__aeabi_memcpy>
            strcpy(msg->version, "");
c0d01c48:	6960      	ldr	r0, [r4, #20]
c0d01c4a:	2100      	movs	r1, #0
c0d01c4c:	7001      	strb	r1, [r0, #0]
c0d01c4e:	2001      	movs	r0, #1
c0d01c50:	e009      	b.n	c0d01c66 <erc721_plugin_call+0x16a>
                    break;
            }
        } break;

        default:
            PRINTF("Unhandled message %d\n", message);
c0d01c52:	4828      	ldr	r0, [pc, #160]	; (c0d01cf4 <erc721_plugin_call+0x1f8>)
c0d01c54:	4478      	add	r0, pc
c0d01c56:	f003 f9f1 	bl	c0d0503c <mcu_usb_printf>
c0d01c5a:	e03f      	b.n	c0d01cdc <erc721_plugin_call+0x1e0>
                PRINTF("Err: Transaction amount is not 0 for erc721 approval\n");
c0d01c5c:	4828      	ldr	r0, [pc, #160]	; (c0d01d00 <erc721_plugin_call+0x204>)
c0d01c5e:	4478      	add	r0, pc
c0d01c60:	f003 f9ec 	bl	c0d0503c <mcu_usb_printf>
c0d01c64:	2000      	movs	r0, #0
c0d01c66:	7720      	strb	r0, [r4, #28]
c0d01c68:	e038      	b.n	c0d01cdc <erc721_plugin_call+0x1e0>
                    PRINTF("Unknown erc721 selector %.*H\n", SELECTOR_SIZE, msg->selector);
c0d01c6a:	6922      	ldr	r2, [r4, #16]
c0d01c6c:	482c      	ldr	r0, [pc, #176]	; (c0d01d20 <erc721_plugin_call+0x224>)
c0d01c6e:	4478      	add	r0, pc
c0d01c70:	2104      	movs	r1, #4
c0d01c72:	f003 f9e3 	bl	c0d0503c <mcu_usb_printf>
c0d01c76:	e031      	b.n	c0d01cdc <erc721_plugin_call+0x1e0>
                    memmove(context->tokenId, msg->parameter, 32);
c0d01c78:	68e1      	ldr	r1, [r4, #12]
c0d01c7a:	3515      	adds	r5, #21
c0d01c7c:	2220      	movs	r2, #32
c0d01c7e:	4628      	mov	r0, r5
c0d01c80:	f008 fcfe 	bl	c0d0a680 <__aeabi_memmove>
c0d01c84:	2001      	movs	r0, #1
c0d01c86:	7520      	strb	r0, [r4, #20]
c0d01c88:	e028      	b.n	c0d01cdc <erc721_plugin_call+0x1e0>
                    PRINTF("Unhandled parameter offset\n");
c0d01c8a:	4820      	ldr	r0, [pc, #128]	; (c0d01d0c <erc721_plugin_call+0x210>)
c0d01c8c:	4478      	add	r0, pc
c0d01c8e:	f003 f9d5 	bl	c0d0503c <mcu_usb_printf>
c0d01c92:	e023      	b.n	c0d01cdc <erc721_plugin_call+0x1e0>
                    strcpy(msg->title, "TokenID");
c0d01c94:	6920      	ldr	r0, [r4, #16]
c0d01c96:	2100      	movs	r1, #0
c0d01c98:	71c1      	strb	r1, [r0, #7]
c0d01c9a:	2144      	movs	r1, #68	; 0x44
c0d01c9c:	7181      	strb	r1, [r0, #6]
c0d01c9e:	2149      	movs	r1, #73	; 0x49
c0d01ca0:	7141      	strb	r1, [r0, #5]
c0d01ca2:	216e      	movs	r1, #110	; 0x6e
c0d01ca4:	7101      	strb	r1, [r0, #4]
c0d01ca6:	2165      	movs	r1, #101	; 0x65
c0d01ca8:	70c1      	strb	r1, [r0, #3]
c0d01caa:	216b      	movs	r1, #107	; 0x6b
c0d01cac:	7081      	strb	r1, [r0, #2]
c0d01cae:	216f      	movs	r1, #111	; 0x6f
c0d01cb0:	7041      	strb	r1, [r0, #1]
c0d01cb2:	2154      	movs	r1, #84	; 0x54
c0d01cb4:	7001      	strb	r1, [r0, #0]
                    starkware_print_stark_key(context->tokenId, msg->msg);
c0d01cb6:	69a1      	ldr	r1, [r4, #24]
c0d01cb8:	3515      	adds	r5, #21
c0d01cba:	4628      	mov	r0, r5
c0d01cbc:	f004 f93a 	bl	c0d05f34 <starkware_print_stark_key>
c0d01cc0:	e009      	b.n	c0d01cd6 <erc721_plugin_call+0x1da>
                    strcpy(msg->title, "NFT Contract");
c0d01cc2:	6920      	ldr	r0, [r4, #16]
c0d01cc4:	4915      	ldr	r1, [pc, #84]	; (c0d01d1c <erc721_plugin_call+0x220>)
c0d01cc6:	4479      	add	r1, pc
c0d01cc8:	220d      	movs	r2, #13
c0d01cca:	f008 fcd5 	bl	c0d0a678 <__aeabi_memcpy>
                    starkware_print_eth_address(context->address, msg->msg);
c0d01cce:	69a1      	ldr	r1, [r4, #24]
c0d01cd0:	1c68      	adds	r0, r5, #1
c0d01cd2:	f004 f93f 	bl	c0d05f54 <starkware_print_eth_address>
c0d01cd6:	2020      	movs	r0, #32
c0d01cd8:	2101      	movs	r1, #1
c0d01cda:	5421      	strb	r1, [r4, r0]
c0d01cdc:	b001      	add	sp, #4
c0d01cde:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    PRINTF("Invalid erc721 approval data size %d\n", msg->dataSize);
c0d01ce0:	4806      	ldr	r0, [pc, #24]	; (c0d01cfc <erc721_plugin_call+0x200>)
c0d01ce2:	4478      	add	r0, pc
c0d01ce4:	e7b7      	b.n	c0d01c56 <erc721_plugin_call+0x15a>
c0d01ce6:	46c0      	nop			; (mov r8, r8)
c0d01ce8:	200018dc 	.word	0x200018dc
c0d01cec:	00000302 	.word	0x00000302
c0d01cf0:	0000977c 	.word	0x0000977c
c0d01cf4:	000093f1 	.word	0x000093f1
c0d01cf8:	00009ba8 	.word	0x00009ba8
c0d01cfc:	0000955d 	.word	0x0000955d
c0d01d00:	0000958d 	.word	0x0000958d
c0d01d04:	00009677 	.word	0x00009677
c0d01d08:	0000967b 	.word	0x0000967b
c0d01d0c:	00009323 	.word	0x00009323
c0d01d10:	00009688 	.word	0x00009688
c0d01d14:	000096b0 	.word	0x000096b0
c0d01d18:	00009786 	.word	0x00009786
c0d01d1c:	00009646 	.word	0x00009646
c0d01d20:	000095b3 	.word	0x000095b3

c0d01d24 <initTx>:

void initTx(txContext_t *context,
            cx_sha3_t *sha3,
            txContent_t *content,
            ustreamProcess_t customProcessor,
            void *extra) {
c0d01d24:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01d26:	b081      	sub	sp, #4
c0d01d28:	461d      	mov	r5, r3
c0d01d2a:	4616      	mov	r6, r2
c0d01d2c:	460c      	mov	r4, r1
c0d01d2e:	4607      	mov	r7, r0
c0d01d30:	2130      	movs	r1, #48	; 0x30
    memset(context, 0, sizeof(txContext_t));
c0d01d32:	f008 fc9b 	bl	c0d0a66c <__aeabi_memclr>
    context->sha3 = sha3;
    context->content = content;
c0d01d36:	637e      	str	r6, [r7, #52]	; 0x34
    context->sha3 = sha3;
c0d01d38:	607c      	str	r4, [r7, #4]
c0d01d3a:	9806      	ldr	r0, [sp, #24]
    context->customProcessor = customProcessor;
    context->extra = extra;
c0d01d3c:	63b8      	str	r0, [r7, #56]	; 0x38
    context->customProcessor = customProcessor;
c0d01d3e:	633d      	str	r5, [r7, #48]	; 0x30
c0d01d40:	2001      	movs	r0, #1
    context->currentField = TX_RLP_CONTENT;
c0d01d42:	7038      	strb	r0, [r7, #0]
c0d01d44:	0201      	lsls	r1, r0, #8
    cx_keccak_init(context->sha3, 256);
c0d01d46:	4620      	mov	r0, r4
c0d01d48:	f004 fda6 	bl	c0d06898 <cx_keccak_init>
}
c0d01d4c:	b001      	add	sp, #4
c0d01d4e:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d01d50 <readTxByte>:

uint8_t readTxByte(txContext_t *context) {
c0d01d50:	b510      	push	{r4, lr}
c0d01d52:	b084      	sub	sp, #16
    uint8_t data;
    if (context->commandLength < 1) {
c0d01d54:	6a82      	ldr	r2, [r0, #40]	; 0x28
c0d01d56:	2a00      	cmp	r2, #0
c0d01d58:	d01e      	beq.n	c0d01d98 <readTxByte+0x48>
        PRINTF("readTxByte Underflow\n");
        THROW(EXCEPTION);
    }
    data = *context->workBuffer;
c0d01d5a:	6a43      	ldr	r3, [r0, #36]	; 0x24
c0d01d5c:	7819      	ldrb	r1, [r3, #0]
c0d01d5e:	ac03      	add	r4, sp, #12
c0d01d60:	7021      	strb	r1, [r4, #0]
    context->workBuffer++;
    context->commandLength--;
c0d01d62:	1e52      	subs	r2, r2, #1
    context->workBuffer++;
c0d01d64:	1c5b      	adds	r3, r3, #1
c0d01d66:	6243      	str	r3, [r0, #36]	; 0x24
    context->commandLength--;
c0d01d68:	6282      	str	r2, [r0, #40]	; 0x28
    if (context->processingField) {
c0d01d6a:	7c42      	ldrb	r2, [r0, #17]
c0d01d6c:	2a00      	cmp	r2, #0
c0d01d6e:	d005      	beq.n	c0d01d7c <readTxByte+0x2c>
        context->currentFieldPos++;
c0d01d70:	68c2      	ldr	r2, [r0, #12]
c0d01d72:	1c52      	adds	r2, r2, #1
c0d01d74:	60c2      	str	r2, [r0, #12]
    }
    if (!(context->processingField && context->fieldSingleByte)) {
c0d01d76:	7c82      	ldrb	r2, [r0, #18]
c0d01d78:	2a00      	cmp	r2, #0
c0d01d7a:	d10a      	bne.n	c0d01d92 <readTxByte+0x42>
        cx_hash((cx_hash_t *) context->sha3, 0, &data, 1, NULL, 0);
c0d01d7c:	6840      	ldr	r0, [r0, #4]
c0d01d7e:	2100      	movs	r1, #0
c0d01d80:	466a      	mov	r2, sp
c0d01d82:	6011      	str	r1, [r2, #0]
c0d01d84:	6051      	str	r1, [r2, #4]
c0d01d86:	ac03      	add	r4, sp, #12
c0d01d88:	2301      	movs	r3, #1
c0d01d8a:	4622      	mov	r2, r4
c0d01d8c:	f004 fd54 	bl	c0d06838 <cx_hash>
    }
    return data;
c0d01d90:	7821      	ldrb	r1, [r4, #0]
c0d01d92:	4608      	mov	r0, r1
c0d01d94:	b004      	add	sp, #16
c0d01d96:	bd10      	pop	{r4, pc}
        PRINTF("readTxByte Underflow\n");
c0d01d98:	4803      	ldr	r0, [pc, #12]	; (c0d01da8 <readTxByte+0x58>)
c0d01d9a:	4478      	add	r0, pc
c0d01d9c:	f003 f94e 	bl	c0d0503c <mcu_usb_printf>
c0d01da0:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0d01da2:	f002 faef 	bl	c0d04384 <os_longjmp>
c0d01da6:	46c0      	nop			; (mov r8, r8)
c0d01da8:	0000957f 	.word	0x0000957f

c0d01dac <copyTxData>:
}

void copyTxData(txContext_t *context, uint8_t *out, uint32_t length) {
c0d01dac:	b5b0      	push	{r4, r5, r7, lr}
c0d01dae:	b082      	sub	sp, #8
c0d01db0:	4605      	mov	r5, r0
    if (context->commandLength < length) {
c0d01db2:	6a80      	ldr	r0, [r0, #40]	; 0x28
c0d01db4:	4290      	cmp	r0, r2
c0d01db6:	d32c      	bcc.n	c0d01e12 <copyTxData+0x66>
c0d01db8:	4614      	mov	r4, r2
        PRINTF("copyTxData Underflow\n");
        THROW(EXCEPTION);
    }
    if (out != NULL) {
c0d01dba:	2900      	cmp	r1, #0
c0d01dbc:	d005      	beq.n	c0d01dca <copyTxData+0x1e>
        memmove(out, context->workBuffer, length);
c0d01dbe:	6a6a      	ldr	r2, [r5, #36]	; 0x24
c0d01dc0:	4608      	mov	r0, r1
c0d01dc2:	4611      	mov	r1, r2
c0d01dc4:	4622      	mov	r2, r4
c0d01dc6:	f008 fc5b 	bl	c0d0a680 <__aeabi_memmove>
    }
    if (!(context->processingField && context->fieldSingleByte)) {
c0d01dca:	7c68      	ldrb	r0, [r5, #17]
c0d01dcc:	2800      	cmp	r0, #0
c0d01dce:	d009      	beq.n	c0d01de4 <copyTxData+0x38>
c0d01dd0:	7ca8      	ldrb	r0, [r5, #18]
c0d01dd2:	2800      	cmp	r0, #0
c0d01dd4:	d006      	beq.n	c0d01de4 <copyTxData+0x38>
        cx_hash((cx_hash_t *) context->sha3, 0, context->workBuffer, length, NULL, 0);
    }
    context->workBuffer += length;
c0d01dd6:	6a68      	ldr	r0, [r5, #36]	; 0x24
c0d01dd8:	1900      	adds	r0, r0, r4
c0d01dda:	6268      	str	r0, [r5, #36]	; 0x24
    context->commandLength -= length;
c0d01ddc:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0d01dde:	1b00      	subs	r0, r0, r4
c0d01de0:	62a8      	str	r0, [r5, #40]	; 0x28
c0d01de2:	e011      	b.n	c0d01e08 <copyTxData+0x5c>
        cx_hash((cx_hash_t *) context->sha3, 0, context->workBuffer, length, NULL, 0);
c0d01de4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
c0d01de6:	6868      	ldr	r0, [r5, #4]
c0d01de8:	2100      	movs	r1, #0
c0d01dea:	466b      	mov	r3, sp
c0d01dec:	6019      	str	r1, [r3, #0]
c0d01dee:	6059      	str	r1, [r3, #4]
c0d01df0:	4623      	mov	r3, r4
c0d01df2:	f004 fd21 	bl	c0d06838 <cx_hash>
    context->workBuffer += length;
c0d01df6:	6a68      	ldr	r0, [r5, #36]	; 0x24
c0d01df8:	1900      	adds	r0, r0, r4
c0d01dfa:	6268      	str	r0, [r5, #36]	; 0x24
    context->commandLength -= length;
c0d01dfc:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0d01dfe:	1b00      	subs	r0, r0, r4
c0d01e00:	62a8      	str	r0, [r5, #40]	; 0x28
    if (context->processingField) {
c0d01e02:	7c68      	ldrb	r0, [r5, #17]
c0d01e04:	2800      	cmp	r0, #0
c0d01e06:	d002      	beq.n	c0d01e0e <copyTxData+0x62>
        context->currentFieldPos += length;
c0d01e08:	68e8      	ldr	r0, [r5, #12]
c0d01e0a:	1900      	adds	r0, r0, r4
c0d01e0c:	60e8      	str	r0, [r5, #12]
    }
}
c0d01e0e:	b002      	add	sp, #8
c0d01e10:	bdb0      	pop	{r4, r5, r7, pc}
        PRINTF("copyTxData Underflow\n");
c0d01e12:	4803      	ldr	r0, [pc, #12]	; (c0d01e20 <copyTxData+0x74>)
c0d01e14:	4478      	add	r0, pc
c0d01e16:	f003 f911 	bl	c0d0503c <mcu_usb_printf>
c0d01e1a:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0d01e1c:	f002 fab2 	bl	c0d04384 <os_longjmp>
c0d01e20:	0000951b 	.word	0x0000951b

c0d01e24 <decodeThetaData>:

void decodeThetaData(txContext_t *context, uint8_t *out, uint32_t length) {
c0d01e24:	b5b0      	push	{r4, r5, r7, lr}
c0d01e26:	b082      	sub	sp, #8
c0d01e28:	4604      	mov	r4, r0
    if (context->commandLength < length) {
c0d01e2a:	6a80      	ldr	r0, [r0, #40]	; 0x28
c0d01e2c:	4290      	cmp	r0, r2
c0d01e2e:	d32b      	bcc.n	c0d01e88 <decodeThetaData+0x64>
c0d01e30:	4615      	mov	r5, r2
        PRINTF("copyTxData Underflow\n");
        THROW(EXCEPTION);
    }

    context->content->thetaTXLength = length;
c0d01e32:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d01e34:	21f9      	movs	r1, #249	; 0xf9
c0d01e36:	5442      	strb	r2, [r0, r1]
    memmove(context->content->thetaTX, context->workBuffer, length);
c0d01e38:	6a61      	ldr	r1, [r4, #36]	; 0x24
c0d01e3a:	3063      	adds	r0, #99	; 0x63
c0d01e3c:	f008 fc20 	bl	c0d0a680 <__aeabi_memmove>
    if (!(context->processingField && context->fieldSingleByte)) {
c0d01e40:	7c60      	ldrb	r0, [r4, #17]
c0d01e42:	2800      	cmp	r0, #0
c0d01e44:	d009      	beq.n	c0d01e5a <decodeThetaData+0x36>
c0d01e46:	7ca0      	ldrb	r0, [r4, #18]
c0d01e48:	2800      	cmp	r0, #0
c0d01e4a:	d006      	beq.n	c0d01e5a <decodeThetaData+0x36>
        cx_hash((cx_hash_t *) context->sha3, 0, context->workBuffer, length, NULL, 0);
    }
    context->workBuffer += length;
c0d01e4c:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0d01e4e:	1940      	adds	r0, r0, r5
c0d01e50:	6260      	str	r0, [r4, #36]	; 0x24
    context->commandLength -= length;
c0d01e52:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d01e54:	1b40      	subs	r0, r0, r5
c0d01e56:	62a0      	str	r0, [r4, #40]	; 0x28
c0d01e58:	e011      	b.n	c0d01e7e <decodeThetaData+0x5a>
        cx_hash((cx_hash_t *) context->sha3, 0, context->workBuffer, length, NULL, 0);
c0d01e5a:	6a62      	ldr	r2, [r4, #36]	; 0x24
c0d01e5c:	6860      	ldr	r0, [r4, #4]
c0d01e5e:	2100      	movs	r1, #0
c0d01e60:	466b      	mov	r3, sp
c0d01e62:	6019      	str	r1, [r3, #0]
c0d01e64:	6059      	str	r1, [r3, #4]
c0d01e66:	462b      	mov	r3, r5
c0d01e68:	f004 fce6 	bl	c0d06838 <cx_hash>
    context->workBuffer += length;
c0d01e6c:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0d01e6e:	1940      	adds	r0, r0, r5
c0d01e70:	6260      	str	r0, [r4, #36]	; 0x24
    context->commandLength -= length;
c0d01e72:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d01e74:	1b40      	subs	r0, r0, r5
c0d01e76:	62a0      	str	r0, [r4, #40]	; 0x28
    if (context->processingField) {
c0d01e78:	7c60      	ldrb	r0, [r4, #17]
c0d01e7a:	2800      	cmp	r0, #0
c0d01e7c:	d002      	beq.n	c0d01e84 <decodeThetaData+0x60>
        context->currentFieldPos += length;
c0d01e7e:	68e0      	ldr	r0, [r4, #12]
c0d01e80:	1940      	adds	r0, r0, r5
c0d01e82:	60e0      	str	r0, [r4, #12]
    }
}
c0d01e84:	b002      	add	sp, #8
c0d01e86:	bdb0      	pop	{r4, r5, r7, pc}
        PRINTF("copyTxData Underflow\n");
c0d01e88:	4803      	ldr	r0, [pc, #12]	; (c0d01e98 <decodeThetaData+0x74>)
c0d01e8a:	4478      	add	r0, pc
c0d01e8c:	f003 f8d6 	bl	c0d0503c <mcu_usb_printf>
c0d01e90:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0d01e92:	f002 fa77 	bl	c0d04384 <os_longjmp>
c0d01e96:	46c0      	nop			; (mov r8, r8)
c0d01e98:	000094a5 	.word	0x000094a5

c0d01e9c <processTx>:
}

parserStatus_e processTx(txContext_t *context,
                         uint8_t *buffer,
                         uint32_t length,
                         uint32_t processingFlags) {
c0d01e9c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01e9e:	b08d      	sub	sp, #52	; 0x34
c0d01ea0:	9300      	str	r3, [sp, #0]
c0d01ea2:	4616      	mov	r6, r2
c0d01ea4:	460f      	mov	r7, r1
c0d01ea6:	4605      	mov	r5, r0
c0d01ea8:	ac01      	add	r4, sp, #4
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0d01eaa:	4620      	mov	r0, r4
c0d01eac:	f008 fd18 	bl	c0d0a8e0 <setjmp>
c0d01eb0:	85a0      	strh	r0, [r4, #44]	; 0x2c
c0d01eb2:	0400      	lsls	r0, r0, #16
c0d01eb4:	d007      	beq.n	c0d01ec6 <processTx+0x2a>
c0d01eb6:	a801      	add	r0, sp, #4
c0d01eb8:	2100      	movs	r1, #0
            result = processTxInternal(context);
            if (result == USTREAM_FINISHED) {
                PRINTF("jxlog92: here \n");
            }
        }
        CATCH_OTHER(e) {
c0d01eba:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d01ebc:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d01ebe:	f004 fe67 	bl	c0d06b90 <try_context_set>
c0d01ec2:	2403      	movs	r4, #3
c0d01ec4:	e012      	b.n	c0d01eec <processTx+0x50>
c0d01ec6:	a801      	add	r0, sp, #4
        TRY {
c0d01ec8:	f004 fe62 	bl	c0d06b90 <try_context_set>
c0d01ecc:	900b      	str	r0, [sp, #44]	; 0x2c
            context->workBuffer = buffer;
c0d01ece:	626f      	str	r7, [r5, #36]	; 0x24
            context->commandLength = length;
c0d01ed0:	62ae      	str	r6, [r5, #40]	; 0x28
            context->processingFlags = processingFlags;
c0d01ed2:	9800      	ldr	r0, [sp, #0]
c0d01ed4:	62e8      	str	r0, [r5, #44]	; 0x2c
            result = processTxInternal(context);
c0d01ed6:	4628      	mov	r0, r5
c0d01ed8:	f000 f81c 	bl	c0d01f14 <processTxInternal>
c0d01edc:	4604      	mov	r4, r0
            if (result == USTREAM_FINISHED) {
c0d01ede:	2802      	cmp	r0, #2
c0d01ee0:	d104      	bne.n	c0d01eec <processTx+0x50>
                PRINTF("jxlog92: here \n");
c0d01ee2:	480b      	ldr	r0, [pc, #44]	; (c0d01f10 <processTx+0x74>)
c0d01ee4:	4478      	add	r0, pc
c0d01ee6:	f003 f8a9 	bl	c0d0503c <mcu_usb_printf>
c0d01eea:	2402      	movs	r4, #2
            result = USTREAM_FAULT;
        }
        FINALLY {
c0d01eec:	f004 fe44 	bl	c0d06b78 <try_context_get>
c0d01ef0:	a901      	add	r1, sp, #4
c0d01ef2:	4288      	cmp	r0, r1
c0d01ef4:	d102      	bne.n	c0d01efc <processTx+0x60>
c0d01ef6:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d01ef8:	f004 fe4a 	bl	c0d06b90 <try_context_set>
c0d01efc:	a801      	add	r0, sp, #4
        }
    }
    END_TRY;
c0d01efe:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d01f00:	2800      	cmp	r0, #0
c0d01f02:	d102      	bne.n	c0d01f0a <processTx+0x6e>
    return result;
c0d01f04:	4620      	mov	r0, r4
c0d01f06:	b00d      	add	sp, #52	; 0x34
c0d01f08:	bdf0      	pop	{r4, r5, r6, r7, pc}
    END_TRY;
c0d01f0a:	f002 fa3b 	bl	c0d04384 <os_longjmp>
c0d01f0e:	46c0      	nop			; (mov r8, r8)
c0d01f10:	00009461 	.word	0x00009461

c0d01f14 <processTxInternal>:
static parserStatus_e processTxInternal(txContext_t *context) {
c0d01f14:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01f16:	b085      	sub	sp, #20
c0d01f18:	4604      	mov	r4, r0
c0d01f1a:	4605      	mov	r5, r0
c0d01f1c:	3510      	adds	r5, #16
c0d01f1e:	4607      	mov	r7, r0
c0d01f20:	3708      	adds	r7, #8
c0d01f22:	4606      	mov	r6, r0
c0d01f24:	3618      	adds	r6, #24
c0d01f26:	e167      	b.n	c0d021f8 <processTxInternal+0x2e4>
        if (context->commandLength == 0) {
c0d01f28:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d01f2a:	2800      	cmp	r0, #0
c0d01f2c:	d104      	bne.n	c0d01f38 <processTxInternal+0x24>
c0d01f2e:	e16b      	b.n	c0d02208 <processTxInternal+0x2f4>
        if ((context->currentField == TX_RLP_V) && (context->commandLength == 0)) {
c0d01f30:	6aa1      	ldr	r1, [r4, #40]	; 0x28
c0d01f32:	2900      	cmp	r1, #0
c0d01f34:	d100      	bne.n	c0d01f38 <processTxInternal+0x24>
c0d01f36:	e170      	b.n	c0d0221a <processTxInternal+0x306>
        if (!context->processingField) {
c0d01f38:	7c60      	ldrb	r0, [r4, #17]
c0d01f3a:	2800      	cmp	r0, #0
c0d01f3c:	d00a      	beq.n	c0d01f54 <processTxInternal+0x40>
        if (context->customProcessor != NULL) {
c0d01f3e:	6b21      	ldr	r1, [r4, #48]	; 0x30
c0d01f40:	2900      	cmp	r1, #0
c0d01f42:	d020      	beq.n	c0d01f86 <processTxInternal+0x72>
            customStatus = context->customProcessor(context);
c0d01f44:	4620      	mov	r0, r4
c0d01f46:	4788      	blx	r1
            switch (customStatus) {
c0d01f48:	2800      	cmp	r0, #0
c0d01f4a:	dd1a      	ble.n	c0d01f82 <processTxInternal+0x6e>
c0d01f4c:	2801      	cmp	r0, #1
c0d01f4e:	d100      	bne.n	c0d01f52 <processTxInternal+0x3e>
c0d01f50:	e152      	b.n	c0d021f8 <processTxInternal+0x2e4>
c0d01f52:	e16b      	b.n	c0d0222c <processTxInternal+0x318>
                context->rlpBuffer[context->rlpBufferPos++] = readTxByte(context);
c0d01f54:	4620      	mov	r0, r4
c0d01f56:	f7ff fefb 	bl	c0d01d50 <readTxByte>
c0d01f5a:	6a21      	ldr	r1, [r4, #32]
c0d01f5c:	1c4a      	adds	r2, r1, #1
c0d01f5e:	6222      	str	r2, [r4, #32]
c0d01f60:	1861      	adds	r1, r4, r1
c0d01f62:	7608      	strb	r0, [r1, #24]
                if (rlpCanDecode(context->rlpBuffer, context->rlpBufferPos, &valid)) {
c0d01f64:	6a21      	ldr	r1, [r4, #32]
c0d01f66:	aa03      	add	r2, sp, #12
c0d01f68:	4630      	mov	r0, r6
c0d01f6a:	f000 fa02 	bl	c0d02372 <rlpCanDecode>
c0d01f6e:	2800      	cmp	r0, #0
c0d01f70:	d175      	bne.n	c0d0205e <processTxInternal+0x14a>
                if (context->rlpBufferPos == sizeof(context->rlpBuffer)) {
c0d01f72:	6a20      	ldr	r0, [r4, #32]
c0d01f74:	2805      	cmp	r0, #5
c0d01f76:	d100      	bne.n	c0d01f7a <processTxInternal+0x66>
c0d01f78:	e148      	b.n	c0d0220c <processTxInternal+0x2f8>
            while (context->commandLength != 0) {
c0d01f7a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d01f7c:	2800      	cmp	r0, #0
c0d01f7e:	d1e9      	bne.n	c0d01f54 <processTxInternal+0x40>
c0d01f80:	e142      	b.n	c0d02208 <processTxInternal+0x2f4>
c0d01f82:	d000      	beq.n	c0d01f86 <processTxInternal+0x72>
c0d01f84:	e161      	b.n	c0d0224a <processTxInternal+0x336>
            switch (context->currentField) {
c0d01f86:	7820      	ldrb	r0, [r4, #0]
c0d01f88:	2806      	cmp	r0, #6
c0d01f8a:	dc13      	bgt.n	c0d01fb4 <processTxInternal+0xa0>
c0d01f8c:	2803      	cmp	r0, #3
c0d01f8e:	dc3c      	bgt.n	c0d0200a <processTxInternal+0xf6>
c0d01f90:	2801      	cmp	r0, #1
c0d01f92:	d100      	bne.n	c0d01f96 <processTxInternal+0x82>
c0d01f94:	e100      	b.n	c0d02198 <processTxInternal+0x284>
c0d01f96:	2802      	cmp	r0, #2
c0d01f98:	d100      	bne.n	c0d01f9c <processTxInternal+0x88>
c0d01f9a:	e0a9      	b.n	c0d020f0 <processTxInternal+0x1dc>
c0d01f9c:	2803      	cmp	r0, #3
c0d01f9e:	d000      	beq.n	c0d01fa2 <processTxInternal+0x8e>
c0d01fa0:	e141      	b.n	c0d02226 <processTxInternal+0x312>
    if (context->currentFieldIsList) {
c0d01fa2:	7828      	ldrb	r0, [r5, #0]
c0d01fa4:	2800      	cmp	r0, #0
c0d01fa6:	d000      	beq.n	c0d01faa <processTxInternal+0x96>
c0d01fa8:	e152      	b.n	c0d02250 <processTxInternal+0x33c>
    if (context->currentFieldLength > MAX_INT256) {
c0d01faa:	6838      	ldr	r0, [r7, #0]
c0d01fac:	2821      	cmp	r0, #33	; 0x21
c0d01fae:	d200      	bcs.n	c0d01fb2 <processTxInternal+0x9e>
c0d01fb0:	e0a6      	b.n	c0d02100 <processTxInternal+0x1ec>
c0d01fb2:	e150      	b.n	c0d02256 <processTxInternal+0x342>
            switch (context->currentField) {
c0d01fb4:	2809      	cmp	r0, #9
c0d01fb6:	dc74      	bgt.n	c0d020a2 <processTxInternal+0x18e>
c0d01fb8:	2807      	cmp	r0, #7
c0d01fba:	d100      	bne.n	c0d01fbe <processTxInternal+0xaa>
c0d01fbc:	e0b1      	b.n	c0d02122 <processTxInternal+0x20e>
c0d01fbe:	2808      	cmp	r0, #8
c0d01fc0:	d079      	beq.n	c0d020b6 <processTxInternal+0x1a2>
c0d01fc2:	2809      	cmp	r0, #9
c0d01fc4:	d000      	beq.n	c0d01fc8 <processTxInternal+0xb4>
c0d01fc6:	e12e      	b.n	c0d02226 <processTxInternal+0x312>
    if (context->currentFieldIsList) {
c0d01fc8:	7828      	ldrb	r0, [r5, #0]
c0d01fca:	2800      	cmp	r0, #0
c0d01fcc:	d000      	beq.n	c0d01fd0 <processTxInternal+0xbc>
c0d01fce:	e145      	b.n	c0d0225c <processTxInternal+0x348>
    if (context->currentFieldLength > MAX_V) {
c0d01fd0:	6838      	ldr	r0, [r7, #0]
c0d01fd2:	2805      	cmp	r0, #5
c0d01fd4:	d300      	bcc.n	c0d01fd8 <processTxInternal+0xc4>
c0d01fd6:	e144      	b.n	c0d02262 <processTxInternal+0x34e>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d01fd8:	68e1      	ldr	r1, [r4, #12]
c0d01fda:	4288      	cmp	r0, r1
c0d01fdc:	d90e      	bls.n	c0d01ffc <processTxInternal+0xe8>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d01fde:	1a40      	subs	r0, r0, r1
c0d01fe0:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d01fe2:	4282      	cmp	r2, r0
c0d01fe4:	d300      	bcc.n	c0d01fe8 <processTxInternal+0xd4>
c0d01fe6:	4602      	mov	r2, r0
        copyTxData(context, context->content->v + context->currentFieldPos, copySize);
c0d01fe8:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d01fea:	1840      	adds	r0, r0, r1
c0d01fec:	21ff      	movs	r1, #255	; 0xff
c0d01fee:	311e      	adds	r1, #30
c0d01ff0:	1841      	adds	r1, r0, r1
c0d01ff2:	4620      	mov	r0, r4
c0d01ff4:	f7ff feda 	bl	c0d01dac <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d01ff8:	68a0      	ldr	r0, [r4, #8]
c0d01ffa:	68e1      	ldr	r1, [r4, #12]
c0d01ffc:	4281      	cmp	r1, r0
c0d01ffe:	d000      	beq.n	c0d02002 <processTxInternal+0xee>
c0d02000:	e0fa      	b.n	c0d021f8 <processTxInternal+0x2e4>
        context->content->vLength = context->currentFieldLength;
c0d02002:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d02004:	22ff      	movs	r2, #255	; 0xff
c0d02006:	3222      	adds	r2, #34	; 0x22
c0d02008:	e0f0      	b.n	c0d021ec <processTxInternal+0x2d8>
            switch (context->currentField) {
c0d0200a:	2804      	cmp	r0, #4
c0d0200c:	d100      	bne.n	c0d02010 <processTxInternal+0xfc>
c0d0200e:	e0d4      	b.n	c0d021ba <processTxInternal+0x2a6>
c0d02010:	2805      	cmp	r0, #5
c0d02012:	d100      	bne.n	c0d02016 <processTxInternal+0x102>
c0d02014:	e0a2      	b.n	c0d0215c <processTxInternal+0x248>
c0d02016:	2806      	cmp	r0, #6
c0d02018:	d000      	beq.n	c0d0201c <processTxInternal+0x108>
c0d0201a:	e104      	b.n	c0d02226 <processTxInternal+0x312>
    if (context->currentFieldIsList) {
c0d0201c:	7828      	ldrb	r0, [r5, #0]
c0d0201e:	2800      	cmp	r0, #0
c0d02020:	d000      	beq.n	c0d02024 <processTxInternal+0x110>
c0d02022:	e121      	b.n	c0d02268 <processTxInternal+0x354>
    if (context->currentFieldLength > MAX_ADDRESS) {
c0d02024:	6838      	ldr	r0, [r7, #0]
c0d02026:	2815      	cmp	r0, #21
c0d02028:	d300      	bcc.n	c0d0202c <processTxInternal+0x118>
c0d0202a:	e120      	b.n	c0d0226e <processTxInternal+0x35a>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d0202c:	68e1      	ldr	r1, [r4, #12]
c0d0202e:	4288      	cmp	r0, r1
c0d02030:	d90e      	bls.n	c0d02050 <processTxInternal+0x13c>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d02032:	1a40      	subs	r0, r0, r1
c0d02034:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d02036:	4282      	cmp	r2, r0
c0d02038:	d300      	bcc.n	c0d0203c <processTxInternal+0x128>
c0d0203a:	4602      	mov	r2, r0
        copyTxData(context, context->content->destination + context->currentFieldPos, copySize);
c0d0203c:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d0203e:	1840      	adds	r0, r0, r1
c0d02040:	2121      	movs	r1, #33	; 0x21
c0d02042:	00c9      	lsls	r1, r1, #3
c0d02044:	1841      	adds	r1, r0, r1
c0d02046:	4620      	mov	r0, r4
c0d02048:	f7ff feb0 	bl	c0d01dac <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d0204c:	68a0      	ldr	r0, [r4, #8]
c0d0204e:	68e1      	ldr	r1, [r4, #12]
c0d02050:	4281      	cmp	r1, r0
c0d02052:	d000      	beq.n	c0d02056 <processTxInternal+0x142>
c0d02054:	e0d0      	b.n	c0d021f8 <processTxInternal+0x2e4>
        context->content->destinationLength = context->currentFieldLength;
c0d02056:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d02058:	2247      	movs	r2, #71	; 0x47
c0d0205a:	0092      	lsls	r2, r2, #2
c0d0205c:	e0c6      	b.n	c0d021ec <processTxInternal+0x2d8>
c0d0205e:	a803      	add	r0, sp, #12
                    if (!valid) {
c0d02060:	7800      	ldrb	r0, [r0, #0]
c0d02062:	2800      	cmp	r0, #0
c0d02064:	d100      	bne.n	c0d02068 <processTxInternal+0x154>
c0d02066:	e0e8      	b.n	c0d0223a <processTxInternal+0x326>
                                 context->rlpBufferPos,
c0d02068:	6a21      	ldr	r1, [r4, #32]
            if (!rlpDecodeLength(context->rlpBuffer,
c0d0206a:	4668      	mov	r0, sp
c0d0206c:	6005      	str	r5, [r0, #0]
c0d0206e:	ab04      	add	r3, sp, #16
c0d02070:	4630      	mov	r0, r6
c0d02072:	463a      	mov	r2, r7
c0d02074:	f000 f99f 	bl	c0d023b6 <rlpDecodeLength>
c0d02078:	2800      	cmp	r0, #0
c0d0207a:	d100      	bne.n	c0d0207e <processTxInternal+0x16a>
c0d0207c:	e0e0      	b.n	c0d02240 <processTxInternal+0x32c>
c0d0207e:	2000      	movs	r0, #0
            if (offset == 0) {
c0d02080:	9904      	ldr	r1, [sp, #16]
c0d02082:	2900      	cmp	r1, #0
c0d02084:	4601      	mov	r1, r0
c0d02086:	d106      	bne.n	c0d02096 <processTxInternal+0x182>
                context->workBuffer--;
c0d02088:	6a61      	ldr	r1, [r4, #36]	; 0x24
c0d0208a:	1e49      	subs	r1, r1, #1
c0d0208c:	6261      	str	r1, [r4, #36]	; 0x24
                context->commandLength++;
c0d0208e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
c0d02090:	1c49      	adds	r1, r1, #1
c0d02092:	62a1      	str	r1, [r4, #40]	; 0x28
c0d02094:	2101      	movs	r1, #1
            context->rlpBufferPos = 0;
c0d02096:	6220      	str	r0, [r4, #32]
            context->currentFieldPos = 0;
c0d02098:	60e0      	str	r0, [r4, #12]
c0d0209a:	74a1      	strb	r1, [r4, #18]
c0d0209c:	2001      	movs	r0, #1
            context->processingField = true;
c0d0209e:	7460      	strb	r0, [r4, #17]
c0d020a0:	e74d      	b.n	c0d01f3e <processTxInternal+0x2a>
            switch (context->currentField) {
c0d020a2:	380a      	subs	r0, #10
c0d020a4:	2802      	cmp	r0, #2
c0d020a6:	d300      	bcc.n	c0d020aa <processTxInternal+0x196>
c0d020a8:	e0bd      	b.n	c0d02226 <processTxInternal+0x312>
    if (context->currentFieldIsList) {
c0d020aa:	7828      	ldrb	r0, [r5, #0]
c0d020ac:	2800      	cmp	r0, #0
c0d020ae:	d000      	beq.n	c0d020b2 <processTxInternal+0x19e>
c0d020b0:	e0e0      	b.n	c0d02274 <processTxInternal+0x360>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d020b2:	68a0      	ldr	r0, [r4, #8]
c0d020b4:	e024      	b.n	c0d02100 <processTxInternal+0x1ec>
    if (context->currentFieldIsList) {
c0d020b6:	7828      	ldrb	r0, [r5, #0]
c0d020b8:	2800      	cmp	r0, #0
c0d020ba:	d000      	beq.n	c0d020be <processTxInternal+0x1aa>
c0d020bc:	e0da      	b.n	c0d02274 <processTxInternal+0x360>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d020be:	68a1      	ldr	r1, [r4, #8]
c0d020c0:	68e2      	ldr	r2, [r4, #12]
c0d020c2:	4291      	cmp	r1, r2
c0d020c4:	d911      	bls.n	c0d020ea <processTxInternal+0x1d6>
c0d020c6:	9702      	str	r7, [sp, #8]
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d020c8:	1a88      	subs	r0, r1, r2
c0d020ca:	6aa7      	ldr	r7, [r4, #40]	; 0x28
c0d020cc:	4287      	cmp	r7, r0
c0d020ce:	d300      	bcc.n	c0d020d2 <processTxInternal+0x1be>
c0d020d0:	4607      	mov	r7, r0
        PRINTF("jxlog22: length %d, pos %d, copysize %d \n",  context->currentFieldLength, context->currentFieldPos, copySize);
c0d020d2:	488e      	ldr	r0, [pc, #568]	; (c0d0230c <processTxInternal+0x3f8>)
c0d020d4:	4478      	add	r0, pc
c0d020d6:	463b      	mov	r3, r7
c0d020d8:	f002 ffb0 	bl	c0d0503c <mcu_usb_printf>
        decodeThetaData(context, NULL, copySize);
c0d020dc:	4620      	mov	r0, r4
c0d020de:	463a      	mov	r2, r7
c0d020e0:	f7ff fea0 	bl	c0d01e24 <decodeThetaData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d020e4:	68a1      	ldr	r1, [r4, #8]
c0d020e6:	68e2      	ldr	r2, [r4, #12]
c0d020e8:	9f02      	ldr	r7, [sp, #8]
c0d020ea:	428a      	cmp	r2, r1
c0d020ec:	d07f      	beq.n	c0d021ee <processTxInternal+0x2da>
c0d020ee:	e083      	b.n	c0d021f8 <processTxInternal+0x2e4>
    if (context->currentFieldIsList) {
c0d020f0:	7828      	ldrb	r0, [r5, #0]
c0d020f2:	2800      	cmp	r0, #0
c0d020f4:	d000      	beq.n	c0d020f8 <processTxInternal+0x1e4>
c0d020f6:	e0c0      	b.n	c0d0227a <processTxInternal+0x366>
    if (context->currentFieldLength > MAX_INT256) {
c0d020f8:	6838      	ldr	r0, [r7, #0]
c0d020fa:	2821      	cmp	r0, #33	; 0x21
c0d020fc:	d300      	bcc.n	c0d02100 <processTxInternal+0x1ec>
c0d020fe:	e0bf      	b.n	c0d02280 <processTxInternal+0x36c>
c0d02100:	68e1      	ldr	r1, [r4, #12]
c0d02102:	4288      	cmp	r0, r1
c0d02104:	d90a      	bls.n	c0d0211c <processTxInternal+0x208>
c0d02106:	1a40      	subs	r0, r0, r1
c0d02108:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d0210a:	4282      	cmp	r2, r0
c0d0210c:	d300      	bcc.n	c0d02110 <processTxInternal+0x1fc>
c0d0210e:	4602      	mov	r2, r0
c0d02110:	2100      	movs	r1, #0
c0d02112:	4620      	mov	r0, r4
c0d02114:	f7ff fe4a 	bl	c0d01dac <copyTxData>
c0d02118:	68a0      	ldr	r0, [r4, #8]
c0d0211a:	68e1      	ldr	r1, [r4, #12]
c0d0211c:	4281      	cmp	r1, r0
c0d0211e:	d16b      	bne.n	c0d021f8 <processTxInternal+0x2e4>
c0d02120:	e065      	b.n	c0d021ee <processTxInternal+0x2da>
    if (context->currentFieldIsList) {
c0d02122:	7828      	ldrb	r0, [r5, #0]
c0d02124:	2800      	cmp	r0, #0
c0d02126:	d000      	beq.n	c0d0212a <processTxInternal+0x216>
c0d02128:	e0ad      	b.n	c0d02286 <processTxInternal+0x372>
    if (context->currentFieldLength > MAX_INT256) {
c0d0212a:	6838      	ldr	r0, [r7, #0]
c0d0212c:	2821      	cmp	r0, #33	; 0x21
c0d0212e:	d300      	bcc.n	c0d02132 <processTxInternal+0x21e>
c0d02130:	e0ac      	b.n	c0d0228c <processTxInternal+0x378>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d02132:	68e1      	ldr	r1, [r4, #12]
c0d02134:	4288      	cmp	r0, r1
c0d02136:	d90c      	bls.n	c0d02152 <processTxInternal+0x23e>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d02138:	1a40      	subs	r0, r0, r1
c0d0213a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d0213c:	4282      	cmp	r2, r0
c0d0213e:	d300      	bcc.n	c0d02142 <processTxInternal+0x22e>
c0d02140:	4602      	mov	r2, r0
        copyTxData(context, context->content->value.value + context->currentFieldPos, copySize);
c0d02142:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d02144:	1841      	adds	r1, r0, r1
c0d02146:	3142      	adds	r1, #66	; 0x42
c0d02148:	4620      	mov	r0, r4
c0d0214a:	f7ff fe2f 	bl	c0d01dac <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d0214e:	68a0      	ldr	r0, [r4, #8]
c0d02150:	68e1      	ldr	r1, [r4, #12]
c0d02152:	4281      	cmp	r1, r0
c0d02154:	d150      	bne.n	c0d021f8 <processTxInternal+0x2e4>
        context->content->value.length = context->currentFieldLength;
c0d02156:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d02158:	2262      	movs	r2, #98	; 0x62
c0d0215a:	e047      	b.n	c0d021ec <processTxInternal+0x2d8>
    if (context->currentFieldIsList) {
c0d0215c:	7828      	ldrb	r0, [r5, #0]
c0d0215e:	2800      	cmp	r0, #0
c0d02160:	d000      	beq.n	c0d02164 <processTxInternal+0x250>
c0d02162:	e096      	b.n	c0d02292 <processTxInternal+0x37e>
    if (context->currentFieldLength > MAX_INT256) {
c0d02164:	6839      	ldr	r1, [r7, #0]
c0d02166:	2921      	cmp	r1, #33	; 0x21
c0d02168:	d300      	bcc.n	c0d0216c <processTxInternal+0x258>
c0d0216a:	e095      	b.n	c0d02298 <processTxInternal+0x384>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d0216c:	68e0      	ldr	r0, [r4, #12]
c0d0216e:	4281      	cmp	r1, r0
c0d02170:	d90c      	bls.n	c0d0218c <processTxInternal+0x278>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d02172:	1a09      	subs	r1, r1, r0
c0d02174:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d02176:	428a      	cmp	r2, r1
c0d02178:	d300      	bcc.n	c0d0217c <processTxInternal+0x268>
c0d0217a:	460a      	mov	r2, r1
        copyTxData(context, context->content->startgas.value + context->currentFieldPos, copySize);
c0d0217c:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d0217e:	1809      	adds	r1, r1, r0
c0d02180:	3121      	adds	r1, #33	; 0x21
c0d02182:	4620      	mov	r0, r4
c0d02184:	f7ff fe12 	bl	c0d01dac <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d02188:	68a1      	ldr	r1, [r4, #8]
c0d0218a:	68e0      	ldr	r0, [r4, #12]
c0d0218c:	4288      	cmp	r0, r1
c0d0218e:	d133      	bne.n	c0d021f8 <processTxInternal+0x2e4>
        context->content->startgas.length = context->currentFieldLength;
c0d02190:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d02192:	2241      	movs	r2, #65	; 0x41
c0d02194:	5481      	strb	r1, [r0, r2]
c0d02196:	e02a      	b.n	c0d021ee <processTxInternal+0x2da>
    if (!context->currentFieldIsList) {
c0d02198:	7828      	ldrb	r0, [r5, #0]
c0d0219a:	2800      	cmp	r0, #0
c0d0219c:	d100      	bne.n	c0d021a0 <processTxInternal+0x28c>
c0d0219e:	e088      	b.n	c0d022b2 <processTxInternal+0x39e>
c0d021a0:	2000      	movs	r0, #0
    context->processingField = false;
c0d021a2:	7460      	strb	r0, [r4, #17]
c0d021a4:	2002      	movs	r0, #2
    context->currentField++;
c0d021a6:	7020      	strb	r0, [r4, #0]
    context->dataLength = context->currentFieldLength;
c0d021a8:	68a0      	ldr	r0, [r4, #8]
c0d021aa:	6160      	str	r0, [r4, #20]
c0d021ac:	202c      	movs	r0, #44	; 0x2c
                    if ((context->processingFlags & TX_FLAG_TYPE) == 0) {
c0d021ae:	5c20      	ldrb	r0, [r4, r0]
c0d021b0:	07c0      	lsls	r0, r0, #31
c0d021b2:	d121      	bne.n	c0d021f8 <processTxInternal+0x2e4>
c0d021b4:	2003      	movs	r0, #3
                        context->currentField++;
c0d021b6:	7020      	strb	r0, [r4, #0]
c0d021b8:	e01e      	b.n	c0d021f8 <processTxInternal+0x2e4>
    if (context->currentFieldIsList) {
c0d021ba:	7828      	ldrb	r0, [r5, #0]
c0d021bc:	2800      	cmp	r0, #0
c0d021be:	d172      	bne.n	c0d022a6 <processTxInternal+0x392>
    if (context->currentFieldLength > MAX_INT256) {
c0d021c0:	6838      	ldr	r0, [r7, #0]
c0d021c2:	2821      	cmp	r0, #33	; 0x21
c0d021c4:	d272      	bcs.n	c0d022ac <processTxInternal+0x398>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d021c6:	68e2      	ldr	r2, [r4, #12]
c0d021c8:	4290      	cmp	r0, r2
c0d021ca:	d90b      	bls.n	c0d021e4 <processTxInternal+0x2d0>
        copyTxData(context, context->content->gasprice.value + context->currentFieldPos, copySize);
c0d021cc:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d021ce:	1889      	adds	r1, r1, r2
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d021d0:	1a80      	subs	r0, r0, r2
c0d021d2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d021d4:	4282      	cmp	r2, r0
c0d021d6:	d300      	bcc.n	c0d021da <processTxInternal+0x2c6>
c0d021d8:	4602      	mov	r2, r0
        copyTxData(context, context->content->gasprice.value + context->currentFieldPos, copySize);
c0d021da:	4620      	mov	r0, r4
c0d021dc:	f7ff fde6 	bl	c0d01dac <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d021e0:	68a0      	ldr	r0, [r4, #8]
c0d021e2:	68e2      	ldr	r2, [r4, #12]
c0d021e4:	4282      	cmp	r2, r0
c0d021e6:	d107      	bne.n	c0d021f8 <processTxInternal+0x2e4>
        context->content->gasprice.length = context->currentFieldLength;
c0d021e8:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d021ea:	2220      	movs	r2, #32
c0d021ec:	5488      	strb	r0, [r1, r2]
c0d021ee:	2000      	movs	r0, #0
c0d021f0:	7460      	strb	r0, [r4, #17]
c0d021f2:	7820      	ldrb	r0, [r4, #0]
c0d021f4:	1c40      	adds	r0, r0, #1
c0d021f6:	7020      	strb	r0, [r4, #0]
        if (context->currentField == TX_RLP_DONE) {
c0d021f8:	7821      	ldrb	r1, [r4, #0]
c0d021fa:	2002      	movs	r0, #2
c0d021fc:	2909      	cmp	r1, #9
c0d021fe:	d100      	bne.n	c0d02202 <processTxInternal+0x2ee>
c0d02200:	e696      	b.n	c0d01f30 <processTxInternal+0x1c>
c0d02202:	290c      	cmp	r1, #12
c0d02204:	d007      	beq.n	c0d02216 <processTxInternal+0x302>
c0d02206:	e68f      	b.n	c0d01f28 <processTxInternal+0x14>
c0d02208:	2000      	movs	r0, #0
c0d0220a:	e004      	b.n	c0d02216 <processTxInternal+0x302>
                    PRINTF("RLP pre-decode logic error\n");
c0d0220c:	482e      	ldr	r0, [pc, #184]	; (c0d022c8 <processTxInternal+0x3b4>)
c0d0220e:	4478      	add	r0, pc
c0d02210:	f002 ff14 	bl	c0d0503c <mcu_usb_printf>
c0d02214:	2003      	movs	r0, #3
}
c0d02216:	b005      	add	sp, #20
c0d02218:	bdf0      	pop	{r4, r5, r6, r7, pc}
            context->content->vLength = 0;
c0d0221a:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d0221c:	22ff      	movs	r2, #255	; 0xff
c0d0221e:	3222      	adds	r2, #34	; 0x22
c0d02220:	2300      	movs	r3, #0
c0d02222:	548b      	strb	r3, [r1, r2]
c0d02224:	e7f7      	b.n	c0d02216 <processTxInternal+0x302>
                    PRINTF("Invalid RLP decoder context\n");
c0d02226:	482d      	ldr	r0, [pc, #180]	; (c0d022dc <processTxInternal+0x3c8>)
c0d02228:	4478      	add	r0, pc
c0d0222a:	e7f1      	b.n	c0d02210 <processTxInternal+0x2fc>
            switch (customStatus) {
c0d0222c:	2802      	cmp	r0, #2
c0d0222e:	d00a      	beq.n	c0d02246 <processTxInternal+0x332>
c0d02230:	2803      	cmp	r0, #3
c0d02232:	d10a      	bne.n	c0d0224a <processTxInternal+0x336>
                    PRINTF("Custom processor aborted\n");
c0d02234:	4826      	ldr	r0, [pc, #152]	; (c0d022d0 <processTxInternal+0x3bc>)
c0d02236:	4478      	add	r0, pc
c0d02238:	e7ea      	b.n	c0d02210 <processTxInternal+0x2fc>
                        PRINTF("RLP pre-decode error\n");
c0d0223a:	4822      	ldr	r0, [pc, #136]	; (c0d022c4 <processTxInternal+0x3b0>)
c0d0223c:	4478      	add	r0, pc
c0d0223e:	e7e7      	b.n	c0d02210 <processTxInternal+0x2fc>
                PRINTF("RLP decode error\n");
c0d02240:	481f      	ldr	r0, [pc, #124]	; (c0d022c0 <processTxInternal+0x3ac>)
c0d02242:	4478      	add	r0, pc
c0d02244:	e7e4      	b.n	c0d02210 <processTxInternal+0x2fc>
c0d02246:	2001      	movs	r0, #1
c0d02248:	e7e5      	b.n	c0d02216 <processTxInternal+0x302>
                    PRINTF("Unhandled custom processor status\n");
c0d0224a:	4820      	ldr	r0, [pc, #128]	; (c0d022cc <processTxInternal+0x3b8>)
c0d0224c:	4478      	add	r0, pc
c0d0224e:	e7df      	b.n	c0d02210 <processTxInternal+0x2fc>
        PRINTF("Invalid type for RLP_NONCE\n");
c0d02250:	4820      	ldr	r0, [pc, #128]	; (c0d022d4 <processTxInternal+0x3c0>)
c0d02252:	4478      	add	r0, pc
c0d02254:	e02f      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid length for RLP_NONCE\n");
c0d02256:	4825      	ldr	r0, [pc, #148]	; (c0d022ec <processTxInternal+0x3d8>)
c0d02258:	4478      	add	r0, pc
c0d0225a:	e02c      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid type for RLP_V\n");
c0d0225c:	482c      	ldr	r0, [pc, #176]	; (c0d02310 <processTxInternal+0x3fc>)
c0d0225e:	4478      	add	r0, pc
c0d02260:	e029      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid length for RLP_V\n");
c0d02262:	482c      	ldr	r0, [pc, #176]	; (c0d02314 <processTxInternal+0x400>)
c0d02264:	4478      	add	r0, pc
c0d02266:	e026      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid type for RLP_TO\n");
c0d02268:	481b      	ldr	r0, [pc, #108]	; (c0d022d8 <processTxInternal+0x3c4>)
c0d0226a:	4478      	add	r0, pc
c0d0226c:	e023      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid length for RLP_TO\n");
c0d0226e:	4825      	ldr	r0, [pc, #148]	; (c0d02304 <processTxInternal+0x3f0>)
c0d02270:	4478      	add	r0, pc
c0d02272:	e020      	b.n	c0d022b6 <processTxInternal+0x3a2>
c0d02274:	4824      	ldr	r0, [pc, #144]	; (c0d02308 <processTxInternal+0x3f4>)
c0d02276:	4478      	add	r0, pc
c0d02278:	e01d      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid type for RLP_TYPE\n");
c0d0227a:	481a      	ldr	r0, [pc, #104]	; (c0d022e4 <processTxInternal+0x3d0>)
c0d0227c:	4478      	add	r0, pc
c0d0227e:	e01a      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid length for RLP_TYPE\n");
c0d02280:	4819      	ldr	r0, [pc, #100]	; (c0d022e8 <processTxInternal+0x3d4>)
c0d02282:	4478      	add	r0, pc
c0d02284:	e017      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid type for RLP_VALUE\n");
c0d02286:	481d      	ldr	r0, [pc, #116]	; (c0d022fc <processTxInternal+0x3e8>)
c0d02288:	4478      	add	r0, pc
c0d0228a:	e014      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid length for RLP_VALUE\n");
c0d0228c:	481c      	ldr	r0, [pc, #112]	; (c0d02300 <processTxInternal+0x3ec>)
c0d0228e:	4478      	add	r0, pc
c0d02290:	e011      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid type for RLP_STARTGAS\n");
c0d02292:	4819      	ldr	r0, [pc, #100]	; (c0d022f8 <processTxInternal+0x3e4>)
c0d02294:	4478      	add	r0, pc
c0d02296:	e00e      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid length for RLP_STARTGAS %d\n", context->currentFieldLength);
c0d02298:	481f      	ldr	r0, [pc, #124]	; (c0d02318 <processTxInternal+0x404>)
c0d0229a:	4478      	add	r0, pc
c0d0229c:	f002 fece 	bl	c0d0503c <mcu_usb_printf>
c0d022a0:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0d022a2:	f002 f86f 	bl	c0d04384 <os_longjmp>
        PRINTF("Invalid type for RLP_GASPRICE\n");
c0d022a6:	4812      	ldr	r0, [pc, #72]	; (c0d022f0 <processTxInternal+0x3dc>)
c0d022a8:	4478      	add	r0, pc
c0d022aa:	e004      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid length for RLP_GASPRICE\n");
c0d022ac:	4811      	ldr	r0, [pc, #68]	; (c0d022f4 <processTxInternal+0x3e0>)
c0d022ae:	4478      	add	r0, pc
c0d022b0:	e001      	b.n	c0d022b6 <processTxInternal+0x3a2>
        PRINTF("Invalid type for RLP_CONTENT\n");
c0d022b2:	480b      	ldr	r0, [pc, #44]	; (c0d022e0 <processTxInternal+0x3cc>)
c0d022b4:	4478      	add	r0, pc
c0d022b6:	f002 fec1 	bl	c0d0503c <mcu_usb_printf>
c0d022ba:	2001      	movs	r0, #1
c0d022bc:	f002 f862 	bl	c0d04384 <os_longjmp>
c0d022c0:	00009145 	.word	0x00009145
c0d022c4:	00009119 	.word	0x00009119
c0d022c8:	0000915d 	.word	0x0000915d
c0d022cc:	00009167 	.word	0x00009167
c0d022d0:	00009163 	.word	0x00009163
c0d022d4:	000091f7 	.word	0x000091f7
c0d022d8:	000092d6 	.word	0x000092d6
c0d022dc:	000091ae 	.word	0x000091ae
c0d022e0:	0000913f 	.word	0x0000913f
c0d022e4:	00009195 	.word	0x00009195
c0d022e8:	000091aa 	.word	0x000091aa
c0d022ec:	0000920d 	.word	0x0000920d
c0d022f0:	000091db 	.word	0x000091db
c0d022f4:	000091f4 	.word	0x000091f4
c0d022f8:	0000922f 	.word	0x0000922f
c0d022fc:	0000927e 	.word	0x0000927e
c0d02300:	00009294 	.word	0x00009294
c0d02304:	000092e9 	.word	0x000092e9
c0d02308:	000092fe 	.word	0x000092fe
c0d0230c:	000094bb 	.word	0x000094bb
c0d02310:	0000935b 	.word	0x0000935b
c0d02314:	0000936d 	.word	0x0000936d
c0d02318:	00009248 	.word	0x00009248

c0d0231c <continueTx>:
}

parserStatus_e continueTx(txContext_t *context) {
c0d0231c:	b5b0      	push	{r4, r5, r7, lr}
c0d0231e:	b08c      	sub	sp, #48	; 0x30
c0d02320:	4604      	mov	r4, r0
c0d02322:	466d      	mov	r5, sp
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0d02324:	4628      	mov	r0, r5
c0d02326:	f008 fadb 	bl	c0d0a8e0 <setjmp>
c0d0232a:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0d0232c:	0400      	lsls	r0, r0, #16
c0d0232e:	d007      	beq.n	c0d02340 <continueTx+0x24>
c0d02330:	4668      	mov	r0, sp
c0d02332:	2100      	movs	r1, #0
            result = processTxInternal(context);
        }
        CATCH_OTHER(e) {
c0d02334:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d02336:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d02338:	f004 fc2a 	bl	c0d06b90 <try_context_set>
c0d0233c:	2403      	movs	r4, #3
c0d0233e:	e007      	b.n	c0d02350 <continueTx+0x34>
c0d02340:	4668      	mov	r0, sp
        TRY {
c0d02342:	f004 fc25 	bl	c0d06b90 <try_context_set>
c0d02346:	900a      	str	r0, [sp, #40]	; 0x28
            result = processTxInternal(context);
c0d02348:	4620      	mov	r0, r4
c0d0234a:	f7ff fde3 	bl	c0d01f14 <processTxInternal>
c0d0234e:	4604      	mov	r4, r0
            result = USTREAM_FAULT;
        }
        FINALLY {
c0d02350:	f004 fc12 	bl	c0d06b78 <try_context_get>
c0d02354:	4669      	mov	r1, sp
c0d02356:	4288      	cmp	r0, r1
c0d02358:	d102      	bne.n	c0d02360 <continueTx+0x44>
c0d0235a:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d0235c:	f004 fc18 	bl	c0d06b90 <try_context_set>
c0d02360:	4668      	mov	r0, sp
        }
    }
    END_TRY;
c0d02362:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d02364:	2800      	cmp	r0, #0
c0d02366:	d102      	bne.n	c0d0236e <continueTx+0x52>
    return result;
c0d02368:	4620      	mov	r0, r4
c0d0236a:	b00c      	add	sp, #48	; 0x30
c0d0236c:	bdb0      	pop	{r4, r5, r7, pc}
    END_TRY;
c0d0236e:	f002 f809 	bl	c0d04384 <os_longjmp>

c0d02372 <rlpCanDecode>:
#include "os.h"
#include "cx.h"
#include "ethUtils.h"
#include "chainConfig.h"

bool rlpCanDecode(uint8_t *buffer, uint32_t bufferLength, bool *valid) {
c0d02372:	b510      	push	{r4, lr}
    if (*buffer <= 0x7f) {
c0d02374:	7800      	ldrb	r0, [r0, #0]
    } else if (*buffer <= 0xb7) {
c0d02376:	08c3      	lsrs	r3, r0, #3
    if (*buffer <= 0x7f) {
c0d02378:	2b17      	cmp	r3, #23
c0d0237a:	d319      	bcc.n	c0d023b0 <rlpCanDecode+0x3e>
    } else if (*buffer <= 0xbf) {
c0d0237c:	0984      	lsrs	r4, r0, #6
c0d0237e:	2c02      	cmp	r4, #2
c0d02380:	d807      	bhi.n	c0d02392 <rlpCanDecode+0x20>
        if (bufferLength < (1 + (*buffer - 0xb7))) {
c0d02382:	4603      	mov	r3, r0
c0d02384:	3bb6      	subs	r3, #182	; 0xb6
c0d02386:	428b      	cmp	r3, r1
c0d02388:	d809      	bhi.n	c0d0239e <rlpCanDecode+0x2c>
            return false;
        }
        if (*buffer > 0xbb) {
c0d0238a:	0880      	lsrs	r0, r0, #2
c0d0238c:	282f      	cmp	r0, #47	; 0x2f
c0d0238e:	d20b      	bcs.n	c0d023a8 <rlpCanDecode+0x36>
c0d02390:	e00e      	b.n	c0d023b0 <rlpCanDecode+0x3e>
            *valid = false;  // arbitrary 32 bits length limitation
            return true;
        }
    } else if (*buffer <= 0xf7) {
c0d02392:	2b1f      	cmp	r3, #31
c0d02394:	d30c      	bcc.n	c0d023b0 <rlpCanDecode+0x3e>
    } else {
        if (bufferLength < (1 + (*buffer - 0xf7))) {
c0d02396:	4603      	mov	r3, r0
c0d02398:	3bf6      	subs	r3, #246	; 0xf6
c0d0239a:	428b      	cmp	r3, r1
c0d0239c:	d901      	bls.n	c0d023a2 <rlpCanDecode+0x30>
c0d0239e:	2000      	movs	r0, #0
            return true;
        }
    }
    *valid = true;
    return true;
}
c0d023a0:	bd10      	pop	{r4, pc}
        if (*buffer > 0xfb) {
c0d023a2:	0880      	lsrs	r0, r0, #2
c0d023a4:	283f      	cmp	r0, #63	; 0x3f
c0d023a6:	d303      	bcc.n	c0d023b0 <rlpCanDecode+0x3e>
c0d023a8:	2000      	movs	r0, #0
c0d023aa:	7010      	strb	r0, [r2, #0]
c0d023ac:	2001      	movs	r0, #1
}
c0d023ae:	bd10      	pop	{r4, pc}
c0d023b0:	2001      	movs	r0, #1
    *valid = true;
c0d023b2:	7010      	strb	r0, [r2, #0]
}
c0d023b4:	bd10      	pop	{r4, pc}

c0d023b6 <rlpDecodeLength>:

bool rlpDecodeLength(uint8_t *buffer,
                     uint32_t bufferLength,
                     uint32_t *fieldLength,
                     uint32_t *offset,
                     bool *list) {
c0d023b6:	b570      	push	{r4, r5, r6, lr}
    if (*buffer <= 0x7f) {
c0d023b8:	7801      	ldrb	r1, [r0, #0]
c0d023ba:	b249      	sxtb	r1, r1
c0d023bc:	9c04      	ldr	r4, [sp, #16]
c0d023be:	2900      	cmp	r1, #0
c0d023c0:	db04      	blt.n	c0d023cc <rlpDecodeLength+0x16>
c0d023c2:	2000      	movs	r0, #0
        *offset = 0;
c0d023c4:	6018      	str	r0, [r3, #0]
c0d023c6:	2101      	movs	r1, #1
        *fieldLength = 1;
c0d023c8:	6011      	str	r1, [r2, #0]
c0d023ca:	e009      	b.n	c0d023e0 <rlpDecodeLength+0x2a>
c0d023cc:	b2c9      	uxtb	r1, r1
        *list = false;
    } else if (*buffer <= 0xb7) {
c0d023ce:	08cd      	lsrs	r5, r1, #3
c0d023d0:	2d16      	cmp	r5, #22
c0d023d2:	d808      	bhi.n	c0d023e6 <rlpDecodeLength+0x30>
c0d023d4:	2101      	movs	r1, #1
        *offset = 1;
c0d023d6:	6019      	str	r1, [r3, #0]
        *fieldLength = *buffer - 0x80;
c0d023d8:	7800      	ldrb	r0, [r0, #0]
c0d023da:	3880      	subs	r0, #128	; 0x80
c0d023dc:	6010      	str	r0, [r2, #0]
c0d023de:	2000      	movs	r0, #0
c0d023e0:	7020      	strb	r0, [r4, #0]
                return false;  // arbitrary 32 bits length limitation
        }
    }

    return true;
}
c0d023e2:	4608      	mov	r0, r1
c0d023e4:	bd70      	pop	{r4, r5, r6, pc}
    } else if (*buffer <= 0xbf) {
c0d023e6:	098e      	lsrs	r6, r1, #6
c0d023e8:	2e02      	cmp	r6, #2
c0d023ea:	d80f      	bhi.n	c0d0240c <rlpDecodeLength+0x56>
        *offset = 1 + (*buffer - 0xb7);
c0d023ec:	39b6      	subs	r1, #182	; 0xb6
c0d023ee:	6019      	str	r1, [r3, #0]
c0d023f0:	2100      	movs	r1, #0
        *list = false;
c0d023f2:	7021      	strb	r1, [r4, #0]
        switch (*buffer) {
c0d023f4:	7803      	ldrb	r3, [r0, #0]
c0d023f6:	2bb9      	cmp	r3, #185	; 0xb9
c0d023f8:	dc11      	bgt.n	c0d0241e <rlpDecodeLength+0x68>
c0d023fa:	2bb8      	cmp	r3, #184	; 0xb8
c0d023fc:	d03c      	beq.n	c0d02478 <rlpDecodeLength+0xc2>
c0d023fe:	2bb9      	cmp	r3, #185	; 0xb9
c0d02400:	d1ef      	bne.n	c0d023e2 <rlpDecodeLength+0x2c>
                *fieldLength = (*(buffer + 1) << 8) + *(buffer + 2);
c0d02402:	7881      	ldrb	r1, [r0, #2]
c0d02404:	7840      	ldrb	r0, [r0, #1]
c0d02406:	0200      	lsls	r0, r0, #8
c0d02408:	1840      	adds	r0, r0, r1
c0d0240a:	e03e      	b.n	c0d0248a <rlpDecodeLength+0xd4>
    } else if (*buffer <= 0xf7) {
c0d0240c:	2d1e      	cmp	r5, #30
c0d0240e:	d814      	bhi.n	c0d0243a <rlpDecodeLength+0x84>
c0d02410:	2101      	movs	r1, #1
        *offset = 1;
c0d02412:	6019      	str	r1, [r3, #0]
        *fieldLength = *buffer - 0xc0;
c0d02414:	7800      	ldrb	r0, [r0, #0]
c0d02416:	38c0      	subs	r0, #192	; 0xc0
c0d02418:	6010      	str	r0, [r2, #0]
        *list = true;
c0d0241a:	7021      	strb	r1, [r4, #0]
c0d0241c:	e7e1      	b.n	c0d023e2 <rlpDecodeLength+0x2c>
        switch (*buffer) {
c0d0241e:	2bba      	cmp	r3, #186	; 0xba
c0d02420:	d02c      	beq.n	c0d0247c <rlpDecodeLength+0xc6>
c0d02422:	2bbb      	cmp	r3, #187	; 0xbb
c0d02424:	d1dd      	bne.n	c0d023e2 <rlpDecodeLength+0x2c>
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0d02426:	7841      	ldrb	r1, [r0, #1]
c0d02428:	0609      	lsls	r1, r1, #24
c0d0242a:	7883      	ldrb	r3, [r0, #2]
c0d0242c:	041b      	lsls	r3, r3, #16
c0d0242e:	1859      	adds	r1, r3, r1
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0d02430:	78c3      	ldrb	r3, [r0, #3]
c0d02432:	021b      	lsls	r3, r3, #8
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0d02434:	18c9      	adds	r1, r1, r3
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0d02436:	7900      	ldrb	r0, [r0, #4]
c0d02438:	e026      	b.n	c0d02488 <rlpDecodeLength+0xd2>
        *offset = 1 + (*buffer - 0xf7);
c0d0243a:	39f6      	subs	r1, #246	; 0xf6
c0d0243c:	6019      	str	r1, [r3, #0]
c0d0243e:	2301      	movs	r3, #1
        *list = true;
c0d02440:	7023      	strb	r3, [r4, #0]
        switch (*buffer) {
c0d02442:	7804      	ldrb	r4, [r0, #0]
c0d02444:	2100      	movs	r1, #0
c0d02446:	2cf9      	cmp	r4, #249	; 0xf9
c0d02448:	dc08      	bgt.n	c0d0245c <rlpDecodeLength+0xa6>
c0d0244a:	2cf8      	cmp	r4, #248	; 0xf8
c0d0244c:	d020      	beq.n	c0d02490 <rlpDecodeLength+0xda>
c0d0244e:	2cf9      	cmp	r4, #249	; 0xf9
c0d02450:	d1c7      	bne.n	c0d023e2 <rlpDecodeLength+0x2c>
                *fieldLength = (*(buffer + 1) << 8) + *(buffer + 2);
c0d02452:	7881      	ldrb	r1, [r0, #2]
c0d02454:	7840      	ldrb	r0, [r0, #1]
c0d02456:	0200      	lsls	r0, r0, #8
c0d02458:	1840      	adds	r0, r0, r1
c0d0245a:	e022      	b.n	c0d024a2 <rlpDecodeLength+0xec>
        switch (*buffer) {
c0d0245c:	2cfa      	cmp	r4, #250	; 0xfa
c0d0245e:	d019      	beq.n	c0d02494 <rlpDecodeLength+0xde>
c0d02460:	2cfb      	cmp	r4, #251	; 0xfb
c0d02462:	d1be      	bne.n	c0d023e2 <rlpDecodeLength+0x2c>
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0d02464:	7841      	ldrb	r1, [r0, #1]
c0d02466:	0609      	lsls	r1, r1, #24
c0d02468:	7884      	ldrb	r4, [r0, #2]
c0d0246a:	0424      	lsls	r4, r4, #16
c0d0246c:	1861      	adds	r1, r4, r1
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0d0246e:	78c4      	ldrb	r4, [r0, #3]
c0d02470:	0224      	lsls	r4, r4, #8
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0d02472:	1909      	adds	r1, r1, r4
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0d02474:	7900      	ldrb	r0, [r0, #4]
c0d02476:	e013      	b.n	c0d024a0 <rlpDecodeLength+0xea>
                *fieldLength = *(buffer + 1);
c0d02478:	7840      	ldrb	r0, [r0, #1]
c0d0247a:	e006      	b.n	c0d0248a <rlpDecodeLength+0xd4>
                *fieldLength = (*(buffer + 1) << 16) + (*(buffer + 2) << 8) + *(buffer + 3);
c0d0247c:	7841      	ldrb	r1, [r0, #1]
c0d0247e:	0409      	lsls	r1, r1, #16
c0d02480:	7883      	ldrb	r3, [r0, #2]
c0d02482:	021b      	lsls	r3, r3, #8
c0d02484:	1859      	adds	r1, r3, r1
c0d02486:	78c0      	ldrb	r0, [r0, #3]
c0d02488:	1808      	adds	r0, r1, r0
c0d0248a:	6010      	str	r0, [r2, #0]
c0d0248c:	2101      	movs	r1, #1
c0d0248e:	e7a8      	b.n	c0d023e2 <rlpDecodeLength+0x2c>
                *fieldLength = *(buffer + 1);
c0d02490:	7840      	ldrb	r0, [r0, #1]
c0d02492:	e006      	b.n	c0d024a2 <rlpDecodeLength+0xec>
                *fieldLength = (*(buffer + 1) << 16) + (*(buffer + 2) << 8) + *(buffer + 3);
c0d02494:	7841      	ldrb	r1, [r0, #1]
c0d02496:	0409      	lsls	r1, r1, #16
c0d02498:	7884      	ldrb	r4, [r0, #2]
c0d0249a:	0224      	lsls	r4, r4, #8
c0d0249c:	1861      	adds	r1, r4, r1
c0d0249e:	78c0      	ldrb	r0, [r0, #3]
c0d024a0:	1808      	adds	r0, r1, r0
c0d024a2:	6010      	str	r0, [r2, #0]
c0d024a4:	4619      	mov	r1, r3
c0d024a6:	e79c      	b.n	c0d023e2 <rlpDecodeLength+0x2c>

c0d024a8 <getEthAddressStringFromKey>:
static const uint8_t const HEXDIGITS[] = "0123456789abcdef";

void getEthAddressStringFromKey(cx_ecfp_public_key_t *publicKey,
                                uint8_t *out,
                                cx_sha3_t *sha3Context,
                                chain_config_t *chain_config) {
c0d024a8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d024aa:	b08d      	sub	sp, #52	; 0x34
c0d024ac:	9304      	str	r3, [sp, #16]
c0d024ae:	4615      	mov	r5, r2
c0d024b0:	9103      	str	r1, [sp, #12]
c0d024b2:	4607      	mov	r7, r0
c0d024b4:	2401      	movs	r4, #1
c0d024b6:	0221      	lsls	r1, r4, #8
    uint8_t hashAddress[32];
    cx_keccak_init(sha3Context, 256);
c0d024b8:	4610      	mov	r0, r2
c0d024ba:	f004 f9ed 	bl	c0d06898 <cx_keccak_init>
c0d024be:	2020      	movs	r0, #32
    cx_hash((cx_hash_t *) sha3Context, CX_LAST, publicKey->W + 1, 64, hashAddress, 32);
c0d024c0:	4669      	mov	r1, sp
c0d024c2:	6048      	str	r0, [r1, #4]
c0d024c4:	ae05      	add	r6, sp, #20
c0d024c6:	600e      	str	r6, [r1, #0]
c0d024c8:	3709      	adds	r7, #9
c0d024ca:	2340      	movs	r3, #64	; 0x40
c0d024cc:	4628      	mov	r0, r5
c0d024ce:	4621      	mov	r1, r4
c0d024d0:	463a      	mov	r2, r7
c0d024d2:	f004 f9b1 	bl	c0d06838 <cx_hash>
    getEthAddressStringFromBinary(hashAddress + 12, out, sha3Context, chain_config);
c0d024d6:	360c      	adds	r6, #12
c0d024d8:	4630      	mov	r0, r6
c0d024da:	9903      	ldr	r1, [sp, #12]
c0d024dc:	462a      	mov	r2, r5
c0d024de:	9b04      	ldr	r3, [sp, #16]
c0d024e0:	f000 f802 	bl	c0d024e8 <getEthAddressStringFromBinary>
}
c0d024e4:	b00d      	add	sp, #52	; 0x34
c0d024e6:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d024e8 <getEthAddressStringFromBinary>:
};

void getEthAddressStringFromBinary(uint8_t *address,
                                   uint8_t *out,
                                   cx_sha3_t *sha3Context,
                                   chain_config_t *chain_config) {
c0d024e8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d024ea:	b093      	sub	sp, #76	; 0x4c
c0d024ec:	9203      	str	r2, [sp, #12]
c0d024ee:	9104      	str	r1, [sp, #16]
c0d024f0:	4605      	mov	r5, r0
    } locals_union;

    uint8_t i;
    bool eip1191 = false;
    uint32_t offset = 0;
    switch (chain_config->chainId) {
c0d024f2:	695b      	ldr	r3, [r3, #20]
c0d024f4:	2101      	movs	r1, #1
c0d024f6:	4618      	mov	r0, r3
c0d024f8:	9105      	str	r1, [sp, #20]
c0d024fa:	4388      	bics	r0, r1
c0d024fc:	2600      	movs	r6, #0
        case 30:
        case 31:
            eip1191 = true;
            break;
    }
    if (eip1191) {
c0d024fe:	281e      	cmp	r0, #30
c0d02500:	4630      	mov	r0, r6
c0d02502:	d109      	bne.n	c0d02518 <getEthAddressStringFromBinary+0x30>
c0d02504:	af06      	add	r7, sp, #24
c0d02506:	2133      	movs	r1, #51	; 0x33
        snprintf((char *) locals_union.tmp,
c0d02508:	4a27      	ldr	r2, [pc, #156]	; (c0d025a8 <getEthAddressStringFromBinary+0xc0>)
c0d0250a:	447a      	add	r2, pc
c0d0250c:	4638      	mov	r0, r7
c0d0250e:	f002 ff3f 	bl	c0d05390 <snprintf>
                 sizeof(locals_union.tmp),
                 "%d0x",
                 chain_config->chainId);
        offset = strlen((char *) locals_union.tmp);
c0d02512:	4638      	mov	r0, r7
c0d02514:	f008 fa70 	bl	c0d0a9f8 <strlen>
c0d02518:	a906      	add	r1, sp, #24
c0d0251a:	9002      	str	r0, [sp, #8]
    }
    for (i = 0; i < 20; i++) {
c0d0251c:	1808      	adds	r0, r1, r0
c0d0251e:	4f23      	ldr	r7, [pc, #140]	; (c0d025ac <getEthAddressStringFromBinary+0xc4>)
c0d02520:	447f      	add	r7, pc
        uint8_t digit = address[i];
c0d02522:	5da9      	ldrb	r1, [r5, r6]
c0d02524:	240f      	movs	r4, #15
        locals_union.tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
c0d02526:	090a      	lsrs	r2, r1, #4
        locals_union.tmp[offset + 2 * i + 1] = HEXDIGITS[digit & 0x0f];
c0d02528:	4021      	ands	r1, r4
c0d0252a:	5c79      	ldrb	r1, [r7, r1]
c0d0252c:	7041      	strb	r1, [r0, #1]
        locals_union.tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
c0d0252e:	5cb9      	ldrb	r1, [r7, r2]
c0d02530:	7001      	strb	r1, [r0, #0]
    for (i = 0; i < 20; i++) {
c0d02532:	1c80      	adds	r0, r0, #2
c0d02534:	1c76      	adds	r6, r6, #1
c0d02536:	2e14      	cmp	r6, #20
c0d02538:	d1f3      	bne.n	c0d02522 <getEthAddressStringFromBinary+0x3a>
c0d0253a:	9805      	ldr	r0, [sp, #20]
c0d0253c:	0201      	lsls	r1, r0, #8
c0d0253e:	9e03      	ldr	r6, [sp, #12]
    }
    cx_keccak_init(sha3Context, 256);
c0d02540:	4630      	mov	r0, r6
c0d02542:	f004 f9a9 	bl	c0d06898 <cx_keccak_init>
c0d02546:	2020      	movs	r0, #32
    cx_hash((cx_hash_t *) sha3Context,
c0d02548:	4669      	mov	r1, sp
c0d0254a:	6048      	str	r0, [r1, #4]
c0d0254c:	aa06      	add	r2, sp, #24
c0d0254e:	600a      	str	r2, [r1, #0]
c0d02550:	9b02      	ldr	r3, [sp, #8]
            CX_LAST,
            locals_union.tmp,
            offset + 40,
c0d02552:	3328      	adds	r3, #40	; 0x28
    cx_hash((cx_hash_t *) sha3Context,
c0d02554:	4630      	mov	r0, r6
c0d02556:	9905      	ldr	r1, [sp, #20]
c0d02558:	f004 f96e 	bl	c0d06838 <cx_hash>
c0d0255c:	2000      	movs	r0, #0
c0d0255e:	9e04      	ldr	r6, [sp, #16]
            locals_union.hashChecksum,
            32);
    for (i = 0; i < 40; i++) {
        uint8_t digit = address[i / 2];
        if ((i % 2) == 0) {
c0d02560:	4602      	mov	r2, r0
c0d02562:	9905      	ldr	r1, [sp, #20]
c0d02564:	400a      	ands	r2, r1
        uint8_t digit = address[i / 2];
c0d02566:	0843      	lsrs	r3, r0, #1
c0d02568:	5ce9      	ldrb	r1, [r5, r3]
        if ((i % 2) == 0) {
c0d0256a:	2a00      	cmp	r2, #0
c0d0256c:	d001      	beq.n	c0d02572 <getEthAddressStringFromBinary+0x8a>
c0d0256e:	4021      	ands	r1, r4
c0d02570:	e000      	b.n	c0d02574 <getEthAddressStringFromBinary+0x8c>
c0d02572:	0909      	lsrs	r1, r1, #4
            digit = (digit >> 4) & 0x0f;
        } else {
            digit = digit & 0x0f;
        }
        if (digit < 10) {
c0d02574:	2909      	cmp	r1, #9
c0d02576:	d801      	bhi.n	c0d0257c <getEthAddressStringFromBinary+0x94>
            out[i] = HEXDIGITS[digit];
c0d02578:	5c79      	ldrb	r1, [r7, r1]
c0d0257a:	e00b      	b.n	c0d02594 <getEthAddressStringFromBinary+0xac>
c0d0257c:	ae06      	add	r6, sp, #24
        } else {
            int v = (locals_union.hashChecksum[i / 2] >> (4 * (1 - i % 2))) & 0x0f;
c0d0257e:	5cf3      	ldrb	r3, [r6, r3]
c0d02580:	0092      	lsls	r2, r2, #2
c0d02582:	2604      	movs	r6, #4
c0d02584:	4056      	eors	r6, r2
c0d02586:	2208      	movs	r2, #8
            if (v >= 8) {
c0d02588:	40b2      	lsls	r2, r6
c0d0258a:	5c79      	ldrb	r1, [r7, r1]
c0d0258c:	421a      	tst	r2, r3
c0d0258e:	d000      	beq.n	c0d02592 <getEthAddressStringFromBinary+0xaa>
c0d02590:	3920      	subs	r1, #32
c0d02592:	9e04      	ldr	r6, [sp, #16]
c0d02594:	5431      	strb	r1, [r6, r0]
    for (i = 0; i < 40; i++) {
c0d02596:	1c40      	adds	r0, r0, #1
c0d02598:	2828      	cmp	r0, #40	; 0x28
c0d0259a:	d1e1      	bne.n	c0d02560 <getEthAddressStringFromBinary+0x78>
c0d0259c:	2028      	movs	r0, #40	; 0x28
c0d0259e:	2100      	movs	r1, #0
            } else {
                out[i] = HEXDIGITS[digit];
            }
        }
    }
    out[40] = '\0';
c0d025a0:	5431      	strb	r1, [r6, r0]
}
c0d025a2:	b013      	add	sp, #76	; 0x4c
c0d025a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d025a6:	46c0      	nop			; (mov r8, r8)
c0d025a8:	0000912c 	.word	0x0000912c
c0d025ac:	000090cb 	.word	0x000090cb

c0d025b0 <getThetaTxFromBinary>:
void getThetaTxFromBinary(txContext_t *context, cx_sha3_t *sha3Context, chain_config_t *chain_config) {
c0d025b0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d025b2:	b0dd      	sub	sp, #372	; 0x174
c0d025b4:	4604      	mov	r4, r0
    uint8_t i, thetaOffset = 12, pos = context->content->thetaTXLength - thetaOffset;
c0d025b6:	6b40      	ldr	r0, [r0, #52]	; 0x34
c0d025b8:	27f9      	movs	r7, #249	; 0xf9
c0d025ba:	5dc6      	ldrb	r6, [r0, r7]
c0d025bc:	ad03      	add	r5, sp, #12
        TRY {
c0d025be:	4628      	mov	r0, r5
c0d025c0:	f008 f98e 	bl	c0d0a8e0 <setjmp>
c0d025c4:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0d025c6:	0400      	lsls	r0, r0, #16
c0d025c8:	d00a      	beq.n	c0d025e0 <getThetaTxFromBinary+0x30>
c0d025ca:	a803      	add	r0, sp, #12
c0d025cc:	2100      	movs	r1, #0
        CATCH_OTHER(e) {
c0d025ce:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d025d0:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d025d2:	f004 fadd 	bl	c0d06b90 <try_context_set>
            PRINTF("jxlog23 USTREAM_FAULT \n");
c0d025d6:	486c      	ldr	r0, [pc, #432]	; (c0d02788 <getThetaTxFromBinary+0x1d8>)
c0d025d8:	4478      	add	r0, pc
c0d025da:	f002 fd2f 	bl	c0d0503c <mcu_usb_printf>
c0d025de:	e0a6      	b.n	c0d0272e <getThetaTxFromBinary+0x17e>
c0d025e0:	9601      	str	r6, [sp, #4]
c0d025e2:	a803      	add	r0, sp, #12
        TRY {
c0d025e4:	f004 fad4 	bl	c0d06b90 <try_context_set>
c0d025e8:	900d      	str	r0, [sp, #52]	; 0x34
c0d025ea:	9402      	str	r4, [sp, #8]
            rlpP = context->content->thetaTX + thetaOffset;
c0d025ec:	6b65      	ldr	r5, [r4, #52]	; 0x34
            for (i = 0; i < (context->content->thetaTXLength - thetaOffset) * 2; i++) {
c0d025ee:	5de9      	ldrb	r1, [r5, r7]
c0d025f0:	4628      	mov	r0, r5
c0d025f2:	30f9      	adds	r0, #249	; 0xf9
            rlpP = context->content->thetaTX + thetaOffset;
c0d025f4:	356f      	adds	r5, #111	; 0x6f
c0d025f6:	2200      	movs	r2, #0
            for (i = 0; i < (context->content->thetaTXLength - thetaOffset) * 2; i++) {
c0d025f8:	290d      	cmp	r1, #13
c0d025fa:	4613      	mov	r3, r2
c0d025fc:	d315      	bcc.n	c0d0262a <getThetaTxFromBinary+0x7a>
c0d025fe:	2300      	movs	r3, #0
c0d02600:	4619      	mov	r1, r3
                uint8_t digit = rlpP[i / 2];
c0d02602:	085c      	lsrs	r4, r3, #1
c0d02604:	5d2c      	ldrb	r4, [r5, r4]
                if ((i % 2) == 0) {
c0d02606:	07de      	lsls	r6, r3, #31
c0d02608:	d002      	beq.n	c0d02610 <getThetaTxFromBinary+0x60>
c0d0260a:	260f      	movs	r6, #15
c0d0260c:	4034      	ands	r4, r6
c0d0260e:	e000      	b.n	c0d02612 <getThetaTxFromBinary+0x62>
c0d02610:	0924      	lsrs	r4, r4, #4
                out[i] = HEXDIGITS[digit];
c0d02612:	4e5b      	ldr	r6, [pc, #364]	; (c0d02780 <getThetaTxFromBinary+0x1d0>)
c0d02614:	447e      	add	r6, pc
c0d02616:	5d34      	ldrb	r4, [r6, r4]
c0d02618:	ae12      	add	r6, sp, #72	; 0x48
c0d0261a:	54f4      	strb	r4, [r6, r3]
            for (i = 0; i < (context->content->thetaTXLength - thetaOffset) * 2; i++) {
c0d0261c:	1c49      	adds	r1, r1, #1
c0d0261e:	b2cb      	uxtb	r3, r1
c0d02620:	7804      	ldrb	r4, [r0, #0]
c0d02622:	0064      	lsls	r4, r4, #1
c0d02624:	3c18      	subs	r4, #24
c0d02626:	429c      	cmp	r4, r3
c0d02628:	dceb      	bgt.n	c0d02602 <getThetaTxFromBinary+0x52>
c0d0262a:	a912      	add	r1, sp, #72	; 0x48
            out[i] = '\0';
c0d0262c:	54ca      	strb	r2, [r1, r3]
            PRINTF("jxlog24: thetaTX %s , length %d \n", out, context->content->thetaTXLength - thetaOffset);
c0d0262e:	7802      	ldrb	r2, [r0, #0]
c0d02630:	3a0c      	subs	r2, #12
c0d02632:	4854      	ldr	r0, [pc, #336]	; (c0d02784 <getThetaTxFromBinary+0x1d4>)
c0d02634:	4478      	add	r0, pc
c0d02636:	f002 fd01 	bl	c0d0503c <mcu_usb_printf>
c0d0263a:	9c02      	ldr	r4, [sp, #8]
            if (context->content->thetaTXLength >= thetaOffset) {
c0d0263c:	6b62      	ldr	r2, [r4, #52]	; 0x34
c0d0263e:	5dd0      	ldrb	r0, [r2, r7]
c0d02640:	280c      	cmp	r0, #12
c0d02642:	d374      	bcc.n	c0d0272e <getThetaTxFromBinary+0x17e>
    if (*buffer <= 0x7f) {
c0d02644:	7828      	ldrb	r0, [r5, #0]
    } else if (*buffer <= 0xb7) {
c0d02646:	08c3      	lsrs	r3, r0, #3
    if (*buffer <= 0x7f) {
c0d02648:	2b17      	cmp	r3, #23
c0d0264a:	d25f      	bcs.n	c0d0270c <getThetaTxFromBinary+0x15c>
c0d0264c:	2601      	movs	r6, #1
c0d0264e:	0237      	lsls	r7, r6, #8
                    decoded = rlpDecodeLength(rlpP, pos, &context->content->thetaCurrentFieldLength, &offset, &context->content->thetaCurrentFieldIsList);
c0d02650:	19d0      	adds	r0, r2, r7
c0d02652:	4669      	mov	r1, sp
c0d02654:	6008      	str	r0, [r1, #0]
c0d02656:	32fc      	adds	r2, #252	; 0xfc
c0d02658:	ab11      	add	r3, sp, #68	; 0x44
c0d0265a:	4628      	mov	r0, r5
c0d0265c:	f7ff feab 	bl	c0d023b6 <rlpDecodeLength>
                    if (decoded && context->content->thetaCurrentFieldIsList) {
c0d02660:	2800      	cmp	r0, #0
c0d02662:	d064      	beq.n	c0d0272e <getThetaTxFromBinary+0x17e>
c0d02664:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d02666:	5dc0      	ldrb	r0, [r0, r7]
c0d02668:	2800      	cmp	r0, #0
c0d0266a:	d060      	beq.n	c0d0272e <getThetaTxFromBinary+0x17e>
                        rlpP += offset;
c0d0266c:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d0266e:	ac0f      	add	r4, sp, #60	; 0x3c
                        decoded = rlpDecodeLength(rlpP, pos, &tmpCurrentFieldLength, &offset, &tmpCurrentFieldIsList);
c0d02670:	4669      	mov	r1, sp
c0d02672:	600c      	str	r4, [r1, #0]
                        rlpP += offset;
c0d02674:	182d      	adds	r5, r5, r0
c0d02676:	aa10      	add	r2, sp, #64	; 0x40
c0d02678:	ab11      	add	r3, sp, #68	; 0x44
                        decoded = rlpDecodeLength(rlpP, pos, &tmpCurrentFieldLength, &offset, &tmpCurrentFieldIsList);
c0d0267a:	4628      	mov	r0, r5
c0d0267c:	f7ff fe9b 	bl	c0d023b6 <rlpDecodeLength>
                        if (decoded && tmpCurrentFieldIsList) {
c0d02680:	7821      	ldrb	r1, [r4, #0]
c0d02682:	2900      	cmp	r1, #0
c0d02684:	d05f      	beq.n	c0d02746 <getThetaTxFromBinary+0x196>
c0d02686:	2800      	cmp	r0, #0
c0d02688:	d05d      	beq.n	c0d02746 <getThetaTxFromBinary+0x196>
                            rlpP += offset + tmpCurrentFieldLength;
c0d0268a:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d0268c:	9911      	ldr	r1, [sp, #68]	; 0x44
c0d0268e:	ac0f      	add	r4, sp, #60	; 0x3c
                        decoded = rlpDecodeLength(rlpP, pos, &tmpCurrentFieldLength, &offset, &tmpCurrentFieldIsList);
c0d02690:	466a      	mov	r2, sp
c0d02692:	6014      	str	r4, [r2, #0]
                            rlpP += offset + tmpCurrentFieldLength;
c0d02694:	1840      	adds	r0, r0, r1
c0d02696:	182d      	adds	r5, r5, r0
c0d02698:	aa10      	add	r2, sp, #64	; 0x40
c0d0269a:	ab11      	add	r3, sp, #68	; 0x44
                        decoded = rlpDecodeLength(rlpP, pos, &tmpCurrentFieldLength, &offset, &tmpCurrentFieldIsList);
c0d0269c:	4628      	mov	r0, r5
c0d0269e:	f7ff fe8a 	bl	c0d023b6 <rlpDecodeLength>
                        if (decoded && tmpCurrentFieldIsList) {
c0d026a2:	7821      	ldrb	r1, [r4, #0]
c0d026a4:	2900      	cmp	r1, #0
c0d026a6:	d04e      	beq.n	c0d02746 <getThetaTxFromBinary+0x196>
c0d026a8:	2800      	cmp	r0, #0
c0d026aa:	d04c      	beq.n	c0d02746 <getThetaTxFromBinary+0x196>
                            rlpP += offset + tmpCurrentFieldLength;
c0d026ac:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d026ae:	9911      	ldr	r1, [sp, #68]	; 0x44
c0d026b0:	ac0f      	add	r4, sp, #60	; 0x3c
                        decoded = rlpDecodeLength(rlpP, pos, &tmpCurrentFieldLength, &offset, &tmpCurrentFieldIsList);
c0d026b2:	466a      	mov	r2, sp
c0d026b4:	6014      	str	r4, [r2, #0]
                            rlpP += offset + tmpCurrentFieldLength;
c0d026b6:	1840      	adds	r0, r0, r1
c0d026b8:	182d      	adds	r5, r5, r0
c0d026ba:	aa10      	add	r2, sp, #64	; 0x40
c0d026bc:	ab11      	add	r3, sp, #68	; 0x44
                        decoded = rlpDecodeLength(rlpP, pos, &tmpCurrentFieldLength, &offset, &tmpCurrentFieldIsList);
c0d026be:	4628      	mov	r0, r5
c0d026c0:	f7ff fe79 	bl	c0d023b6 <rlpDecodeLength>
                        if (decoded && tmpCurrentFieldIsList) {
c0d026c4:	7821      	ldrb	r1, [r4, #0]
c0d026c6:	2900      	cmp	r1, #0
c0d026c8:	9c02      	ldr	r4, [sp, #8]
c0d026ca:	d030      	beq.n	c0d0272e <getThetaTxFromBinary+0x17e>
c0d026cc:	2800      	cmp	r0, #0
c0d026ce:	d02e      	beq.n	c0d0272e <getThetaTxFromBinary+0x17e>
                            if (*(rlpP + 2) == 148) {
c0d026d0:	78a8      	ldrb	r0, [r5, #2]
c0d026d2:	2894      	cmp	r0, #148	; 0x94
c0d026d4:	d108      	bne.n	c0d026e8 <getThetaTxFromBinary+0x138>
c0d026d6:	2021      	movs	r0, #33	; 0x21
c0d026d8:	00c0      	lsls	r0, r0, #3
                                memmove(context->content->destination, rlpP, 20);
c0d026da:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d026dc:	1808      	adds	r0, r1, r0
                                rlpP += 3;
c0d026de:	1ced      	adds	r5, r5, #3
c0d026e0:	2214      	movs	r2, #20
                                memmove(context->content->destination, rlpP, 20);
c0d026e2:	4629      	mov	r1, r5
c0d026e4:	f007 ffcc 	bl	c0d0a680 <__aeabi_memmove>
                            if (*rlpP != 128 && rlpDecodeLength(rlpP, pos, &tmpCurrentFieldLength, &offset, &tmpCurrentFieldIsList)) {//Theta is not 0
c0d026e8:	7d68      	ldrb	r0, [r5, #21]
c0d026ea:	2880      	cmp	r0, #128	; 0x80
c0d026ec:	d02d      	beq.n	c0d0274a <getThetaTxFromBinary+0x19a>
c0d026ee:	4628      	mov	r0, r5
c0d026f0:	3015      	adds	r0, #21
c0d026f2:	a90f      	add	r1, sp, #60	; 0x3c
c0d026f4:	466a      	mov	r2, sp
c0d026f6:	6011      	str	r1, [r2, #0]
c0d026f8:	aa10      	add	r2, sp, #64	; 0x40
c0d026fa:	ab11      	add	r3, sp, #68	; 0x44
c0d026fc:	f7ff fe5b 	bl	c0d023b6 <rlpDecodeLength>
c0d02700:	2800      	cmp	r0, #0
c0d02702:	d022      	beq.n	c0d0274a <getThetaTxFromBinary+0x19a>
                                memmove(context->content->value.value, rlpP, tmpCurrentFieldLength);
c0d02704:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d02706:	9e10      	ldr	r6, [sp, #64]	; 0x40
                                rlpP++;                          
c0d02708:	3516      	adds	r5, #22
c0d0270a:	e02e      	b.n	c0d0276a <getThetaTxFromBinary+0x1ba>
c0d0270c:	9901      	ldr	r1, [sp, #4]
c0d0270e:	390c      	subs	r1, #12
c0d02710:	b2c9      	uxtb	r1, r1
    } else if (*buffer <= 0xbf) {
c0d02712:	0984      	lsrs	r4, r0, #6
c0d02714:	2c02      	cmp	r4, #2
c0d02716:	d804      	bhi.n	c0d02722 <getThetaTxFromBinary+0x172>
        if (bufferLength < (1 + (*buffer - 0xb7))) {
c0d02718:	38b6      	subs	r0, #182	; 0xb6
c0d0271a:	4288      	cmp	r0, r1
c0d0271c:	9c02      	ldr	r4, [sp, #8]
c0d0271e:	d995      	bls.n	c0d0264c <getThetaTxFromBinary+0x9c>
c0d02720:	e005      	b.n	c0d0272e <getThetaTxFromBinary+0x17e>
    } else if (*buffer <= 0xf7) {
c0d02722:	2b1f      	cmp	r3, #31
c0d02724:	9c02      	ldr	r4, [sp, #8]
c0d02726:	d391      	bcc.n	c0d0264c <getThetaTxFromBinary+0x9c>
c0d02728:	38f6      	subs	r0, #246	; 0xf6
c0d0272a:	4288      	cmp	r0, r1
c0d0272c:	d98e      	bls.n	c0d0264c <getThetaTxFromBinary+0x9c>
        FINALLY {
c0d0272e:	f004 fa23 	bl	c0d06b78 <try_context_get>
c0d02732:	a903      	add	r1, sp, #12
c0d02734:	4288      	cmp	r0, r1
c0d02736:	d102      	bne.n	c0d0273e <getThetaTxFromBinary+0x18e>
c0d02738:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d0273a:	f004 fa29 	bl	c0d06b90 <try_context_set>
c0d0273e:	a803      	add	r0, sp, #12
    END_TRY;
c0d02740:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d02742:	2800      	cmp	r0, #0
c0d02744:	d11a      	bne.n	c0d0277c <getThetaTxFromBinary+0x1cc>
};
c0d02746:	b05d      	add	sp, #372	; 0x174
c0d02748:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0274a:	a80f      	add	r0, sp, #60	; 0x3c
                            } else if (rlpDecodeLength(++rlpP, pos, &tmpCurrentFieldLength, &offset, &tmpCurrentFieldIsList)) { // send Tfuel
c0d0274c:	4669      	mov	r1, sp
c0d0274e:	6008      	str	r0, [r1, #0]
c0d02750:	4628      	mov	r0, r5
c0d02752:	3016      	adds	r0, #22
c0d02754:	aa10      	add	r2, sp, #64	; 0x40
c0d02756:	ab11      	add	r3, sp, #68	; 0x44
c0d02758:	f7ff fe2d 	bl	c0d023b6 <rlpDecodeLength>
c0d0275c:	2800      	cmp	r0, #0
c0d0275e:	d0e6      	beq.n	c0d0272e <getThetaTxFromBinary+0x17e>
                                context->content->thetaTXtoken = 1;
c0d02760:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d02762:	21fa      	movs	r1, #250	; 0xfa
c0d02764:	5446      	strb	r6, [r0, r1]
                                memmove(context->content->value.value, rlpP + 1, tmpCurrentFieldLength);
c0d02766:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0d02768:	3517      	adds	r5, #23
c0d0276a:	3042      	adds	r0, #66	; 0x42
c0d0276c:	4629      	mov	r1, r5
c0d0276e:	4632      	mov	r2, r6
c0d02770:	f007 ff86 	bl	c0d0a680 <__aeabi_memmove>
c0d02774:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d02776:	2162      	movs	r1, #98	; 0x62
c0d02778:	5446      	strb	r6, [r0, r1]
c0d0277a:	e7d8      	b.n	c0d0272e <getThetaTxFromBinary+0x17e>
    END_TRY;
c0d0277c:	f001 fe02 	bl	c0d04384 <os_longjmp>
c0d02780:	00008fd7 	.word	0x00008fd7
c0d02784:	00008fc8 	.word	0x00008fc8
c0d02788:	00009046 	.word	0x00009046

c0d0278c <adjustDecimals>:

bool adjustDecimals(char *src,
                    uint32_t srcLength,
                    char *target,
                    uint32_t targetLength,
                    uint8_t decimals) {
c0d0278c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0278e:	b081      	sub	sp, #4
c0d02790:	460e      	mov	r6, r1
c0d02792:	4605      	mov	r5, r0
    uint32_t startOffset;
    uint32_t lastZeroOffset = 0;
    uint32_t offset = 0;
    if ((srcLength == 1) && (*src == '0')) {
c0d02794:	2901      	cmp	r1, #1
c0d02796:	d10a      	bne.n	c0d027ae <adjustDecimals+0x22>
c0d02798:	7828      	ldrb	r0, [r5, #0]
c0d0279a:	2830      	cmp	r0, #48	; 0x30
c0d0279c:	d107      	bne.n	c0d027ae <adjustDecimals+0x22>
        if (targetLength < 2) {
c0d0279e:	2b02      	cmp	r3, #2
c0d027a0:	d32d      	bcc.n	c0d027fe <adjustDecimals+0x72>
c0d027a2:	2000      	movs	r0, #0
            return false;
        }
        target[0] = '0';
        target[1] = '\0';
c0d027a4:	7050      	strb	r0, [r2, #1]
c0d027a6:	2030      	movs	r0, #48	; 0x30
        target[0] = '0';
c0d027a8:	7010      	strb	r0, [r2, #0]
c0d027aa:	2001      	movs	r0, #1
c0d027ac:	e064      	b.n	c0d02878 <adjustDecimals+0xec>
c0d027ae:	9c06      	ldr	r4, [sp, #24]
        return true;
    }
    if (srcLength <= decimals) {
c0d027b0:	42b4      	cmp	r4, r6
c0d027b2:	d221      	bcs.n	c0d027f8 <adjustDecimals+0x6c>
        }
        target[offset] = '\0';
    } else {
        uint32_t sourceOffset = 0;
        uint32_t delta = srcLength - decimals;
        if (targetLength < srcLength + 1 + 1) {
c0d027b4:	1cb0      	adds	r0, r6, #2
c0d027b6:	4298      	cmp	r0, r3
c0d027b8:	d821      	bhi.n	c0d027fe <adjustDecimals+0x72>
c0d027ba:	9200      	str	r2, [sp, #0]
c0d027bc:	1b30      	subs	r0, r6, r4
            return false;
        }
        while (offset < delta) {
c0d027be:	d009      	beq.n	c0d027d4 <adjustDecimals+0x48>
c0d027c0:	4629      	mov	r1, r5
c0d027c2:	4602      	mov	r2, r0
c0d027c4:	9b00      	ldr	r3, [sp, #0]
            target[offset++] = src[sourceOffset++];
c0d027c6:	780f      	ldrb	r7, [r1, #0]
c0d027c8:	701f      	strb	r7, [r3, #0]
        while (offset < delta) {
c0d027ca:	1c49      	adds	r1, r1, #1
c0d027cc:	1e52      	subs	r2, r2, #1
c0d027ce:	1c5b      	adds	r3, r3, #1
c0d027d0:	2a00      	cmp	r2, #0
c0d027d2:	d1f8      	bne.n	c0d027c6 <adjustDecimals+0x3a>
        }
        if (decimals != 0) {
c0d027d4:	2c00      	cmp	r4, #0
c0d027d6:	4601      	mov	r1, r0
c0d027d8:	9f00      	ldr	r7, [sp, #0]
c0d027da:	d002      	beq.n	c0d027e2 <adjustDecimals+0x56>
c0d027dc:	212e      	movs	r1, #46	; 0x2e
            target[offset++] = '.';
c0d027de:	5439      	strb	r1, [r7, r0]
c0d027e0:	1c41      	adds	r1, r0, #1
        }
        startOffset = offset;
        while (sourceOffset < srcLength) {
c0d027e2:	42b0      	cmp	r0, r6
c0d027e4:	d22d      	bcs.n	c0d02842 <adjustDecimals+0xb6>
            target[offset++] = src[sourceOffset++];
c0d027e6:	187a      	adds	r2, r7, r1
c0d027e8:	182b      	adds	r3, r5, r0
c0d027ea:	2000      	movs	r0, #0
c0d027ec:	5c1d      	ldrb	r5, [r3, r0]
c0d027ee:	5415      	strb	r5, [r2, r0]
        while (sourceOffset < srcLength) {
c0d027f0:	1c40      	adds	r0, r0, #1
c0d027f2:	4284      	cmp	r4, r0
c0d027f4:	d1fa      	bne.n	c0d027ec <adjustDecimals+0x60>
c0d027f6:	e022      	b.n	c0d0283e <adjustDecimals+0xb2>
        if (targetLength < srcLength + 1 + 2 + delta) {
c0d027f8:	1ce0      	adds	r0, r4, #3
c0d027fa:	4298      	cmp	r0, r3
c0d027fc:	d901      	bls.n	c0d02802 <adjustDecimals+0x76>
c0d027fe:	2000      	movs	r0, #0
c0d02800:	e03a      	b.n	c0d02878 <adjustDecimals+0xec>
c0d02802:	1ba7      	subs	r7, r4, r6
c0d02804:	202e      	movs	r0, #46	; 0x2e
        target[offset++] = '.';
c0d02806:	7050      	strb	r0, [r2, #1]
c0d02808:	2030      	movs	r0, #48	; 0x30
        target[offset++] = '0';
c0d0280a:	7010      	strb	r0, [r2, #0]
        for (uint32_t i = 0; i < delta; i++) {
c0d0280c:	2f00      	cmp	r7, #0
c0d0280e:	d00b      	beq.n	c0d02828 <adjustDecimals+0x9c>
c0d02810:	9200      	str	r2, [sp, #0]
            target[offset++] = '0';
c0d02812:	1c90      	adds	r0, r2, #2
c0d02814:	2230      	movs	r2, #48	; 0x30
c0d02816:	4639      	mov	r1, r7
c0d02818:	f007 ff36 	bl	c0d0a688 <__aeabi_memset>
c0d0281c:	1ca0      	adds	r0, r4, #2
c0d0281e:	1b81      	subs	r1, r0, r6
        for (uint32_t i = 0; i < delta; i++) {
c0d02820:	1e7f      	subs	r7, r7, #1
c0d02822:	d1fd      	bne.n	c0d02820 <adjustDecimals+0x94>
c0d02824:	9f00      	ldr	r7, [sp, #0]
c0d02826:	e001      	b.n	c0d0282c <adjustDecimals+0xa0>
c0d02828:	2102      	movs	r1, #2
c0d0282a:	4617      	mov	r7, r2
        for (uint32_t i = 0; i < srcLength; i++) {
c0d0282c:	2e00      	cmp	r6, #0
c0d0282e:	d008      	beq.n	c0d02842 <adjustDecimals+0xb6>
            target[offset++] = src[i];
c0d02830:	187a      	adds	r2, r7, r1
c0d02832:	2000      	movs	r0, #0
c0d02834:	5c2b      	ldrb	r3, [r5, r0]
c0d02836:	5413      	strb	r3, [r2, r0]
        for (uint32_t i = 0; i < srcLength; i++) {
c0d02838:	1c40      	adds	r0, r0, #1
c0d0283a:	4286      	cmp	r6, r0
c0d0283c:	d1fa      	bne.n	c0d02834 <adjustDecimals+0xa8>
c0d0283e:	180a      	adds	r2, r1, r0
c0d02840:	e000      	b.n	c0d02844 <adjustDecimals+0xb8>
c0d02842:	460a      	mov	r2, r1
c0d02844:	2400      	movs	r4, #0
c0d02846:	54bc      	strb	r4, [r7, r2]
c0d02848:	2001      	movs	r0, #1
        }
        target[offset] = '\0';
    }
    for (uint32_t i = startOffset; i < offset; i++) {
c0d0284a:	4291      	cmp	r1, r2
c0d0284c:	d214      	bcs.n	c0d02878 <adjustDecimals+0xec>
        if (target[i] == '0') {
c0d0284e:	5c7d      	ldrb	r5, [r7, r1]
c0d02850:	2c00      	cmp	r4, #0
c0d02852:	460b      	mov	r3, r1
c0d02854:	d000      	beq.n	c0d02858 <adjustDecimals+0xcc>
c0d02856:	4623      	mov	r3, r4
c0d02858:	2d30      	cmp	r5, #48	; 0x30
c0d0285a:	d000      	beq.n	c0d0285e <adjustDecimals+0xd2>
c0d0285c:	2300      	movs	r3, #0
    for (uint32_t i = startOffset; i < offset; i++) {
c0d0285e:	1c49      	adds	r1, r1, #1
c0d02860:	428a      	cmp	r2, r1
c0d02862:	461c      	mov	r4, r3
c0d02864:	d1f3      	bne.n	c0d0284e <adjustDecimals+0xc2>
            }
        } else {
            lastZeroOffset = 0;
        }
    }
    if (lastZeroOffset != 0) {
c0d02866:	2b00      	cmp	r3, #0
c0d02868:	d006      	beq.n	c0d02878 <adjustDecimals+0xec>
c0d0286a:	2100      	movs	r1, #0
        target[lastZeroOffset] = '\0';
c0d0286c:	54f9      	strb	r1, [r7, r3]
        if (target[lastZeroOffset - 1] == '.') {
c0d0286e:	1e5a      	subs	r2, r3, #1
c0d02870:	5cbb      	ldrb	r3, [r7, r2]
c0d02872:	2b2e      	cmp	r3, #46	; 0x2e
c0d02874:	d100      	bne.n	c0d02878 <adjustDecimals+0xec>
            target[lastZeroOffset - 1] = '\0';
c0d02876:	54b9      	strb	r1, [r7, r2]
        }
    }
    return true;
}
c0d02878:	b001      	add	sp, #4
c0d0287a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d0287c <eth_plugin_prepare_init>:
#include "eth_plugin_handler.h"
#include "eth_plugin_internal.h"
#include "shared_context.h"
#include "base64.h"

void eth_plugin_prepare_init(ethPluginInitContract_t *init, uint8_t *selector, uint32_t dataSize) {
c0d0287c:	b570      	push	{r4, r5, r6, lr}
c0d0287e:	4614      	mov	r4, r2
c0d02880:	460d      	mov	r5, r1
c0d02882:	4606      	mov	r6, r0
c0d02884:	2120      	movs	r1, #32
    memset((uint8_t *) init, 0, sizeof(ethPluginInitContract_t));
c0d02886:	f007 fef1 	bl	c0d0a66c <__aeabi_memclr>
    init->selector = selector;
c0d0288a:	6135      	str	r5, [r6, #16]
    init->dataSize = dataSize;
c0d0288c:	6174      	str	r4, [r6, #20]
}
c0d0288e:	bd70      	pop	{r4, r5, r6, pc}

c0d02890 <eth_plugin_prepare_provide_parameter>:

void eth_plugin_prepare_provide_parameter(ethPluginProvideParameter_t *provideParameter,
                                          uint8_t *parameter,
                                          uint32_t parameterOffset) {
c0d02890:	b570      	push	{r4, r5, r6, lr}
c0d02892:	4614      	mov	r4, r2
c0d02894:	460d      	mov	r5, r1
c0d02896:	4606      	mov	r6, r0
c0d02898:	2118      	movs	r1, #24
    memset((uint8_t *) provideParameter, 0, sizeof(ethPluginProvideParameter_t));
c0d0289a:	f007 fee7 	bl	c0d0a66c <__aeabi_memclr>
    provideParameter->parameter = parameter;
c0d0289e:	60f5      	str	r5, [r6, #12]
    provideParameter->parameterOffset = parameterOffset;
c0d028a0:	6134      	str	r4, [r6, #16]
}
c0d028a2:	bd70      	pop	{r4, r5, r6, pc}

c0d028a4 <eth_plugin_prepare_finalize>:

void eth_plugin_prepare_finalize(ethPluginFinalize_t *finalize) {
c0d028a4:	b580      	push	{r7, lr}
c0d028a6:	2120      	movs	r1, #32
    memset((uint8_t *) finalize, 0, sizeof(ethPluginFinalize_t));
c0d028a8:	f007 fee0 	bl	c0d0a66c <__aeabi_memclr>
}
c0d028ac:	bd80      	pop	{r7, pc}

c0d028ae <eth_plugin_prepare_provide_token>:

void eth_plugin_prepare_provide_token(ethPluginProvideToken_t *provideToken,
                                      tokenDefinition_t *token1,
                                      tokenDefinition_t *token2) {
c0d028ae:	b570      	push	{r4, r5, r6, lr}
c0d028b0:	4614      	mov	r4, r2
c0d028b2:	460d      	mov	r5, r1
c0d028b4:	4606      	mov	r6, r0
c0d028b6:	2118      	movs	r1, #24
    memset((uint8_t *) provideToken, 0, sizeof(ethPluginProvideToken_t));
c0d028b8:	f007 fed8 	bl	c0d0a66c <__aeabi_memclr>
    provideToken->token1 = token1;
c0d028bc:	60f5      	str	r5, [r6, #12]
    provideToken->token2 = token2;
c0d028be:	6134      	str	r4, [r6, #16]
}
c0d028c0:	bd70      	pop	{r4, r5, r6, pc}

c0d028c2 <eth_plugin_prepare_query_contract_ID>:

void eth_plugin_prepare_query_contract_ID(ethQueryContractID_t *queryContractID,
                                          char *name,
                                          uint32_t nameLength,
                                          char *version,
                                          uint32_t versionLength) {
c0d028c2:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d028c4:	b081      	sub	sp, #4
c0d028c6:	461c      	mov	r4, r3
c0d028c8:	4615      	mov	r5, r2
c0d028ca:	460e      	mov	r6, r1
c0d028cc:	4607      	mov	r7, r0
c0d028ce:	2120      	movs	r1, #32
    memset((uint8_t *) queryContractID, 0, sizeof(ethQueryContractID_t));
c0d028d0:	f007 fecc 	bl	c0d0a66c <__aeabi_memclr>
c0d028d4:	9806      	ldr	r0, [sp, #24]
    queryContractID->name = name;
c0d028d6:	60fe      	str	r6, [r7, #12]
    queryContractID->nameLength = nameLength;
c0d028d8:	613d      	str	r5, [r7, #16]
    queryContractID->version = version;
c0d028da:	617c      	str	r4, [r7, #20]
    queryContractID->versionLength = versionLength;
c0d028dc:	61b8      	str	r0, [r7, #24]
}
c0d028de:	b001      	add	sp, #4
c0d028e0:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d028e2 <eth_plugin_prepare_query_contract_UI>:
void eth_plugin_prepare_query_contract_UI(ethQueryContractUI_t *queryContractUI,
                                          uint8_t screenIndex,
                                          char *title,
                                          uint32_t titleLength,
                                          char *msg,
                                          uint32_t msgLength) {
c0d028e2:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d028e4:	b081      	sub	sp, #4
c0d028e6:	461c      	mov	r4, r3
c0d028e8:	4615      	mov	r5, r2
c0d028ea:	460e      	mov	r6, r1
c0d028ec:	4607      	mov	r7, r0
c0d028ee:	2124      	movs	r1, #36	; 0x24
    memset((uint8_t *) queryContractUI, 0, sizeof(ethQueryContractUI_t));
c0d028f0:	f007 febc 	bl	c0d0a66c <__aeabi_memclr>
c0d028f4:	9807      	ldr	r0, [sp, #28]
    queryContractUI->screenIndex = screenIndex;
    queryContractUI->title = title;
    queryContractUI->titleLength = titleLength;
    queryContractUI->msg = msg;
    queryContractUI->msgLength = msgLength;
c0d028f6:	61f8      	str	r0, [r7, #28]
c0d028f8:	9806      	ldr	r0, [sp, #24]
    queryContractUI->msg = msg;
c0d028fa:	61b8      	str	r0, [r7, #24]
    queryContractUI->titleLength = titleLength;
c0d028fc:	617c      	str	r4, [r7, #20]
    queryContractUI->title = title;
c0d028fe:	613d      	str	r5, [r7, #16]
    queryContractUI->screenIndex = screenIndex;
c0d02900:	733e      	strb	r6, [r7, #12]
}
c0d02902:	b001      	add	sp, #4
c0d02904:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d02908 <eth_plugin_perform_init>:

int eth_plugin_perform_init(uint8_t *contractAddress, ethPluginInitContract_t *init) {
c0d02908:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0290a:	b087      	sub	sp, #28
c0d0290c:	4605      	mov	r5, r0
    uint8_t i;
    const uint8_t **selectors;
    dataContext.tokenContext.pluginAvailable = 0;
c0d0290e:	4853      	ldr	r0, [pc, #332]	; (c0d02a5c <eth_plugin_perform_init+0x154>)
c0d02910:	2400      	movs	r4, #0
c0d02912:	7784      	strb	r4, [r0, #30]
c0d02914:	9106      	str	r1, [sp, #24]
    // Handle hardcoded plugin list
    PRINTF("Selector %.*H\n", 4, init->selector);
c0d02916:	690a      	ldr	r2, [r1, #16]
c0d02918:	4852      	ldr	r0, [pc, #328]	; (c0d02a64 <eth_plugin_perform_init+0x15c>)
c0d0291a:	4478      	add	r0, pc
c0d0291c:	2104      	movs	r1, #4
c0d0291e:	f002 fb8d 	bl	c0d0503c <mcu_usb_printf>
    for (i = 0;; i++) {
        uint8_t j;
        selectors = PIC(INTERNAL_ETH_PLUGINS[i].selectors);
c0d02922:	4e51      	ldr	r6, [pc, #324]	; (c0d02a68 <eth_plugin_perform_init+0x160>)
c0d02924:	447e      	add	r6, pc
c0d02926:	6870      	ldr	r0, [r6, #4]
c0d02928:	f002 ff06 	bl	c0d05738 <pic>
        if (selectors == NULL) {
c0d0292c:	2800      	cmp	r0, #0
c0d0292e:	d050      	beq.n	c0d029d2 <eth_plugin_perform_init+0xca>
c0d02930:	4607      	mov	r7, r0
c0d02932:	9404      	str	r4, [sp, #16]
c0d02934:	9601      	str	r6, [sp, #4]
c0d02936:	2114      	movs	r1, #20
            break;
        }
        for (j = 0; ((j < INTERNAL_ETH_PLUGINS[i].num_selectors) && (contractAddress != NULL));
c0d02938:	2d00      	cmp	r5, #0
c0d0293a:	d032      	beq.n	c0d029a2 <eth_plugin_perform_init+0x9a>
c0d0293c:	434c      	muls	r4, r1
c0d0293e:	1930      	adds	r0, r6, r4
c0d02940:	9005      	str	r0, [sp, #20]
c0d02942:	7a04      	ldrb	r4, [r0, #8]
c0d02944:	2c00      	cmp	r4, #0
c0d02946:	d02c      	beq.n	c0d029a2 <eth_plugin_perform_init+0x9a>
c0d02948:	9103      	str	r1, [sp, #12]
c0d0294a:	9502      	str	r5, [sp, #8]
c0d0294c:	2500      	movs	r5, #0
             j++) {
            if (memcmp(init->selector, PIC(selectors[j]), SELECTOR_SIZE) == 0) {
c0d0294e:	9806      	ldr	r0, [sp, #24]
c0d02950:	6906      	ldr	r6, [r0, #16]
c0d02952:	6838      	ldr	r0, [r7, #0]
c0d02954:	f002 fef0 	bl	c0d05738 <pic>
c0d02958:	7801      	ldrb	r1, [r0, #0]
c0d0295a:	7842      	ldrb	r2, [r0, #1]
c0d0295c:	0212      	lsls	r2, r2, #8
c0d0295e:	1851      	adds	r1, r2, r1
c0d02960:	7882      	ldrb	r2, [r0, #2]
c0d02962:	78c0      	ldrb	r0, [r0, #3]
c0d02964:	0200      	lsls	r0, r0, #8
c0d02966:	1880      	adds	r0, r0, r2
c0d02968:	0400      	lsls	r0, r0, #16
c0d0296a:	1840      	adds	r0, r0, r1
c0d0296c:	7831      	ldrb	r1, [r6, #0]
c0d0296e:	7872      	ldrb	r2, [r6, #1]
c0d02970:	0212      	lsls	r2, r2, #8
c0d02972:	1851      	adds	r1, r2, r1
c0d02974:	78b2      	ldrb	r2, [r6, #2]
c0d02976:	78f3      	ldrb	r3, [r6, #3]
c0d02978:	021b      	lsls	r3, r3, #8
c0d0297a:	189a      	adds	r2, r3, r2
c0d0297c:	0412      	lsls	r2, r2, #16
c0d0297e:	1851      	adds	r1, r2, r1
c0d02980:	4281      	cmp	r1, r0
c0d02982:	d108      	bne.n	c0d02996 <eth_plugin_perform_init+0x8e>
                if ((INTERNAL_ETH_PLUGINS[i].availableCheck == NULL) ||
c0d02984:	9805      	ldr	r0, [sp, #20]
c0d02986:	6800      	ldr	r0, [r0, #0]
c0d02988:	2800      	cmp	r0, #0
c0d0298a:	d00c      	beq.n	c0d029a6 <eth_plugin_perform_init+0x9e>
                    ((PluginAvailableCheck) PIC(INTERNAL_ETH_PLUGINS[i].availableCheck))()) {
c0d0298c:	f002 fed4 	bl	c0d05738 <pic>
c0d02990:	4780      	blx	r0
                if ((INTERNAL_ETH_PLUGINS[i].availableCheck == NULL) ||
c0d02992:	2800      	cmp	r0, #0
c0d02994:	d107      	bne.n	c0d029a6 <eth_plugin_perform_init+0x9e>
        for (j = 0; ((j < INTERNAL_ETH_PLUGINS[i].num_selectors) && (contractAddress != NULL));
c0d02996:	1d3f      	adds	r7, r7, #4
             j++) {
c0d02998:	1c6d      	adds	r5, r5, #1
        for (j = 0; ((j < INTERNAL_ETH_PLUGINS[i].num_selectors) && (contractAddress != NULL));
c0d0299a:	42a5      	cmp	r5, r4
c0d0299c:	d3d7      	bcc.n	c0d0294e <eth_plugin_perform_init+0x46>
c0d0299e:	9d02      	ldr	r5, [sp, #8]
c0d029a0:	e009      	b.n	c0d029b6 <eth_plugin_perform_init+0xae>
c0d029a2:	9804      	ldr	r0, [sp, #16]
c0d029a4:	e00a      	b.n	c0d029bc <eth_plugin_perform_init+0xb4>
c0d029a6:	9905      	ldr	r1, [sp, #20]
                    strcpy(dataContext.tokenContext.pluginName, INTERNAL_ETH_PLUGINS[i].alias);
c0d029a8:	3109      	adds	r1, #9
c0d029aa:	482c      	ldr	r0, [pc, #176]	; (c0d02a5c <eth_plugin_perform_init+0x154>)
c0d029ac:	f008 f81c 	bl	c0d0a9e8 <strcpy>
c0d029b0:	2101      	movs	r1, #1
                    dataContext.tokenContext.pluginAvailable = 1;
c0d029b2:	7781      	strb	r1, [r0, #30]
c0d029b4:	2500      	movs	r5, #0
c0d029b6:	9e01      	ldr	r6, [sp, #4]
c0d029b8:	9804      	ldr	r0, [sp, #16]
c0d029ba:	9903      	ldr	r1, [sp, #12]
    for (i = 0;; i++) {
c0d029bc:	1c40      	adds	r0, r0, #1
c0d029be:	9004      	str	r0, [sp, #16]
        selectors = PIC(INTERNAL_ETH_PLUGINS[i].selectors);
c0d029c0:	b2c4      	uxtb	r4, r0
c0d029c2:	4361      	muls	r1, r4
c0d029c4:	1870      	adds	r0, r6, r1
c0d029c6:	6840      	ldr	r0, [r0, #4]
c0d029c8:	f002 feb6 	bl	c0d05738 <pic>
c0d029cc:	4607      	mov	r7, r0
        if (selectors == NULL) {
c0d029ce:	2800      	cmp	r0, #0
c0d029d0:	d1b1      	bne.n	c0d02936 <eth_plugin_perform_init+0x2e>
            }
        }
    }

    // Do not handle a plugin if running in swap mode
    if (called_from_swap && (contractAddress != NULL)) {
c0d029d2:	2d00      	cmp	r5, #0
c0d029d4:	d009      	beq.n	c0d029ea <eth_plugin_perform_init+0xe2>
c0d029d6:	4822      	ldr	r0, [pc, #136]	; (c0d02a60 <eth_plugin_perform_init+0x158>)
c0d029d8:	7800      	ldrb	r0, [r0, #0]
c0d029da:	2800      	cmp	r0, #0
c0d029dc:	d005      	beq.n	c0d029ea <eth_plugin_perform_init+0xe2>
        PRINTF("eth_plug_init aborted in swap mode\n");
c0d029de:	4823      	ldr	r0, [pc, #140]	; (c0d02a6c <eth_plugin_perform_init+0x164>)
c0d029e0:	4478      	add	r0, pc
c0d029e2:	f002 fb2b 	bl	c0d0503c <mcu_usb_printf>
c0d029e6:	2700      	movs	r7, #0
c0d029e8:	e035      	b.n	c0d02a56 <eth_plugin_perform_init+0x14e>
c0d029ea:	4821      	ldr	r0, [pc, #132]	; (c0d02a70 <eth_plugin_perform_init+0x168>)
c0d029ec:	4478      	add	r0, pc
c0d029ee:	9005      	str	r0, [sp, #20]
c0d029f0:	4820      	ldr	r0, [pc, #128]	; (c0d02a74 <eth_plugin_perform_init+0x16c>)
c0d029f2:	4478      	add	r0, pc
c0d029f4:	9003      	str	r0, [sp, #12]
c0d029f6:	4c19      	ldr	r4, [pc, #100]	; (c0d02a5c <eth_plugin_perform_init+0x154>)
c0d029f8:	4e1f      	ldr	r6, [pc, #124]	; (c0d02a78 <eth_plugin_perform_init+0x170>)
c0d029fa:	447e      	add	r6, pc
c0d029fc:	481f      	ldr	r0, [pc, #124]	; (c0d02a7c <eth_plugin_perform_init+0x174>)
c0d029fe:	4478      	add	r0, pc
        return 0;
    }
    for (;;) {
        PRINTF("eth_plugin_init\n");
c0d02a00:	9004      	str	r0, [sp, #16]
c0d02a02:	9805      	ldr	r0, [sp, #20]
c0d02a04:	f002 fb1a 	bl	c0d0503c <mcu_usb_printf>
        if (contractAddress != NULL) {
c0d02a08:	2d00      	cmp	r5, #0
c0d02a0a:	d005      	beq.n	c0d02a18 <eth_plugin_perform_init+0x110>
c0d02a0c:	2114      	movs	r1, #20
            PRINTF("Trying address %.*H\n", 20, contractAddress);
c0d02a0e:	9804      	ldr	r0, [sp, #16]
c0d02a10:	462a      	mov	r2, r5
c0d02a12:	f002 fb13 	bl	c0d0503c <mcu_usb_printf>
c0d02a16:	e003      	b.n	c0d02a20 <eth_plugin_perform_init+0x118>
        } else {
            PRINTF("Trying alias %s\n", dataContext.tokenContext.pluginName);
c0d02a18:	9803      	ldr	r0, [sp, #12]
c0d02a1a:	4621      	mov	r1, r4
c0d02a1c:	f002 fb0e 	bl	c0d0503c <mcu_usb_printf>
c0d02a20:	21ff      	movs	r1, #255	; 0xff
c0d02a22:	3102      	adds	r1, #2
        }
        int status = eth_plugin_call(contractAddress, ETH_PLUGIN_INIT_CONTRACT, (void *) init);
c0d02a24:	4628      	mov	r0, r5
c0d02a26:	9a06      	ldr	r2, [sp, #24]
c0d02a28:	f000 f82c 	bl	c0d02a84 <eth_plugin_call>
c0d02a2c:	4607      	mov	r7, r0
        PRINTF("jxlog91: status = %d \n", status);
c0d02a2e:	4630      	mov	r0, r6
c0d02a30:	4639      	mov	r1, r7
c0d02a32:	f002 fb03 	bl	c0d0503c <mcu_usb_printf>

        if (!status) {
c0d02a36:	2f00      	cmp	r7, #0
c0d02a38:	d00d      	beq.n	c0d02a56 <eth_plugin_perform_init+0x14e>
c0d02a3a:	2f02      	cmp	r7, #2
c0d02a3c:	d002      	beq.n	c0d02a44 <eth_plugin_perform_init+0x13c>
c0d02a3e:	2f01      	cmp	r7, #1
c0d02a40:	d1df      	bne.n	c0d02a02 <eth_plugin_perform_init+0xfa>
c0d02a42:	e001      	b.n	c0d02a48 <eth_plugin_perform_init+0x140>
c0d02a44:	2500      	movs	r5, #0
c0d02a46:	e7d0      	b.n	c0d029ea <eth_plugin_perform_init+0xe2>
        }
        if (status == ETH_PLUGIN_RESULT_OK_ALIAS) {
            contractAddress = NULL;
        }
    }
    PRINTF("eth_plugin_init ok %s\n", dataContext.tokenContext.pluginName);
c0d02a48:	480d      	ldr	r0, [pc, #52]	; (c0d02a80 <eth_plugin_perform_init+0x178>)
c0d02a4a:	4478      	add	r0, pc
c0d02a4c:	4621      	mov	r1, r4
c0d02a4e:	f002 faf5 	bl	c0d0503c <mcu_usb_printf>
c0d02a52:	2701      	movs	r7, #1
    dataContext.tokenContext.pluginAvailable = 1;
c0d02a54:	77a7      	strb	r7, [r4, #30]
    return 1;
}
c0d02a56:	4638      	mov	r0, r7
c0d02a58:	b007      	add	sp, #28
c0d02a5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02a5c:	20001be4 	.word	0x20001be4
c0d02a60:	2000189c 	.word	0x2000189c
c0d02a64:	00008d21 	.word	0x00008d21
c0d02a68:	00008ecc 	.word	0x00008ecc
c0d02a6c:	00008c6a 	.word	0x00008c6a
c0d02a70:	00008c82 	.word	0x00008c82
c0d02a74:	00008ca2 	.word	0x00008ca2
c0d02a78:	00008cab 	.word	0x00008cab
c0d02a7c:	00008c81 	.word	0x00008c81
c0d02a80:	00008c72 	.word	0x00008c72

c0d02a84 <eth_plugin_call>:

int eth_plugin_call(uint8_t *contractAddress, int method, void *parameter) {
c0d02a84:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02a86:	b09f      	sub	sp, #124	; 0x7c
c0d02a88:	4614      	mov	r4, r2
c0d02a8a:	460d      	mov	r5, r1
c0d02a8c:	4601      	mov	r1, r0
    char *alias;
    uint8_t i;
    uint8_t internalPlugin = 0;

    pluginRW.sha3 = &global_sha3;
    pluginRO.txContent = &tmpContent.txContent;
c0d02a8e:	4872      	ldr	r0, [pc, #456]	; (c0d02c58 <eth_plugin_call+0x1d4>)
c0d02a90:	901d      	str	r0, [sp, #116]	; 0x74
    pluginRW.sha3 = &global_sha3;
c0d02a92:	4872      	ldr	r0, [pc, #456]	; (c0d02c5c <eth_plugin_call+0x1d8>)
c0d02a94:	901e      	str	r0, [sp, #120]	; 0x78

    if (contractAddress == NULL) {
c0d02a96:	2900      	cmp	r1, #0
c0d02a98:	9103      	str	r1, [sp, #12]
c0d02a9a:	d005      	beq.n	c0d02aa8 <eth_plugin_call+0x24>
c0d02a9c:	af15      	add	r7, sp, #84	; 0x54
c0d02a9e:	2214      	movs	r2, #20
            PRINTF("Cached plugin call but no plugin available\n");
            return 0;
        }
        alias = dataContext.tokenContext.pluginName;
    } else {
        Base64encode(tmp, (char *) contractAddress, 20);
c0d02aa0:	4638      	mov	r0, r7
c0d02aa2:	f7fd facb 	bl	c0d0003c <Base64encode>
c0d02aa6:	e004      	b.n	c0d02ab2 <eth_plugin_call+0x2e>
        if (!dataContext.tokenContext.pluginAvailable) {
c0d02aa8:	4f6d      	ldr	r7, [pc, #436]	; (c0d02c60 <eth_plugin_call+0x1dc>)
c0d02aaa:	7fb8      	ldrb	r0, [r7, #30]
c0d02aac:	2800      	cmp	r0, #0
c0d02aae:	d100      	bne.n	c0d02ab2 <eth_plugin_call+0x2e>
c0d02ab0:	e0a2      	b.n	c0d02bf8 <eth_plugin_call+0x174>
c0d02ab2:	21ff      	movs	r1, #255	; 0xff
c0d02ab4:	460a      	mov	r2, r1
c0d02ab6:	3204      	adds	r2, #4
        alias = tmp;
    }

    // Prepare the call

    switch (method) {
c0d02ab8:	4295      	cmp	r5, r2
c0d02aba:	dc0b      	bgt.n	c0d02ad4 <eth_plugin_call+0x50>
c0d02abc:	4608      	mov	r0, r1
c0d02abe:	3002      	adds	r0, #2
c0d02ac0:	4285      	cmp	r5, r0
c0d02ac2:	d100      	bne.n	c0d02ac6 <eth_plugin_call+0x42>
c0d02ac4:	e09d      	b.n	c0d02c02 <eth_plugin_call+0x17e>
c0d02ac6:	2081      	movs	r0, #129	; 0x81
c0d02ac8:	0040      	lsls	r0, r0, #1
c0d02aca:	4285      	cmp	r5, r0
c0d02acc:	d00f      	beq.n	c0d02aee <eth_plugin_call+0x6a>
c0d02ace:	4295      	cmp	r5, r2
c0d02ad0:	d00d      	beq.n	c0d02aee <eth_plugin_call+0x6a>
c0d02ad2:	e0a5      	b.n	c0d02c20 <eth_plugin_call+0x19c>
c0d02ad4:	2041      	movs	r0, #65	; 0x41
c0d02ad6:	0080      	lsls	r0, r0, #2
c0d02ad8:	4285      	cmp	r5, r0
c0d02ada:	d008      	beq.n	c0d02aee <eth_plugin_call+0x6a>
c0d02adc:	4608      	mov	r0, r1
c0d02ade:	3006      	adds	r0, #6
c0d02ae0:	4285      	cmp	r5, r0
c0d02ae2:	d004      	beq.n	c0d02aee <eth_plugin_call+0x6a>
c0d02ae4:	2083      	movs	r0, #131	; 0x83
c0d02ae6:	0040      	lsls	r0, r0, #1
c0d02ae8:	4285      	cmp	r5, r0
c0d02aea:	d000      	beq.n	c0d02aee <eth_plugin_call+0x6a>
c0d02aec:	e098      	b.n	c0d02c20 <eth_plugin_call+0x19c>
c0d02aee:	9201      	str	r2, [sp, #4]
c0d02af0:	9102      	str	r1, [sp, #8]
c0d02af2:	9504      	str	r5, [sp, #16]
c0d02af4:	a81d      	add	r0, sp, #116	; 0x74
c0d02af6:	6060      	str	r0, [r4, #4]
c0d02af8:	a81e      	add	r0, sp, #120	; 0x78
c0d02afa:	6020      	str	r0, [r4, #0]
c0d02afc:	4858      	ldr	r0, [pc, #352]	; (c0d02c60 <eth_plugin_call+0x1dc>)
c0d02afe:	3044      	adds	r0, #68	; 0x44
c0d02b00:	2108      	movs	r1, #8
c0d02b02:	9405      	str	r4, [sp, #20]
c0d02b04:	5060      	str	r0, [r4, r1]
    }

    // Perform the call

    for (i = 0;; i++) {
        if (INTERNAL_ETH_PLUGINS[i].alias[0] == 0) {
c0d02b06:	4e59      	ldr	r6, [pc, #356]	; (c0d02c6c <eth_plugin_call+0x1e8>)
c0d02b08:	447e      	add	r6, pc
c0d02b0a:	7a70      	ldrb	r0, [r6, #9]
c0d02b0c:	2800      	cmp	r0, #0
c0d02b0e:	d016      	beq.n	c0d02b3e <eth_plugin_call+0xba>
            break;
        }
        if (strcmp(alias, INTERNAL_ETH_PLUGINS[i].alias) == 0) {
c0d02b10:	4631      	mov	r1, r6
c0d02b12:	3109      	adds	r1, #9
c0d02b14:	4638      	mov	r0, r7
c0d02b16:	f007 ff23 	bl	c0d0a960 <strcmp>
c0d02b1a:	2800      	cmp	r0, #0
c0d02b1c:	d027      	beq.n	c0d02b6e <eth_plugin_call+0xea>
c0d02b1e:	2501      	movs	r5, #1
        if (INTERNAL_ETH_PLUGINS[i].alias[0] == 0) {
c0d02b20:	b2ec      	uxtb	r4, r5
c0d02b22:	2014      	movs	r0, #20
c0d02b24:	4360      	muls	r0, r4
c0d02b26:	1831      	adds	r1, r6, r0
c0d02b28:	7a48      	ldrb	r0, [r1, #9]
c0d02b2a:	2800      	cmp	r0, #0
c0d02b2c:	d007      	beq.n	c0d02b3e <eth_plugin_call+0xba>
c0d02b2e:	3109      	adds	r1, #9
        if (strcmp(alias, INTERNAL_ETH_PLUGINS[i].alias) == 0) {
c0d02b30:	4638      	mov	r0, r7
c0d02b32:	f007 ff15 	bl	c0d0a960 <strcmp>
    for (i = 0;; i++) {
c0d02b36:	1c6d      	adds	r5, r5, #1
        if (strcmp(alias, INTERNAL_ETH_PLUGINS[i].alias) == 0) {
c0d02b38:	2800      	cmp	r0, #0
c0d02b3a:	d1f1      	bne.n	c0d02b20 <eth_plugin_call+0x9c>
c0d02b3c:	e018      	b.n	c0d02b70 <eth_plugin_call+0xec>
c0d02b3e:	9c05      	ldr	r4, [sp, #20]

    if (!internalPlugin) {
        uint32_t params[3];
        params[0] = (uint32_t) alias;
        params[1] = method;
        params[2] = (uint32_t) parameter;
c0d02b40:	9414      	str	r4, [sp, #80]	; 0x50
c0d02b42:	9d04      	ldr	r5, [sp, #16]
        params[1] = method;
c0d02b44:	9513      	str	r5, [sp, #76]	; 0x4c
        params[0] = (uint32_t) alias;
c0d02b46:	9712      	str	r7, [sp, #72]	; 0x48
c0d02b48:	ae06      	add	r6, sp, #24
        BEGIN_TRY {
            TRY {
c0d02b4a:	4630      	mov	r0, r6
c0d02b4c:	f007 fec8 	bl	c0d0a8e0 <setjmp>
c0d02b50:	85b0      	strh	r0, [r6, #44]	; 0x2c
c0d02b52:	0400      	lsls	r0, r0, #16
c0d02b54:	d019      	beq.n	c0d02b8a <eth_plugin_call+0x106>
c0d02b56:	a806      	add	r0, sp, #24
c0d02b58:	2100      	movs	r1, #0
                os_lib_call(params);
            }
            CATCH_OTHER(e) {
c0d02b5a:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d02b5c:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d02b5e:	f004 f817 	bl	c0d06b90 <try_context_set>
                PRINTF("Plugin call exception for %s\n", alias);
c0d02b62:	4843      	ldr	r0, [pc, #268]	; (c0d02c70 <eth_plugin_call+0x1ec>)
c0d02b64:	4478      	add	r0, pc
c0d02b66:	4639      	mov	r1, r7
c0d02b68:	f002 fa68 	bl	c0d0503c <mcu_usb_printf>
c0d02b6c:	e014      	b.n	c0d02b98 <eth_plugin_call+0x114>
c0d02b6e:	2400      	movs	r4, #0
c0d02b70:	2014      	movs	r0, #20
            ((PluginCall) PIC(INTERNAL_ETH_PLUGINS[i].impl))(method, parameter);
c0d02b72:	4360      	muls	r0, r4
c0d02b74:	1830      	adds	r0, r6, r0
c0d02b76:	6900      	ldr	r0, [r0, #16]
c0d02b78:	f002 fdde 	bl	c0d05738 <pic>
c0d02b7c:	4602      	mov	r2, r0
c0d02b7e:	9d04      	ldr	r5, [sp, #16]
c0d02b80:	4628      	mov	r0, r5
c0d02b82:	9c05      	ldr	r4, [sp, #20]
c0d02b84:	4621      	mov	r1, r4
c0d02b86:	4790      	blx	r2
c0d02b88:	e012      	b.n	c0d02bb0 <eth_plugin_call+0x12c>
c0d02b8a:	a806      	add	r0, sp, #24
            TRY {
c0d02b8c:	f004 f800 	bl	c0d06b90 <try_context_set>
c0d02b90:	9010      	str	r0, [sp, #64]	; 0x40
c0d02b92:	a812      	add	r0, sp, #72	; 0x48
                os_lib_call(params);
c0d02b94:	f003 ff8c 	bl	c0d06ab0 <os_lib_call>
            }
            FINALLY {
c0d02b98:	f003 ffee 	bl	c0d06b78 <try_context_get>
c0d02b9c:	a906      	add	r1, sp, #24
c0d02b9e:	4288      	cmp	r0, r1
c0d02ba0:	d102      	bne.n	c0d02ba8 <eth_plugin_call+0x124>
c0d02ba2:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d02ba4:	f003 fff4 	bl	c0d06b90 <try_context_set>
c0d02ba8:	a806      	add	r0, sp, #24
            }
        }
        END_TRY;
c0d02baa:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d02bac:	2800      	cmp	r0, #0
c0d02bae:	d151      	bne.n	c0d02c54 <eth_plugin_call+0x1d0>
c0d02bb0:	9a02      	ldr	r2, [sp, #8]
c0d02bb2:	9b01      	ldr	r3, [sp, #4]
c0d02bb4:	2000      	movs	r0, #0
    }

    // Check the call result

    switch (method) {
c0d02bb6:	429d      	cmp	r5, r3
c0d02bb8:	dc0a      	bgt.n	c0d02bd0 <eth_plugin_call+0x14c>
c0d02bba:	3202      	adds	r2, #2
c0d02bbc:	4295      	cmp	r5, r2
c0d02bbe:	d036      	beq.n	c0d02c2e <eth_plugin_call+0x1aa>
c0d02bc0:	2181      	movs	r1, #129	; 0x81
c0d02bc2:	0049      	lsls	r1, r1, #1
c0d02bc4:	428d      	cmp	r5, r1
c0d02bc6:	d011      	beq.n	c0d02bec <eth_plugin_call+0x168>
c0d02bc8:	429d      	cmp	r5, r3
c0d02bca:	d141      	bne.n	c0d02c50 <eth_plugin_call+0x1cc>
                default:
                    return 0;
            }
            break;
        case ETH_PLUGIN_FINALIZE:
            switch (((ethPluginFinalize_t *) parameter)->result) {
c0d02bcc:	7fa1      	ldrb	r1, [r4, #30]
c0d02bce:	e00e      	b.n	c0d02bee <eth_plugin_call+0x16a>
c0d02bd0:	2141      	movs	r1, #65	; 0x41
c0d02bd2:	0089      	lsls	r1, r1, #2
    switch (method) {
c0d02bd4:	428d      	cmp	r5, r1
c0d02bd6:	d009      	beq.n	c0d02bec <eth_plugin_call+0x168>
c0d02bd8:	3206      	adds	r2, #6
c0d02bda:	4295      	cmp	r5, r2
c0d02bdc:	d034      	beq.n	c0d02c48 <eth_plugin_call+0x1c4>
c0d02bde:	2183      	movs	r1, #131	; 0x83
c0d02be0:	0049      	lsls	r1, r1, #1
c0d02be2:	428d      	cmp	r5, r1
c0d02be4:	d134      	bne.n	c0d02c50 <eth_plugin_call+0x1cc>
c0d02be6:	2120      	movs	r1, #32
            if (((ethQueryContractID_t *) parameter)->result != ETH_PLUGIN_RESULT_OK) {
                return 0;
            }
            break;
        case ETH_PLUGIN_QUERY_CONTRACT_UI:
            if (((ethQueryContractUI_t *) parameter)->result != ETH_PLUGIN_RESULT_OK) {
c0d02be8:	5c61      	ldrb	r1, [r4, r1]
c0d02bea:	e02e      	b.n	c0d02c4a <eth_plugin_call+0x1c6>
c0d02bec:	7d21      	ldrb	r1, [r4, #20]
c0d02bee:	2202      	movs	r2, #2
c0d02bf0:	430a      	orrs	r2, r1
c0d02bf2:	2a03      	cmp	r2, #3
c0d02bf4:	d02b      	beq.n	c0d02c4e <eth_plugin_call+0x1ca>
c0d02bf6:	e02b      	b.n	c0d02c50 <eth_plugin_call+0x1cc>
            PRINTF("Cached plugin call but no plugin available\n");
c0d02bf8:	481a      	ldr	r0, [pc, #104]	; (c0d02c64 <eth_plugin_call+0x1e0>)
c0d02bfa:	4478      	add	r0, pc
c0d02bfc:	f002 fa1e 	bl	c0d0503c <mcu_usb_printf>
c0d02c00:	e013      	b.n	c0d02c2a <eth_plugin_call+0x1a6>
c0d02c02:	9201      	str	r2, [sp, #4]
c0d02c04:	9102      	str	r1, [sp, #8]
c0d02c06:	9504      	str	r5, [sp, #16]
c0d02c08:	2060      	movs	r0, #96	; 0x60
            ((ethPluginInitContract_t *) parameter)->pluginContextLength =
c0d02c0a:	60e0      	str	r0, [r4, #12]
c0d02c0c:	a81d      	add	r0, sp, #116	; 0x74
            ((ethPluginInitContract_t *) parameter)->pluginSharedRO = &pluginRO;
c0d02c0e:	6060      	str	r0, [r4, #4]
c0d02c10:	a81e      	add	r0, sp, #120	; 0x78
            ((ethPluginInitContract_t *) parameter)->pluginSharedRW = &pluginRW;
c0d02c12:	6020      	str	r0, [r4, #0]
            ((ethPluginInitContract_t *) parameter)->pluginContext =
c0d02c14:	4812      	ldr	r0, [pc, #72]	; (c0d02c60 <eth_plugin_call+0x1dc>)
c0d02c16:	4601      	mov	r1, r0
c0d02c18:	3144      	adds	r1, #68	; 0x44
c0d02c1a:	60a1      	str	r1, [r4, #8]
c0d02c1c:	2118      	movs	r1, #24
c0d02c1e:	e770      	b.n	c0d02b02 <eth_plugin_call+0x7e>
            PRINTF("Unknown plugin method %d\n", method);
c0d02c20:	4811      	ldr	r0, [pc, #68]	; (c0d02c68 <eth_plugin_call+0x1e4>)
c0d02c22:	4478      	add	r0, pc
c0d02c24:	4629      	mov	r1, r5
c0d02c26:	f002 fa09 	bl	c0d0503c <mcu_usb_printf>
c0d02c2a:	2000      	movs	r0, #0
c0d02c2c:	e010      	b.n	c0d02c50 <eth_plugin_call+0x1cc>
            switch (((ethPluginInitContract_t *) parameter)->result) {
c0d02c2e:	7f21      	ldrb	r1, [r4, #28]
c0d02c30:	2902      	cmp	r1, #2
c0d02c32:	d00c      	beq.n	c0d02c4e <eth_plugin_call+0x1ca>
c0d02c34:	2901      	cmp	r1, #1
c0d02c36:	d10b      	bne.n	c0d02c50 <eth_plugin_call+0x1cc>
                    if (contractAddress != NULL) {
c0d02c38:	9803      	ldr	r0, [sp, #12]
c0d02c3a:	2800      	cmp	r0, #0
c0d02c3c:	d007      	beq.n	c0d02c4e <eth_plugin_call+0x1ca>
                        strcpy(dataContext.tokenContext.pluginName, alias);
c0d02c3e:	4808      	ldr	r0, [pc, #32]	; (c0d02c60 <eth_plugin_call+0x1dc>)
c0d02c40:	4639      	mov	r1, r7
c0d02c42:	f007 fed1 	bl	c0d0a9e8 <strcpy>
c0d02c46:	e002      	b.n	c0d02c4e <eth_plugin_call+0x1ca>
            if (((ethQueryContractID_t *) parameter)->result != ETH_PLUGIN_RESULT_OK) {
c0d02c48:	7f21      	ldrb	r1, [r4, #28]
c0d02c4a:	2901      	cmp	r1, #1
c0d02c4c:	d100      	bne.n	c0d02c50 <eth_plugin_call+0x1cc>
c0d02c4e:	2001      	movs	r0, #1
        default:
            return 0;
    }

    return 1;
}
c0d02c50:	b01f      	add	sp, #124	; 0x7c
c0d02c52:	bdf0      	pop	{r4, r5, r6, r7, pc}
        END_TRY;
c0d02c54:	f001 fb96 	bl	c0d04384 <os_longjmp>
c0d02c58:	200018dc 	.word	0x200018dc
c0d02c5c:	20001d60 	.word	0x20001d60
c0d02c60:	20001be4 	.word	0x20001be4
c0d02c64:	00008ad9 	.word	0x00008ad9
c0d02c68:	00008add 	.word	0x00008add
c0d02c6c:	00008ce8 	.word	0x00008ce8
c0d02c70:	00008bb5 	.word	0x00008bb5

c0d02c74 <plugin_ui_get_id>:

} plugin_ui_state_t;

void computeFees(char *displayBuffer, uint32_t displayBufferSize);

void plugin_ui_get_id() {
c0d02c74:	b510      	push	{r4, lr}
c0d02c76:	b08a      	sub	sp, #40	; 0x28
c0d02c78:	2028      	movs	r0, #40	; 0x28
    ethQueryContractID_t pluginQueryContractID;
    eth_plugin_prepare_query_contract_ID(&pluginQueryContractID,
c0d02c7a:	4669      	mov	r1, sp
c0d02c7c:	6008      	str	r0, [r1, #0]
c0d02c7e:	4911      	ldr	r1, [pc, #68]	; (c0d02cc4 <plugin_ui_get_id+0x50>)
c0d02c80:	460b      	mov	r3, r1
c0d02c82:	3364      	adds	r3, #100	; 0x64
c0d02c84:	ac02      	add	r4, sp, #8
c0d02c86:	2264      	movs	r2, #100	; 0x64
c0d02c88:	4620      	mov	r0, r4
c0d02c8a:	f7ff fe1a 	bl	c0d028c2 <eth_plugin_prepare_query_contract_ID>
                                         sizeof(strings.tmp.tmp),
                                         strings.tmp.tmp2,
                                         sizeof(strings.tmp.tmp2));
    // Query the original contract for ID if it's not an internal alias
    if (!eth_plugin_call(
            (dataContext.tokenContext.pluginName[0] == '-' ? NULL
c0d02c8e:	480f      	ldr	r0, [pc, #60]	; (c0d02ccc <plugin_ui_get_id+0x58>)
c0d02c90:	7800      	ldrb	r0, [r0, #0]
c0d02c92:	282d      	cmp	r0, #45	; 0x2d
c0d02c94:	d004      	beq.n	c0d02ca0 <plugin_ui_get_id+0x2c>
c0d02c96:	2021      	movs	r0, #33	; 0x21
c0d02c98:	00c0      	lsls	r0, r0, #3
c0d02c9a:	490b      	ldr	r1, [pc, #44]	; (c0d02cc8 <plugin_ui_get_id+0x54>)
c0d02c9c:	1808      	adds	r0, r1, r0
c0d02c9e:	e000      	b.n	c0d02ca2 <plugin_ui_get_id+0x2e>
c0d02ca0:	2000      	movs	r0, #0
c0d02ca2:	21ff      	movs	r1, #255	; 0xff
c0d02ca4:	3106      	adds	r1, #6
    if (!eth_plugin_call(
c0d02ca6:	4622      	mov	r2, r4
c0d02ca8:	f7ff feec 	bl	c0d02a84 <eth_plugin_call>
c0d02cac:	2800      	cmp	r0, #0
c0d02cae:	d106      	bne.n	c0d02cbe <plugin_ui_get_id+0x4a>
                                                           : tmpContent.txContent.destination),
            ETH_PLUGIN_QUERY_CONTRACT_ID,
            (void *) &pluginQueryContractID)) {
        PRINTF("Plugin query contract ID call failed\n");
c0d02cb0:	4807      	ldr	r0, [pc, #28]	; (c0d02cd0 <plugin_ui_get_id+0x5c>)
c0d02cb2:	4478      	add	r0, pc
c0d02cb4:	f002 f9c2 	bl	c0d0503c <mcu_usb_printf>
c0d02cb8:	2000      	movs	r0, #0
        io_seproxyhal_touch_tx_cancel(NULL);
c0d02cba:	f004 fddf 	bl	c0d0787c <io_seproxyhal_touch_tx_cancel>
    }
}
c0d02cbe:	b00a      	add	sp, #40	; 0x28
c0d02cc0:	bd10      	pop	{r4, pc}
c0d02cc2:	46c0      	nop			; (mov r8, r8)
c0d02cc4:	20001cca 	.word	0x20001cca
c0d02cc8:	200018dc 	.word	0x200018dc
c0d02ccc:	20001be4 	.word	0x20001be4
c0d02cd0:	00008ba2 	.word	0x00008ba2

c0d02cd4 <plugin_ui_get_item>:

void plugin_ui_get_item() {
c0d02cd4:	b510      	push	{r4, lr}
c0d02cd6:	b08c      	sub	sp, #48	; 0x30
c0d02cd8:	2042      	movs	r0, #66	; 0x42
    ethQueryContractUI_t pluginQueryContractUI;
    eth_plugin_prepare_query_contract_UI(&pluginQueryContractUI,
                                         dataContext.tokenContext.pluginUiCurrentItem,
c0d02cda:	490f      	ldr	r1, [pc, #60]	; (c0d02d18 <plugin_ui_get_item+0x44>)
c0d02cdc:	5c09      	ldrb	r1, [r1, r0]
c0d02cde:	2028      	movs	r0, #40	; 0x28
    eth_plugin_prepare_query_contract_UI(&pluginQueryContractUI,
c0d02ce0:	466b      	mov	r3, sp
c0d02ce2:	6058      	str	r0, [r3, #4]
c0d02ce4:	4a0d      	ldr	r2, [pc, #52]	; (c0d02d1c <plugin_ui_get_item+0x48>)
c0d02ce6:	4610      	mov	r0, r2
c0d02ce8:	3064      	adds	r0, #100	; 0x64
c0d02cea:	6018      	str	r0, [r3, #0]
c0d02cec:	ac03      	add	r4, sp, #12
c0d02cee:	2364      	movs	r3, #100	; 0x64
c0d02cf0:	4620      	mov	r0, r4
c0d02cf2:	f7ff fdf6 	bl	c0d028e2 <eth_plugin_prepare_query_contract_UI>
c0d02cf6:	2083      	movs	r0, #131	; 0x83
c0d02cf8:	0041      	lsls	r1, r0, #1
c0d02cfa:	2000      	movs	r0, #0
                                         strings.tmp.tmp,
                                         sizeof(strings.tmp.tmp),
                                         strings.tmp.tmp2,
                                         sizeof(strings.tmp.tmp2));
    if (!eth_plugin_call(NULL, ETH_PLUGIN_QUERY_CONTRACT_UI, (void *) &pluginQueryContractUI)) {
c0d02cfc:	4622      	mov	r2, r4
c0d02cfe:	f7ff fec1 	bl	c0d02a84 <eth_plugin_call>
c0d02d02:	2800      	cmp	r0, #0
c0d02d04:	d106      	bne.n	c0d02d14 <plugin_ui_get_item+0x40>
        PRINTF("Plugin query contract UI call failed\n");
c0d02d06:	4806      	ldr	r0, [pc, #24]	; (c0d02d20 <plugin_ui_get_item+0x4c>)
c0d02d08:	4478      	add	r0, pc
c0d02d0a:	f002 f997 	bl	c0d0503c <mcu_usb_printf>
c0d02d0e:	2000      	movs	r0, #0
        io_seproxyhal_touch_tx_cancel(NULL);
c0d02d10:	f004 fdb4 	bl	c0d0787c <io_seproxyhal_touch_tx_cancel>
    }
}
c0d02d14:	b00c      	add	sp, #48	; 0x30
c0d02d16:	bd10      	pop	{r4, pc}
c0d02d18:	20001be4 	.word	0x20001be4
c0d02d1c:	20001cca 	.word	0x20001cca
c0d02d20:	00008b72 	.word	0x00008b72

c0d02d24 <display_next_plugin_item>:

void display_next_plugin_item(bool entering) {
c0d02d24:	b510      	push	{r4, lr}
c0d02d26:	2243      	movs	r2, #67	; 0x43
c0d02d28:	491e      	ldr	r1, [pc, #120]	; (c0d02da4 <display_next_plugin_item+0x80>)
c0d02d2a:	5c8b      	ldrb	r3, [r1, r2]
    if (entering) {
c0d02d2c:	2800      	cmp	r0, #0
c0d02d2e:	d006      	beq.n	c0d02d3e <display_next_plugin_item+0x1a>
c0d02d30:	2042      	movs	r0, #66	; 0x42
        if (dataContext.tokenContext.pluginUiState == PLUGIN_UI_OUTSIDE) {
c0d02d32:	2b01      	cmp	r3, #1
c0d02d34:	d10c      	bne.n	c0d02d50 <display_next_plugin_item+0x2c>
c0d02d36:	2300      	movs	r3, #0
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
            dataContext.tokenContext.pluginUiCurrentItem = 0;
c0d02d38:	540b      	strb	r3, [r1, r0]
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
c0d02d3a:	548b      	strb	r3, [r1, r2]
c0d02d3c:	e00d      	b.n	c0d02d5a <display_next_plugin_item+0x36>
                dataContext.tokenContext.pluginUiCurrentItem = 0;
                ux_flow_prev();
            }
        }
    } else {
        if (dataContext.tokenContext.pluginUiState == PLUGIN_UI_OUTSIDE) {
c0d02d3e:	2b01      	cmp	r3, #1
c0d02d40:	d10e      	bne.n	c0d02d60 <display_next_plugin_item+0x3c>
c0d02d42:	2000      	movs	r0, #0
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
c0d02d44:	5488      	strb	r0, [r1, r2]
            plugin_ui_get_item();
c0d02d46:	f7ff ffc5 	bl	c0d02cd4 <plugin_ui_get_item>
            ux_flow_prev();
c0d02d4a:	f006 fe9f 	bl	c0d09a8c <ux_flow_prev>
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
                ux_flow_next();
            }
        }
    }
}
c0d02d4e:	bd10      	pop	{r4, pc}
            if (dataContext.tokenContext.pluginUiCurrentItem > 0) {
c0d02d50:	5c0b      	ldrb	r3, [r1, r0]
c0d02d52:	2b00      	cmp	r3, #0
c0d02d54:	d01e      	beq.n	c0d02d94 <display_next_plugin_item+0x70>
                dataContext.tokenContext.pluginUiCurrentItem--;
c0d02d56:	1e5a      	subs	r2, r3, #1
c0d02d58:	540a      	strb	r2, [r1, r0]
c0d02d5a:	f7ff ffbb 	bl	c0d02cd4 <plugin_ui_get_item>
c0d02d5e:	e016      	b.n	c0d02d8e <display_next_plugin_item+0x6a>
c0d02d60:	2042      	movs	r0, #66	; 0x42
            if (dataContext.tokenContext.pluginUiCurrentItem <
c0d02d62:	5c0b      	ldrb	r3, [r1, r0]
c0d02d64:	2441      	movs	r4, #65	; 0x41
                dataContext.tokenContext.pluginUiMaxItems - 1) {
c0d02d66:	5d0c      	ldrb	r4, [r1, r4]
c0d02d68:	1e64      	subs	r4, r4, #1
            if (dataContext.tokenContext.pluginUiCurrentItem <
c0d02d6a:	429c      	cmp	r4, r3
c0d02d6c:	dd0d      	ble.n	c0d02d8a <display_next_plugin_item+0x66>
                dataContext.tokenContext.pluginUiCurrentItem++;
c0d02d6e:	1c5a      	adds	r2, r3, #1
c0d02d70:	540a      	strb	r2, [r1, r0]
                plugin_ui_get_item();
c0d02d72:	f7ff ffaf 	bl	c0d02cd4 <plugin_ui_get_item>
                ux_flow_prev();
c0d02d76:	f006 fe89 	bl	c0d09a8c <ux_flow_prev>
                G_ux.layout_paging.current = 0;
c0d02d7a:	480b      	ldr	r0, [pc, #44]	; (c0d02da8 <display_next_plugin_item+0x84>)
c0d02d7c:	2100      	movs	r1, #0
c0d02d7e:	6041      	str	r1, [r0, #4]
                ux_layout_paging_redisplay(G_ux.stack_count - 1);
c0d02d80:	7800      	ldrb	r0, [r0, #0]
c0d02d82:	1e40      	subs	r0, r0, #1
c0d02d84:	f007 f8d0 	bl	c0d09f28 <ux_layout_paging_redisplay>
}
c0d02d88:	bd10      	pop	{r4, pc}
c0d02d8a:	2001      	movs	r0, #1
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0d02d8c:	5488      	strb	r0, [r1, r2]
c0d02d8e:	f006 fe77 	bl	c0d09a80 <ux_flow_next>
}
c0d02d92:	bd10      	pop	{r4, pc}
c0d02d94:	2300      	movs	r3, #0
                dataContext.tokenContext.pluginUiCurrentItem = 0;
c0d02d96:	540b      	strb	r3, [r1, r0]
c0d02d98:	2001      	movs	r0, #1
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0d02d9a:	5488      	strb	r0, [r1, r2]
                ux_flow_prev();
c0d02d9c:	f006 fe76 	bl	c0d09a8c <ux_flow_prev>
}
c0d02da0:	bd10      	pop	{r4, pc}
c0d02da2:	46c0      	nop			; (mov r8, r8)
c0d02da4:	20001be4 	.word	0x20001be4
c0d02da8:	20001a00 	.word	0x20001a00

c0d02dac <ux_plugin_approval_id_step_init>:
      &C_icon_eye,
      "Review",
      "contract call",
    });

UX_STEP_NOCB_INIT(
c0d02dac:	b510      	push	{r4, lr}
c0d02dae:	4604      	mov	r4, r0
c0d02db0:	f7ff ff60 	bl	c0d02c74 <plugin_ui_get_id>
c0d02db4:	4620      	mov	r0, r4
c0d02db6:	f007 f98d 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d02dba:	bd10      	pop	{r4, pc}

c0d02dbc <ux_plugin_approval_before_step_init>:
  {
    .title = strings.tmp.tmp,
    .text = strings.tmp.tmp2
  });

UX_STEP_INIT(
c0d02dbc:	b580      	push	{r7, lr}
c0d02dbe:	2001      	movs	r0, #1
c0d02dc0:	f7ff ffb0 	bl	c0d02d24 <display_next_plugin_item>
c0d02dc4:	bd80      	pop	{r7, pc}

c0d02dc6 <ux_plugin_approval_after_step_init>:
  {
    .title = strings.tmp.tmp,
    .text = strings.tmp.tmp2
  });

UX_STEP_INIT(
c0d02dc6:	b580      	push	{r7, lr}
c0d02dc8:	2000      	movs	r0, #0
c0d02dca:	f7ff ffab 	bl	c0d02d24 <display_next_plugin_item>
c0d02dce:	bd80      	pop	{r7, pc}

c0d02dd0 <ux_plugin_approval_fees_step_init>:
  NULL,
  {
    display_next_plugin_item(false);
  });

UX_STEP_NOCB_INIT(
c0d02dd0:	b510      	push	{r4, lr}
c0d02dd2:	4604      	mov	r4, r0
    computeFees(strings.common.maxFee, sizeof(strings.common.maxFee));
c0d02dd4:	4804      	ldr	r0, [pc, #16]	; (c0d02de8 <ux_plugin_approval_fees_step_init+0x18>)
c0d02dd6:	305d      	adds	r0, #93	; 0x5d
c0d02dd8:	2132      	movs	r1, #50	; 0x32
c0d02dda:	f000 fb5f 	bl	c0d0349c <computeFees>
UX_STEP_NOCB_INIT(
c0d02dde:	4620      	mov	r0, r4
c0d02de0:	f007 f978 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d02de4:	bd10      	pop	{r4, pc}
c0d02de6:	46c0      	nop			; (mov r8, r8)
c0d02de8:	20001cca 	.word	0x20001cca

c0d02dec <ux_plugin_approval_ok_step_validateinit>:
  {
    .title = "Max Fees",
    .text = strings.common.maxFee
  });

UX_FLOW_DEF_VALID(
c0d02dec:	b580      	push	{r7, lr}
c0d02dee:	2000      	movs	r0, #0
c0d02df0:	f004 fcd0 	bl	c0d07794 <io_seproxyhal_touch_tx_ok>
c0d02df4:	bd80      	pop	{r7, pc}

c0d02df6 <ux_plugin_approval_cancel_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_FLOW_DEF_VALID(
c0d02df6:	b580      	push	{r7, lr}
c0d02df8:	2000      	movs	r0, #0
c0d02dfa:	f004 fd3f 	bl	c0d0787c <io_seproxyhal_touch_tx_cancel>
c0d02dfe:	bd80      	pop	{r7, pc}

c0d02e00 <plugin_ui_start>:
        &ux_plugin_approval_after_step,
        &ux_plugin_approval_fees_step,
        &ux_plugin_approval_ok_step,
        &ux_plugin_approval_cancel_step);

void plugin_ui_start() {
c0d02e00:	b580      	push	{r7, lr}
c0d02e02:	2142      	movs	r1, #66	; 0x42
    dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0d02e04:	4a05      	ldr	r2, [pc, #20]	; (c0d02e1c <plugin_ui_start+0x1c>)
c0d02e06:	2000      	movs	r0, #0
    dataContext.tokenContext.pluginUiCurrentItem = 0;
c0d02e08:	5450      	strb	r0, [r2, r1]
c0d02e0a:	2143      	movs	r1, #67	; 0x43
c0d02e0c:	2301      	movs	r3, #1
    dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0d02e0e:	5453      	strb	r3, [r2, r1]
    ux_flow_init(0, ux_plugin_approval_flow, NULL);
c0d02e10:	4903      	ldr	r1, [pc, #12]	; (c0d02e20 <plugin_ui_start+0x20>)
c0d02e12:	4479      	add	r1, pc
c0d02e14:	4602      	mov	r2, r0
c0d02e16:	f006 feff 	bl	c0d09c18 <ux_flow_init>
}
c0d02e1a:	bd80      	pop	{r7, pc}
c0d02e1c:	20001be4 	.word	0x20001be4
c0d02e20:	00008bae 	.word	0x00008bae

c0d02e24 <handle_check_address>:
static int os_strcmp(const char* s1, const char* s2) {
    size_t size = strlen(s1) + 1;
    return memcmp(s1, s2, size);
}

int handle_check_address(check_address_parameters_t* params, chain_config_t* chain_config) {
c0d02e24:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02e26:	b0ff      	sub	sp, #508	; 0x1fc
c0d02e28:	b092      	sub	sp, #72	; 0x48
c0d02e2a:	460d      	mov	r5, r1
c0d02e2c:	4604      	mov	r4, r0
    PRINTF("Params on the address %d\n", (unsigned int) params);
c0d02e2e:	4845      	ldr	r0, [pc, #276]	; (c0d02f44 <handle_check_address+0x120>)
c0d02e30:	4478      	add	r0, pc
c0d02e32:	4621      	mov	r1, r4
c0d02e34:	f002 f902 	bl	c0d0503c <mcu_usb_printf>
    PRINTF("Address to check %s\n", params->address_to_check);
c0d02e38:	6921      	ldr	r1, [r4, #16]
c0d02e3a:	4843      	ldr	r0, [pc, #268]	; (c0d02f48 <handle_check_address+0x124>)
c0d02e3c:	4478      	add	r0, pc
c0d02e3e:	f002 f8fd 	bl	c0d0503c <mcu_usb_printf>
    PRINTF("Inside handle_check_address\n");
c0d02e42:	4842      	ldr	r0, [pc, #264]	; (c0d02f4c <handle_check_address+0x128>)
c0d02e44:	4478      	add	r0, pc
c0d02e46:	f002 f8f9 	bl	c0d0503c <mcu_usb_printf>
    if (params->address_to_check == 0) {
c0d02e4a:	6920      	ldr	r0, [r4, #16]
c0d02e4c:	2800      	cmp	r0, #0
c0d02e4e:	d067      	beq.n	c0d02f20 <handle_check_address+0xfc>
        PRINTF("Address to check == 0\n");
        return 0;
    }

    uint8_t i;
    uint8_t* bip32_path_ptr = params->address_parameters;
c0d02e50:	68a0      	ldr	r0, [r4, #8]
    uint8_t bip32PathLength = *(bip32_path_ptr++);
c0d02e52:	7802      	ldrb	r2, [r0, #0]
    union group2 {
        uint8_t privateKeyData[32];
        cx_ecfp_public_key_t publicKey;
    } locals_union2;

    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH) ||
c0d02e54:	1e51      	subs	r1, r2, #1
c0d02e56:	b2c9      	uxtb	r1, r1
c0d02e58:	2909      	cmp	r1, #9
c0d02e5a:	d85e      	bhi.n	c0d02f1a <handle_check_address+0xf6>
        (bip32PathLength * 4 != params->address_parameters_length - 1)) {
c0d02e5c:	0091      	lsls	r1, r2, #2
c0d02e5e:	7b23      	ldrb	r3, [r4, #12]
c0d02e60:	1e5b      	subs	r3, r3, #1
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH) ||
c0d02e62:	428b      	cmp	r3, r1
c0d02e64:	d159      	bne.n	c0d02f1a <handle_check_address+0xf6>
c0d02e66:	9504      	str	r5, [sp, #16]
    uint8_t bip32PathLength = *(bip32_path_ptr++);
c0d02e68:	1c40      	adds	r0, r0, #1
c0d02e6a:	a919      	add	r1, sp, #100	; 0x64
c0d02e6c:	4613      	mov	r3, r2
        PRINTF("Invalid path\n");
        return 0;
    }
    for (i = 0; i < bip32PathLength; i++) {
        locals_union1.bip32Path[i] = U4BE(bip32_path_ptr, 0);
c0d02e6e:	78c5      	ldrb	r5, [r0, #3]
c0d02e70:	7886      	ldrb	r6, [r0, #2]
c0d02e72:	0236      	lsls	r6, r6, #8
c0d02e74:	1975      	adds	r5, r6, r5
c0d02e76:	7846      	ldrb	r6, [r0, #1]
c0d02e78:	7807      	ldrb	r7, [r0, #0]
c0d02e7a:	023f      	lsls	r7, r7, #8
c0d02e7c:	19be      	adds	r6, r7, r6
c0d02e7e:	0436      	lsls	r6, r6, #16
c0d02e80:	19ad      	adds	r5, r5, r6
c0d02e82:	c120      	stmia	r1!, {r5}
    for (i = 0; i < bip32PathLength; i++) {
c0d02e84:	1d00      	adds	r0, r0, #4
c0d02e86:	1e5b      	subs	r3, r3, #1
c0d02e88:	d1f1      	bne.n	c0d02e6e <handle_check_address+0x4a>
c0d02e8a:	2600      	movs	r6, #0
        bip32_path_ptr += 4;
    }
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d02e8c:	4668      	mov	r0, sp
c0d02e8e:	6006      	str	r6, [r0, #0]
c0d02e90:	2021      	movs	r0, #33	; 0x21
c0d02e92:	9005      	str	r0, [sp, #20]
c0d02e94:	af19      	add	r7, sp, #100	; 0x64
c0d02e96:	ad06      	add	r5, sp, #24
c0d02e98:	4639      	mov	r1, r7
c0d02e9a:	462b      	mov	r3, r5
c0d02e9c:	f003 fdd2 	bl	c0d06a44 <os_perso_derive_node_bip32>
c0d02ea0:	2134      	movs	r1, #52	; 0x34
                               locals_union1.bip32Path,
                               bip32PathLength,
                               locals_union2.privateKeyData,
                               NULL);
    ZERO(locals_union1);
c0d02ea2:	9103      	str	r1, [sp, #12]
c0d02ea4:	4638      	mov	r0, r7
c0d02ea6:	f007 fbe1 	bl	c0d0a66c <__aeabi_memclr>
c0d02eaa:	2220      	movs	r2, #32
    cx_ecfp_init_private_key(CX_CURVE_256K1,
c0d02eac:	9805      	ldr	r0, [sp, #20]
c0d02eae:	4629      	mov	r1, r5
c0d02eb0:	463b      	mov	r3, r7
c0d02eb2:	f003 fd33 	bl	c0d0691c <cx_ecfp_init_private_key>
c0d02eb6:	214c      	movs	r1, #76	; 0x4c
                             locals_union2.privateKeyData,
                             32,
                             &locals_union1.privateKey);
    ZERO(locals_union2);
c0d02eb8:	9102      	str	r1, [sp, #8]
c0d02eba:	4628      	mov	r0, r5
c0d02ebc:	f007 fbd6 	bl	c0d0a66c <__aeabi_memclr>
c0d02ec0:	2301      	movs	r3, #1
    cx_ecfp_generate_pair(CX_CURVE_256K1, &locals_union2.publicKey, &locals_union1.privateKey, 1);
c0d02ec2:	9805      	ldr	r0, [sp, #20]
c0d02ec4:	4629      	mov	r1, r5
c0d02ec6:	463a      	mov	r2, r7
c0d02ec8:	9305      	str	r3, [sp, #20]
c0d02eca:	f003 fd37 	bl	c0d0693c <cx_ecfp_generate_pair>
    ZERO(locals_union1);
c0d02ece:	4638      	mov	r0, r7
c0d02ed0:	9903      	ldr	r1, [sp, #12]
c0d02ed2:	f007 fbcb 	bl	c0d0a66c <__aeabi_memclr>
c0d02ed6:	aa26      	add	r2, sp, #152	; 0x98
    getEthAddressStringFromKey(&locals_union2.publicKey,
c0d02ed8:	4628      	mov	r0, r5
c0d02eda:	4639      	mov	r1, r7
c0d02edc:	9b04      	ldr	r3, [sp, #16]
c0d02ede:	f7ff fae3 	bl	c0d024a8 <getEthAddressStringFromKey>
                               (uint8_t*) locals_union1.address,
                               &local_sha3,
                               chain_config);
    ZERO(locals_union2);
c0d02ee2:	4628      	mov	r0, r5
c0d02ee4:	9902      	ldr	r1, [sp, #8]
c0d02ee6:	f007 fbc1 	bl	c0d0a66c <__aeabi_memclr>

    uint8_t offset_0x = 0;
    if (memcmp(params->address_to_check, "0x", 2) == 0) {
c0d02eea:	6924      	ldr	r4, [r4, #16]
c0d02eec:	7820      	ldrb	r0, [r4, #0]
c0d02eee:	7861      	ldrb	r1, [r4, #1]
c0d02ef0:	0209      	lsls	r1, r1, #8
c0d02ef2:	1808      	adds	r0, r1, r0
c0d02ef4:	4912      	ldr	r1, [pc, #72]	; (c0d02f40 <handle_check_address+0x11c>)
        offset_0x = 2;
    }

    if (os_strcmp(locals_union1.address, params->address_to_check + offset_0x) != 0) {
c0d02ef6:	4288      	cmp	r0, r1
c0d02ef8:	d100      	bne.n	c0d02efc <handle_check_address+0xd8>
c0d02efa:	1ca4      	adds	r4, r4, #2
    size_t size = strlen(s1) + 1;
c0d02efc:	4638      	mov	r0, r7
c0d02efe:	f007 fd7b 	bl	c0d0a9f8 <strlen>
c0d02f02:	1c42      	adds	r2, r0, #1
    return memcmp(s1, s2, size);
c0d02f04:	4638      	mov	r0, r7
c0d02f06:	4621      	mov	r1, r4
c0d02f08:	f007 fbca 	bl	c0d0a6a0 <memcmp>
    if (os_strcmp(locals_union1.address, params->address_to_check + offset_0x) != 0) {
c0d02f0c:	2800      	cmp	r0, #0
c0d02f0e:	d010      	beq.n	c0d02f32 <handle_check_address+0x10e>
        PRINTF("Addresses don't match\n");
c0d02f10:	4810      	ldr	r0, [pc, #64]	; (c0d02f54 <handle_check_address+0x130>)
c0d02f12:	4478      	add	r0, pc
c0d02f14:	f002 f892 	bl	c0d0503c <mcu_usb_printf>
c0d02f18:	e007      	b.n	c0d02f2a <handle_check_address+0x106>
        PRINTF("Invalid path\n");
c0d02f1a:	4810      	ldr	r0, [pc, #64]	; (c0d02f5c <handle_check_address+0x138>)
c0d02f1c:	4478      	add	r0, pc
c0d02f1e:	e001      	b.n	c0d02f24 <handle_check_address+0x100>
        PRINTF("Address to check == 0\n");
c0d02f20:	480b      	ldr	r0, [pc, #44]	; (c0d02f50 <handle_check_address+0x12c>)
c0d02f22:	4478      	add	r0, pc
c0d02f24:	f002 f88a 	bl	c0d0503c <mcu_usb_printf>
c0d02f28:	2600      	movs	r6, #0
        return 0;
    }
    PRINTF("Addresses  match\n");
    return 1;
}
c0d02f2a:	4630      	mov	r0, r6
c0d02f2c:	b07f      	add	sp, #508	; 0x1fc
c0d02f2e:	b012      	add	sp, #72	; 0x48
c0d02f30:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PRINTF("Addresses  match\n");
c0d02f32:	4809      	ldr	r0, [pc, #36]	; (c0d02f58 <handle_check_address+0x134>)
c0d02f34:	4478      	add	r0, pc
c0d02f36:	f002 f881 	bl	c0d0503c <mcu_usb_printf>
c0d02f3a:	9e05      	ldr	r6, [sp, #20]
c0d02f3c:	e7f5      	b.n	c0d02f2a <handle_check_address+0x106>
c0d02f3e:	46c0      	nop			; (mov r8, r8)
c0d02f40:	00007830 	.word	0x00007830
c0d02f44:	00008d7c 	.word	0x00008d7c
c0d02f48:	00008d8a 	.word	0x00008d8a
c0d02f4c:	00008d97 	.word	0x00008d97
c0d02f50:	00008cd6 	.word	0x00008cd6
c0d02f54:	00008cfd 	.word	0x00008cfd
c0d02f58:	00008cf2 	.word	0x00008cf2
c0d02f5c:	00007cfc 	.word	0x00007cfc

c0d02f60 <handle_get_printable_amount>:
#include "utils.h"
#include "uint256.h"
#include "string.h"
#include <stdint.h>

int handle_get_printable_amount(get_printable_amount_parameters_t* params, chain_config_t* config) {
c0d02f60:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02f62:	b087      	sub	sp, #28
c0d02f64:	460f      	mov	r7, r1
c0d02f66:	4605      	mov	r5, r0
    uint8_t decimals;
    char ticker[MAX_TICKER_LEN];
    memset(params->printable_amount, 0, sizeof(params->printable_amount));
c0d02f68:	4604      	mov	r4, r0
c0d02f6a:	340e      	adds	r4, #14
c0d02f6c:	261e      	movs	r6, #30
c0d02f6e:	4620      	mov	r0, r4
c0d02f70:	4631      	mov	r1, r6
c0d02f72:	f007 fb7b 	bl	c0d0a66c <__aeabi_memclr>
    if (params->amount_length > 32) {
c0d02f76:	7b29      	ldrb	r1, [r5, #12]
c0d02f78:	2921      	cmp	r1, #33	; 0x21
c0d02f7a:	d304      	bcc.n	c0d02f86 <handle_get_printable_amount+0x26>
        PRINTF("Amount is too big, 32 bytes max but buffer has %u bytes", params->amount_length);
c0d02f7c:	481b      	ldr	r0, [pc, #108]	; (c0d02fec <handle_get_printable_amount+0x8c>)
c0d02f7e:	4478      	add	r0, pc
c0d02f80:	f002 f85c 	bl	c0d0503c <mcu_usb_printf>
c0d02f84:	e023      	b.n	c0d02fce <handle_get_printable_amount+0x6e>
        return 0;
    }
    if (!parse_swap_config(params->coin_configuration,
                           params->coin_configuration_length,
c0d02f86:	7929      	ldrb	r1, [r5, #4]
    if (!parse_swap_config(params->coin_configuration,
c0d02f88:	6828      	ldr	r0, [r5, #0]
c0d02f8a:	aa03      	add	r2, sp, #12
c0d02f8c:	ab06      	add	r3, sp, #24
c0d02f8e:	f006 fcc5 	bl	c0d0991c <parse_swap_config>
c0d02f92:	2800      	cmp	r0, #0
c0d02f94:	d017      	beq.n	c0d02fc6 <handle_get_printable_amount+0x66>
        PRINTF("Error while parsing config\n");
        return 0;
    }

    // If the amount is a fee, its value is nominated in ETH even if we're doing an ERC20 swap
    if (params->is_fee) {
c0d02f96:	7b68      	ldrb	r0, [r5, #13]
c0d02f98:	2800      	cmp	r0, #0
c0d02f9a:	d01a      	beq.n	c0d02fd2 <handle_get_printable_amount+0x72>
c0d02f9c:	210a      	movs	r1, #10
        uint8_t ticker_len = strnlen(config->coinName, sizeof(config->coinName));
c0d02f9e:	4638      	mov	r0, r7
c0d02fa0:	f007 fdc8 	bl	c0d0ab34 <strnlen>
        memcpy(ticker, config->coinName, ticker_len);
c0d02fa4:	b2c2      	uxtb	r2, r0
c0d02fa6:	9202      	str	r2, [sp, #8]
c0d02fa8:	4639      	mov	r1, r7
c0d02faa:	af03      	add	r7, sp, #12
c0d02fac:	4638      	mov	r0, r7
c0d02fae:	f007 fb63 	bl	c0d0a678 <__aeabi_memcpy>
c0d02fb2:	2020      	movs	r0, #32
c0d02fb4:	9902      	ldr	r1, [sp, #8]
        // uint8_t ticker_len = strnlen(config->coinName, sizeof(config->coinName)) + 1;
        // memcpy(ticker, config->coinName, ticker_len - 1);
        // ticker[ticker_len - 1] = '#';
        ticker[ticker_len] = ' ';
c0d02fb6:	5478      	strb	r0, [r7, r1]
c0d02fb8:	1878      	adds	r0, r7, r1
c0d02fba:	2100      	movs	r1, #0
        ticker[ticker_len + 1] = '\0';
c0d02fbc:	7041      	strb	r1, [r0, #1]
c0d02fbe:	a806      	add	r0, sp, #24
c0d02fc0:	2212      	movs	r2, #18
        decimals = WEI_TO_ETHER;
c0d02fc2:	7002      	strb	r2, [r0, #0]
c0d02fc4:	e007      	b.n	c0d02fd6 <handle_get_printable_amount+0x76>
        PRINTF("Error while parsing config\n");
c0d02fc6:	480a      	ldr	r0, [pc, #40]	; (c0d02ff0 <handle_get_printable_amount+0x90>)
c0d02fc8:	4478      	add	r0, pc
c0d02fca:	f002 f837 	bl	c0d0503c <mcu_usb_printf>
c0d02fce:	2000      	movs	r0, #0
c0d02fd0:	e009      	b.n	c0d02fe6 <handle_get_printable_amount+0x86>
c0d02fd2:	a806      	add	r0, sp, #24
    }

    amountToString(params->amount,
                   params->amount_length,
                   decimals,
c0d02fd4:	7802      	ldrb	r2, [r0, #0]
                   params->amount_length,
c0d02fd6:	7b29      	ldrb	r1, [r5, #12]
    amountToString(params->amount,
c0d02fd8:	68a8      	ldr	r0, [r5, #8]
c0d02fda:	466b      	mov	r3, sp
c0d02fdc:	c350      	stmia	r3!, {r4, r6}
c0d02fde:	ab03      	add	r3, sp, #12
c0d02fe0:	f006 fc58 	bl	c0d09894 <amountToString>
c0d02fe4:	2001      	movs	r0, #1
                   ticker,
                   params->printable_amount,
                   sizeof(params->printable_amount));
    return 1;
}
c0d02fe6:	b007      	add	sp, #28
c0d02fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02fea:	46c0      	nop			; (mov r8, r8)
c0d02fec:	00008cba 	.word	0x00008cba
c0d02ff0:	00008ca8 	.word	0x00008ca8

c0d02ff4 <copy_transaction_parameters>:
#include "ux.h"
#include "shared_context.h"
#include "utils.h"

bool copy_transaction_parameters(create_transaction_parameters_t* sign_transaction_params,
                                 chain_config_t* config) {
c0d02ff4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02ff6:	b0ad      	sub	sp, #180	; 0xb4
c0d02ff8:	460d      	mov	r5, r1
c0d02ffa:	4604      	mov	r4, r0
c0d02ffc:	ae09      	add	r6, sp, #36	; 0x24
c0d02ffe:	218f      	movs	r1, #143	; 0x8f
    // first copy parameters to stack, and then to global data.
    // We need this "trick" as the input data position can overlap with app-ethereum globals
    txStringProperties_t stack_data;
    memset(&stack_data, 0, sizeof(stack_data));
c0d03000:	4630      	mov	r0, r6
c0d03002:	f007 fb33 	bl	c0d0a66c <__aeabi_memclr>
    strncpy(stack_data.fullAddress,
            sign_transaction_params->destination_address,
c0d03006:	69a1      	ldr	r1, [r4, #24]
c0d03008:	222b      	movs	r2, #43	; 0x2b
    strncpy(stack_data.fullAddress,
c0d0300a:	4630      	mov	r0, r6
c0d0300c:	f007 fd5c 	bl	c0d0aac8 <strncpy>
c0d03010:	202a      	movs	r0, #42	; 0x2a
            sizeof(stack_data.fullAddress));
    if ((stack_data.fullAddress[sizeof(stack_data.fullAddress) - 1] != '\0') ||
c0d03012:	5c31      	ldrb	r1, [r6, r0]
c0d03014:	2000      	movs	r0, #0
c0d03016:	2900      	cmp	r1, #0
c0d03018:	d13c      	bne.n	c0d03094 <copy_transaction_parameters+0xa0>
        (sign_transaction_params->amount_length > 32) ||
c0d0301a:	7b21      	ldrb	r1, [r4, #12]
c0d0301c:	2920      	cmp	r1, #32
c0d0301e:	d839      	bhi.n	c0d03094 <copy_transaction_parameters+0xa0>
        (sign_transaction_params->fee_amount_length > 8)) {
c0d03020:	7d21      	ldrb	r1, [r4, #20]
    if ((stack_data.fullAddress[sizeof(stack_data.fullAddress) - 1] != '\0') ||
c0d03022:	2908      	cmp	r1, #8
c0d03024:	d836      	bhi.n	c0d03094 <copy_transaction_parameters+0xa0>
    }

    uint8_t decimals;
    char ticker[MAX_TICKER_LEN];
    if (!parse_swap_config(sign_transaction_params->coin_configuration,
                           sign_transaction_params->coin_configuration_length,
c0d03026:	7921      	ldrb	r1, [r4, #4]
    if (!parse_swap_config(sign_transaction_params->coin_configuration,
c0d03028:	6820      	ldr	r0, [r4, #0]
c0d0302a:	aa05      	add	r2, sp, #20
c0d0302c:	ab08      	add	r3, sp, #32
c0d0302e:	f006 fc75 	bl	c0d0991c <parse_swap_config>
c0d03032:	2800      	cmp	r0, #0
c0d03034:	d029      	beq.n	c0d0308a <copy_transaction_parameters+0x96>
c0d03036:	a808      	add	r0, sp, #32
        PRINTF("Error while parsing config\n");
        return false;
    }
    amountToString(sign_transaction_params->amount,
                   sign_transaction_params->amount_length,
                   decimals,
c0d03038:	9003      	str	r0, [sp, #12]
c0d0303a:	7802      	ldrb	r2, [r0, #0]
                   sign_transaction_params->amount_length,
c0d0303c:	7b21      	ldrb	r1, [r4, #12]
    amountToString(sign_transaction_params->amount,
c0d0303e:	68a0      	ldr	r0, [r4, #8]
c0d03040:	2632      	movs	r6, #50	; 0x32
c0d03042:	9604      	str	r6, [sp, #16]
c0d03044:	466b      	mov	r3, sp
c0d03046:	605e      	str	r6, [r3, #4]
c0d03048:	ae09      	add	r6, sp, #36	; 0x24
                   ticker,
                   stack_data.fullAmount,
c0d0304a:	4637      	mov	r7, r6
c0d0304c:	372b      	adds	r7, #43	; 0x2b
    amountToString(sign_transaction_params->amount,
c0d0304e:	601f      	str	r7, [r3, #0]
c0d03050:	af05      	add	r7, sp, #20
c0d03052:	463b      	mov	r3, r7
c0d03054:	f006 fc1e 	bl	c0d09894 <amountToString>
                   sizeof(stack_data.fullAmount));

    // If the amount is a fee, its value is nominated in ETH even if we're doing an ERC20 swap
    strcpy(ticker, config->coinName);
c0d03058:	4638      	mov	r0, r7
c0d0305a:	4629      	mov	r1, r5
c0d0305c:	f007 fcc4 	bl	c0d0a9e8 <strcpy>
c0d03060:	2212      	movs	r2, #18
    decimals = WEI_TO_ETHER;
c0d03062:	9803      	ldr	r0, [sp, #12]
c0d03064:	7002      	strb	r2, [r0, #0]
    amountToString(sign_transaction_params->fee_amount,
                   sign_transaction_params->fee_amount_length,
c0d03066:	7d21      	ldrb	r1, [r4, #20]
    amountToString(sign_transaction_params->fee_amount,
c0d03068:	6920      	ldr	r0, [r4, #16]
c0d0306a:	466b      	mov	r3, sp
                   decimals,
                   ticker,
                   stack_data.maxFee,
c0d0306c:	4634      	mov	r4, r6
c0d0306e:	345d      	adds	r4, #93	; 0x5d
    amountToString(sign_transaction_params->fee_amount,
c0d03070:	601c      	str	r4, [r3, #0]
c0d03072:	9c04      	ldr	r4, [sp, #16]
c0d03074:	605c      	str	r4, [r3, #4]
c0d03076:	463b      	mov	r3, r7
c0d03078:	f006 fc0c 	bl	c0d09894 <amountToString>
                   sizeof(stack_data.maxFee));

    memcpy(&strings.common, &stack_data, sizeof(stack_data));
c0d0307c:	4806      	ldr	r0, [pc, #24]	; (c0d03098 <copy_transaction_parameters+0xa4>)
c0d0307e:	228f      	movs	r2, #143	; 0x8f
c0d03080:	4631      	mov	r1, r6
c0d03082:	f007 faf9 	bl	c0d0a678 <__aeabi_memcpy>
c0d03086:	2001      	movs	r0, #1
c0d03088:	e004      	b.n	c0d03094 <copy_transaction_parameters+0xa0>
        PRINTF("Error while parsing config\n");
c0d0308a:	4804      	ldr	r0, [pc, #16]	; (c0d0309c <copy_transaction_parameters+0xa8>)
c0d0308c:	4478      	add	r0, pc
c0d0308e:	f001 ffd5 	bl	c0d0503c <mcu_usb_printf>
c0d03092:	2000      	movs	r0, #0
    return true;
}
c0d03094:	b02d      	add	sp, #180	; 0xb4
c0d03096:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03098:	20001cca 	.word	0x20001cca
c0d0309c:	00008be4 	.word	0x00008be4

c0d030a0 <handle_swap_sign_transaction>:

void handle_swap_sign_transaction(chain_config_t* config) {
c0d030a0:	b5b0      	push	{r4, r5, r7, lr}
c0d030a2:	b082      	sub	sp, #8
    chainConfig = config;
c0d030a4:	4916      	ldr	r1, [pc, #88]	; (c0d03100 <handle_swap_sign_transaction+0x60>)
c0d030a6:	6008      	str	r0, [r1, #0]
    reset_app_context();
c0d030a8:	f000 fbd0 	bl	c0d0384c <reset_app_context>
    called_from_swap = true;
c0d030ac:	4815      	ldr	r0, [pc, #84]	; (c0d03104 <handle_swap_sign_transaction+0x64>)
c0d030ae:	2401      	movs	r4, #1
c0d030b0:	7004      	strb	r4, [r0, #0]
    io_seproxyhal_init();
c0d030b2:	f001 fba9 	bl	c0d04808 <io_seproxyhal_init>

    if (N_storage.initialized != 0x01) {
c0d030b6:	4815      	ldr	r0, [pc, #84]	; (c0d0310c <handle_swap_sign_transaction+0x6c>)
c0d030b8:	4478      	add	r0, pc
c0d030ba:	f002 fb3d 	bl	c0d05738 <pic>
c0d030be:	7880      	ldrb	r0, [r0, #2]
c0d030c0:	2801      	cmp	r0, #1
c0d030c2:	d00b      	beq.n	c0d030dc <handle_swap_sign_transaction+0x3c>
c0d030c4:	ad01      	add	r5, sp, #4
        internalStorage_t storage;
        storage.dataAllowed = 0x00;
        storage.contractDetails = 0x00;
        storage.initialized = 0x01;
c0d030c6:	70ac      	strb	r4, [r5, #2]
c0d030c8:	2000      	movs	r0, #0
        storage.dataAllowed = 0x00;
c0d030ca:	8028      	strh	r0, [r5, #0]
        nvm_write((void*) &N_storage, (void*) &storage, sizeof(internalStorage_t));
c0d030cc:	4810      	ldr	r0, [pc, #64]	; (c0d03110 <handle_swap_sign_transaction+0x70>)
c0d030ce:	4478      	add	r0, pc
c0d030d0:	f002 fb32 	bl	c0d05738 <pic>
c0d030d4:	2203      	movs	r2, #3
c0d030d6:	4629      	mov	r1, r5
c0d030d8:	f003 fb92 	bl	c0d06800 <nvm_write>
c0d030dc:	0221      	lsls	r1, r4, #8
    }

    UX_INIT();
c0d030de:	480a      	ldr	r0, [pc, #40]	; (c0d03108 <handle_swap_sign_transaction+0x68>)
c0d030e0:	f007 fac4 	bl	c0d0a66c <__aeabi_memclr>
c0d030e4:	2000      	movs	r0, #0
    USB_power(0);
c0d030e6:	f006 fab5 	bl	c0d09654 <USB_power>
    USB_power(1);
c0d030ea:	4620      	mov	r0, r4
c0d030ec:	f006 fab2 	bl	c0d09654 <USB_power>
    // ui_idle();
    PRINTF("USB power ON/OFF\n");
c0d030f0:	4808      	ldr	r0, [pc, #32]	; (c0d03114 <handle_swap_sign_transaction+0x74>)
c0d030f2:	4478      	add	r0, pc
c0d030f4:	f001 ffa2 	bl	c0d0503c <mcu_usb_printf>
#endif  // TARGET_NANOX
#ifdef HAVE_BLE
    BLE_power(0, NULL);
    BLE_power(1, "Nano X");
#endif  // HAVE_BLE
    app_main();
c0d030f8:	f000 fd7e 	bl	c0d03bf8 <app_main>
c0d030fc:	b002      	add	sp, #8
c0d030fe:	bdb0      	pop	{r4, r5, r7, pc}
c0d03100:	20001be0 	.word	0x20001be0
c0d03104:	2000189c 	.word	0x2000189c
c0d03108:	20001a00 	.word	0x20001a00
c0d0310c:	0000a704 	.word	0x0000a704
c0d03110:	0000a6ee 	.word	0x0000a6ee
c0d03114:	00008b9a 	.word	0x00008b9a

c0d03118 <set_result_get_publicKey>:
#include "shared_context.h"

uint32_t set_result_get_publicKey() {
c0d03118:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = 0;
    G_io_apdu_buffer[tx++] = 65;
c0d0311a:	4c10      	ldr	r4, [pc, #64]	; (c0d0315c <set_result_get_publicKey+0x44>)
c0d0311c:	2241      	movs	r2, #65	; 0x41
c0d0311e:	7022      	strb	r2, [r4, #0]
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.publicKey.W, 65);
c0d03120:	1c60      	adds	r0, r4, #1
c0d03122:	4d0f      	ldr	r5, [pc, #60]	; (c0d03160 <set_result_get_publicKey+0x48>)
c0d03124:	4629      	mov	r1, r5
c0d03126:	3108      	adds	r1, #8
c0d03128:	f007 faa6 	bl	c0d0a678 <__aeabi_memcpy>
c0d0312c:	2042      	movs	r0, #66	; 0x42
c0d0312e:	2228      	movs	r2, #40	; 0x28
    tx += 65;
    G_io_apdu_buffer[tx++] = 40;
c0d03130:	5422      	strb	r2, [r4, r0]
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.address, 40);
c0d03132:	4620      	mov	r0, r4
c0d03134:	3043      	adds	r0, #67	; 0x43
c0d03136:	4629      	mov	r1, r5
c0d03138:	314c      	adds	r1, #76	; 0x4c
c0d0313a:	f007 fa9d 	bl	c0d0a678 <__aeabi_memcpy>
c0d0313e:	2095      	movs	r0, #149	; 0x95
    tx += 40;
    if (tmpCtx.publicKeyContext.getChaincode) {
c0d03140:	5c28      	ldrb	r0, [r5, r0]
c0d03142:	2800      	cmp	r0, #0
c0d03144:	d008      	beq.n	c0d03158 <set_result_get_publicKey+0x40>
        memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.chainCode, 32);
c0d03146:	346b      	adds	r4, #107	; 0x6b
c0d03148:	3575      	adds	r5, #117	; 0x75
c0d0314a:	2220      	movs	r2, #32
c0d0314c:	4620      	mov	r0, r4
c0d0314e:	4629      	mov	r1, r5
c0d03150:	f007 fa92 	bl	c0d0a678 <__aeabi_memcpy>
c0d03154:	208b      	movs	r0, #139	; 0x8b
        tx += 32;
    }
    return tx;
c0d03156:	bdb0      	pop	{r4, r5, r7, pc}
c0d03158:	206b      	movs	r0, #107	; 0x6b
c0d0315a:	bdb0      	pop	{r4, r5, r7, pc}
c0d0315c:	20001f09 	.word	0x20001f09
c0d03160:	20001804 	.word	0x20001804

c0d03164 <splitBinaryParameterPart>:
#endif
#include "eth_plugin_handler.h"

#define ERR_SILENT_MODE_CHECK_FAILED 0x6001

uint32_t splitBinaryParameterPart(char *result, uint8_t *parameter) {
c0d03164:	b510      	push	{r4, lr}
c0d03166:	2200      	movs	r2, #0
    uint32_t i;
    for (i = 0; i < 8; i++) {
        if (parameter[i] != 0x00) {
c0d03168:	5c8b      	ldrb	r3, [r1, r2]
c0d0316a:	2b00      	cmp	r3, #0
c0d0316c:	d10a      	bne.n	c0d03184 <splitBinaryParameterPart+0x20>
    for (i = 0; i < 8; i++) {
c0d0316e:	1c52      	adds	r2, r2, #1
c0d03170:	2a08      	cmp	r2, #8
c0d03172:	d3f9      	bcc.n	c0d03168 <splitBinaryParameterPart+0x4>
            break;
        }
    }
    if (i == 8) {
c0d03174:	d106      	bne.n	c0d03184 <splitBinaryParameterPart+0x20>
c0d03176:	2100      	movs	r1, #0
        result[0] = '0';
        result[1] = '0';
        result[2] = '\0';
c0d03178:	7081      	strb	r1, [r0, #2]
c0d0317a:	2130      	movs	r1, #48	; 0x30
        result[1] = '0';
c0d0317c:	7041      	strb	r1, [r0, #1]
        result[0] = '0';
c0d0317e:	7001      	strb	r1, [r0, #0]
c0d03180:	2002      	movs	r0, #2
        return 2;
    } else {
        array_hexstr(result, parameter + i, 8 - i);
        return ((8 - i) * 2);
    }
}
c0d03182:	bd10      	pop	{r4, pc}
        array_hexstr(result, parameter + i, 8 - i);
c0d03184:	1889      	adds	r1, r1, r2
c0d03186:	2308      	movs	r3, #8
c0d03188:	1a9c      	subs	r4, r3, r2
c0d0318a:	4622      	mov	r2, r4
c0d0318c:	f006 fb0e 	bl	c0d097ac <array_hexstr>
        return ((8 - i) * 2);
c0d03190:	0060      	lsls	r0, r4, #1
}
c0d03192:	bd10      	pop	{r4, pc}

c0d03194 <customProcessor>:

customStatus_e customProcessor(txContext_t *context) {
c0d03194:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d03196:	b08d      	sub	sp, #52	; 0x34
c0d03198:	4604      	mov	r4, r0
    if ((context->currentField == TX_RLP_DATA) && (context->currentFieldLength != 0)) {
c0d0319a:	7800      	ldrb	r0, [r0, #0]
c0d0319c:	2500      	movs	r5, #0
c0d0319e:	2808      	cmp	r0, #8
c0d031a0:	d000      	beq.n	c0d031a4 <customProcessor+0x10>
c0d031a2:	e0ae      	b.n	c0d03302 <customProcessor+0x16e>
c0d031a4:	68a0      	ldr	r0, [r4, #8]
c0d031a6:	2800      	cmp	r0, #0
c0d031a8:	d100      	bne.n	c0d031ac <customProcessor+0x18>
c0d031aa:	e0aa      	b.n	c0d03302 <customProcessor+0x16e>
        dataPresent = true;
c0d031ac:	4884      	ldr	r0, [pc, #528]	; (c0d033c0 <customProcessor+0x22c>)
c0d031ae:	2101      	movs	r1, #1
c0d031b0:	7001      	strb	r1, [r0, #0]
c0d031b2:	2047      	movs	r0, #71	; 0x47
c0d031b4:	0080      	lsls	r0, r0, #2
        // If handling a new contract rather than a function call, abort immediately
        if (tmpContent.txContent.destinationLength == 0) {
c0d031b6:	4f83      	ldr	r7, [pc, #524]	; (c0d033c4 <customProcessor+0x230>)
c0d031b8:	5c38      	ldrb	r0, [r7, r0]
c0d031ba:	2800      	cmp	r0, #0
c0d031bc:	d100      	bne.n	c0d031c0 <customProcessor+0x2c>
c0d031be:	e0a0      	b.n	c0d03302 <customProcessor+0x16e>
            return CUSTOM_NOT_HANDLED;
        }
        if (context->currentFieldPos == 0) {
c0d031c0:	68e6      	ldr	r6, [r4, #12]
c0d031c2:	2e00      	cmp	r6, #0
c0d031c4:	d01c      	beq.n	c0d03200 <customProcessor+0x6c>
c0d031c6:	9104      	str	r1, [sp, #16]
c0d031c8:	4881      	ldr	r0, [pc, #516]	; (c0d033d0 <customProcessor+0x23c>)
c0d031ca:	4478      	add	r0, pc
c0d031cc:	f002 fab4 	bl	c0d05738 <pic>
            }
            dataContext.tokenContext.fieldIndex = 0;
            dataContext.tokenContext.fieldOffset = 0;
            blockSize = 4;
        } else {
            if (!N_storage.contractDetails && !dataContext.tokenContext.pluginAvailable) {
c0d031d0:	7841      	ldrb	r1, [r0, #1]
c0d031d2:	487d      	ldr	r0, [pc, #500]	; (c0d033c8 <customProcessor+0x234>)
c0d031d4:	7f82      	ldrb	r2, [r0, #30]
c0d031d6:	430a      	orrs	r2, r1
c0d031d8:	0611      	lsls	r1, r2, #24
c0d031da:	d100      	bne.n	c0d031de <customProcessor+0x4a>
c0d031dc:	e091      	b.n	c0d03302 <customProcessor+0x16e>
c0d031de:	2140      	movs	r1, #64	; 0x40
                return CUSTOM_NOT_HANDLED;
            }
            blockSize = 32 - (dataContext.tokenContext.fieldOffset % 32);
c0d031e0:	5c40      	ldrb	r0, [r0, r1]
c0d031e2:	211f      	movs	r1, #31
c0d031e4:	4001      	ands	r1, r0
c0d031e6:	2020      	movs	r0, #32
c0d031e8:	1a47      	subs	r7, r0, r1
c0d031ea:	2100      	movs	r1, #0
        }

        // Sanity check
        if ((context->currentFieldLength - fieldPos) < blockSize) {
c0d031ec:	68a0      	ldr	r0, [r4, #8]
c0d031ee:	1b80      	subs	r0, r0, r6
c0d031f0:	42b8      	cmp	r0, r7
c0d031f2:	d20e      	bcs.n	c0d03212 <customProcessor+0x7e>
            PRINTF("Unconsistent data\n");
c0d031f4:	487d      	ldr	r0, [pc, #500]	; (c0d033ec <customProcessor+0x258>)
c0d031f6:	4478      	add	r0, pc
c0d031f8:	f001 ff20 	bl	c0d0503c <mcu_usb_printf>
c0d031fc:	2503      	movs	r5, #3
c0d031fe:	e080      	b.n	c0d03302 <customProcessor+0x16e>
            if (context->commandLength < 4) {
c0d03200:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d03202:	2803      	cmp	r0, #3
c0d03204:	d82e      	bhi.n	c0d03264 <customProcessor+0xd0>
                PRINTF("Missing function selector\n");
c0d03206:	4873      	ldr	r0, [pc, #460]	; (c0d033d4 <customProcessor+0x240>)
c0d03208:	4478      	add	r0, pc
c0d0320a:	f001 ff17 	bl	c0d0503c <mcu_usb_printf>
c0d0320e:	2603      	movs	r6, #3
c0d03210:	e076      	b.n	c0d03300 <customProcessor+0x16c>
c0d03212:	9101      	str	r1, [sp, #4]
            return CUSTOM_FAULT;
        }

        copySize = (context->commandLength < blockSize ? context->commandLength : blockSize);
c0d03214:	6aa6      	ldr	r6, [r4, #40]	; 0x28
c0d03216:	42be      	cmp	r6, r7
c0d03218:	9602      	str	r6, [sp, #8]
c0d0321a:	d300      	bcc.n	c0d0321e <customProcessor+0x8a>
c0d0321c:	463e      	mov	r6, r7

        PRINTF("currentFieldPos %d copySize %d\n", context->currentFieldPos, copySize);
c0d0321e:	68e1      	ldr	r1, [r4, #12]
c0d03220:	4873      	ldr	r0, [pc, #460]	; (c0d033f0 <customProcessor+0x25c>)
c0d03222:	4478      	add	r0, pc
c0d03224:	4632      	mov	r2, r6
c0d03226:	f001 ff09 	bl	c0d0503c <mcu_usb_printf>
c0d0322a:	2040      	movs	r0, #64	; 0x40

        copyTxData(context,
                   dataContext.tokenContext.data + dataContext.tokenContext.fieldOffset,
c0d0322c:	4d66      	ldr	r5, [pc, #408]	; (c0d033c8 <customProcessor+0x234>)
c0d0322e:	9003      	str	r0, [sp, #12]
c0d03230:	5c28      	ldrb	r0, [r5, r0]
c0d03232:	1829      	adds	r1, r5, r0
c0d03234:	311f      	adds	r1, #31
        copyTxData(context,
c0d03236:	4620      	mov	r0, r4
c0d03238:	4632      	mov	r2, r6
c0d0323a:	f7fe fdb7 	bl	c0d01dac <copyTxData>
                   copySize);

        if (context->currentFieldPos == context->currentFieldLength) {
c0d0323e:	68a0      	ldr	r0, [r4, #8]
c0d03240:	68e1      	ldr	r1, [r4, #12]
c0d03242:	4281      	cmp	r1, r0
c0d03244:	d104      	bne.n	c0d03250 <customProcessor+0xbc>
c0d03246:	2000      	movs	r0, #0
            context->currentField++;
            context->processingField = false;
c0d03248:	7460      	strb	r0, [r4, #17]
            context->currentField++;
c0d0324a:	7820      	ldrb	r0, [r4, #0]
c0d0324c:	1c40      	adds	r0, r0, #1
c0d0324e:	7020      	strb	r0, [r4, #0]
c0d03250:	9903      	ldr	r1, [sp, #12]
        }

        dataContext.tokenContext.fieldOffset += copySize;
c0d03252:	5c68      	ldrb	r0, [r5, r1]
c0d03254:	1980      	adds	r0, r0, r6
c0d03256:	5468      	strb	r0, [r5, r1]

        if (copySize == blockSize) {
c0d03258:	9802      	ldr	r0, [sp, #8]
c0d0325a:	42b8      	cmp	r0, r7
c0d0325c:	9904      	ldr	r1, [sp, #16]
c0d0325e:	d20f      	bcs.n	c0d03280 <customProcessor+0xec>
c0d03260:	460d      	mov	r5, r1
c0d03262:	e04e      	b.n	c0d03302 <customProcessor+0x16e>
c0d03264:	9104      	str	r1, [sp, #16]
            dataContext.tokenContext.pluginAvailable = 0;
c0d03266:	4858      	ldr	r0, [pc, #352]	; (c0d033c8 <customProcessor+0x234>)
c0d03268:	2600      	movs	r6, #0
c0d0326a:	7786      	strb	r6, [r0, #30]
            if (!N_storage.contractDetails) {
c0d0326c:	485a      	ldr	r0, [pc, #360]	; (c0d033d8 <customProcessor+0x244>)
c0d0326e:	4478      	add	r0, pc
c0d03270:	f002 fa62 	bl	c0d05738 <pic>
c0d03274:	7840      	ldrb	r0, [r0, #1]
c0d03276:	2800      	cmp	r0, #0
c0d03278:	d020      	beq.n	c0d032bc <customProcessor+0x128>
c0d0327a:	4f53      	ldr	r7, [pc, #332]	; (c0d033c8 <customProcessor+0x234>)
            PRINTF("pluginAvailable %d\n", dataContext.tokenContext.pluginAvailable);
c0d0327c:	7fb8      	ldrb	r0, [r7, #30]
c0d0327e:	e02b      	b.n	c0d032d8 <customProcessor+0x144>
            // Can process or display
            if (dataContext.tokenContext.pluginAvailable) {
c0d03280:	7fa8      	ldrb	r0, [r5, #30]
c0d03282:	2800      	cmp	r0, #0
c0d03284:	d05a      	beq.n	c0d0333c <customProcessor+0x1a8>
c0d03286:	9104      	str	r1, [sp, #16]
c0d03288:	273f      	movs	r7, #63	; 0x3f
                ethPluginProvideParameter_t pluginProvideParameter;
                eth_plugin_prepare_provide_parameter(&pluginProvideParameter,
                                                     dataContext.tokenContext.data,
                                                     dataContext.tokenContext.fieldIndex * 32 + 4);
c0d0328a:	5de8      	ldrb	r0, [r5, r7]
c0d0328c:	0140      	lsls	r0, r0, #5
c0d0328e:	1d02      	adds	r2, r0, #4
                eth_plugin_prepare_provide_parameter(&pluginProvideParameter,
c0d03290:	4629      	mov	r1, r5
c0d03292:	311f      	adds	r1, #31
c0d03294:	ae05      	add	r6, sp, #20
c0d03296:	4630      	mov	r0, r6
c0d03298:	f7ff fafa 	bl	c0d02890 <eth_plugin_prepare_provide_parameter>
c0d0329c:	2081      	movs	r0, #129	; 0x81
c0d0329e:	0041      	lsls	r1, r0, #1
c0d032a0:	2400      	movs	r4, #0
                if (!eth_plugin_call(NULL,
c0d032a2:	4620      	mov	r0, r4
c0d032a4:	4632      	mov	r2, r6
c0d032a6:	f7ff fbed 	bl	c0d02a84 <eth_plugin_call>
c0d032aa:	2800      	cmp	r0, #0
c0d032ac:	d057      	beq.n	c0d0335e <customProcessor+0x1ca>
                                     (void *) &pluginProvideParameter)) {
                    PRINTF("Plugin parameter call failed\n");
                    return CUSTOM_FAULT;
                }
                dataContext.tokenContext.fieldIndex++;
                dataContext.tokenContext.fieldOffset = 0;
c0d032ae:	9803      	ldr	r0, [sp, #12]
c0d032b0:	542c      	strb	r4, [r5, r0]
                dataContext.tokenContext.fieldIndex++;
c0d032b2:	5de8      	ldrb	r0, [r5, r7]
c0d032b4:	1c40      	adds	r0, r0, #1
c0d032b6:	55e8      	strb	r0, [r5, r7]
c0d032b8:	9d04      	ldr	r5, [sp, #16]
c0d032ba:	e022      	b.n	c0d03302 <customProcessor+0x16e>
                                        context->currentFieldLength);
c0d032bc:	68a2      	ldr	r2, [r4, #8]
                                        context->workBuffer,
c0d032be:	6a61      	ldr	r1, [r4, #36]	; 0x24
c0d032c0:	a805      	add	r0, sp, #20
                eth_plugin_prepare_init(&pluginInit,
c0d032c2:	9003      	str	r0, [sp, #12]
c0d032c4:	f7ff fada 	bl	c0d0287c <eth_plugin_prepare_init>
c0d032c8:	2021      	movs	r0, #33	; 0x21
c0d032ca:	00c0      	lsls	r0, r0, #3
                    eth_plugin_perform_init(tmpContent.txContent.destination, &pluginInit);
c0d032cc:	1838      	adds	r0, r7, r0
c0d032ce:	9903      	ldr	r1, [sp, #12]
c0d032d0:	f7ff fb1a 	bl	c0d02908 <eth_plugin_perform_init>
c0d032d4:	4f3c      	ldr	r7, [pc, #240]	; (c0d033c8 <customProcessor+0x234>)
                dataContext.tokenContext.pluginAvailable =
c0d032d6:	77b8      	strb	r0, [r7, #30]
            PRINTF("pluginAvailable %d\n", dataContext.tokenContext.pluginAvailable);
c0d032d8:	b2c1      	uxtb	r1, r0
c0d032da:	4840      	ldr	r0, [pc, #256]	; (c0d033dc <customProcessor+0x248>)
c0d032dc:	4478      	add	r0, pc
c0d032de:	f001 fead 	bl	c0d0503c <mcu_usb_printf>
            if (dataContext.tokenContext.pluginAvailable) {
c0d032e2:	7fb8      	ldrb	r0, [r7, #30]
c0d032e4:	2800      	cmp	r0, #0
c0d032e6:	d00f      	beq.n	c0d03308 <customProcessor+0x174>
c0d032e8:	2040      	movs	r0, #64	; 0x40
                dataContext.tokenContext.fieldOffset = 0;
c0d032ea:	543e      	strb	r6, [r7, r0]
c0d032ec:	203f      	movs	r0, #63	; 0x3f
                dataContext.tokenContext.fieldIndex = 0;
c0d032ee:	543e      	strb	r6, [r7, r0]
c0d032f0:	2204      	movs	r2, #4
                copyTxData(context, NULL, 4);
c0d032f2:	4620      	mov	r0, r4
c0d032f4:	4631      	mov	r1, r6
c0d032f6:	f7fe fd59 	bl	c0d01dac <copyTxData>
                if (context->currentFieldLength == 4) {
c0d032fa:	68a0      	ldr	r0, [r4, #8]
c0d032fc:	2804      	cmp	r0, #4
c0d032fe:	d103      	bne.n	c0d03308 <customProcessor+0x174>
c0d03300:	4635      	mov	r5, r6
        }

        return CUSTOM_SUSPENDED;
    }
    return CUSTOM_NOT_HANDLED;
}
c0d03302:	4628      	mov	r0, r5
c0d03304:	b00d      	add	sp, #52	; 0x34
c0d03306:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint32_t fieldPos = context->currentFieldPos;
c0d03308:	68e6      	ldr	r6, [r4, #12]
c0d0330a:	4835      	ldr	r0, [pc, #212]	; (c0d033e0 <customProcessor+0x24c>)
c0d0330c:	4478      	add	r0, pc
c0d0330e:	f002 fa13 	bl	c0d05738 <pic>
        if (fieldPos == 0) {  // not reached if a plugin is available
c0d03312:	2e00      	cmp	r6, #0
c0d03314:	d000      	beq.n	c0d03318 <customProcessor+0x184>
c0d03316:	e75b      	b.n	c0d031d0 <customProcessor+0x3c>
            if (!N_storage.dataAllowed) {
c0d03318:	7800      	ldrb	r0, [r0, #0]
c0d0331a:	2800      	cmp	r0, #0
c0d0331c:	d04b      	beq.n	c0d033b6 <customProcessor+0x222>
            if (!N_storage.contractDetails) {
c0d0331e:	4832      	ldr	r0, [pc, #200]	; (c0d033e8 <customProcessor+0x254>)
c0d03320:	4478      	add	r0, pc
c0d03322:	f002 fa09 	bl	c0d05738 <pic>
c0d03326:	7840      	ldrb	r0, [r0, #1]
c0d03328:	2800      	cmp	r0, #0
c0d0332a:	d047      	beq.n	c0d033bc <customProcessor+0x228>
c0d0332c:	2040      	movs	r0, #64	; 0x40
c0d0332e:	2600      	movs	r6, #0
            dataContext.tokenContext.fieldOffset = 0;
c0d03330:	543e      	strb	r6, [r7, r0]
c0d03332:	203f      	movs	r0, #63	; 0x3f
            dataContext.tokenContext.fieldIndex = 0;
c0d03334:	543e      	strb	r6, [r7, r0]
c0d03336:	2704      	movs	r7, #4
c0d03338:	2101      	movs	r1, #1
c0d0333a:	e757      	b.n	c0d031ec <customProcessor+0x58>
            if (fieldPos != 0) {
c0d0333c:	9801      	ldr	r0, [sp, #4]
c0d0333e:	2800      	cmp	r0, #0
c0d03340:	d010      	beq.n	c0d03364 <customProcessor+0x1d0>
c0d03342:	2400      	movs	r4, #0
            dataContext.tokenContext.fieldOffset = 0;
c0d03344:	9803      	ldr	r0, [sp, #12]
c0d03346:	542c      	strb	r4, [r5, r0]
                array_hexstr(strings.tmp.tmp, dataContext.tokenContext.data, 4);
c0d03348:	351f      	adds	r5, #31
c0d0334a:	4820      	ldr	r0, [pc, #128]	; (c0d033cc <customProcessor+0x238>)
c0d0334c:	2204      	movs	r2, #4
c0d0334e:	4629      	mov	r1, r5
c0d03350:	f006 fa2c 	bl	c0d097ac <array_hexstr>
                ux_flow_init(0, ux_confirm_selector_flow, NULL);
c0d03354:	4928      	ldr	r1, [pc, #160]	; (c0d033f8 <customProcessor+0x264>)
c0d03356:	4479      	add	r1, pc
c0d03358:	4620      	mov	r0, r4
c0d0335a:	4622      	mov	r2, r4
c0d0335c:	e027      	b.n	c0d033ae <customProcessor+0x21a>
                    PRINTF("Plugin parameter call failed\n");
c0d0335e:	4825      	ldr	r0, [pc, #148]	; (c0d033f4 <customProcessor+0x260>)
c0d03360:	4478      	add	r0, pc
c0d03362:	e749      	b.n	c0d031f8 <customProcessor+0x64>
c0d03364:	2000      	movs	r0, #0
            dataContext.tokenContext.fieldOffset = 0;
c0d03366:	9903      	ldr	r1, [sp, #12]
c0d03368:	5468      	strb	r0, [r5, r1]
c0d0336a:	203f      	movs	r0, #63	; 0x3f
                dataContext.tokenContext.fieldIndex++;
c0d0336c:	5c29      	ldrb	r1, [r5, r0]
c0d0336e:	1c49      	adds	r1, r1, #1
c0d03370:	5429      	strb	r1, [r5, r0]
                         dataContext.tokenContext.fieldIndex);
c0d03372:	b2cb      	uxtb	r3, r1
                snprintf(strings.tmp.tmp2,
c0d03374:	4c15      	ldr	r4, [pc, #84]	; (c0d033cc <customProcessor+0x238>)
c0d03376:	4620      	mov	r0, r4
c0d03378:	3064      	adds	r0, #100	; 0x64
c0d0337a:	2128      	movs	r1, #40	; 0x28
c0d0337c:	4a1f      	ldr	r2, [pc, #124]	; (c0d033fc <customProcessor+0x268>)
c0d0337e:	447a      	add	r2, pc
c0d03380:	f002 f806 	bl	c0d05390 <snprintf>
                    offset += splitBinaryParameterPart(strings.tmp.tmp + offset,
c0d03384:	4629      	mov	r1, r5
c0d03386:	311f      	adds	r1, #31
c0d03388:	4620      	mov	r0, r4
c0d0338a:	f7ff feeb 	bl	c0d03164 <splitBinaryParameterPart>
c0d0338e:	2627      	movs	r6, #39	; 0x27
c0d03390:	213a      	movs	r1, #58	; 0x3a
                        strings.tmp.tmp[offset++] = ':';
c0d03392:	5421      	strb	r1, [r4, r0]
                    offset += splitBinaryParameterPart(strings.tmp.tmp + offset,
c0d03394:	19a9      	adds	r1, r5, r6
                        strings.tmp.tmp[offset++] = ':';
c0d03396:	1c47      	adds	r7, r0, #1
                    offset += splitBinaryParameterPart(strings.tmp.tmp + offset,
c0d03398:	19e0      	adds	r0, r4, r7
c0d0339a:	f7ff fee3 	bl	c0d03164 <splitBinaryParameterPart>
c0d0339e:	19c0      	adds	r0, r0, r7
                    if (i != 3) {
c0d033a0:	3608      	adds	r6, #8
c0d033a2:	2e3f      	cmp	r6, #63	; 0x3f
c0d033a4:	d1f4      	bne.n	c0d03390 <customProcessor+0x1fc>
                ux_flow_init(0, ux_confirm_parameter_flow, NULL);
c0d033a6:	4916      	ldr	r1, [pc, #88]	; (c0d03400 <customProcessor+0x26c>)
c0d033a8:	4479      	add	r1, pc
c0d033aa:	2000      	movs	r0, #0
c0d033ac:	4602      	mov	r2, r0
c0d033ae:	f006 fc33 	bl	c0d09c18 <ux_flow_init>
c0d033b2:	2502      	movs	r5, #2
c0d033b4:	e7a5      	b.n	c0d03302 <customProcessor+0x16e>
                PRINTF("Data field forbidden\n");
c0d033b6:	480b      	ldr	r0, [pc, #44]	; (c0d033e4 <customProcessor+0x250>)
c0d033b8:	4478      	add	r0, pc
c0d033ba:	e71d      	b.n	c0d031f8 <customProcessor+0x64>
c0d033bc:	2500      	movs	r5, #0
c0d033be:	e7a0      	b.n	c0d03302 <customProcessor+0x16e>
c0d033c0:	20001f08 	.word	0x20001f08
c0d033c4:	200018dc 	.word	0x200018dc
c0d033c8:	20001be4 	.word	0x20001be4
c0d033cc:	20001cca 	.word	0x20001cca
c0d033d0:	0000a5f2 	.word	0x0000a5f2
c0d033d4:	00008a96 	.word	0x00008a96
c0d033d8:	0000a54e 	.word	0x0000a54e
c0d033dc:	000089dd 	.word	0x000089dd
c0d033e0:	0000a4b0 	.word	0x0000a4b0
c0d033e4:	00008915 	.word	0x00008915
c0d033e8:	0000a49c 	.word	0x0000a49c
c0d033ec:	00008aed 	.word	0x00008aed
c0d033f0:	00008ad4 	.word	0x00008ad4
c0d033f4:	000089b6 	.word	0x000089b6
c0d033f8:	0000977a 	.word	0x0000977a
c0d033fc:	000089b6 	.word	0x000089b6
c0d03400:	000097d0 	.word	0x000097d0

c0d03404 <compareOrCopy>:
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
        str[i] = str[i] >= 'a' ? str[i] - ('a' - 'A') : str[i];
    }
}

void compareOrCopy(char *preapproved_string, char *parsed_string, bool silent_mode) {
c0d03404:	b5b0      	push	{r4, r5, r7, lr}
c0d03406:	460c      	mov	r4, r1
c0d03408:	4605      	mov	r5, r0
    if (silent_mode) {
c0d0340a:	2a00      	cmp	r2, #0
c0d0340c:	d02c      	beq.n	c0d03468 <compareOrCopy+0x64>
        /* ETH address are not fundamentally case sensitive but might
        have some for checksum purpose, so let's get rid of these diffs */
        to_uppercase(preapproved_string, strlen(preapproved_string));
c0d0340e:	4628      	mov	r0, r5
c0d03410:	f007 faf2 	bl	c0d0a9f8 <strlen>
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0d03414:	0601      	lsls	r1, r0, #24
c0d03416:	d00b      	beq.n	c0d03430 <compareOrCopy+0x2c>
c0d03418:	b2c0      	uxtb	r0, r0
c0d0341a:	2100      	movs	r1, #0
c0d0341c:	5c6a      	ldrb	r2, [r5, r1]
c0d0341e:	2a00      	cmp	r2, #0
c0d03420:	d006      	beq.n	c0d03430 <compareOrCopy+0x2c>
        str[i] = str[i] >= 'a' ? str[i] - ('a' - 'A') : str[i];
c0d03422:	2a60      	cmp	r2, #96	; 0x60
c0d03424:	d900      	bls.n	c0d03428 <compareOrCopy+0x24>
c0d03426:	3a20      	subs	r2, #32
c0d03428:	546a      	strb	r2, [r5, r1]
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0d0342a:	1c49      	adds	r1, r1, #1
c0d0342c:	4281      	cmp	r1, r0
c0d0342e:	d3f5      	bcc.n	c0d0341c <compareOrCopy+0x18>
        to_uppercase(parsed_string, strlen(parsed_string));
c0d03430:	4620      	mov	r0, r4
c0d03432:	f007 fae1 	bl	c0d0a9f8 <strlen>
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0d03436:	0601      	lsls	r1, r0, #24
c0d03438:	d00b      	beq.n	c0d03452 <compareOrCopy+0x4e>
c0d0343a:	b2c0      	uxtb	r0, r0
c0d0343c:	2100      	movs	r1, #0
c0d0343e:	5c62      	ldrb	r2, [r4, r1]
c0d03440:	2a00      	cmp	r2, #0
c0d03442:	d006      	beq.n	c0d03452 <compareOrCopy+0x4e>
        str[i] = str[i] >= 'a' ? str[i] - ('a' - 'A') : str[i];
c0d03444:	2a60      	cmp	r2, #96	; 0x60
c0d03446:	d900      	bls.n	c0d0344a <compareOrCopy+0x46>
c0d03448:	3a20      	subs	r2, #32
c0d0344a:	5462      	strb	r2, [r4, r1]
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0d0344c:	1c49      	adds	r1, r1, #1
c0d0344e:	4281      	cmp	r1, r0
c0d03450:	d3f5      	bcc.n	c0d0343e <compareOrCopy+0x3a>
        if (memcmp(preapproved_string, parsed_string, strlen(preapproved_string))) {
c0d03452:	4628      	mov	r0, r5
c0d03454:	f007 fad0 	bl	c0d0a9f8 <strlen>
c0d03458:	4602      	mov	r2, r0
c0d0345a:	4628      	mov	r0, r5
c0d0345c:	4621      	mov	r1, r4
c0d0345e:	f007 f91f 	bl	c0d0a6a0 <memcmp>
c0d03462:	2800      	cmp	r0, #0
c0d03464:	d105      	bne.n	c0d03472 <compareOrCopy+0x6e>
            THROW(ERR_SILENT_MODE_CHECK_FAILED);
        }
    } else {
        strcpy(preapproved_string, parsed_string);
    }
}
c0d03466:	bdb0      	pop	{r4, r5, r7, pc}
        strcpy(preapproved_string, parsed_string);
c0d03468:	4628      	mov	r0, r5
c0d0346a:	4621      	mov	r1, r4
c0d0346c:	f007 fabc 	bl	c0d0a9e8 <strcpy>
}
c0d03470:	bdb0      	pop	{r4, r5, r7, pc}
c0d03472:	4801      	ldr	r0, [pc, #4]	; (c0d03478 <compareOrCopy+0x74>)
            THROW(ERR_SILENT_MODE_CHECK_FAILED);
c0d03474:	f000 ff86 	bl	c0d04384 <os_longjmp>
c0d03478:	00006001 	.word	0x00006001

c0d0347c <reportFinalizeError>:

void reportFinalizeError(bool direct) {
c0d0347c:	b510      	push	{r4, lr}
c0d0347e:	4604      	mov	r4, r0
    reset_app_context();
c0d03480:	f000 f9e4 	bl	c0d0384c <reset_app_context>
c0d03484:	20d5      	movs	r0, #213	; 0xd5
c0d03486:	01c0      	lsls	r0, r0, #7
    if (direct) {
c0d03488:	2c00      	cmp	r4, #0
c0d0348a:	d104      	bne.n	c0d03496 <reportFinalizeError+0x1a>
        THROW(0x6A80);
    } else {
        io_seproxyhal_send_status(0x6A80);
c0d0348c:	f000 fa12 	bl	c0d038b4 <io_seproxyhal_send_status>
        ui_idle();
c0d03490:	f000 f9fe 	bl	c0d03890 <ui_idle>
    }
}
c0d03494:	bd10      	pop	{r4, pc}
        THROW(0x6A80);
c0d03496:	f000 ff75 	bl	c0d04384 <os_longjmp>
	...

c0d0349c <computeFees>:

void computeFees(char *displayBuffer, uint32_t displayBufferSize) {
c0d0349c:	b570      	push	{r4, r5, r6, lr}
c0d0349e:	460e      	mov	r6, r1
c0d034a0:	4604      	mov	r4, r0
    uint256_t gasPrice, startGas, uint256;
    uint8_t *feeTicker = (uint8_t *) PIC(chainConfig->coinName2);
c0d034a2:	4816      	ldr	r0, [pc, #88]	; (c0d034fc <computeFees+0x60>)
c0d034a4:	6800      	ldr	r0, [r0, #0]
c0d034a6:	300a      	adds	r0, #10
c0d034a8:	f002 f946 	bl	c0d05738 <pic>
c0d034ac:	4605      	mov	r5, r0
    uint8_t tickerOffset = 0;
    uint32_t i, j;

    PRINTF("Max fee\n");
c0d034ae:	4814      	ldr	r0, [pc, #80]	; (c0d03500 <computeFees+0x64>)
c0d034b0:	4478      	add	r0, pc
c0d034b2:	f001 fdc3 	bl	c0d0503c <mcu_usb_printf>
    //                (char *) G_io_apdu_buffer,
    //                100,
    //                WEI_TO_ETHER);
    i = 0;
    tickerOffset = 0;
    memset(displayBuffer, 0, displayBufferSize);
c0d034b6:	4620      	mov	r0, r4
c0d034b8:	4631      	mov	r1, r6
c0d034ba:	f007 f8d7 	bl	c0d0a66c <__aeabi_memclr>
    while (feeTicker[tickerOffset]) {
c0d034be:	7828      	ldrb	r0, [r5, #0]
c0d034c0:	2800      	cmp	r0, #0
c0d034c2:	d009      	beq.n	c0d034d8 <computeFees+0x3c>
c0d034c4:	2200      	movs	r2, #0
c0d034c6:	4613      	mov	r3, r2
c0d034c8:	4619      	mov	r1, r3
        displayBuffer[tickerOffset] = feeTicker[tickerOffset];
c0d034ca:	54a0      	strb	r0, [r4, r2]
        tickerOffset++;
c0d034cc:	1c5b      	adds	r3, r3, #1
    while (feeTicker[tickerOffset]) {
c0d034ce:	b2da      	uxtb	r2, r3
c0d034d0:	5ca8      	ldrb	r0, [r5, r2]
c0d034d2:	2800      	cmp	r0, #0
c0d034d4:	d1f8      	bne.n	c0d034c8 <computeFees+0x2c>
c0d034d6:	e000      	b.n	c0d034da <computeFees+0x3e>
c0d034d8:	21ff      	movs	r1, #255	; 0xff
    }
    tickerOffset--;
    displayBuffer[tickerOffset + 1] = '0';
c0d034da:	b2c8      	uxtb	r0, r1
c0d034dc:	1820      	adds	r0, r4, r0
c0d034de:	2100      	movs	r1, #0
    displayBuffer[tickerOffset + 8] = '1';
    // while (G_io_apdu_buffer[i]) {
    //     displayBuffer[tickerOffset + i] = G_io_apdu_buffer[i];
    //     i++;
    // }
    displayBuffer[tickerOffset + 9] = '\0';
c0d034e0:	7241      	strb	r1, [r0, #9]
c0d034e2:	2131      	movs	r1, #49	; 0x31
    displayBuffer[tickerOffset + 8] = '1';
c0d034e4:	7201      	strb	r1, [r0, #8]
c0d034e6:	2130      	movs	r1, #48	; 0x30
    displayBuffer[tickerOffset + 7] = '0';
c0d034e8:	71c1      	strb	r1, [r0, #7]
    displayBuffer[tickerOffset + 6] = '0';
c0d034ea:	7181      	strb	r1, [r0, #6]
    displayBuffer[tickerOffset + 5] = '0';
c0d034ec:	7141      	strb	r1, [r0, #5]
    displayBuffer[tickerOffset + 4] = '0';
c0d034ee:	7101      	strb	r1, [r0, #4]
    displayBuffer[tickerOffset + 3] = '0';
c0d034f0:	70c1      	strb	r1, [r0, #3]
c0d034f2:	222e      	movs	r2, #46	; 0x2e
    displayBuffer[tickerOffset + 2] = '.';
c0d034f4:	7082      	strb	r2, [r0, #2]
    displayBuffer[tickerOffset + 1] = '0';
c0d034f6:	7041      	strb	r1, [r0, #1]
}
c0d034f8:	bd70      	pop	{r4, r5, r6, pc}
c0d034fa:	46c0      	nop			; (mov r8, r8)
c0d034fc:	20001be0 	.word	0x20001be0
c0d03500:	0000888d 	.word	0x0000888d

c0d03504 <finalizeParsing>:

void finalizeParsing(bool direct) {
c0d03504:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d03506:	b09f      	sub	sp, #124	; 0x7c
c0d03508:	9009      	str	r0, [sp, #36]	; 0x24
    char displayBuffer[50];
    uint8_t decimals = WEI_TO_ETHER;
    uint8_t *ticker = (uint8_t *) PIC(chainConfig->coinName);
c0d0350a:	4fb4      	ldr	r7, [pc, #720]	; (c0d037dc <finalizeParsing+0x2d8>)
c0d0350c:	6838      	ldr	r0, [r7, #0]
c0d0350e:	f002 f913 	bl	c0d05738 <pic>
c0d03512:	9007      	str	r0, [sp, #28]
    ethPluginFinalize_t pluginFinalize;
    tokenDefinition_t *token1 = NULL, *token2 = NULL;
    bool genericUI = true;

    // Verify the chain
    if (chainConfig->chainId != 0) {
c0d03514:	6838      	ldr	r0, [r7, #0]
c0d03516:	6940      	ldr	r0, [r0, #20]
c0d03518:	2800      	cmp	r0, #0
c0d0351a:	d017      	beq.n	c0d0354c <finalizeParsing+0x48>
        uint32_t v = getV(&tmpContent.txContent);
c0d0351c:	48b0      	ldr	r0, [pc, #704]	; (c0d037e0 <finalizeParsing+0x2dc>)
c0d0351e:	f006 f973 	bl	c0d09808 <getV>
c0d03522:	4604      	mov	r4, r0
        if (chainConfig->chainId != v) {
c0d03524:	6838      	ldr	r0, [r7, #0]
c0d03526:	6940      	ldr	r0, [r0, #20]
c0d03528:	42a0      	cmp	r0, r4
c0d0352a:	d00f      	beq.n	c0d0354c <finalizeParsing+0x48>
            reset_app_context();
c0d0352c:	f000 f98e 	bl	c0d0384c <reset_app_context>
            PRINTF("Invalid chainId %d expected %d\n", v, chainConfig->chainId);
c0d03530:	6838      	ldr	r0, [r7, #0]
c0d03532:	6942      	ldr	r2, [r0, #20]
c0d03534:	48b2      	ldr	r0, [pc, #712]	; (c0d03800 <finalizeParsing+0x2fc>)
c0d03536:	4478      	add	r0, pc
c0d03538:	4621      	mov	r1, r4
c0d0353a:	f001 fd7f 	bl	c0d0503c <mcu_usb_printf>
c0d0353e:	9c09      	ldr	r4, [sp, #36]	; 0x24
            reportFinalizeError(direct);
c0d03540:	4620      	mov	r0, r4
c0d03542:	f7ff ff9b 	bl	c0d0347c <reportFinalizeError>
            if (!direct) {
c0d03546:	2c00      	cmp	r4, #0
c0d03548:	d100      	bne.n	c0d0354c <finalizeParsing+0x48>
c0d0354a:	e142      	b.n	c0d037d2 <finalizeParsing+0x2ce>
c0d0354c:	2620      	movs	r6, #32
                return;
            }
        }
    }
    // Store the hash
    cx_hash((cx_hash_t *) &global_sha3,
c0d0354e:	4668      	mov	r0, sp
c0d03550:	6046      	str	r6, [r0, #4]
c0d03552:	4aa4      	ldr	r2, [pc, #656]	; (c0d037e4 <finalizeParsing+0x2e0>)
c0d03554:	322c      	adds	r2, #44	; 0x2c
c0d03556:	6002      	str	r2, [r0, #0]
c0d03558:	48a3      	ldr	r0, [pc, #652]	; (c0d037e8 <finalizeParsing+0x2e4>)
c0d0355a:	2501      	movs	r5, #1
c0d0355c:	2400      	movs	r4, #0
c0d0355e:	4629      	mov	r1, r5
c0d03560:	4623      	mov	r3, r4
c0d03562:	f003 f969 	bl	c0d06838 <cx_hash>
            0,
            tmpCtx.transactionContext.hash,
            32);

    // Finalize the plugin handling
    if (dataContext.tokenContext.pluginAvailable) {
c0d03566:	48a1      	ldr	r0, [pc, #644]	; (c0d037ec <finalizeParsing+0x2e8>)
c0d03568:	7f80      	ldrb	r0, [r0, #30]
c0d0356a:	2112      	movs	r1, #18
c0d0356c:	2800      	cmp	r0, #0
c0d0356e:	9508      	str	r5, [sp, #32]
c0d03570:	9105      	str	r1, [sp, #20]
c0d03572:	9406      	str	r4, [sp, #24]
c0d03574:	d046      	beq.n	c0d03604 <finalizeParsing+0x100>
c0d03576:	9604      	str	r6, [sp, #16]
c0d03578:	af0a      	add	r7, sp, #40	; 0x28
        genericUI = false;
        eth_plugin_prepare_finalize(&pluginFinalize);
c0d0357a:	4638      	mov	r0, r7
c0d0357c:	f7ff f992 	bl	c0d028a4 <eth_plugin_prepare_finalize>
c0d03580:	26ff      	movs	r6, #255	; 0xff
c0d03582:	3604      	adds	r6, #4
c0d03584:	2500      	movs	r5, #0
        if (!eth_plugin_call(NULL, ETH_PLUGIN_FINALIZE, (void *) &pluginFinalize)) {
c0d03586:	4628      	mov	r0, r5
c0d03588:	4631      	mov	r1, r6
c0d0358a:	463a      	mov	r2, r7
c0d0358c:	4f93      	ldr	r7, [pc, #588]	; (c0d037dc <finalizeParsing+0x2d8>)
c0d0358e:	f7ff fa79 	bl	c0d02a84 <eth_plugin_call>
c0d03592:	2800      	cmp	r0, #0
c0d03594:	d10a      	bne.n	c0d035ac <finalizeParsing+0xa8>
            PRINTF("Plugin finalize call failed\n");
c0d03596:	489b      	ldr	r0, [pc, #620]	; (c0d03804 <finalizeParsing+0x300>)
c0d03598:	4478      	add	r0, pc
c0d0359a:	f001 fd4f 	bl	c0d0503c <mcu_usb_printf>
c0d0359e:	9c09      	ldr	r4, [sp, #36]	; 0x24
            reportFinalizeError(direct);
c0d035a0:	4620      	mov	r0, r4
c0d035a2:	f7ff ff6b 	bl	c0d0347c <reportFinalizeError>
            if (!direct) {
c0d035a6:	2c00      	cmp	r4, #0
c0d035a8:	d100      	bne.n	c0d035ac <finalizeParsing+0xa8>
c0d035aa:	e112      	b.n	c0d037d2 <finalizeParsing+0x2ce>
                return;
            }
        }
        // Lookup tokens if requested
        if (pluginFinalize.tokenLookup1 != NULL) {
c0d035ac:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d035ae:	2800      	cmp	r0, #0
c0d035b0:	d02a      	beq.n	c0d03608 <finalizeParsing+0x104>
            ethPluginProvideToken_t pluginProvideToken;
            token1 = getKnownToken(pluginFinalize.tokenLookup1);
c0d035b2:	f000 f9e1 	bl	c0d03978 <getKnownToken>
c0d035b6:	4604      	mov	r4, r0
            if (pluginFinalize.tokenLookup2 != NULL) {
c0d035b8:	980e      	ldr	r0, [sp, #56]	; 0x38
c0d035ba:	2800      	cmp	r0, #0
c0d035bc:	d002      	beq.n	c0d035c4 <finalizeParsing+0xc0>
                token2 = getKnownToken(pluginFinalize.tokenLookup2);
c0d035be:	f000 f9db 	bl	c0d03978 <getKnownToken>
c0d035c2:	4605      	mov	r5, r0
c0d035c4:	af12      	add	r7, sp, #72	; 0x48
            }
            eth_plugin_prepare_provide_token(&pluginProvideToken, token1, token2);
c0d035c6:	4638      	mov	r0, r7
c0d035c8:	9403      	str	r4, [sp, #12]
c0d035ca:	4621      	mov	r1, r4
c0d035cc:	462a      	mov	r2, r5
c0d035ce:	f7ff f96e 	bl	c0d028ae <eth_plugin_prepare_provide_token>
            if (!eth_plugin_call(NULL, ETH_PLUGIN_PROVIDE_TOKEN, (void *) &pluginProvideToken)) {
c0d035d2:	1c71      	adds	r1, r6, #1
c0d035d4:	2000      	movs	r0, #0
c0d035d6:	463a      	mov	r2, r7
c0d035d8:	f7ff fa54 	bl	c0d02a84 <eth_plugin_call>
c0d035dc:	2800      	cmp	r0, #0
c0d035de:	d10a      	bne.n	c0d035f6 <finalizeParsing+0xf2>
                PRINTF("Plugin provide token call failed\n");
c0d035e0:	4889      	ldr	r0, [pc, #548]	; (c0d03808 <finalizeParsing+0x304>)
c0d035e2:	4478      	add	r0, pc
c0d035e4:	f001 fd2a 	bl	c0d0503c <mcu_usb_printf>
c0d035e8:	9c09      	ldr	r4, [sp, #36]	; 0x24
                reportFinalizeError(direct);
c0d035ea:	4620      	mov	r0, r4
c0d035ec:	f7ff ff46 	bl	c0d0347c <reportFinalizeError>
                if (!direct) {
c0d035f0:	2c00      	cmp	r4, #0
c0d035f2:	d100      	bne.n	c0d035f6 <finalizeParsing+0xf2>
c0d035f4:	e0ed      	b.n	c0d037d2 <finalizeParsing+0x2ce>
c0d035f6:	a812      	add	r0, sp, #72	; 0x48
                    return;
                }
            }
            pluginFinalize.result = pluginProvideToken.result;
c0d035f8:	7d00      	ldrb	r0, [r0, #20]
c0d035fa:	a90a      	add	r1, sp, #40	; 0x28
c0d035fc:	7788      	strb	r0, [r1, #30]
c0d035fe:	9908      	ldr	r1, [sp, #32]
c0d03600:	4f76      	ldr	r7, [pc, #472]	; (c0d037dc <finalizeParsing+0x2d8>)
c0d03602:	e006      	b.n	c0d03612 <finalizeParsing+0x10e>
c0d03604:	462c      	mov	r4, r5
c0d03606:	e009      	b.n	c0d0361c <finalizeParsing+0x118>
c0d03608:	a80a      	add	r0, sp, #40	; 0x28
        }
        if (pluginFinalize.result != ETH_PLUGIN_RESULT_FALLBACK) {
c0d0360a:	7f80      	ldrb	r0, [r0, #30]
c0d0360c:	2100      	movs	r1, #0
c0d0360e:	9103      	str	r1, [sp, #12]
c0d03610:	9908      	ldr	r1, [sp, #32]
c0d03612:	9c04      	ldr	r4, [sp, #16]
c0d03614:	4a75      	ldr	r2, [pc, #468]	; (c0d037ec <finalizeParsing+0x2e8>)
c0d03616:	2803      	cmp	r0, #3
c0d03618:	d143      	bne.n	c0d036a2 <finalizeParsing+0x19e>
c0d0361a:	460c      	mov	r4, r1
        } else {
            genericUI = true;
        }
    }

    if (dataPresent && !N_storage.dataAllowed) {
c0d0361c:	4874      	ldr	r0, [pc, #464]	; (c0d037f0 <finalizeParsing+0x2ec>)
c0d0361e:	7800      	ldrb	r0, [r0, #0]
c0d03620:	2800      	cmp	r0, #0
c0d03622:	d011      	beq.n	c0d03648 <finalizeParsing+0x144>
c0d03624:	487b      	ldr	r0, [pc, #492]	; (c0d03814 <finalizeParsing+0x310>)
c0d03626:	4478      	add	r0, pc
c0d03628:	f002 f886 	bl	c0d05738 <pic>
c0d0362c:	7800      	ldrb	r0, [r0, #0]
c0d0362e:	2800      	cmp	r0, #0
c0d03630:	d10a      	bne.n	c0d03648 <finalizeParsing+0x144>
        PRINTF("Data field forbidden\n");
c0d03632:	4879      	ldr	r0, [pc, #484]	; (c0d03818 <finalizeParsing+0x314>)
c0d03634:	4478      	add	r0, pc
c0d03636:	f001 fd01 	bl	c0d0503c <mcu_usb_printf>
c0d0363a:	9d09      	ldr	r5, [sp, #36]	; 0x24
        reportFinalizeError(direct);
c0d0363c:	4628      	mov	r0, r5
c0d0363e:	f7ff ff1d 	bl	c0d0347c <reportFinalizeError>
        if (!direct) {
c0d03642:	2d00      	cmp	r5, #0
c0d03644:	d100      	bne.n	c0d03648 <finalizeParsing+0x144>
c0d03646:	e0c4      	b.n	c0d037d2 <finalizeParsing+0x2ce>
            return;
        }
    }
    // Decode Theta Tx
    if (genericUI) {
c0d03648:	2c00      	cmp	r4, #0
c0d0364a:	9906      	ldr	r1, [sp, #24]
c0d0364c:	d062      	beq.n	c0d03714 <finalizeParsing+0x210>
        getThetaTxFromBinary(&txContext, &global_sha3, chainConfig);
c0d0364e:	683a      	ldr	r2, [r7, #0]
c0d03650:	4c68      	ldr	r4, [pc, #416]	; (c0d037f4 <finalizeParsing+0x2f0>)
c0d03652:	4965      	ldr	r1, [pc, #404]	; (c0d037e8 <finalizeParsing+0x2e4>)
c0d03654:	4620      	mov	r0, r4
c0d03656:	f7fe ffab 	bl	c0d025b0 <getThetaTxFromBinary>
        if (txContext.content->thetaTXtoken == 1) {
c0d0365a:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d0365c:	21fa      	movs	r1, #250	; 0xfa
c0d0365e:	5c40      	ldrb	r0, [r0, r1]
c0d03660:	2801      	cmp	r0, #1
c0d03662:	d104      	bne.n	c0d0366e <finalizeParsing+0x16a>
            ticker = (uint8_t *) PIC(chainConfig->coinName2);
c0d03664:	6838      	ldr	r0, [r7, #0]
c0d03666:	300a      	adds	r0, #10
c0d03668:	f002 f866 	bl	c0d05738 <pic>
c0d0366c:	9007      	str	r0, [sp, #28]
c0d0366e:	2047      	movs	r0, #71	; 0x47
c0d03670:	0080      	lsls	r0, r0, #2
        }
    }
    // Prepare destination address to display
    if (genericUI) {
        if (tmpContent.txContent.destinationLength != 0) {
c0d03672:	4c5b      	ldr	r4, [pc, #364]	; (c0d037e0 <finalizeParsing+0x2dc>)
c0d03674:	5c20      	ldrb	r0, [r4, r0]
c0d03676:	2800      	cmp	r0, #0
c0d03678:	d021      	beq.n	c0d036be <finalizeParsing+0x1ba>
c0d0367a:	ad12      	add	r5, sp, #72	; 0x48
c0d0367c:	2078      	movs	r0, #120	; 0x78
            displayBuffer[0] = '0';
            displayBuffer[1] = 'x';
c0d0367e:	7068      	strb	r0, [r5, #1]
c0d03680:	2030      	movs	r0, #48	; 0x30
            displayBuffer[0] = '0';
c0d03682:	7028      	strb	r0, [r5, #0]
c0d03684:	2021      	movs	r0, #33	; 0x21
c0d03686:	00c0      	lsls	r0, r0, #3
            getEthAddressStringFromBinary(tmpContent.txContent.destination,
c0d03688:	1820      	adds	r0, r4, r0
                                          (uint8_t *) displayBuffer + 2,
                                          &global_sha3,
                                          chainConfig);
c0d0368a:	683b      	ldr	r3, [r7, #0]
                                          (uint8_t *) displayBuffer + 2,
c0d0368c:	1ca9      	adds	r1, r5, #2
            getEthAddressStringFromBinary(tmpContent.txContent.destination,
c0d0368e:	4a56      	ldr	r2, [pc, #344]	; (c0d037e8 <finalizeParsing+0x2e4>)
c0d03690:	f7fe ff2a 	bl	c0d024e8 <getEthAddressStringFromBinary>
            compareOrCopy(strings.common.fullAddress, displayBuffer, called_from_swap);
c0d03694:	4858      	ldr	r0, [pc, #352]	; (c0d037f8 <finalizeParsing+0x2f4>)
c0d03696:	7802      	ldrb	r2, [r0, #0]
c0d03698:	4858      	ldr	r0, [pc, #352]	; (c0d037fc <finalizeParsing+0x2f8>)
c0d0369a:	4629      	mov	r1, r5
c0d0369c:	f7ff feb2 	bl	c0d03404 <compareOrCopy>
c0d036a0:	e013      	b.n	c0d036ca <finalizeParsing+0x1c6>
c0d036a2:	a80a      	add	r0, sp, #40	; 0x28
            switch (pluginFinalize.uiType) {
c0d036a4:	7f01      	ldrb	r1, [r0, #28]
c0d036a6:	2901      	cmp	r1, #1
c0d036a8:	d04f      	beq.n	c0d0374a <finalizeParsing+0x246>
c0d036aa:	2902      	cmp	r1, #2
c0d036ac:	d17f      	bne.n	c0d037ae <finalizeParsing+0x2aa>
c0d036ae:	a80a      	add	r0, sp, #40	; 0x28
                    dataContext.tokenContext.pluginUiMaxItems = pluginFinalize.numScreens;
c0d036b0:	7f40      	ldrb	r0, [r0, #29]
c0d036b2:	2141      	movs	r1, #65	; 0x41
c0d036b4:	5450      	strb	r0, [r2, r1]
                    dataPresent = false;
c0d036b6:	484e      	ldr	r0, [pc, #312]	; (c0d037f0 <finalizeParsing+0x2ec>)
c0d036b8:	2100      	movs	r1, #0
c0d036ba:	7001      	strb	r1, [r0, #0]
c0d036bc:	e02a      	b.n	c0d03714 <finalizeParsing+0x210>
        } else {
            strcpy(strings.common.fullAddress, "Contract");
c0d036be:	484f      	ldr	r0, [pc, #316]	; (c0d037fc <finalizeParsing+0x2f8>)
c0d036c0:	4956      	ldr	r1, [pc, #344]	; (c0d0381c <finalizeParsing+0x318>)
c0d036c2:	4479      	add	r1, pc
c0d036c4:	2209      	movs	r2, #9
c0d036c6:	f006 ffd7 	bl	c0d0a678 <__aeabi_memcpy>
c0d036ca:	2062      	movs	r0, #98	; 0x62
        }
    }
    // Prepare amount to display
    if (genericUI) {
        amountToString(tmpContent.txContent.value.value,
                       tmpContent.txContent.value.length,
c0d036cc:	5c21      	ldrb	r1, [r4, r0]
c0d036ce:	2632      	movs	r6, #50	; 0x32
        amountToString(tmpContent.txContent.value.value,
c0d036d0:	4668      	mov	r0, sp
c0d036d2:	6046      	str	r6, [r0, #4]
c0d036d4:	ad12      	add	r5, sp, #72	; 0x48
c0d036d6:	6005      	str	r5, [r0, #0]
                       tmpContent.txContent.value.length,
c0d036d8:	3442      	adds	r4, #66	; 0x42
        amountToString(tmpContent.txContent.value.value,
c0d036da:	4620      	mov	r0, r4
c0d036dc:	9a05      	ldr	r2, [sp, #20]
c0d036de:	9b07      	ldr	r3, [sp, #28]
c0d036e0:	f006 f8d8 	bl	c0d09894 <amountToString>
                       decimals,
                       (char *) ticker,
                       displayBuffer,
                       sizeof(displayBuffer));
        compareOrCopy(strings.common.fullAmount, displayBuffer, called_from_swap);
c0d036e4:	4f44      	ldr	r7, [pc, #272]	; (c0d037f8 <finalizeParsing+0x2f4>)
c0d036e6:	783a      	ldrb	r2, [r7, #0]
c0d036e8:	4c44      	ldr	r4, [pc, #272]	; (c0d037fc <finalizeParsing+0x2f8>)
c0d036ea:	4620      	mov	r0, r4
c0d036ec:	302b      	adds	r0, #43	; 0x2b
c0d036ee:	4629      	mov	r1, r5
c0d036f0:	f7ff fe88 	bl	c0d03404 <compareOrCopy>
    }
    // Compute maximum fee
    if (genericUI) {
        computeFees(displayBuffer, sizeof(displayBuffer));
c0d036f4:	4628      	mov	r0, r5
c0d036f6:	4631      	mov	r1, r6
c0d036f8:	f7ff fed0 	bl	c0d0349c <computeFees>
        PRINTF("jxlog95 displayBuffer is %s \n", displayBuffer);
c0d036fc:	4848      	ldr	r0, [pc, #288]	; (c0d03820 <finalizeParsing+0x31c>)
c0d036fe:	4478      	add	r0, pc
c0d03700:	4629      	mov	r1, r5
c0d03702:	f001 fc9b 	bl	c0d0503c <mcu_usb_printf>
        compareOrCopy(strings.common.maxFee, displayBuffer, called_from_swap);
c0d03706:	783a      	ldrb	r2, [r7, #0]
c0d03708:	345d      	adds	r4, #93	; 0x5d
c0d0370a:	4620      	mov	r0, r4
c0d0370c:	4629      	mov	r1, r5
c0d0370e:	f7ff fe79 	bl	c0d03404 <compareOrCopy>
c0d03712:	9908      	ldr	r1, [sp, #32]
    }

    bool no_consent = false;

    no_consent = called_from_swap;
c0d03714:	4838      	ldr	r0, [pc, #224]	; (c0d037f8 <finalizeParsing+0x2f4>)
c0d03716:	7800      	ldrb	r0, [r0, #0]

#ifdef NO_CONSENT
    no_consent = true;
#endif  // NO_CONSENT

    if (no_consent) {
c0d03718:	2800      	cmp	r0, #0
c0d0371a:	d003      	beq.n	c0d03724 <finalizeParsing+0x220>
c0d0371c:	2000      	movs	r0, #0
        io_seproxyhal_touch_tx_ok(NULL);
c0d0371e:	f004 f839 	bl	c0d07794 <io_seproxyhal_touch_tx_ok>
c0d03722:	e056      	b.n	c0d037d2 <finalizeParsing+0x2ce>
    } else {
        if (genericUI) {
c0d03724:	2900      	cmp	r1, #0
c0d03726:	d00d      	beq.n	c0d03744 <finalizeParsing+0x240>
            ux_flow_init(
                0,
                ((dataPresent && !N_storage.contractDetails) ? ux_approval_tx_data_warning_flow
c0d03728:	4831      	ldr	r0, [pc, #196]	; (c0d037f0 <finalizeParsing+0x2ec>)
c0d0372a:	7800      	ldrb	r0, [r0, #0]
c0d0372c:	2800      	cmp	r0, #0
c0d0372e:	d006      	beq.n	c0d0373e <finalizeParsing+0x23a>
c0d03730:	483c      	ldr	r0, [pc, #240]	; (c0d03824 <finalizeParsing+0x320>)
c0d03732:	4478      	add	r0, pc
c0d03734:	f002 f800 	bl	c0d05738 <pic>
c0d03738:	7840      	ldrb	r0, [r0, #1]
c0d0373a:	2800      	cmp	r0, #0
c0d0373c:	d043      	beq.n	c0d037c6 <finalizeParsing+0x2c2>
c0d0373e:	493b      	ldr	r1, [pc, #236]	; (c0d0382c <finalizeParsing+0x328>)
c0d03740:	4479      	add	r1, pc
c0d03742:	e042      	b.n	c0d037ca <finalizeParsing+0x2c6>
                                                             : ux_approval_tx_flow),
                NULL);
        } else {
            plugin_ui_start();
c0d03744:	f7ff fb5c 	bl	c0d02e00 <plugin_ui_start>
c0d03748:	e043      	b.n	c0d037d2 <finalizeParsing+0x2ce>
                    dataPresent = false;
c0d0374a:	4829      	ldr	r0, [pc, #164]	; (c0d037f0 <finalizeParsing+0x2ec>)
c0d0374c:	2100      	movs	r1, #0
c0d0374e:	7001      	strb	r1, [r0, #0]
                    if ((pluginFinalize.amount == NULL) || (pluginFinalize.address == NULL)) {
c0d03750:	990f      	ldr	r1, [sp, #60]	; 0x3c
c0d03752:	2900      	cmp	r1, #0
c0d03754:	d002      	beq.n	c0d0375c <finalizeParsing+0x258>
c0d03756:	9d10      	ldr	r5, [sp, #64]	; 0x40
c0d03758:	2d00      	cmp	r5, #0
c0d0375a:	d10c      	bne.n	c0d03776 <finalizeParsing+0x272>
                        PRINTF("Incorrect amount/address set by plugin\n");
c0d0375c:	482b      	ldr	r0, [pc, #172]	; (c0d0380c <finalizeParsing+0x308>)
c0d0375e:	4478      	add	r0, pc
c0d03760:	f001 fc6c 	bl	c0d0503c <mcu_usb_printf>
c0d03764:	9c09      	ldr	r4, [sp, #36]	; 0x24
                        reportFinalizeError(direct);
c0d03766:	4620      	mov	r0, r4
c0d03768:	f7ff fe88 	bl	c0d0347c <reportFinalizeError>
                        if (!direct) {
c0d0376c:	2c00      	cmp	r4, #0
c0d0376e:	d030      	beq.n	c0d037d2 <finalizeParsing+0x2ce>
                    memmove(tmpContent.txContent.destination, pluginFinalize.address, 20);
c0d03770:	9d10      	ldr	r5, [sp, #64]	; 0x40
                    memmove(tmpContent.txContent.value.value, pluginFinalize.amount, 32);
c0d03772:	990f      	ldr	r1, [sp, #60]	; 0x3c
c0d03774:	9c04      	ldr	r4, [sp, #16]
c0d03776:	4f1a      	ldr	r7, [pc, #104]	; (c0d037e0 <finalizeParsing+0x2dc>)
c0d03778:	4638      	mov	r0, r7
c0d0377a:	3042      	adds	r0, #66	; 0x42
c0d0377c:	4622      	mov	r2, r4
c0d0377e:	f006 ff7f 	bl	c0d0a680 <__aeabi_memmove>
c0d03782:	2062      	movs	r0, #98	; 0x62
                    tmpContent.txContent.value.length = 32;
c0d03784:	543c      	strb	r4, [r7, r0]
c0d03786:	2021      	movs	r0, #33	; 0x21
c0d03788:	00c0      	lsls	r0, r0, #3
                    memmove(tmpContent.txContent.destination, pluginFinalize.address, 20);
c0d0378a:	1838      	adds	r0, r7, r0
c0d0378c:	2614      	movs	r6, #20
c0d0378e:	4629      	mov	r1, r5
c0d03790:	4632      	mov	r2, r6
c0d03792:	f006 ff75 	bl	c0d0a680 <__aeabi_memmove>
c0d03796:	2047      	movs	r0, #71	; 0x47
c0d03798:	0080      	lsls	r0, r0, #2
                    tmpContent.txContent.destinationLength = 20;
c0d0379a:	543e      	strb	r6, [r7, r0]
c0d0379c:	9903      	ldr	r1, [sp, #12]
                    if (token1 != NULL) {
c0d0379e:	2900      	cmp	r1, #0
c0d037a0:	d019      	beq.n	c0d037d6 <finalizeParsing+0x2d2>
                        decimals = token1->decimals;
c0d037a2:	5d08      	ldrb	r0, [r1, r4]
                        ticker = token1->ticker;
c0d037a4:	9005      	str	r0, [sp, #20]
c0d037a6:	3114      	adds	r1, #20
c0d037a8:	9c08      	ldr	r4, [sp, #32]
c0d037aa:	9107      	str	r1, [sp, #28]
c0d037ac:	e014      	b.n	c0d037d8 <finalizeParsing+0x2d4>
                    PRINTF("ui type %d not supported\n", pluginFinalize.uiType);
c0d037ae:	4818      	ldr	r0, [pc, #96]	; (c0d03810 <finalizeParsing+0x30c>)
c0d037b0:	4478      	add	r0, pc
c0d037b2:	f001 fc43 	bl	c0d0503c <mcu_usb_printf>
c0d037b6:	9c09      	ldr	r4, [sp, #36]	; 0x24
                    reportFinalizeError(direct);
c0d037b8:	4620      	mov	r0, r4
c0d037ba:	f7ff fe5f 	bl	c0d0347c <reportFinalizeError>
                    if (!direct) {
c0d037be:	2c00      	cmp	r4, #0
c0d037c0:	d007      	beq.n	c0d037d2 <finalizeParsing+0x2ce>
c0d037c2:	2400      	movs	r4, #0
c0d037c4:	e72a      	b.n	c0d0361c <finalizeParsing+0x118>
c0d037c6:	4918      	ldr	r1, [pc, #96]	; (c0d03828 <finalizeParsing+0x324>)
c0d037c8:	4479      	add	r1, pc
c0d037ca:	2000      	movs	r0, #0
            ux_flow_init(
c0d037cc:	4602      	mov	r2, r0
c0d037ce:	f006 fa23 	bl	c0d09c18 <ux_flow_init>
        }
    }
}
c0d037d2:	b01f      	add	sp, #124	; 0x7c
c0d037d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d037d6:	9c08      	ldr	r4, [sp, #32]
c0d037d8:	4f00      	ldr	r7, [pc, #0]	; (c0d037dc <finalizeParsing+0x2d8>)
c0d037da:	e71f      	b.n	c0d0361c <finalizeParsing+0x118>
c0d037dc:	20001be0 	.word	0x20001be0
c0d037e0:	200018dc 	.word	0x200018dc
c0d037e4:	20001804 	.word	0x20001804
c0d037e8:	20001d60 	.word	0x20001d60
c0d037ec:	20001be4 	.word	0x20001be4
c0d037f0:	20001f08 	.word	0x20001f08
c0d037f4:	200018a0 	.word	0x200018a0
c0d037f8:	2000189c 	.word	0x2000189c
c0d037fc:	20001cca 	.word	0x20001cca
c0d03800:	00008810 	.word	0x00008810
c0d03804:	000087ce 	.word	0x000087ce
c0d03808:	000087a1 	.word	0x000087a1
c0d0380c:	00008647 	.word	0x00008647
c0d03810:	0000861d 	.word	0x0000861d
c0d03814:	0000a196 	.word	0x0000a196
c0d03818:	00008699 	.word	0x00008699
c0d0381c:	00007c4e 	.word	0x00007c4e
c0d03820:	000086e9 	.word	0x000086e9
c0d03824:	0000a08a 	.word	0x0000a08a
c0d03828:	000094c4 	.word	0x000094c4
c0d0382c:	00009530 	.word	0x00009530

c0d03830 <set_result_get_stark_publicKey>:
#ifdef HAVE_STARKWARE

#include "shared_context.h"
#include "feature_stark_getPublicKey.h"

uint32_t set_result_get_stark_publicKey() {
c0d03830:	b510      	push	{r4, lr}
    uint32_t tx = 0;
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.publicKey.W, 65);
c0d03832:	4904      	ldr	r1, [pc, #16]	; (c0d03844 <set_result_get_stark_publicKey+0x14>)
c0d03834:	3108      	adds	r1, #8
c0d03836:	4804      	ldr	r0, [pc, #16]	; (c0d03848 <set_result_get_stark_publicKey+0x18>)
c0d03838:	2441      	movs	r4, #65	; 0x41
c0d0383a:	4622      	mov	r2, r4
c0d0383c:	f006 ff1c 	bl	c0d0a678 <__aeabi_memcpy>
    tx += 65;
    return tx;
c0d03840:	4620      	mov	r0, r4
c0d03842:	bd10      	pop	{r4, pc}
c0d03844:	20001804 	.word	0x20001804
c0d03848:	20001f09 	.word	0x20001f09

c0d0384c <reset_app_context>:
void reset_app_context() {
c0d0384c:	b580      	push	{r7, lr}
c0d0384e:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03850:	4909      	ldr	r1, [pc, #36]	; (c0d03878 <reset_app_context+0x2c>)
c0d03852:	2200      	movs	r2, #0
c0d03854:	520a      	strh	r2, [r1, r0]
    appState = APP_STATE_IDLE;
c0d03856:	4809      	ldr	r0, [pc, #36]	; (c0d0387c <reset_app_context+0x30>)
c0d03858:	7002      	strb	r2, [r0, #0]
    called_from_swap = false;
c0d0385a:	4809      	ldr	r0, [pc, #36]	; (c0d03880 <reset_app_context+0x34>)
c0d0385c:	7002      	strb	r2, [r0, #0]
    quantumSet = false;
c0d0385e:	4809      	ldr	r0, [pc, #36]	; (c0d03884 <reset_app_context+0x38>)
c0d03860:	7002      	strb	r2, [r0, #0]
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03862:	4809      	ldr	r0, [pc, #36]	; (c0d03888 <reset_app_context+0x3c>)
c0d03864:	213c      	movs	r1, #60	; 0x3c
c0d03866:	f006 ff01 	bl	c0d0a66c <__aeabi_memclr>
c0d0386a:	2049      	movs	r0, #73	; 0x49
c0d0386c:	0081      	lsls	r1, r0, #2
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d0386e:	4807      	ldr	r0, [pc, #28]	; (c0d0388c <reset_app_context+0x40>)
c0d03870:	f006 fefc 	bl	c0d0a66c <__aeabi_memclr>
}
c0d03874:	bd80      	pop	{r7, pc}
c0d03876:	46c0      	nop			; (mov r8, r8)
c0d03878:	20001804 	.word	0x20001804
c0d0387c:	20001800 	.word	0x20001800
c0d03880:	2000189c 	.word	0x2000189c
c0d03884:	2000189d 	.word	0x2000189d
c0d03888:	200018a0 	.word	0x200018a0
c0d0388c:	200018dc 	.word	0x200018dc

c0d03890 <ui_idle>:
void ui_idle(void) {
c0d03890:	b580      	push	{r7, lr}
    if (G_ux.stack_count == 0) {
c0d03892:	4806      	ldr	r0, [pc, #24]	; (c0d038ac <ui_idle+0x1c>)
c0d03894:	7800      	ldrb	r0, [r0, #0]
c0d03896:	2800      	cmp	r0, #0
c0d03898:	d101      	bne.n	c0d0389e <ui_idle+0xe>
        ux_stack_push();
c0d0389a:	f006 fd79 	bl	c0d0a390 <ux_stack_push>
    ux_flow_init(0, ux_idle_flow, NULL);
c0d0389e:	4904      	ldr	r1, [pc, #16]	; (c0d038b0 <ui_idle+0x20>)
c0d038a0:	4479      	add	r1, pc
c0d038a2:	2000      	movs	r0, #0
c0d038a4:	4602      	mov	r2, r0
c0d038a6:	f006 f9b7 	bl	c0d09c18 <ux_flow_init>
}
c0d038aa:	bd80      	pop	{r7, pc}
c0d038ac:	20001a00 	.word	0x20001a00
c0d038b0:	00008e34 	.word	0x00008e34

c0d038b4 <io_seproxyhal_send_status>:
void io_seproxyhal_send_status(uint32_t sw) {
c0d038b4:	b580      	push	{r7, lr}
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0d038b6:	4904      	ldr	r1, [pc, #16]	; (c0d038c8 <io_seproxyhal_send_status+0x14>)
    G_io_apdu_buffer[1] = (sw & 0xff);
c0d038b8:	7048      	strb	r0, [r1, #1]
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0d038ba:	0a00      	lsrs	r0, r0, #8
c0d038bc:	7008      	strb	r0, [r1, #0]
c0d038be:	2020      	movs	r0, #32
c0d038c0:	2102      	movs	r1, #2
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d038c2:	f001 f8af 	bl	c0d04a24 <io_exchange>
}
c0d038c6:	bd80      	pop	{r7, pc}
c0d038c8:	20001f09 	.word	0x20001f09

c0d038cc <format_signature_out>:
void format_signature_out(const uint8_t *signature) {
c0d038cc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d038ce:	b081      	sub	sp, #4
c0d038d0:	4604      	mov	r4, r0
    memset(G_io_apdu_buffer + 1, 0x00, 64);
c0d038d2:	4817      	ldr	r0, [pc, #92]	; (c0d03930 <format_signature_out+0x64>)
c0d038d4:	1c40      	adds	r0, r0, #1
c0d038d6:	2140      	movs	r1, #64	; 0x40
c0d038d8:	f006 fec8 	bl	c0d0a66c <__aeabi_memclr>
    uint8_t xlength = signature[xoffset - 1];
c0d038dc:	78e0      	ldrb	r0, [r4, #3]
    if (xlength == 33) {
c0d038de:	2821      	cmp	r0, #33	; 0x21
c0d038e0:	d001      	beq.n	c0d038e6 <format_signature_out+0x1a>
c0d038e2:	2704      	movs	r7, #4
c0d038e4:	e000      	b.n	c0d038e8 <format_signature_out+0x1c>
c0d038e6:	2705      	movs	r7, #5
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0d038e8:	19e1      	adds	r1, r4, r7
c0d038ea:	2520      	movs	r5, #32
    if (xlength == 33) {
c0d038ec:	2821      	cmp	r0, #33	; 0x21
c0d038ee:	462e      	mov	r6, r5
c0d038f0:	d000      	beq.n	c0d038f4 <format_signature_out+0x28>
c0d038f2:	4606      	mov	r6, r0
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0d038f4:	480e      	ldr	r0, [pc, #56]	; (c0d03930 <format_signature_out+0x64>)
c0d038f6:	1b80      	subs	r0, r0, r6
c0d038f8:	3021      	adds	r0, #33	; 0x21
c0d038fa:	4632      	mov	r2, r6
c0d038fc:	f006 fec0 	bl	c0d0a680 <__aeabi_memmove>
    xoffset += xlength + 2;  // move over rvalue and TagLEn
c0d03900:	1cb8      	adds	r0, r7, #2
c0d03902:	1981      	adds	r1, r0, r6
    xlength = signature[xoffset - 1];
c0d03904:	b2c8      	uxtb	r0, r1
c0d03906:	1820      	adds	r0, r4, r0
c0d03908:	2200      	movs	r2, #0
c0d0390a:	43d2      	mvns	r2, r2
c0d0390c:	5c80      	ldrb	r0, [r0, r2]
    if (xlength == 33) {
c0d0390e:	2821      	cmp	r0, #33	; 0x21
c0d03910:	d100      	bne.n	c0d03914 <format_signature_out+0x48>
c0d03912:	1c49      	adds	r1, r1, #1
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0d03914:	b2c9      	uxtb	r1, r1
c0d03916:	1861      	adds	r1, r4, r1
    if (xlength == 33) {
c0d03918:	2821      	cmp	r0, #33	; 0x21
c0d0391a:	d000      	beq.n	c0d0391e <format_signature_out+0x52>
c0d0391c:	4605      	mov	r5, r0
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0d0391e:	4804      	ldr	r0, [pc, #16]	; (c0d03930 <format_signature_out+0x64>)
c0d03920:	1b40      	subs	r0, r0, r5
c0d03922:	3041      	adds	r0, #65	; 0x41
c0d03924:	462a      	mov	r2, r5
c0d03926:	f006 feab 	bl	c0d0a680 <__aeabi_memmove>
}
c0d0392a:	b001      	add	sp, #4
c0d0392c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0392e:	46c0      	nop			; (mov r8, r8)
c0d03930:	20001f09 	.word	0x20001f09

c0d03934 <io_exchange_al>:
unsigned short io_exchange_al(unsigned char channel, unsigned short tx_len) {
c0d03934:	b5b0      	push	{r4, r5, r7, lr}
c0d03936:	4605      	mov	r5, r0
c0d03938:	2007      	movs	r0, #7
    switch (channel & ~(IO_FLAGS)) {
c0d0393a:	4028      	ands	r0, r5
c0d0393c:	2400      	movs	r4, #0
c0d0393e:	2801      	cmp	r0, #1
c0d03940:	d012      	beq.n	c0d03968 <io_exchange_al+0x34>
c0d03942:	2802      	cmp	r0, #2
c0d03944:	d112      	bne.n	c0d0396c <io_exchange_al+0x38>
            if (tx_len) {
c0d03946:	2900      	cmp	r1, #0
c0d03948:	d007      	beq.n	c0d0395a <io_exchange_al+0x26>
                io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);
c0d0394a:	480a      	ldr	r0, [pc, #40]	; (c0d03974 <io_exchange_al+0x40>)
c0d0394c:	f003 f8ec 	bl	c0d06b28 <io_seph_send>
                if (channel & IO_RESET_AFTER_REPLIED) {
c0d03950:	0628      	lsls	r0, r5, #24
c0d03952:	d509      	bpl.n	c0d03968 <io_exchange_al+0x34>
                    reset();
c0d03954:	f002 ff4a 	bl	c0d067ec <halt>
c0d03958:	e006      	b.n	c0d03968 <io_exchange_al+0x34>
c0d0395a:	21ff      	movs	r1, #255	; 0xff
c0d0395c:	3152      	adds	r1, #82	; 0x52
                return io_seproxyhal_spi_recv(G_io_apdu_buffer, sizeof(G_io_apdu_buffer), 0);
c0d0395e:	4805      	ldr	r0, [pc, #20]	; (c0d03974 <io_exchange_al+0x40>)
c0d03960:	2200      	movs	r2, #0
c0d03962:	f003 f8f9 	bl	c0d06b58 <io_seph_recv>
c0d03966:	4604      	mov	r4, r0
}
c0d03968:	4620      	mov	r0, r4
c0d0396a:	bdb0      	pop	{r4, r5, r7, pc}
c0d0396c:	2002      	movs	r0, #2
            THROW(INVALID_PARAMETER);
c0d0396e:	f000 fd09 	bl	c0d04384 <os_longjmp>
c0d03972:	46c0      	nop			; (mov r8, r8)
c0d03974:	20001f09 	.word	0x20001f09

c0d03978 <getKnownToken>:
tokenDefinition_t *getKnownToken(uint8_t *contractAddress) {
c0d03978:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0397a:	b081      	sub	sp, #4
c0d0397c:	4606      	mov	r6, r0
c0d0397e:	4f0f      	ldr	r7, [pc, #60]	; (c0d039bc <getKnownToken+0x44>)
c0d03980:	463c      	mov	r4, r7
c0d03982:	344c      	adds	r4, #76	; 0x4c
c0d03984:	2500      	movs	r5, #0
        if (tmpCtx.transactionContext.tokenSet[i] &&
c0d03986:	1978      	adds	r0, r7, r5
c0d03988:	218e      	movs	r1, #142	; 0x8e
c0d0398a:	5c40      	ldrb	r0, [r0, r1]
c0d0398c:	2800      	cmp	r0, #0
c0d0398e:	d006      	beq.n	c0d0399e <getKnownToken+0x26>
c0d03990:	2214      	movs	r2, #20
            (memcmp(currentToken->address, contractAddress, 20) == 0)) {
c0d03992:	4620      	mov	r0, r4
c0d03994:	4631      	mov	r1, r6
c0d03996:	f006 fe83 	bl	c0d0a6a0 <memcmp>
        if (tmpCtx.transactionContext.tokenSet[i] &&
c0d0399a:	2800      	cmp	r0, #0
c0d0399c:	d005      	beq.n	c0d039aa <getKnownToken+0x32>
    for (size_t i = 0; i < MAX_TOKEN; i++) {
c0d0399e:	3421      	adds	r4, #33	; 0x21
c0d039a0:	1c6d      	adds	r5, r5, #1
c0d039a2:	2d02      	cmp	r5, #2
c0d039a4:	d3ef      	bcc.n	c0d03986 <getKnownToken+0xe>
c0d039a6:	2400      	movs	r4, #0
c0d039a8:	e004      	b.n	c0d039b4 <getKnownToken+0x3c>
            PRINTF("Token found at index %d\n", i);
c0d039aa:	4805      	ldr	r0, [pc, #20]	; (c0d039c0 <getKnownToken+0x48>)
c0d039ac:	4478      	add	r0, pc
c0d039ae:	4629      	mov	r1, r5
c0d039b0:	f001 fb44 	bl	c0d0503c <mcu_usb_printf>
}
c0d039b4:	4620      	mov	r0, r4
c0d039b6:	b001      	add	sp, #4
c0d039b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d039ba:	46c0      	nop			; (mov r8, r8)
c0d039bc:	20001804 	.word	0x20001804
c0d039c0:	00008459 	.word	0x00008459

c0d039c4 <handleApdu>:
void handleApdu(unsigned int *flags, unsigned int *tx) {
c0d039c4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d039c6:	b08f      	sub	sp, #60	; 0x3c
c0d039c8:	460c      	mov	r4, r1
c0d039ca:	4605      	mov	r5, r0
c0d039cc:	af03      	add	r7, sp, #12
        TRY {
c0d039ce:	4638      	mov	r0, r7
c0d039d0:	f006 ff86 	bl	c0d0a8e0 <setjmp>
c0d039d4:	85b8      	strh	r0, [r7, #44]	; 0x2c
c0d039d6:	b287      	uxth	r7, r0
c0d039d8:	2f00      	cmp	r7, #0
c0d039da:	d028      	beq.n	c0d03a2e <handleApdu+0x6a>
c0d039dc:	2f10      	cmp	r7, #16
c0d039de:	d100      	bne.n	c0d039e2 <handleApdu+0x1e>
c0d039e0:	e0eb      	b.n	c0d03bba <handleApdu+0x1f6>
c0d039e2:	4606      	mov	r6, r0
c0d039e4:	a803      	add	r0, sp, #12
c0d039e6:	2500      	movs	r5, #0
        CATCH_OTHER(e) {
c0d039e8:	8585      	strh	r5, [r0, #44]	; 0x2c
c0d039ea:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d039ec:	f003 f8d0 	bl	c0d06b90 <try_context_set>
c0d039f0:	200f      	movs	r0, #15
c0d039f2:	0300      	lsls	r0, r0, #12
            switch (e & 0xF000) {
c0d039f4:	4030      	ands	r0, r6
c0d039f6:	2109      	movs	r1, #9
c0d039f8:	0309      	lsls	r1, r1, #12
c0d039fa:	4288      	cmp	r0, r1
c0d039fc:	d015      	beq.n	c0d03a2a <handleApdu+0x66>
c0d039fe:	2103      	movs	r1, #3
c0d03a00:	0349      	lsls	r1, r1, #13
c0d03a02:	4288      	cmp	r0, r1
c0d03a04:	d13f      	bne.n	c0d03a86 <handleApdu+0xc2>
c0d03a06:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03a08:	4975      	ldr	r1, [pc, #468]	; (c0d03be0 <handleApdu+0x21c>)
c0d03a0a:	520d      	strh	r5, [r1, r0]
    appState = APP_STATE_IDLE;
c0d03a0c:	4875      	ldr	r0, [pc, #468]	; (c0d03be4 <handleApdu+0x220>)
c0d03a0e:	7005      	strb	r5, [r0, #0]
    called_from_swap = false;
c0d03a10:	4875      	ldr	r0, [pc, #468]	; (c0d03be8 <handleApdu+0x224>)
c0d03a12:	7005      	strb	r5, [r0, #0]
    quantumSet = false;
c0d03a14:	4875      	ldr	r0, [pc, #468]	; (c0d03bec <handleApdu+0x228>)
c0d03a16:	7005      	strb	r5, [r0, #0]
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03a18:	4875      	ldr	r0, [pc, #468]	; (c0d03bf0 <handleApdu+0x22c>)
c0d03a1a:	213c      	movs	r1, #60	; 0x3c
c0d03a1c:	f006 fe26 	bl	c0d0a66c <__aeabi_memclr>
c0d03a20:	2049      	movs	r0, #73	; 0x49
c0d03a22:	0081      	lsls	r1, r0, #2
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d03a24:	4873      	ldr	r0, [pc, #460]	; (c0d03bf4 <handleApdu+0x230>)
c0d03a26:	f006 fe21 	bl	c0d0a66c <__aeabi_memclr>
c0d03a2a:	0a38      	lsrs	r0, r7, #8
c0d03a2c:	e040      	b.n	c0d03ab0 <handleApdu+0xec>
c0d03a2e:	a803      	add	r0, sp, #12
        TRY {
c0d03a30:	f003 f8ae 	bl	c0d06b90 <try_context_set>
c0d03a34:	900d      	str	r0, [sp, #52]	; 0x34
            if (G_io_apdu_buffer[OFFSET_CLA] == STARKWARE_CLA) {
c0d03a36:	4a69      	ldr	r2, [pc, #420]	; (c0d03bdc <handleApdu+0x218>)
c0d03a38:	7810      	ldrb	r0, [r2, #0]
c0d03a3a:	28e0      	cmp	r0, #224	; 0xe0
c0d03a3c:	d011      	beq.n	c0d03a62 <handleApdu+0x9e>
c0d03a3e:	28f0      	cmp	r0, #240	; 0xf0
c0d03a40:	d000      	beq.n	c0d03a44 <handleApdu+0x80>
c0d03a42:	e0c3      	b.n	c0d03bcc <handleApdu+0x208>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03a44:	7850      	ldrb	r0, [r2, #1]
c0d03a46:	2807      	cmp	r0, #7
c0d03a48:	dc49      	bgt.n	c0d03ade <handleApdu+0x11a>
c0d03a4a:	2802      	cmp	r0, #2
c0d03a4c:	d161      	bne.n	c0d03b12 <handleApdu+0x14e>
                                                    G_io_apdu_buffer[OFFSET_LC],
c0d03a4e:	7913      	ldrb	r3, [r2, #4]
                                                    G_io_apdu_buffer[OFFSET_P2],
c0d03a50:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareGetPublicKey(G_io_apdu_buffer[OFFSET_P1],
c0d03a52:	7890      	ldrb	r0, [r2, #2]
c0d03a54:	466e      	mov	r6, sp
c0d03a56:	6035      	str	r5, [r6, #0]
c0d03a58:	6074      	str	r4, [r6, #4]
c0d03a5a:	1d52      	adds	r2, r2, #5
c0d03a5c:	f7fc ffee 	bl	c0d00a3c <handleStarkwareGetPublicKey>
c0d03a60:	e06e      	b.n	c0d03b40 <handleApdu+0x17c>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03a62:	7850      	ldrb	r0, [r2, #1]
c0d03a64:	2807      	cmp	r0, #7
c0d03a66:	dc46      	bgt.n	c0d03af6 <handleApdu+0x132>
c0d03a68:	2802      	cmp	r0, #2
c0d03a6a:	d06e      	beq.n	c0d03b4a <handleApdu+0x186>
c0d03a6c:	2804      	cmp	r0, #4
c0d03a6e:	d000      	beq.n	c0d03a72 <handleApdu+0xae>
c0d03a70:	e087      	b.n	c0d03b82 <handleApdu+0x1be>
                               G_io_apdu_buffer[OFFSET_LC],
c0d03a72:	7913      	ldrb	r3, [r2, #4]
                               G_io_apdu_buffer[OFFSET_P2],
c0d03a74:	78d1      	ldrb	r1, [r2, #3]
                    handleSign(G_io_apdu_buffer[OFFSET_P1],
c0d03a76:	7890      	ldrb	r0, [r2, #2]
c0d03a78:	466e      	mov	r6, sp
c0d03a7a:	6035      	str	r5, [r6, #0]
c0d03a7c:	6074      	str	r4, [r6, #4]
c0d03a7e:	1d52      	adds	r2, r2, #5
c0d03a80:	f7fc ff28 	bl	c0d008d4 <handleSign>
c0d03a84:	e01d      	b.n	c0d03ac2 <handleApdu+0xfe>
c0d03a86:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03a88:	4955      	ldr	r1, [pc, #340]	; (c0d03be0 <handleApdu+0x21c>)
c0d03a8a:	520d      	strh	r5, [r1, r0]
    appState = APP_STATE_IDLE;
c0d03a8c:	4855      	ldr	r0, [pc, #340]	; (c0d03be4 <handleApdu+0x220>)
c0d03a8e:	7005      	strb	r5, [r0, #0]
    called_from_swap = false;
c0d03a90:	4855      	ldr	r0, [pc, #340]	; (c0d03be8 <handleApdu+0x224>)
c0d03a92:	7005      	strb	r5, [r0, #0]
    quantumSet = false;
c0d03a94:	4855      	ldr	r0, [pc, #340]	; (c0d03bec <handleApdu+0x228>)
c0d03a96:	7005      	strb	r5, [r0, #0]
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03a98:	4855      	ldr	r0, [pc, #340]	; (c0d03bf0 <handleApdu+0x22c>)
c0d03a9a:	213c      	movs	r1, #60	; 0x3c
c0d03a9c:	f006 fde6 	bl	c0d0a66c <__aeabi_memclr>
c0d03aa0:	2049      	movs	r0, #73	; 0x49
c0d03aa2:	0081      	lsls	r1, r0, #2
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d03aa4:	4853      	ldr	r0, [pc, #332]	; (c0d03bf4 <handleApdu+0x230>)
c0d03aa6:	f006 fde1 	bl	c0d0a66c <__aeabi_memclr>
                    break;
c0d03aaa:	0570      	lsls	r0, r6, #21
c0d03aac:	0f40      	lsrs	r0, r0, #29
c0d03aae:	3068      	adds	r0, #104	; 0x68
            G_io_apdu_buffer[*tx] = sw >> 8;
c0d03ab0:	6821      	ldr	r1, [r4, #0]
c0d03ab2:	4a4a      	ldr	r2, [pc, #296]	; (c0d03bdc <handleApdu+0x218>)
c0d03ab4:	5450      	strb	r0, [r2, r1]
            G_io_apdu_buffer[*tx + 1] = sw;
c0d03ab6:	6820      	ldr	r0, [r4, #0]
            G_io_apdu_buffer[*tx] = sw >> 8;
c0d03ab8:	1810      	adds	r0, r2, r0
            G_io_apdu_buffer[*tx + 1] = sw;
c0d03aba:	7046      	strb	r6, [r0, #1]
            *tx += 2;
c0d03abc:	6820      	ldr	r0, [r4, #0]
c0d03abe:	1c80      	adds	r0, r0, #2
c0d03ac0:	6020      	str	r0, [r4, #0]
        FINALLY {
c0d03ac2:	f003 f859 	bl	c0d06b78 <try_context_get>
c0d03ac6:	a903      	add	r1, sp, #12
c0d03ac8:	4288      	cmp	r0, r1
c0d03aca:	d102      	bne.n	c0d03ad2 <handleApdu+0x10e>
c0d03acc:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d03ace:	f003 f85f 	bl	c0d06b90 <try_context_set>
c0d03ad2:	a803      	add	r0, sp, #12
    END_TRY;
c0d03ad4:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d03ad6:	2800      	cmp	r0, #0
c0d03ad8:	d035      	beq.n	c0d03b46 <handleApdu+0x182>
c0d03ada:	f000 fc53 	bl	c0d04384 <os_longjmp>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03ade:	2808      	cmp	r0, #8
c0d03ae0:	d123      	bne.n	c0d03b2a <handleApdu+0x166>
                                                      G_io_apdu_buffer[OFFSET_LC],
c0d03ae2:	7913      	ldrb	r3, [r2, #4]
                                                      G_io_apdu_buffer[OFFSET_P2],
c0d03ae4:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareProvideQuantum(G_io_apdu_buffer[OFFSET_P1],
c0d03ae6:	7890      	ldrb	r0, [r2, #2]
c0d03ae8:	466e      	mov	r6, sp
c0d03aea:	6035      	str	r5, [r6, #0]
c0d03aec:	6074      	str	r4, [r6, #4]
c0d03aee:	1d52      	adds	r2, r2, #5
c0d03af0:	f7fd f828 	bl	c0d00b44 <handleStarkwareProvideQuantum>
c0d03af4:	e024      	b.n	c0d03b40 <handleApdu+0x17c>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03af6:	2808      	cmp	r0, #8
c0d03af8:	d035      	beq.n	c0d03b66 <handleApdu+0x1a2>
c0d03afa:	280a      	cmp	r0, #10
c0d03afc:	d14d      	bne.n	c0d03b9a <handleApdu+0x1d6>
                                                       G_io_apdu_buffer[OFFSET_LC],
c0d03afe:	7913      	ldrb	r3, [r2, #4]
                                                       G_io_apdu_buffer[OFFSET_P2],
c0d03b00:	78d1      	ldrb	r1, [r2, #3]
                    handleProvideErc20TokenInformation(G_io_apdu_buffer[OFFSET_P1],
c0d03b02:	7890      	ldrb	r0, [r2, #2]
c0d03b04:	466e      	mov	r6, sp
c0d03b06:	6035      	str	r5, [r6, #0]
c0d03b08:	6074      	str	r4, [r6, #4]
c0d03b0a:	1d52      	adds	r2, r2, #5
c0d03b0c:	f7fc fcb4 	bl	c0d00478 <handleProvideErc20TokenInformation>
c0d03b10:	e7d7      	b.n	c0d03ac2 <handleApdu+0xfe>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03b12:	2804      	cmp	r0, #4
c0d03b14:	d15e      	bne.n	c0d03bd4 <handleApdu+0x210>
                                                   G_io_apdu_buffer[OFFSET_LC],
c0d03b16:	7913      	ldrb	r3, [r2, #4]
                                                   G_io_apdu_buffer[OFFSET_P2],
c0d03b18:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareSignMessage(G_io_apdu_buffer[OFFSET_P1],
c0d03b1a:	7890      	ldrb	r0, [r2, #2]
c0d03b1c:	466e      	mov	r6, sp
c0d03b1e:	6035      	str	r5, [r6, #0]
c0d03b20:	6074      	str	r4, [r6, #4]
c0d03b22:	1d52      	adds	r2, r2, #5
c0d03b24:	f7fd f880 	bl	c0d00c28 <handleStarkwareSignMessage>
c0d03b28:	e00a      	b.n	c0d03b40 <handleApdu+0x17c>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03b2a:	280a      	cmp	r0, #10
c0d03b2c:	d152      	bne.n	c0d03bd4 <handleApdu+0x210>
                                                  G_io_apdu_buffer[OFFSET_LC],
c0d03b2e:	7913      	ldrb	r3, [r2, #4]
                                                  G_io_apdu_buffer[OFFSET_P2],
c0d03b30:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareUnsafeSign(G_io_apdu_buffer[OFFSET_P1],
c0d03b32:	7890      	ldrb	r0, [r2, #2]
c0d03b34:	466e      	mov	r6, sp
c0d03b36:	6035      	str	r5, [r6, #0]
c0d03b38:	6074      	str	r4, [r6, #4]
c0d03b3a:	1d52      	adds	r2, r2, #5
c0d03b3c:	f7fd fbcc 	bl	c0d012d8 <handleStarkwareUnsafeSign>
                CLOSE_TRY;
c0d03b40:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d03b42:	f003 f825 	bl	c0d06b90 <try_context_set>
}
c0d03b46:	b00f      	add	sp, #60	; 0x3c
c0d03b48:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03b4a:	208e      	movs	r0, #142	; 0x8e
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03b4c:	4924      	ldr	r1, [pc, #144]	; (c0d03be0 <handleApdu+0x21c>)
c0d03b4e:	2300      	movs	r3, #0
c0d03b50:	520b      	strh	r3, [r1, r0]
                                       G_io_apdu_buffer[OFFSET_LC],
c0d03b52:	7913      	ldrb	r3, [r2, #4]
                                       G_io_apdu_buffer[OFFSET_P2],
c0d03b54:	78d1      	ldrb	r1, [r2, #3]
                    handleGetPublicKey(G_io_apdu_buffer[OFFSET_P1],
c0d03b56:	7890      	ldrb	r0, [r2, #2]
c0d03b58:	466e      	mov	r6, sp
c0d03b5a:	6035      	str	r5, [r6, #0]
c0d03b5c:	6074      	str	r4, [r6, #4]
c0d03b5e:	1d52      	adds	r2, r2, #5
c0d03b60:	f7fc fbe6 	bl	c0d00330 <handleGetPublicKey>
c0d03b64:	e7ad      	b.n	c0d03ac2 <handleApdu+0xfe>
c0d03b66:	208e      	movs	r0, #142	; 0x8e
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03b68:	491d      	ldr	r1, [pc, #116]	; (c0d03be0 <handleApdu+0x21c>)
c0d03b6a:	2300      	movs	r3, #0
c0d03b6c:	520b      	strh	r3, [r1, r0]
                                              G_io_apdu_buffer[OFFSET_LC],
c0d03b6e:	7913      	ldrb	r3, [r2, #4]
                                              G_io_apdu_buffer[OFFSET_P2],
c0d03b70:	78d1      	ldrb	r1, [r2, #3]
                    handleSignPersonalMessage(G_io_apdu_buffer[OFFSET_P1],
c0d03b72:	7890      	ldrb	r0, [r2, #2]
c0d03b74:	466e      	mov	r6, sp
c0d03b76:	6035      	str	r5, [r6, #0]
c0d03b78:	6074      	str	r4, [r6, #4]
c0d03b7a:	1d52      	adds	r2, r2, #5
c0d03b7c:	f7fc fd0e 	bl	c0d0059c <handleSignPersonalMessage>
c0d03b80:	e79f      	b.n	c0d03ac2 <handleApdu+0xfe>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03b82:	2806      	cmp	r0, #6
c0d03b84:	d126      	bne.n	c0d03bd4 <handleApdu+0x210>
                                              G_io_apdu_buffer[OFFSET_LC],
c0d03b86:	7913      	ldrb	r3, [r2, #4]
                                              G_io_apdu_buffer[OFFSET_P2],
c0d03b88:	78d1      	ldrb	r1, [r2, #3]
                    handleGetAppConfiguration(G_io_apdu_buffer[OFFSET_P1],
c0d03b8a:	7890      	ldrb	r0, [r2, #2]
c0d03b8c:	466e      	mov	r6, sp
c0d03b8e:	6035      	str	r5, [r6, #0]
c0d03b90:	6074      	str	r4, [r6, #4]
c0d03b92:	1d52      	adds	r2, r2, #5
c0d03b94:	f7fc fbb0 	bl	c0d002f8 <handleGetAppConfiguration>
c0d03b98:	e793      	b.n	c0d03ac2 <handleApdu+0xfe>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03b9a:	280c      	cmp	r0, #12
c0d03b9c:	d11a      	bne.n	c0d03bd4 <handleApdu+0x210>
c0d03b9e:	208e      	movs	r0, #142	; 0x8e
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03ba0:	490f      	ldr	r1, [pc, #60]	; (c0d03be0 <handleApdu+0x21c>)
c0d03ba2:	2300      	movs	r3, #0
c0d03ba4:	520b      	strh	r3, [r1, r0]
                                            G_io_apdu_buffer[OFFSET_LC],
c0d03ba6:	7913      	ldrb	r3, [r2, #4]
                                            G_io_apdu_buffer[OFFSET_P2],
c0d03ba8:	78d1      	ldrb	r1, [r2, #3]
                    handleSignEIP712Message(G_io_apdu_buffer[OFFSET_P1],
c0d03baa:	7890      	ldrb	r0, [r2, #2]
c0d03bac:	466e      	mov	r6, sp
c0d03bae:	6035      	str	r5, [r6, #0]
c0d03bb0:	6074      	str	r4, [r6, #4]
c0d03bb2:	1d52      	adds	r2, r2, #5
c0d03bb4:	f7fc fe22 	bl	c0d007fc <handleSignEIP712Message>
c0d03bb8:	e783      	b.n	c0d03ac2 <handleApdu+0xfe>
c0d03bba:	a803      	add	r0, sp, #12
c0d03bbc:	2100      	movs	r1, #0
        CATCH(EXCEPTION_IO_RESET) {
c0d03bbe:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d03bc0:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d03bc2:	f002 ffe5 	bl	c0d06b90 <try_context_set>
c0d03bc6:	2010      	movs	r0, #16
            THROW(EXCEPTION_IO_RESET);
c0d03bc8:	f000 fbdc 	bl	c0d04384 <os_longjmp>
c0d03bcc:	2037      	movs	r0, #55	; 0x37
c0d03bce:	0240      	lsls	r0, r0, #9
                THROW(0x6E00);
c0d03bd0:	f000 fbd8 	bl	c0d04384 <os_longjmp>
c0d03bd4:	206d      	movs	r0, #109	; 0x6d
c0d03bd6:	0200      	lsls	r0, r0, #8
c0d03bd8:	f000 fbd4 	bl	c0d04384 <os_longjmp>
c0d03bdc:	20001f09 	.word	0x20001f09
c0d03be0:	20001804 	.word	0x20001804
c0d03be4:	20001800 	.word	0x20001800
c0d03be8:	2000189c 	.word	0x2000189c
c0d03bec:	2000189d 	.word	0x2000189d
c0d03bf0:	200018a0 	.word	0x200018a0
c0d03bf4:	200018dc 	.word	0x200018dc

c0d03bf8 <app_main>:
void app_main(void) {
c0d03bf8:	b090      	sub	sp, #64	; 0x40
c0d03bfa:	2400      	movs	r4, #0
    unsigned int tx = 0;
c0d03bfc:	940f      	str	r4, [sp, #60]	; 0x3c
    unsigned int flags = 0;
c0d03bfe:	940e      	str	r4, [sp, #56]	; 0x38
c0d03c00:	484a      	ldr	r0, [pc, #296]	; (c0d03d2c <app_main+0x134>)
c0d03c02:	4478      	add	r0, pc
c0d03c04:	9001      	str	r0, [sp, #4]
c0d03c06:	4d41      	ldr	r5, [pc, #260]	; (c0d03d0c <app_main+0x114>)
c0d03c08:	af02      	add	r7, sp, #8
            TRY {
c0d03c0a:	4638      	mov	r0, r7
c0d03c0c:	f006 fe68 	bl	c0d0a8e0 <setjmp>
c0d03c10:	85b8      	strh	r0, [r7, #44]	; 0x2c
c0d03c12:	b287      	uxth	r7, r0
c0d03c14:	2f00      	cmp	r7, #0
c0d03c16:	d026      	beq.n	c0d03c66 <app_main+0x6e>
c0d03c18:	2f10      	cmp	r7, #16
c0d03c1a:	d06c      	beq.n	c0d03cf6 <app_main+0xfe>
c0d03c1c:	4606      	mov	r6, r0
c0d03c1e:	a802      	add	r0, sp, #8
            CATCH_OTHER(e) {
c0d03c20:	8584      	strh	r4, [r0, #44]	; 0x2c
c0d03c22:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d03c24:	f002 ffb4 	bl	c0d06b90 <try_context_set>
c0d03c28:	200f      	movs	r0, #15
c0d03c2a:	0300      	lsls	r0, r0, #12
                switch (e & 0xF000) {
c0d03c2c:	4030      	ands	r0, r6
c0d03c2e:	2109      	movs	r1, #9
c0d03c30:	030d      	lsls	r5, r1, #12
c0d03c32:	42a8      	cmp	r0, r5
c0d03c34:	d015      	beq.n	c0d03c62 <app_main+0x6a>
c0d03c36:	2103      	movs	r1, #3
c0d03c38:	0349      	lsls	r1, r1, #13
c0d03c3a:	4288      	cmp	r0, r1
c0d03c3c:	d12b      	bne.n	c0d03c96 <app_main+0x9e>
c0d03c3e:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03c40:	4934      	ldr	r1, [pc, #208]	; (c0d03d14 <app_main+0x11c>)
c0d03c42:	520c      	strh	r4, [r1, r0]
    appState = APP_STATE_IDLE;
c0d03c44:	4834      	ldr	r0, [pc, #208]	; (c0d03d18 <app_main+0x120>)
c0d03c46:	7004      	strb	r4, [r0, #0]
    called_from_swap = false;
c0d03c48:	4834      	ldr	r0, [pc, #208]	; (c0d03d1c <app_main+0x124>)
c0d03c4a:	7004      	strb	r4, [r0, #0]
    quantumSet = false;
c0d03c4c:	4834      	ldr	r0, [pc, #208]	; (c0d03d20 <app_main+0x128>)
c0d03c4e:	7004      	strb	r4, [r0, #0]
c0d03c50:	213c      	movs	r1, #60	; 0x3c
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03c52:	4834      	ldr	r0, [pc, #208]	; (c0d03d24 <app_main+0x12c>)
c0d03c54:	f006 fd0a 	bl	c0d0a66c <__aeabi_memclr>
c0d03c58:	2049      	movs	r0, #73	; 0x49
c0d03c5a:	0081      	lsls	r1, r0, #2
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d03c5c:	4832      	ldr	r0, [pc, #200]	; (c0d03d28 <app_main+0x130>)
c0d03c5e:	f006 fd05 	bl	c0d0a66c <__aeabi_memclr>
c0d03c62:	0a38      	lsrs	r0, r7, #8
c0d03c64:	e02c      	b.n	c0d03cc0 <app_main+0xc8>
c0d03c66:	a802      	add	r0, sp, #8
            TRY {
c0d03c68:	f002 ff92 	bl	c0d06b90 <try_context_set>
c0d03c6c:	900c      	str	r0, [sp, #48]	; 0x30
c0d03c6e:	a80f      	add	r0, sp, #60	; 0x3c
                rx = tx;
c0d03c70:	8801      	ldrh	r1, [r0, #0]
                tx = 0;  // ensure no race in catch_other if io_exchange throws
c0d03c72:	940f      	str	r4, [sp, #60]	; 0x3c
c0d03c74:	a80e      	add	r0, sp, #56	; 0x38
                rx = io_exchange(CHANNEL_APDU | flags, rx);
c0d03c76:	7800      	ldrb	r0, [r0, #0]
c0d03c78:	f000 fed4 	bl	c0d04a24 <io_exchange>
                flags = 0;
c0d03c7c:	940e      	str	r4, [sp, #56]	; 0x38
                if (rx == 0) {
c0d03c7e:	2800      	cmp	r0, #0
c0d03c80:	d041      	beq.n	c0d03d06 <app_main+0x10e>
c0d03c82:	4601      	mov	r1, r0
                PRINTF("New APDU received:\n%.*H\n", rx, G_io_apdu_buffer);
c0d03c84:	9801      	ldr	r0, [sp, #4]
c0d03c86:	462a      	mov	r2, r5
c0d03c88:	f001 f9d8 	bl	c0d0503c <mcu_usb_printf>
c0d03c8c:	a80e      	add	r0, sp, #56	; 0x38
c0d03c8e:	a90f      	add	r1, sp, #60	; 0x3c
                handleApdu(&flags, &tx);
c0d03c90:	f7ff fe98 	bl	c0d039c4 <handleApdu>
c0d03c94:	e021      	b.n	c0d03cda <app_main+0xe2>
c0d03c96:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03c98:	491e      	ldr	r1, [pc, #120]	; (c0d03d14 <app_main+0x11c>)
c0d03c9a:	520c      	strh	r4, [r1, r0]
    appState = APP_STATE_IDLE;
c0d03c9c:	481e      	ldr	r0, [pc, #120]	; (c0d03d18 <app_main+0x120>)
c0d03c9e:	7004      	strb	r4, [r0, #0]
    called_from_swap = false;
c0d03ca0:	481e      	ldr	r0, [pc, #120]	; (c0d03d1c <app_main+0x124>)
c0d03ca2:	7004      	strb	r4, [r0, #0]
    quantumSet = false;
c0d03ca4:	481e      	ldr	r0, [pc, #120]	; (c0d03d20 <app_main+0x128>)
c0d03ca6:	7004      	strb	r4, [r0, #0]
c0d03ca8:	213c      	movs	r1, #60	; 0x3c
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03caa:	481e      	ldr	r0, [pc, #120]	; (c0d03d24 <app_main+0x12c>)
c0d03cac:	f006 fcde 	bl	c0d0a66c <__aeabi_memclr>
c0d03cb0:	2049      	movs	r0, #73	; 0x49
c0d03cb2:	0081      	lsls	r1, r0, #2
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d03cb4:	481c      	ldr	r0, [pc, #112]	; (c0d03d28 <app_main+0x130>)
c0d03cb6:	f006 fcd9 	bl	c0d0a66c <__aeabi_memclr>
                        break;
c0d03cba:	0570      	lsls	r0, r6, #21
c0d03cbc:	0f40      	lsrs	r0, r0, #29
c0d03cbe:	3068      	adds	r0, #104	; 0x68
                if (e != 0x9000) {
c0d03cc0:	42af      	cmp	r7, r5
c0d03cc2:	d003      	beq.n	c0d03ccc <app_main+0xd4>
c0d03cc4:	2110      	movs	r1, #16
                    flags &= ~IO_ASYNCH_REPLY;
c0d03cc6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
c0d03cc8:	438a      	bics	r2, r1
c0d03cca:	920e      	str	r2, [sp, #56]	; 0x38
                G_io_apdu_buffer[tx] = sw >> 8;
c0d03ccc:	990f      	ldr	r1, [sp, #60]	; 0x3c
c0d03cce:	4d0f      	ldr	r5, [pc, #60]	; (c0d03d0c <app_main+0x114>)
c0d03cd0:	5468      	strb	r0, [r5, r1]
c0d03cd2:	1868      	adds	r0, r5, r1
                G_io_apdu_buffer[tx + 1] = sw;
c0d03cd4:	7046      	strb	r6, [r0, #1]
                tx += 2;
c0d03cd6:	1c88      	adds	r0, r1, #2
c0d03cd8:	900f      	str	r0, [sp, #60]	; 0x3c
            FINALLY {
c0d03cda:	f002 ff4d 	bl	c0d06b78 <try_context_get>
c0d03cde:	a902      	add	r1, sp, #8
c0d03ce0:	4288      	cmp	r0, r1
c0d03ce2:	d102      	bne.n	c0d03cea <app_main+0xf2>
c0d03ce4:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d03ce6:	f002 ff53 	bl	c0d06b90 <try_context_set>
c0d03cea:	a802      	add	r0, sp, #8
        END_TRY;
c0d03cec:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d03cee:	2800      	cmp	r0, #0
c0d03cf0:	d08a      	beq.n	c0d03c08 <app_main+0x10>
c0d03cf2:	f000 fb47 	bl	c0d04384 <os_longjmp>
c0d03cf6:	a802      	add	r0, sp, #8
            CATCH(EXCEPTION_IO_RESET) {
c0d03cf8:	8584      	strh	r4, [r0, #44]	; 0x2c
c0d03cfa:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d03cfc:	f002 ff48 	bl	c0d06b90 <try_context_set>
c0d03d00:	2010      	movs	r0, #16
                THROW(EXCEPTION_IO_RESET);
c0d03d02:	f000 fb3f 	bl	c0d04384 <os_longjmp>
c0d03d06:	4802      	ldr	r0, [pc, #8]	; (c0d03d10 <app_main+0x118>)
                    THROW(0x6982);
c0d03d08:	f000 fb3c 	bl	c0d04384 <os_longjmp>
c0d03d0c:	20001f09 	.word	0x20001f09
c0d03d10:	00006982 	.word	0x00006982
c0d03d14:	20001804 	.word	0x20001804
c0d03d18:	20001800 	.word	0x20001800
c0d03d1c:	2000189c 	.word	0x2000189c
c0d03d20:	2000189d 	.word	0x2000189d
c0d03d24:	200018a0 	.word	0x200018a0
c0d03d28:	200018dc 	.word	0x200018dc
c0d03d2c:	0000821c 	.word	0x0000821c

c0d03d30 <io_seproxyhal_display>:
void io_seproxyhal_display(const bagl_element_t *element) {
c0d03d30:	b580      	push	{r7, lr}
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d03d32:	f000 fddf 	bl	c0d048f4 <io_seproxyhal_display_default>
}
c0d03d36:	bd80      	pop	{r7, pc}

c0d03d38 <io_event>:
unsigned char io_event(unsigned char channel) {
c0d03d38:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d03d3a:	b081      	sub	sp, #4
    switch (G_io_seproxyhal_spi_buffer[0]) {
c0d03d3c:	4de7      	ldr	r5, [pc, #924]	; (c0d040dc <io_event+0x3a4>)
c0d03d3e:	7828      	ldrb	r0, [r5, #0]
c0d03d40:	280c      	cmp	r0, #12
c0d03d42:	dc05      	bgt.n	c0d03d50 <io_event+0x18>
c0d03d44:	2805      	cmp	r0, #5
c0d03d46:	d100      	bne.n	c0d03d4a <io_event+0x12>
c0d03d48:	e098      	b.n	c0d03e7c <io_event+0x144>
c0d03d4a:	280c      	cmp	r0, #12
c0d03d4c:	d10d      	bne.n	c0d03d6a <io_event+0x32>
c0d03d4e:	e1b9      	b.n	c0d040c4 <io_event+0x38c>
c0d03d50:	280d      	cmp	r0, #13
c0d03d52:	d100      	bne.n	c0d03d56 <io_event+0x1e>
c0d03d54:	e0ec      	b.n	c0d03f30 <io_event+0x1f8>
c0d03d56:	2815      	cmp	r0, #21
c0d03d58:	d107      	bne.n	c0d03d6a <io_event+0x32>
            if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID &&
c0d03d5a:	48e3      	ldr	r0, [pc, #908]	; (c0d040e8 <io_event+0x3b0>)
c0d03d5c:	7980      	ldrb	r0, [r0, #6]
c0d03d5e:	2801      	cmp	r0, #1
c0d03d60:	d103      	bne.n	c0d03d6a <io_event+0x32>
                !(U4BE(G_io_seproxyhal_spi_buffer, 3) &
c0d03d62:	79a8      	ldrb	r0, [r5, #6]
            if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID &&
c0d03d64:	0700      	lsls	r0, r0, #28
c0d03d66:	d400      	bmi.n	c0d03d6a <io_event+0x32>
c0d03d68:	e1b5      	b.n	c0d040d6 <io_event+0x39e>
            UX_DEFAULT_EVENT();
c0d03d6a:	4cdd      	ldr	r4, [pc, #884]	; (c0d040e0 <io_event+0x3a8>)
c0d03d6c:	2700      	movs	r7, #0
c0d03d6e:	6067      	str	r7, [r4, #4]
c0d03d70:	2001      	movs	r0, #1
c0d03d72:	7020      	strb	r0, [r4, #0]
c0d03d74:	4620      	mov	r0, r4
c0d03d76:	f002 fe8f 	bl	c0d06a98 <os_ux>
c0d03d7a:	2004      	movs	r0, #4
c0d03d7c:	f002 ff14 	bl	c0d06ba8 <os_sched_last_status>
c0d03d80:	6060      	str	r0, [r4, #4]
c0d03d82:	2869      	cmp	r0, #105	; 0x69
c0d03d84:	d144      	bne.n	c0d03e10 <io_event+0xd8>
c0d03d86:	f000 fd5b 	bl	c0d04840 <io_seproxyhal_init_ux>
c0d03d8a:	f000 fd5b 	bl	c0d04844 <io_seproxyhal_init_button>
c0d03d8e:	25be      	movs	r5, #190	; 0xbe
c0d03d90:	4ed4      	ldr	r6, [pc, #848]	; (c0d040e4 <io_event+0x3ac>)
c0d03d92:	5377      	strh	r7, [r6, r5]
c0d03d94:	2004      	movs	r0, #4
c0d03d96:	f002 ff07 	bl	c0d06ba8 <os_sched_last_status>
c0d03d9a:	6060      	str	r0, [r4, #4]
c0d03d9c:	2800      	cmp	r0, #0
c0d03d9e:	d100      	bne.n	c0d03da2 <io_event+0x6a>
c0d03da0:	e190      	b.n	c0d040c4 <io_event+0x38c>
c0d03da2:	2897      	cmp	r0, #151	; 0x97
c0d03da4:	d100      	bne.n	c0d03da8 <io_event+0x70>
c0d03da6:	e18d      	b.n	c0d040c4 <io_event+0x38c>
c0d03da8:	24c0      	movs	r4, #192	; 0xc0
c0d03daa:	5930      	ldr	r0, [r6, r4]
c0d03dac:	2800      	cmp	r0, #0
c0d03dae:	d100      	bne.n	c0d03db2 <io_event+0x7a>
c0d03db0:	e188      	b.n	c0d040c4 <io_event+0x38c>
c0d03db2:	5b70      	ldrh	r0, [r6, r5]
c0d03db4:	21c4      	movs	r1, #196	; 0xc4
c0d03db6:	5c71      	ldrb	r1, [r6, r1]
c0d03db8:	b280      	uxth	r0, r0
c0d03dba:	4288      	cmp	r0, r1
c0d03dbc:	d300      	bcc.n	c0d03dc0 <io_event+0x88>
c0d03dbe:	e181      	b.n	c0d040c4 <io_event+0x38c>
c0d03dc0:	f002 febe 	bl	c0d06b40 <io_seph_is_status_sent>
c0d03dc4:	2800      	cmp	r0, #0
c0d03dc6:	d000      	beq.n	c0d03dca <io_event+0x92>
c0d03dc8:	e17c      	b.n	c0d040c4 <io_event+0x38c>
c0d03dca:	f002 fe2f 	bl	c0d06a2c <os_perso_isonboarded>
c0d03dce:	28aa      	cmp	r0, #170	; 0xaa
c0d03dd0:	d104      	bne.n	c0d03ddc <io_event+0xa4>
c0d03dd2:	f002 fe55 	bl	c0d06a80 <os_global_pin_is_validated>
c0d03dd6:	28aa      	cmp	r0, #170	; 0xaa
c0d03dd8:	d000      	beq.n	c0d03ddc <io_event+0xa4>
c0d03dda:	e173      	b.n	c0d040c4 <io_event+0x38c>
c0d03ddc:	5930      	ldr	r0, [r6, r4]
c0d03dde:	5b71      	ldrh	r1, [r6, r5]
c0d03de0:	0149      	lsls	r1, r1, #5
c0d03de2:	1840      	adds	r0, r0, r1
c0d03de4:	21cc      	movs	r1, #204	; 0xcc
c0d03de6:	5871      	ldr	r1, [r6, r1]
c0d03de8:	2900      	cmp	r1, #0
c0d03dea:	d002      	beq.n	c0d03df2 <io_event+0xba>
c0d03dec:	4788      	blx	r1
c0d03dee:	2800      	cmp	r0, #0
c0d03df0:	d007      	beq.n	c0d03e02 <io_event+0xca>
c0d03df2:	2801      	cmp	r0, #1
c0d03df4:	d103      	bne.n	c0d03dfe <io_event+0xc6>
c0d03df6:	5930      	ldr	r0, [r6, r4]
c0d03df8:	5b71      	ldrh	r1, [r6, r5]
c0d03dfa:	0149      	lsls	r1, r1, #5
c0d03dfc:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d03dfe:	f000 fd79 	bl	c0d048f4 <io_seproxyhal_display_default>
            UX_DEFAULT_EVENT();
c0d03e02:	5b70      	ldrh	r0, [r6, r5]
c0d03e04:	1c40      	adds	r0, r0, #1
c0d03e06:	5370      	strh	r0, [r6, r5]
c0d03e08:	5931      	ldr	r1, [r6, r4]
c0d03e0a:	2900      	cmp	r1, #0
c0d03e0c:	d1d2      	bne.n	c0d03db4 <io_event+0x7c>
c0d03e0e:	e159      	b.n	c0d040c4 <io_event+0x38c>
c0d03e10:	25c0      	movs	r5, #192	; 0xc0
c0d03e12:	4cb4      	ldr	r4, [pc, #720]	; (c0d040e4 <io_event+0x3ac>)
c0d03e14:	5960      	ldr	r0, [r4, r5]
c0d03e16:	2800      	cmp	r0, #0
c0d03e18:	d100      	bne.n	c0d03e1c <io_event+0xe4>
c0d03e1a:	e14b      	b.n	c0d040b4 <io_event+0x37c>
c0d03e1c:	26be      	movs	r6, #190	; 0xbe
c0d03e1e:	5ba0      	ldrh	r0, [r4, r6]
c0d03e20:	21c4      	movs	r1, #196	; 0xc4
c0d03e22:	5c61      	ldrb	r1, [r4, r1]
c0d03e24:	b280      	uxth	r0, r0
c0d03e26:	4288      	cmp	r0, r1
c0d03e28:	d300      	bcc.n	c0d03e2c <io_event+0xf4>
c0d03e2a:	e143      	b.n	c0d040b4 <io_event+0x37c>
c0d03e2c:	f002 fe88 	bl	c0d06b40 <io_seph_is_status_sent>
c0d03e30:	2800      	cmp	r0, #0
c0d03e32:	d000      	beq.n	c0d03e36 <io_event+0xfe>
c0d03e34:	e13e      	b.n	c0d040b4 <io_event+0x37c>
c0d03e36:	f002 fdf9 	bl	c0d06a2c <os_perso_isonboarded>
c0d03e3a:	28aa      	cmp	r0, #170	; 0xaa
c0d03e3c:	d104      	bne.n	c0d03e48 <io_event+0x110>
c0d03e3e:	f002 fe1f 	bl	c0d06a80 <os_global_pin_is_validated>
c0d03e42:	28aa      	cmp	r0, #170	; 0xaa
c0d03e44:	d000      	beq.n	c0d03e48 <io_event+0x110>
c0d03e46:	e135      	b.n	c0d040b4 <io_event+0x37c>
c0d03e48:	5960      	ldr	r0, [r4, r5]
c0d03e4a:	5ba1      	ldrh	r1, [r4, r6]
c0d03e4c:	0149      	lsls	r1, r1, #5
c0d03e4e:	1840      	adds	r0, r0, r1
c0d03e50:	21cc      	movs	r1, #204	; 0xcc
c0d03e52:	5861      	ldr	r1, [r4, r1]
c0d03e54:	2900      	cmp	r1, #0
c0d03e56:	d002      	beq.n	c0d03e5e <io_event+0x126>
c0d03e58:	4788      	blx	r1
c0d03e5a:	2800      	cmp	r0, #0
c0d03e5c:	d007      	beq.n	c0d03e6e <io_event+0x136>
c0d03e5e:	2801      	cmp	r0, #1
c0d03e60:	d103      	bne.n	c0d03e6a <io_event+0x132>
c0d03e62:	5960      	ldr	r0, [r4, r5]
c0d03e64:	5ba1      	ldrh	r1, [r4, r6]
c0d03e66:	0149      	lsls	r1, r1, #5
c0d03e68:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d03e6a:	f000 fd43 	bl	c0d048f4 <io_seproxyhal_display_default>
            UX_DEFAULT_EVENT();
c0d03e6e:	5ba0      	ldrh	r0, [r4, r6]
c0d03e70:	1c40      	adds	r0, r0, #1
c0d03e72:	53a0      	strh	r0, [r4, r6]
c0d03e74:	5961      	ldr	r1, [r4, r5]
c0d03e76:	2900      	cmp	r1, #0
c0d03e78:	d1d2      	bne.n	c0d03e20 <io_event+0xe8>
c0d03e7a:	e11b      	b.n	c0d040b4 <io_event+0x37c>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d03e7c:	4c98      	ldr	r4, [pc, #608]	; (c0d040e0 <io_event+0x3a8>)
c0d03e7e:	2700      	movs	r7, #0
c0d03e80:	6067      	str	r7, [r4, #4]
c0d03e82:	2001      	movs	r0, #1
c0d03e84:	7020      	strb	r0, [r4, #0]
c0d03e86:	4620      	mov	r0, r4
c0d03e88:	f002 fe06 	bl	c0d06a98 <os_ux>
c0d03e8c:	2004      	movs	r0, #4
c0d03e8e:	f002 fe8b 	bl	c0d06ba8 <os_sched_last_status>
c0d03e92:	6060      	str	r0, [r4, #4]
c0d03e94:	2800      	cmp	r0, #0
c0d03e96:	d100      	bne.n	c0d03e9a <io_event+0x162>
c0d03e98:	e114      	b.n	c0d040c4 <io_event+0x38c>
c0d03e9a:	2897      	cmp	r0, #151	; 0x97
c0d03e9c:	d100      	bne.n	c0d03ea0 <io_event+0x168>
c0d03e9e:	e111      	b.n	c0d040c4 <io_event+0x38c>
c0d03ea0:	2869      	cmp	r0, #105	; 0x69
c0d03ea2:	d000      	beq.n	c0d03ea6 <io_event+0x16e>
c0d03ea4:	e0cd      	b.n	c0d04042 <io_event+0x30a>
c0d03ea6:	f000 fccb 	bl	c0d04840 <io_seproxyhal_init_ux>
c0d03eaa:	f000 fccb 	bl	c0d04844 <io_seproxyhal_init_button>
c0d03eae:	25be      	movs	r5, #190	; 0xbe
c0d03eb0:	4e8c      	ldr	r6, [pc, #560]	; (c0d040e4 <io_event+0x3ac>)
c0d03eb2:	5377      	strh	r7, [r6, r5]
c0d03eb4:	2004      	movs	r0, #4
c0d03eb6:	f002 fe77 	bl	c0d06ba8 <os_sched_last_status>
c0d03eba:	6060      	str	r0, [r4, #4]
c0d03ebc:	2800      	cmp	r0, #0
c0d03ebe:	d100      	bne.n	c0d03ec2 <io_event+0x18a>
c0d03ec0:	e100      	b.n	c0d040c4 <io_event+0x38c>
c0d03ec2:	2897      	cmp	r0, #151	; 0x97
c0d03ec4:	d100      	bne.n	c0d03ec8 <io_event+0x190>
c0d03ec6:	e0fd      	b.n	c0d040c4 <io_event+0x38c>
c0d03ec8:	24c0      	movs	r4, #192	; 0xc0
c0d03eca:	5930      	ldr	r0, [r6, r4]
c0d03ecc:	2800      	cmp	r0, #0
c0d03ece:	d100      	bne.n	c0d03ed2 <io_event+0x19a>
c0d03ed0:	e0f8      	b.n	c0d040c4 <io_event+0x38c>
c0d03ed2:	5b70      	ldrh	r0, [r6, r5]
c0d03ed4:	21c4      	movs	r1, #196	; 0xc4
c0d03ed6:	5c71      	ldrb	r1, [r6, r1]
c0d03ed8:	b280      	uxth	r0, r0
c0d03eda:	4288      	cmp	r0, r1
c0d03edc:	d300      	bcc.n	c0d03ee0 <io_event+0x1a8>
c0d03ede:	e0f1      	b.n	c0d040c4 <io_event+0x38c>
c0d03ee0:	f002 fe2e 	bl	c0d06b40 <io_seph_is_status_sent>
c0d03ee4:	2800      	cmp	r0, #0
c0d03ee6:	d000      	beq.n	c0d03eea <io_event+0x1b2>
c0d03ee8:	e0ec      	b.n	c0d040c4 <io_event+0x38c>
c0d03eea:	f002 fd9f 	bl	c0d06a2c <os_perso_isonboarded>
c0d03eee:	28aa      	cmp	r0, #170	; 0xaa
c0d03ef0:	d104      	bne.n	c0d03efc <io_event+0x1c4>
c0d03ef2:	f002 fdc5 	bl	c0d06a80 <os_global_pin_is_validated>
c0d03ef6:	28aa      	cmp	r0, #170	; 0xaa
c0d03ef8:	d000      	beq.n	c0d03efc <io_event+0x1c4>
c0d03efa:	e0e3      	b.n	c0d040c4 <io_event+0x38c>
c0d03efc:	5930      	ldr	r0, [r6, r4]
c0d03efe:	5b71      	ldrh	r1, [r6, r5]
c0d03f00:	0149      	lsls	r1, r1, #5
c0d03f02:	1840      	adds	r0, r0, r1
c0d03f04:	21cc      	movs	r1, #204	; 0xcc
c0d03f06:	5871      	ldr	r1, [r6, r1]
c0d03f08:	2900      	cmp	r1, #0
c0d03f0a:	d002      	beq.n	c0d03f12 <io_event+0x1da>
c0d03f0c:	4788      	blx	r1
c0d03f0e:	2800      	cmp	r0, #0
c0d03f10:	d007      	beq.n	c0d03f22 <io_event+0x1ea>
c0d03f12:	2801      	cmp	r0, #1
c0d03f14:	d103      	bne.n	c0d03f1e <io_event+0x1e6>
c0d03f16:	5930      	ldr	r0, [r6, r4]
c0d03f18:	5b71      	ldrh	r1, [r6, r5]
c0d03f1a:	0149      	lsls	r1, r1, #5
c0d03f1c:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d03f1e:	f000 fce9 	bl	c0d048f4 <io_seproxyhal_display_default>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d03f22:	5b70      	ldrh	r0, [r6, r5]
c0d03f24:	1c40      	adds	r0, r0, #1
c0d03f26:	5370      	strh	r0, [r6, r5]
c0d03f28:	5931      	ldr	r1, [r6, r4]
c0d03f2a:	2900      	cmp	r1, #0
c0d03f2c:	d1d2      	bne.n	c0d03ed4 <io_event+0x19c>
c0d03f2e:	e0c9      	b.n	c0d040c4 <io_event+0x38c>
            UX_DISPLAYED_EVENT({});
c0d03f30:	4c6b      	ldr	r4, [pc, #428]	; (c0d040e0 <io_event+0x3a8>)
c0d03f32:	2700      	movs	r7, #0
c0d03f34:	6067      	str	r7, [r4, #4]
c0d03f36:	2001      	movs	r0, #1
c0d03f38:	7020      	strb	r0, [r4, #0]
c0d03f3a:	4620      	mov	r0, r4
c0d03f3c:	f002 fdac 	bl	c0d06a98 <os_ux>
c0d03f40:	2004      	movs	r0, #4
c0d03f42:	f002 fe31 	bl	c0d06ba8 <os_sched_last_status>
c0d03f46:	6060      	str	r0, [r4, #4]
c0d03f48:	2800      	cmp	r0, #0
c0d03f4a:	d100      	bne.n	c0d03f4e <io_event+0x216>
c0d03f4c:	e0ba      	b.n	c0d040c4 <io_event+0x38c>
c0d03f4e:	2869      	cmp	r0, #105	; 0x69
c0d03f50:	d038      	beq.n	c0d03fc4 <io_event+0x28c>
c0d03f52:	2897      	cmp	r0, #151	; 0x97
c0d03f54:	d100      	bne.n	c0d03f58 <io_event+0x220>
c0d03f56:	e0b5      	b.n	c0d040c4 <io_event+0x38c>
c0d03f58:	25c0      	movs	r5, #192	; 0xc0
c0d03f5a:	4c62      	ldr	r4, [pc, #392]	; (c0d040e4 <io_event+0x3ac>)
c0d03f5c:	5960      	ldr	r0, [r4, r5]
c0d03f5e:	2800      	cmp	r0, #0
c0d03f60:	d100      	bne.n	c0d03f64 <io_event+0x22c>
c0d03f62:	e0a7      	b.n	c0d040b4 <io_event+0x37c>
c0d03f64:	26be      	movs	r6, #190	; 0xbe
c0d03f66:	5ba0      	ldrh	r0, [r4, r6]
c0d03f68:	21c4      	movs	r1, #196	; 0xc4
c0d03f6a:	5c61      	ldrb	r1, [r4, r1]
c0d03f6c:	b280      	uxth	r0, r0
c0d03f6e:	4288      	cmp	r0, r1
c0d03f70:	d300      	bcc.n	c0d03f74 <io_event+0x23c>
c0d03f72:	e09f      	b.n	c0d040b4 <io_event+0x37c>
c0d03f74:	f002 fde4 	bl	c0d06b40 <io_seph_is_status_sent>
c0d03f78:	2800      	cmp	r0, #0
c0d03f7a:	d000      	beq.n	c0d03f7e <io_event+0x246>
c0d03f7c:	e09a      	b.n	c0d040b4 <io_event+0x37c>
c0d03f7e:	f002 fd55 	bl	c0d06a2c <os_perso_isonboarded>
c0d03f82:	28aa      	cmp	r0, #170	; 0xaa
c0d03f84:	d104      	bne.n	c0d03f90 <io_event+0x258>
c0d03f86:	f002 fd7b 	bl	c0d06a80 <os_global_pin_is_validated>
c0d03f8a:	28aa      	cmp	r0, #170	; 0xaa
c0d03f8c:	d000      	beq.n	c0d03f90 <io_event+0x258>
c0d03f8e:	e091      	b.n	c0d040b4 <io_event+0x37c>
c0d03f90:	5960      	ldr	r0, [r4, r5]
c0d03f92:	5ba1      	ldrh	r1, [r4, r6]
c0d03f94:	0149      	lsls	r1, r1, #5
c0d03f96:	1840      	adds	r0, r0, r1
c0d03f98:	21cc      	movs	r1, #204	; 0xcc
c0d03f9a:	5861      	ldr	r1, [r4, r1]
c0d03f9c:	2900      	cmp	r1, #0
c0d03f9e:	d002      	beq.n	c0d03fa6 <io_event+0x26e>
c0d03fa0:	4788      	blx	r1
c0d03fa2:	2800      	cmp	r0, #0
c0d03fa4:	d007      	beq.n	c0d03fb6 <io_event+0x27e>
c0d03fa6:	2801      	cmp	r0, #1
c0d03fa8:	d103      	bne.n	c0d03fb2 <io_event+0x27a>
c0d03faa:	5960      	ldr	r0, [r4, r5]
c0d03fac:	5ba1      	ldrh	r1, [r4, r6]
c0d03fae:	0149      	lsls	r1, r1, #5
c0d03fb0:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d03fb2:	f000 fc9f 	bl	c0d048f4 <io_seproxyhal_display_default>
            UX_DISPLAYED_EVENT({});
c0d03fb6:	5ba0      	ldrh	r0, [r4, r6]
c0d03fb8:	1c40      	adds	r0, r0, #1
c0d03fba:	53a0      	strh	r0, [r4, r6]
c0d03fbc:	5961      	ldr	r1, [r4, r5]
c0d03fbe:	2900      	cmp	r1, #0
c0d03fc0:	d1d2      	bne.n	c0d03f68 <io_event+0x230>
c0d03fc2:	e077      	b.n	c0d040b4 <io_event+0x37c>
c0d03fc4:	f000 fc3c 	bl	c0d04840 <io_seproxyhal_init_ux>
c0d03fc8:	f000 fc3c 	bl	c0d04844 <io_seproxyhal_init_button>
c0d03fcc:	25be      	movs	r5, #190	; 0xbe
c0d03fce:	4e45      	ldr	r6, [pc, #276]	; (c0d040e4 <io_event+0x3ac>)
c0d03fd0:	5377      	strh	r7, [r6, r5]
c0d03fd2:	2004      	movs	r0, #4
c0d03fd4:	f002 fde8 	bl	c0d06ba8 <os_sched_last_status>
c0d03fd8:	6060      	str	r0, [r4, #4]
c0d03fda:	2800      	cmp	r0, #0
c0d03fdc:	d072      	beq.n	c0d040c4 <io_event+0x38c>
c0d03fde:	2897      	cmp	r0, #151	; 0x97
c0d03fe0:	d070      	beq.n	c0d040c4 <io_event+0x38c>
c0d03fe2:	24c0      	movs	r4, #192	; 0xc0
c0d03fe4:	5930      	ldr	r0, [r6, r4]
c0d03fe6:	2800      	cmp	r0, #0
c0d03fe8:	d06c      	beq.n	c0d040c4 <io_event+0x38c>
c0d03fea:	5b70      	ldrh	r0, [r6, r5]
c0d03fec:	21c4      	movs	r1, #196	; 0xc4
c0d03fee:	5c71      	ldrb	r1, [r6, r1]
c0d03ff0:	b280      	uxth	r0, r0
c0d03ff2:	4288      	cmp	r0, r1
c0d03ff4:	d266      	bcs.n	c0d040c4 <io_event+0x38c>
c0d03ff6:	f002 fda3 	bl	c0d06b40 <io_seph_is_status_sent>
c0d03ffa:	2800      	cmp	r0, #0
c0d03ffc:	d162      	bne.n	c0d040c4 <io_event+0x38c>
c0d03ffe:	f002 fd15 	bl	c0d06a2c <os_perso_isonboarded>
c0d04002:	28aa      	cmp	r0, #170	; 0xaa
c0d04004:	d103      	bne.n	c0d0400e <io_event+0x2d6>
c0d04006:	f002 fd3b 	bl	c0d06a80 <os_global_pin_is_validated>
c0d0400a:	28aa      	cmp	r0, #170	; 0xaa
c0d0400c:	d15a      	bne.n	c0d040c4 <io_event+0x38c>
c0d0400e:	5930      	ldr	r0, [r6, r4]
c0d04010:	5b71      	ldrh	r1, [r6, r5]
c0d04012:	0149      	lsls	r1, r1, #5
c0d04014:	1840      	adds	r0, r0, r1
c0d04016:	21cc      	movs	r1, #204	; 0xcc
c0d04018:	5871      	ldr	r1, [r6, r1]
c0d0401a:	2900      	cmp	r1, #0
c0d0401c:	d002      	beq.n	c0d04024 <io_event+0x2ec>
c0d0401e:	4788      	blx	r1
c0d04020:	2800      	cmp	r0, #0
c0d04022:	d007      	beq.n	c0d04034 <io_event+0x2fc>
c0d04024:	2801      	cmp	r0, #1
c0d04026:	d103      	bne.n	c0d04030 <io_event+0x2f8>
c0d04028:	5930      	ldr	r0, [r6, r4]
c0d0402a:	5b71      	ldrh	r1, [r6, r5]
c0d0402c:	0149      	lsls	r1, r1, #5
c0d0402e:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d04030:	f000 fc60 	bl	c0d048f4 <io_seproxyhal_display_default>
            UX_DISPLAYED_EVENT({});
c0d04034:	5b70      	ldrh	r0, [r6, r5]
c0d04036:	1c40      	adds	r0, r0, #1
c0d04038:	5370      	strh	r0, [r6, r5]
c0d0403a:	5931      	ldr	r1, [r6, r4]
c0d0403c:	2900      	cmp	r1, #0
c0d0403e:	d1d5      	bne.n	c0d03fec <io_event+0x2b4>
c0d04040:	e040      	b.n	c0d040c4 <io_event+0x38c>
c0d04042:	20d0      	movs	r0, #208	; 0xd0
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d04044:	4c27      	ldr	r4, [pc, #156]	; (c0d040e4 <io_event+0x3ac>)
c0d04046:	5820      	ldr	r0, [r4, r0]
c0d04048:	2800      	cmp	r0, #0
c0d0404a:	d003      	beq.n	c0d04054 <io_event+0x31c>
c0d0404c:	78e9      	ldrb	r1, [r5, #3]
c0d0404e:	0849      	lsrs	r1, r1, #1
c0d04050:	f000 fc94 	bl	c0d0497c <io_seproxyhal_button_push>
c0d04054:	25c0      	movs	r5, #192	; 0xc0
c0d04056:	5960      	ldr	r0, [r4, r5]
c0d04058:	2800      	cmp	r0, #0
c0d0405a:	d02b      	beq.n	c0d040b4 <io_event+0x37c>
c0d0405c:	26be      	movs	r6, #190	; 0xbe
c0d0405e:	5ba0      	ldrh	r0, [r4, r6]
c0d04060:	21c4      	movs	r1, #196	; 0xc4
c0d04062:	5c61      	ldrb	r1, [r4, r1]
c0d04064:	b280      	uxth	r0, r0
c0d04066:	4288      	cmp	r0, r1
c0d04068:	d224      	bcs.n	c0d040b4 <io_event+0x37c>
c0d0406a:	f002 fd69 	bl	c0d06b40 <io_seph_is_status_sent>
c0d0406e:	2800      	cmp	r0, #0
c0d04070:	d120      	bne.n	c0d040b4 <io_event+0x37c>
c0d04072:	f002 fcdb 	bl	c0d06a2c <os_perso_isonboarded>
c0d04076:	28aa      	cmp	r0, #170	; 0xaa
c0d04078:	d103      	bne.n	c0d04082 <io_event+0x34a>
c0d0407a:	f002 fd01 	bl	c0d06a80 <os_global_pin_is_validated>
c0d0407e:	28aa      	cmp	r0, #170	; 0xaa
c0d04080:	d118      	bne.n	c0d040b4 <io_event+0x37c>
c0d04082:	5960      	ldr	r0, [r4, r5]
c0d04084:	5ba1      	ldrh	r1, [r4, r6]
c0d04086:	0149      	lsls	r1, r1, #5
c0d04088:	1840      	adds	r0, r0, r1
c0d0408a:	21cc      	movs	r1, #204	; 0xcc
c0d0408c:	5861      	ldr	r1, [r4, r1]
c0d0408e:	2900      	cmp	r1, #0
c0d04090:	d002      	beq.n	c0d04098 <io_event+0x360>
c0d04092:	4788      	blx	r1
c0d04094:	2800      	cmp	r0, #0
c0d04096:	d007      	beq.n	c0d040a8 <io_event+0x370>
c0d04098:	2801      	cmp	r0, #1
c0d0409a:	d103      	bne.n	c0d040a4 <io_event+0x36c>
c0d0409c:	5960      	ldr	r0, [r4, r5]
c0d0409e:	5ba1      	ldrh	r1, [r4, r6]
c0d040a0:	0149      	lsls	r1, r1, #5
c0d040a2:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d040a4:	f000 fc26 	bl	c0d048f4 <io_seproxyhal_display_default>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d040a8:	5ba0      	ldrh	r0, [r4, r6]
c0d040aa:	1c40      	adds	r0, r0, #1
c0d040ac:	53a0      	strh	r0, [r4, r6]
c0d040ae:	5961      	ldr	r1, [r4, r5]
c0d040b0:	2900      	cmp	r1, #0
c0d040b2:	d1d5      	bne.n	c0d04060 <io_event+0x328>
c0d040b4:	20c4      	movs	r0, #196	; 0xc4
c0d040b6:	5c20      	ldrb	r0, [r4, r0]
c0d040b8:	21be      	movs	r1, #190	; 0xbe
c0d040ba:	5a61      	ldrh	r1, [r4, r1]
c0d040bc:	4281      	cmp	r1, r0
c0d040be:	d301      	bcc.n	c0d040c4 <io_event+0x38c>
c0d040c0:	f002 fd3e 	bl	c0d06b40 <io_seph_is_status_sent>
    if (!io_seproxyhal_spi_is_status_sent()) {
c0d040c4:	f002 fd3c 	bl	c0d06b40 <io_seph_is_status_sent>
c0d040c8:	2800      	cmp	r0, #0
c0d040ca:	d101      	bne.n	c0d040d0 <io_event+0x398>
        io_seproxyhal_general_status();
c0d040cc:	f000 fa72 	bl	c0d045b4 <io_seproxyhal_general_status>
c0d040d0:	2001      	movs	r0, #1
    return 1;
c0d040d2:	b001      	add	sp, #4
c0d040d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d040d6:	2010      	movs	r0, #16
                THROW(EXCEPTION_IO_RESET);
c0d040d8:	f000 f954 	bl	c0d04384 <os_longjmp>
c0d040dc:	20001b00 	.word	0x20001b00
c0d040e0:	20001b48 	.word	0x20001b48
c0d040e4:	20001a00 	.word	0x20001a00
c0d040e8:	2000205c 	.word	0x2000205c

c0d040ec <app_exit>:
void app_exit() {
c0d040ec:	b510      	push	{r4, lr}
c0d040ee:	b08c      	sub	sp, #48	; 0x30
c0d040f0:	466c      	mov	r4, sp
        TRY_L(exit) {
c0d040f2:	4620      	mov	r0, r4
c0d040f4:	f006 fbf4 	bl	c0d0a8e0 <setjmp>
c0d040f8:	85a0      	strh	r0, [r4, #44]	; 0x2c
c0d040fa:	0400      	lsls	r0, r0, #16
c0d040fc:	d106      	bne.n	c0d0410c <app_exit+0x20>
c0d040fe:	4668      	mov	r0, sp
c0d04100:	f002 fd46 	bl	c0d06b90 <try_context_set>
c0d04104:	900a      	str	r0, [sp, #40]	; 0x28
c0d04106:	20ff      	movs	r0, #255	; 0xff
            os_sched_exit(-1);
c0d04108:	f002 fd02 	bl	c0d06b10 <os_sched_exit>
        FINALLY_L(exit) {
c0d0410c:	f002 fd34 	bl	c0d06b78 <try_context_get>
c0d04110:	4669      	mov	r1, sp
c0d04112:	4288      	cmp	r0, r1
c0d04114:	d102      	bne.n	c0d0411c <app_exit+0x30>
c0d04116:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d04118:	f002 fd3a 	bl	c0d06b90 <try_context_set>
c0d0411c:	4668      	mov	r0, sp
    END_TRY_L(exit);
c0d0411e:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d04120:	2800      	cmp	r0, #0
c0d04122:	d101      	bne.n	c0d04128 <app_exit+0x3c>
}
c0d04124:	b00c      	add	sp, #48	; 0x30
c0d04126:	bd10      	pop	{r4, pc}
    END_TRY_L(exit);
c0d04128:	f000 f92c 	bl	c0d04384 <os_longjmp>

c0d0412c <coin_main>:
void coin_main(chain_config_t *coin_config) {
c0d0412c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0412e:	b095      	sub	sp, #84	; 0x54
c0d04130:	4604      	mov	r4, r0
    if (coin_config == NULL) {
c0d04132:	2800      	cmp	r0, #0
c0d04134:	d115      	bne.n	c0d04162 <coin_main+0x36>
c0d04136:	ac0e      	add	r4, sp, #56	; 0x38
    strcpy(coin_config->coinName, CHAINID_COINNAME1 " ");
c0d04138:	1de0      	adds	r0, r4, #7
c0d0413a:	2115      	movs	r1, #21
c0d0413c:	f006 fa96 	bl	c0d0a66c <__aeabi_memclr>
c0d04140:	493a      	ldr	r1, [pc, #232]	; (c0d0422c <coin_main+0x100>)
c0d04142:	4479      	add	r1, pc
c0d04144:	2507      	movs	r5, #7
c0d04146:	4620      	mov	r0, r4
c0d04148:	462a      	mov	r2, r5
c0d0414a:	f006 fa95 	bl	c0d0a678 <__aeabi_memcpy>
    strcpy(coin_config->coinName2, CHAINID_COINNAME2 " ");
c0d0414e:	4620      	mov	r0, r4
c0d04150:	300a      	adds	r0, #10
c0d04152:	4937      	ldr	r1, [pc, #220]	; (c0d04230 <coin_main+0x104>)
c0d04154:	4479      	add	r1, pc
c0d04156:	462a      	mov	r2, r5
c0d04158:	f006 fa8e 	bl	c0d0a678 <__aeabi_memcpy>
c0d0415c:	2000      	movs	r0, #0
    coin_config->kind = CHAIN_KIND;
c0d0415e:	7620      	strb	r0, [r4, #24]
    coin_config->chainId = CHAIN_ID;
c0d04160:	9013      	str	r0, [sp, #76]	; 0x4c
c0d04162:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d04164:	4d29      	ldr	r5, [pc, #164]	; (c0d0420c <coin_main+0xe0>)
c0d04166:	2600      	movs	r6, #0
c0d04168:	522e      	strh	r6, [r5, r0]
    appState = APP_STATE_IDLE;
c0d0416a:	4829      	ldr	r0, [pc, #164]	; (c0d04210 <coin_main+0xe4>)
c0d0416c:	7006      	strb	r6, [r0, #0]
c0d0416e:	4829      	ldr	r0, [pc, #164]	; (c0d04214 <coin_main+0xe8>)
c0d04170:	6004      	str	r4, [r0, #0]
    called_from_swap = false;
c0d04172:	4829      	ldr	r0, [pc, #164]	; (c0d04218 <coin_main+0xec>)
c0d04174:	7006      	strb	r6, [r0, #0]
    quantumSet = false;
c0d04176:	4829      	ldr	r0, [pc, #164]	; (c0d0421c <coin_main+0xf0>)
c0d04178:	7006      	strb	r6, [r0, #0]
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d0417a:	4829      	ldr	r0, [pc, #164]	; (c0d04220 <coin_main+0xf4>)
c0d0417c:	213c      	movs	r1, #60	; 0x3c
c0d0417e:	f006 fa75 	bl	c0d0a66c <__aeabi_memclr>
c0d04182:	2049      	movs	r0, #73	; 0x49
c0d04184:	0081      	lsls	r1, r0, #2
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d04186:	4827      	ldr	r0, [pc, #156]	; (c0d04224 <coin_main+0xf8>)
c0d04188:	f006 fa70 	bl	c0d0a66c <__aeabi_memclr>
c0d0418c:	2090      	movs	r0, #144	; 0x90
    tmpCtx.transactionContext.currentTokenIndex = 0;
c0d0418e:	542e      	strb	r6, [r5, r0]
c0d04190:	4c25      	ldr	r4, [pc, #148]	; (c0d04228 <coin_main+0xfc>)
c0d04192:	2701      	movs	r7, #1
c0d04194:	0239      	lsls	r1, r7, #8
        UX_INIT();
c0d04196:	4620      	mov	r0, r4
c0d04198:	f006 fa68 	bl	c0d0a66c <__aeabi_memclr>
c0d0419c:	ad02      	add	r5, sp, #8
            TRY {
c0d0419e:	4628      	mov	r0, r5
c0d041a0:	f006 fb9e 	bl	c0d0a8e0 <setjmp>
c0d041a4:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0d041a6:	b285      	uxth	r5, r0
c0d041a8:	2d00      	cmp	r5, #0
c0d041aa:	d00d      	beq.n	c0d041c8 <coin_main+0x9c>
c0d041ac:	a802      	add	r0, sp, #8
c0d041ae:	8586      	strh	r6, [r0, #44]	; 0x2c
c0d041b0:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d041b2:	f002 fced 	bl	c0d06b90 <try_context_set>
c0d041b6:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d041b8:	f002 fcea 	bl	c0d06b90 <try_context_set>
c0d041bc:	2d10      	cmp	r5, #16
c0d041be:	d0e8      	beq.n	c0d04192 <coin_main+0x66>
    app_exit();
c0d041c0:	f7ff ff94 	bl	c0d040ec <app_exit>
}
c0d041c4:	b015      	add	sp, #84	; 0x54
c0d041c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d041c8:	a802      	add	r0, sp, #8
            TRY {
c0d041ca:	f002 fce1 	bl	c0d06b90 <try_context_set>
c0d041ce:	900c      	str	r0, [sp, #48]	; 0x30
                io_seproxyhal_init();
c0d041d0:	f000 fb1a 	bl	c0d04808 <io_seproxyhal_init>
                if (N_storage.initialized != 0x01) {
c0d041d4:	4817      	ldr	r0, [pc, #92]	; (c0d04234 <coin_main+0x108>)
c0d041d6:	4478      	add	r0, pc
c0d041d8:	f001 faae 	bl	c0d05738 <pic>
c0d041dc:	7880      	ldrb	r0, [r0, #2]
c0d041de:	2801      	cmp	r0, #1
c0d041e0:	d00a      	beq.n	c0d041f8 <coin_main+0xcc>
c0d041e2:	ac01      	add	r4, sp, #4
                    storage.initialized = 0x01;
c0d041e4:	70a7      	strb	r7, [r4, #2]
                    storage.dataAllowed = 0x00;
c0d041e6:	8026      	strh	r6, [r4, #0]
                    nvm_write((void *) &N_storage, (void *) &storage, sizeof(internalStorage_t));
c0d041e8:	4813      	ldr	r0, [pc, #76]	; (c0d04238 <coin_main+0x10c>)
c0d041ea:	4478      	add	r0, pc
c0d041ec:	f001 faa4 	bl	c0d05738 <pic>
c0d041f0:	2203      	movs	r2, #3
c0d041f2:	4621      	mov	r1, r4
c0d041f4:	f002 fb04 	bl	c0d06800 <nvm_write>
c0d041f8:	2000      	movs	r0, #0
                USB_power(0);
c0d041fa:	f005 fa2b 	bl	c0d09654 <USB_power>
c0d041fe:	2001      	movs	r0, #1
                USB_power(1);
c0d04200:	f005 fa28 	bl	c0d09654 <USB_power>
                ui_idle();
c0d04204:	f7ff fb44 	bl	c0d03890 <ui_idle>
                app_main();
c0d04208:	f7ff fcf6 	bl	c0d03bf8 <app_main>
c0d0420c:	20001804 	.word	0x20001804
c0d04210:	20001800 	.word	0x20001800
c0d04214:	20001be0 	.word	0x20001be0
c0d04218:	2000189c 	.word	0x2000189c
c0d0421c:	2000189d 	.word	0x2000189d
c0d04220:	200018a0 	.word	0x200018a0
c0d04224:	200018dc 	.word	0x200018dc
c0d04228:	20001a00 	.word	0x20001a00
c0d0422c:	00007cf5 	.word	0x00007cf5
c0d04230:	00007cea 	.word	0x00007cea
c0d04234:	000095e6 	.word	0x000095e6
c0d04238:	000095d2 	.word	0x000095d2

c0d0423c <library_main>:
void library_main(struct libargs_s *args) {
c0d0423c:	b094      	sub	sp, #80	; 0x50
c0d0423e:	4604      	mov	r4, r0
    if (args->chain_config == NULL) {
c0d04240:	6880      	ldr	r0, [r0, #8]
c0d04242:	2800      	cmp	r0, #0
c0d04244:	d116      	bne.n	c0d04274 <library_main+0x38>
c0d04246:	ad0d      	add	r5, sp, #52	; 0x34
    strcpy(coin_config->coinName, CHAINID_COINNAME1 " ");
c0d04248:	1de8      	adds	r0, r5, #7
c0d0424a:	2115      	movs	r1, #21
c0d0424c:	f006 fa0e 	bl	c0d0a66c <__aeabi_memclr>
c0d04250:	492c      	ldr	r1, [pc, #176]	; (c0d04304 <library_main+0xc8>)
c0d04252:	4479      	add	r1, pc
c0d04254:	2607      	movs	r6, #7
c0d04256:	4628      	mov	r0, r5
c0d04258:	4632      	mov	r2, r6
c0d0425a:	f006 fa0d 	bl	c0d0a678 <__aeabi_memcpy>
    strcpy(coin_config->coinName2, CHAINID_COINNAME2 " ");
c0d0425e:	4628      	mov	r0, r5
c0d04260:	300a      	adds	r0, #10
c0d04262:	4929      	ldr	r1, [pc, #164]	; (c0d04308 <library_main+0xcc>)
c0d04264:	4479      	add	r1, pc
c0d04266:	4632      	mov	r2, r6
c0d04268:	f006 fa06 	bl	c0d0a678 <__aeabi_memcpy>
c0d0426c:	2000      	movs	r0, #0
    coin_config->kind = CHAIN_KIND;
c0d0426e:	7628      	strb	r0, [r5, #24]
    coin_config->chainId = CHAIN_ID;
c0d04270:	9012      	str	r0, [sp, #72]	; 0x48
        args->chain_config = &coin_config;
c0d04272:	60a5      	str	r5, [r4, #8]
c0d04274:	2700      	movs	r7, #0
c0d04276:	4d25      	ldr	r5, [pc, #148]	; (c0d0430c <library_main+0xd0>)
c0d04278:	447d      	add	r5, pc
c0d0427a:	ae01      	add	r6, sp, #4
            TRY {
c0d0427c:	4630      	mov	r0, r6
c0d0427e:	f006 fb2f 	bl	c0d0a8e0 <setjmp>
c0d04282:	85b0      	strh	r0, [r6, #44]	; 0x2c
c0d04284:	0400      	lsls	r0, r0, #16
c0d04286:	d107      	bne.n	c0d04298 <library_main+0x5c>
c0d04288:	a801      	add	r0, sp, #4
c0d0428a:	f002 fc81 	bl	c0d06b90 <try_context_set>
c0d0428e:	900b      	str	r0, [sp, #44]	; 0x2c
                if (!end) {
c0d04290:	07f8      	lsls	r0, r7, #31
c0d04292:	d00f      	beq.n	c0d042b4 <library_main+0x78>
                os_lib_end();
c0d04294:	f002 fc18 	bl	c0d06ac8 <os_lib_end>
            FINALLY {
c0d04298:	f002 fc6e 	bl	c0d06b78 <try_context_get>
c0d0429c:	a901      	add	r1, sp, #4
c0d0429e:	4288      	cmp	r0, r1
c0d042a0:	d102      	bne.n	c0d042a8 <library_main+0x6c>
c0d042a2:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d042a4:	f002 fc74 	bl	c0d06b90 <try_context_set>
c0d042a8:	a801      	add	r0, sp, #4
        END_TRY;
c0d042aa:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d042ac:	2800      	cmp	r0, #0
c0d042ae:	d127      	bne.n	c0d04300 <library_main+0xc4>
c0d042b0:	2701      	movs	r7, #1
c0d042b2:	e7e2      	b.n	c0d0427a <library_main+0x3e>
c0d042b4:	200a      	movs	r0, #10
    check_api_level(CX_COMPAT_APILEVEL);
c0d042b6:	f002 fa8d 	bl	c0d067d4 <check_api_level>
    PRINTF("Inside a library \n");
c0d042ba:	4628      	mov	r0, r5
c0d042bc:	f000 febe 	bl	c0d0503c <mcu_usb_printf>
    switch (args->command) {
c0d042c0:	6860      	ldr	r0, [r4, #4]
c0d042c2:	2802      	cmp	r0, #2
c0d042c4:	d012      	beq.n	c0d042ec <library_main+0xb0>
c0d042c6:	2804      	cmp	r0, #4
c0d042c8:	d00b      	beq.n	c0d042e2 <library_main+0xa6>
c0d042ca:	2803      	cmp	r0, #3
c0d042cc:	d1e2      	bne.n	c0d04294 <library_main+0x58>
            args->check_address->result = 0;
c0d042ce:	68e0      	ldr	r0, [r4, #12]
c0d042d0:	2100      	movs	r1, #0
c0d042d2:	6181      	str	r1, [r0, #24]
                handle_check_address(args->check_address, args->chain_config);
c0d042d4:	68a1      	ldr	r1, [r4, #8]
c0d042d6:	68e0      	ldr	r0, [r4, #12]
c0d042d8:	f7fe fda4 	bl	c0d02e24 <handle_check_address>
            args->check_address->result =
c0d042dc:	68e1      	ldr	r1, [r4, #12]
c0d042de:	6188      	str	r0, [r1, #24]
c0d042e0:	e7d8      	b.n	c0d04294 <library_main+0x58>
            handle_get_printable_amount(args->get_printable_amount, args->chain_config);
c0d042e2:	68a1      	ldr	r1, [r4, #8]
c0d042e4:	68e0      	ldr	r0, [r4, #12]
c0d042e6:	f7fe fe3b 	bl	c0d02f60 <handle_get_printable_amount>
c0d042ea:	e7d3      	b.n	c0d04294 <library_main+0x58>
            if (copy_transaction_parameters(args->create_transaction, args->chain_config)) {
c0d042ec:	68a1      	ldr	r1, [r4, #8]
c0d042ee:	68e0      	ldr	r0, [r4, #12]
c0d042f0:	f7fe fe80 	bl	c0d02ff4 <copy_transaction_parameters>
c0d042f4:	2800      	cmp	r0, #0
c0d042f6:	d0cd      	beq.n	c0d04294 <library_main+0x58>
                handle_swap_sign_transaction(args->chain_config);
c0d042f8:	68a0      	ldr	r0, [r4, #8]
c0d042fa:	f7fe fed1 	bl	c0d030a0 <handle_swap_sign_transaction>
c0d042fe:	e7c9      	b.n	c0d04294 <library_main+0x58>
        END_TRY;
c0d04300:	f000 f840 	bl	c0d04384 <os_longjmp>
c0d04304:	00007be5 	.word	0x00007be5
c0d04308:	00007bda 	.word	0x00007bda
c0d0430c:	00007bcd 	.word	0x00007bcd

c0d04310 <os_boot>:

// apdu buffer must hold a complete apdu to avoid troubles
unsigned char G_io_apdu_buffer[IO_APDU_BUFFER_SIZE];


void os_boot(void) {
c0d04310:	b580      	push	{r7, lr}
c0d04312:	2000      	movs	r0, #0
  // // TODO patch entry point when romming (f)
  // // set the default try context to nothing
#ifndef HAVE_BOLOS
  try_context_set(NULL);
c0d04314:	f002 fc3c 	bl	c0d06b90 <try_context_set>
#endif // HAVE_BOLOS
}
c0d04318:	bd80      	pop	{r7, pc}

c0d0431a <os_memmove>:


REENTRANT(void os_memmove(void * dst, const void WIDE * src, unsigned int length)) {
c0d0431a:	b5b0      	push	{r4, r5, r7, lr}
#define DSTCHAR ((unsigned char *)dst)
#define SRCCHAR ((unsigned char WIDE *)src)
  if (dst > src) {
c0d0431c:	4288      	cmp	r0, r1
c0d0431e:	d908      	bls.n	c0d04332 <os_memmove+0x18>
    while(length--) {
c0d04320:	2a00      	cmp	r2, #0
c0d04322:	d00f      	beq.n	c0d04344 <os_memmove+0x2a>
c0d04324:	1e49      	subs	r1, r1, #1
c0d04326:	1e40      	subs	r0, r0, #1
      DSTCHAR[length] = SRCCHAR[length];
c0d04328:	5c8b      	ldrb	r3, [r1, r2]
c0d0432a:	5483      	strb	r3, [r0, r2]
    while(length--) {
c0d0432c:	1e52      	subs	r2, r2, #1
c0d0432e:	d1fb      	bne.n	c0d04328 <os_memmove+0xe>
c0d04330:	e008      	b.n	c0d04344 <os_memmove+0x2a>
    }
  }
  else {
    unsigned short l = 0;
    while (length--) {
c0d04332:	2a00      	cmp	r2, #0
c0d04334:	d006      	beq.n	c0d04344 <os_memmove+0x2a>
c0d04336:	2300      	movs	r3, #0
      DSTCHAR[l] = SRCCHAR[l];
c0d04338:	b29c      	uxth	r4, r3
c0d0433a:	5d0d      	ldrb	r5, [r1, r4]
c0d0433c:	5505      	strb	r5, [r0, r4]
      l++;
c0d0433e:	1c5b      	adds	r3, r3, #1
    while (length--) {
c0d04340:	1e52      	subs	r2, r2, #1
c0d04342:	d1f9      	bne.n	c0d04338 <os_memmove+0x1e>
    }
  }
#undef DSTCHAR
}
c0d04344:	bdb0      	pop	{r4, r5, r7, pc}

c0d04346 <os_memset>:

void os_memset(void * dst, unsigned char c, unsigned int length) {
c0d04346:	b580      	push	{r7, lr}
#define DSTCHAR ((unsigned char *)dst)
  while(length--) {
c0d04348:	2a00      	cmp	r2, #0
c0d0434a:	d004      	beq.n	c0d04356 <os_memset+0x10>
c0d0434c:	460b      	mov	r3, r1
    DSTCHAR[length] = c;
c0d0434e:	4611      	mov	r1, r2
c0d04350:	461a      	mov	r2, r3
c0d04352:	f006 f999 	bl	c0d0a688 <__aeabi_memset>
  }
#undef DSTCHAR
}
c0d04356:	bd80      	pop	{r7, pc}

c0d04358 <os_memcmp>:
  while(nbintval--) {
    ((unsigned int*) dst)[nbintval] = initval;
  }
}

char os_memcmp(const void WIDE * buf1, const void WIDE * buf2, unsigned int length) {
c0d04358:	b5b0      	push	{r4, r5, r7, lr}
#define BUF1 ((unsigned char const WIDE *)buf1)
#define BUF2 ((unsigned char const WIDE *)buf2)
  while(length--) {
c0d0435a:	1e40      	subs	r0, r0, #1
c0d0435c:	1e49      	subs	r1, r1, #1
c0d0435e:	2a00      	cmp	r2, #0
c0d04360:	d00a      	beq.n	c0d04378 <os_memcmp+0x20>
c0d04362:	1e55      	subs	r5, r2, #1
    if (BUF1[length] != BUF2[length]) {
c0d04364:	5c8b      	ldrb	r3, [r1, r2]
c0d04366:	5c84      	ldrb	r4, [r0, r2]
c0d04368:	429c      	cmp	r4, r3
c0d0436a:	462a      	mov	r2, r5
c0d0436c:	d0f7      	beq.n	c0d0435e <os_memcmp+0x6>
      return (BUF1[length] > BUF2[length])? 1:-1;
c0d0436e:	429c      	cmp	r4, r3
c0d04370:	d804      	bhi.n	c0d0437c <os_memcmp+0x24>
c0d04372:	2000      	movs	r0, #0
c0d04374:	43c0      	mvns	r0, r0
c0d04376:	e002      	b.n	c0d0437e <os_memcmp+0x26>
c0d04378:	2000      	movs	r0, #0
c0d0437a:	e000      	b.n	c0d0437e <os_memcmp+0x26>
c0d0437c:	2001      	movs	r0, #1
  }
  return 0;
#undef BUF1
#undef BUF2

}
c0d0437e:	b2c0      	uxtb	r0, r0
c0d04380:	bdb0      	pop	{r4, r5, r7, pc}
	...

c0d04384 <os_longjmp>:
  return (try_context_t*) current_ctx->jmp_buf[5];
}
#endif // BOLOS_EXCEPTION_OLD

#ifndef HAVE_BOLOS
void os_longjmp(unsigned int exception) {
c0d04384:	4604      	mov	r4, r0
#ifdef HAVE_PRINTF  
  unsigned int lr_val;
  __asm volatile("mov %0, lr" :"=r"(lr_val));
c0d04386:	4672      	mov	r2, lr
  PRINTF("exception[%d]: LR=0x%08X\n", exception, lr_val);
c0d04388:	4804      	ldr	r0, [pc, #16]	; (c0d0439c <os_longjmp+0x18>)
c0d0438a:	4478      	add	r0, pc
c0d0438c:	4621      	mov	r1, r4
c0d0438e:	f000 fe55 	bl	c0d0503c <mcu_usb_printf>
#endif // HAVE_PRINTF
  longjmp(try_context_get()->jmp_buf, exception);
c0d04392:	f002 fbf1 	bl	c0d06b78 <try_context_get>
c0d04396:	4621      	mov	r1, r4
c0d04398:	f006 faae 	bl	c0d0a8f8 <longjmp>
c0d0439c:	00007ace 	.word	0x00007ace

c0d043a0 <os_secure_memcmp>:
char os_secure_memcmp(void WIDE* src1, void WIDE* src2, unsigned int length) {
c0d043a0:	b5b0      	push	{r4, r5, r7, lr}
c0d043a2:	b082      	sub	sp, #8
c0d043a4:	9201      	str	r2, [sp, #4]
c0d043a6:	9200      	str	r2, [sp, #0]
  while(!(!length && !l)) {
c0d043a8:	2a00      	cmp	r2, #0
c0d043aa:	d00c      	beq.n	c0d043c6 <os_secure_memcmp+0x26>
    length--;
c0d043ac:	1e43      	subs	r3, r0, #1
c0d043ae:	1e49      	subs	r1, r1, #1
c0d043b0:	2000      	movs	r0, #0
    xoracc |= SRC1[length] ^ SRC2[length];
c0d043b2:	5c9c      	ldrb	r4, [r3, r2]
c0d043b4:	5c8d      	ldrb	r5, [r1, r2]
c0d043b6:	4065      	eors	r5, r4
c0d043b8:	4328      	orrs	r0, r5
    length--;
c0d043ba:	1e52      	subs	r2, r2, #1
  while(!(!length && !l)) {
c0d043bc:	d1f9      	bne.n	c0d043b2 <os_secure_memcmp+0x12>
c0d043be:	2100      	movs	r1, #0
c0d043c0:	9100      	str	r1, [sp, #0]
    length--;
c0d043c2:	9101      	str	r1, [sp, #4]
c0d043c4:	e000      	b.n	c0d043c8 <os_secure_memcmp+0x28>
c0d043c6:	2000      	movs	r0, #0
  if (*(volatile unsigned int*)&l!=*(volatile unsigned int*)&length) {
c0d043c8:	9900      	ldr	r1, [sp, #0]
c0d043ca:	9a01      	ldr	r2, [sp, #4]
c0d043cc:	4291      	cmp	r1, r2
c0d043ce:	d102      	bne.n	c0d043d6 <os_secure_memcmp+0x36>
  return xoracc;
c0d043d0:	b2c0      	uxtb	r0, r0
c0d043d2:	b002      	add	sp, #8
c0d043d4:	bdb0      	pop	{r4, r5, r7, pc}
c0d043d6:	2001      	movs	r0, #1
    THROW(EXCEPTION);
c0d043d8:	f7ff ffd4 	bl	c0d04384 <os_longjmp>

c0d043dc <os_parse_bertlv>:
// <tag> <length> <value>
// tag: 1 byte only
// length: 1 byte if little than 0x80, else 1 byte of length encoding (0x8Y, with Y the number of following bytes the length is encoded on) and then Y bytes of BE encoded total length
// value: no encoding, raw data
unsigned int os_parse_bertlv(unsigned char* mem, unsigned int mem_len, 
                             unsigned int * tlvoffset, unsigned int tag, unsigned int offset, void** buffer, unsigned int maxlength) {
c0d043dc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d043de:	b08b      	sub	sp, #44	; 0x2c
c0d043e0:	4607      	mov	r7, r0
c0d043e2:	2000      	movs	r0, #0
  unsigned int check_equals_buffer = offset & OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER;
  unsigned int get_address = offset & OS_PARSE_BERTLV_OFFSET_GET_LENGTH;
  offset &= ~(OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER|OS_PARSE_BERTLV_OFFSET_GET_LENGTH);

  // nothing to be read
  if (mem_len == 0 || buffer == NULL || (!get_address && *buffer == NULL)) {
c0d043e4:	2900      	cmp	r1, #0
c0d043e6:	d05b      	beq.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d043e8:	9d11      	ldr	r5, [sp, #68]	; 0x44
c0d043ea:	2d00      	cmp	r5, #0
c0d043ec:	d058      	beq.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d043ee:	920a      	str	r2, [sp, #40]	; 0x28
c0d043f0:	4c6f      	ldr	r4, [pc, #444]	; (c0d045b0 <os_parse_bertlv+0x1d4>)
c0d043f2:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0d043f4:	9409      	str	r4, [sp, #36]	; 0x24
  unsigned int get_address = offset & OS_PARSE_BERTLV_OFFSET_GET_LENGTH;
c0d043f6:	1c62      	adds	r2, r4, #1
c0d043f8:	4032      	ands	r2, r6
c0d043fa:	9204      	str	r2, [sp, #16]
  if (mem_len == 0 || buffer == NULL || (!get_address && *buffer == NULL)) {
c0d043fc:	2a00      	cmp	r2, #0
c0d043fe:	d102      	bne.n	c0d04406 <os_parse_bertlv+0x2a>
c0d04400:	682c      	ldr	r4, [r5, #0]
c0d04402:	2c00      	cmp	r4, #0
c0d04404:	d04c      	beq.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d04406:	2000      	movs	r0, #0
c0d04408:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  unsigned int remlen = mem_len;
  ret = 0;

  // account for a shift in the tlv list before parsing
  tlvoffset_in = 0;
  if (tlvoffset) {
c0d0440a:	2a00      	cmp	r2, #0
c0d0440c:	4604      	mov	r4, r0
c0d0440e:	d000      	beq.n	c0d04412 <os_parse_bertlv+0x36>
    tlvoffset_in = *tlvoffset;
c0d04410:	6814      	ldr	r4, [r2, #0]
  }

  // parse tlv until some tag to parse
  while(remlen>=2) {
c0d04412:	2902      	cmp	r1, #2
c0d04414:	d344      	bcc.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d04416:	9406      	str	r4, [sp, #24]
c0d04418:	9501      	str	r5, [sp, #4]
c0d0441a:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d0441c:	9602      	str	r6, [sp, #8]
c0d0441e:	4030      	ands	r0, r6
c0d04420:	9009      	str	r0, [sp, #36]	; 0x24
c0d04422:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d04424:	9003      	str	r0, [sp, #12]
c0d04426:	2000      	movs	r0, #0
c0d04428:	43c4      	mvns	r4, r0
c0d0442a:	9405      	str	r4, [sp, #20]
c0d0442c:	b2da      	uxtb	r2, r3
c0d0442e:	9207      	str	r2, [sp, #28]
c0d04430:	460b      	mov	r3, r1
c0d04432:	463e      	mov	r6, r7
c0d04434:	9008      	str	r0, [sp, #32]
    remlen--;
    if (remlen == 0) {
      goto retret; 
    }
    unsigned int tlvlen = *tlv++;
    remlen--;
c0d04436:	1e9b      	subs	r3, r3, #2
    if (remlen == 0) {
c0d04438:	d032      	beq.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d0443a:	460a      	mov	r2, r1
c0d0443c:	4639      	mov	r1, r7
c0d0443e:	1cb5      	adds	r5, r6, #2
c0d04440:	7830      	ldrb	r0, [r6, #0]
c0d04442:	7876      	ldrb	r6, [r6, #1]
c0d04444:	b277      	sxtb	r7, r6
      goto retret; 
    }
    if (tlvlen >= 0x80) {
c0d04446:	2f00      	cmp	r7, #0
c0d04448:	da12      	bge.n	c0d04470 <os_parse_bertlv+0x94>
      // invalid encoding
      if (tlvlen == 0x80) {
c0d0444a:	3780      	adds	r7, #128	; 0x80
c0d0444c:	d05f      	beq.n	c0d0450e <os_parse_bertlv+0x132>
c0d0444e:	277f      	movs	r7, #127	; 0x7f
        goto retret; 
      }
      unsigned int tlvlenlen_ = tlvlen & 0x7F;
c0d04450:	403e      	ands	r6, r7
      tlvlen = 0;
      while(tlvlenlen_--) {
c0d04452:	9c05      	ldr	r4, [sp, #20]
c0d04454:	4366      	muls	r6, r4
c0d04456:	2700      	movs	r7, #0
c0d04458:	2e00      	cmp	r6, #0
c0d0445a:	d008      	beq.n	c0d0446e <os_parse_bertlv+0x92>
        // BE encoded
        tlvlen = (tlvlen << 8) | ((*tlv++)&0xFF);
c0d0445c:	782c      	ldrb	r4, [r5, #0]
c0d0445e:	023f      	lsls	r7, r7, #8
c0d04460:	193f      	adds	r7, r7, r4
        remlen--;
        if (remlen == 0) {
c0d04462:	1c76      	adds	r6, r6, #1
        remlen--;
c0d04464:	1e5b      	subs	r3, r3, #1
        tlvlen = (tlvlen << 8) | ((*tlv++)&0xFF);
c0d04466:	1c6d      	adds	r5, r5, #1
        if (remlen == 0) {
c0d04468:	2b00      	cmp	r3, #0
c0d0446a:	d1f5      	bne.n	c0d04458 <os_parse_bertlv+0x7c>
c0d0446c:	e017      	b.n	c0d0449e <os_parse_bertlv+0xc2>
c0d0446e:	463e      	mov	r6, r7
c0d04470:	9c0a      	ldr	r4, [sp, #40]	; 0x28
          goto retret; 
        }
      }
    }
    // check if tag matches
    if (tlvtag == (tag&0xFF)) {
c0d04472:	9f07      	ldr	r7, [sp, #28]
c0d04474:	42b8      	cmp	r0, r7
c0d04476:	460f      	mov	r7, r1
c0d04478:	d106      	bne.n	c0d04488 <os_parse_bertlv+0xac>
      if (tlvoffset) {
c0d0447a:	2c00      	cmp	r4, #0
c0d0447c:	d012      	beq.n	c0d044a4 <os_parse_bertlv+0xc8>
        unsigned int o = (unsigned int) tlv - (unsigned int)mem;
c0d0447e:	1be8      	subs	r0, r5, r7
        // compute the current position in the tlv bytes
        *tlvoffset = o;
c0d04480:	6020      	str	r0, [r4, #0]
c0d04482:	9906      	ldr	r1, [sp, #24]
c0d04484:	4281      	cmp	r1, r0
c0d04486:	d90d      	bls.n	c0d044a4 <os_parse_bertlv+0xc8>
      goto retret;
    }
  next_tlv:
    // skip to next tlv
    tlv += tlvlen;
    remlen-=MIN(remlen, tlvlen);
c0d04488:	42b3      	cmp	r3, r6
c0d0448a:	461c      	mov	r4, r3
c0d0448c:	4611      	mov	r1, r2
c0d0448e:	d300      	bcc.n	c0d04492 <os_parse_bertlv+0xb6>
c0d04490:	4634      	mov	r4, r6
c0d04492:	19ae      	adds	r6, r5, r6
c0d04494:	1b1b      	subs	r3, r3, r4
  while(remlen>=2) {
c0d04496:	2b01      	cmp	r3, #1
c0d04498:	9808      	ldr	r0, [sp, #32]
c0d0449a:	d8cc      	bhi.n	c0d04436 <os_parse_bertlv+0x5a>
c0d0449c:	e000      	b.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d0449e:	2000      	movs	r0, #0
  }
retret:
  return ret;
}
c0d044a0:	b00b      	add	sp, #44	; 0x2c
c0d044a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d044a4:	9809      	ldr	r0, [sp, #36]	; 0x24
      if (offset > tlvlen || offset > remlen) {
c0d044a6:	4298      	cmp	r0, r3
c0d044a8:	d831      	bhi.n	c0d0450e <os_parse_bertlv+0x132>
c0d044aa:	4286      	cmp	r6, r0
c0d044ac:	d32f      	bcc.n	c0d0450e <os_parse_bertlv+0x132>
c0d044ae:	4611      	mov	r1, r2
      if (check_equals_buffer && (tlvlen-offset) != maxlength) {
c0d044b0:	1a34      	subs	r4, r6, r0
c0d044b2:	9a03      	ldr	r2, [sp, #12]
c0d044b4:	4294      	cmp	r4, r2
c0d044b6:	d002      	beq.n	c0d044be <os_parse_bertlv+0xe2>
c0d044b8:	9a02      	ldr	r2, [sp, #8]
c0d044ba:	2a00      	cmp	r2, #0
c0d044bc:	db27      	blt.n	c0d0450e <os_parse_bertlv+0x132>
      maxlength = MIN(maxlength, MIN(tlvlen-offset, remlen));
c0d044be:	429c      	cmp	r4, r3
c0d044c0:	d300      	bcc.n	c0d044c4 <os_parse_bertlv+0xe8>
c0d044c2:	461c      	mov	r4, r3
c0d044c4:	9a03      	ldr	r2, [sp, #12]
c0d044c6:	4294      	cmp	r4, r2
c0d044c8:	d800      	bhi.n	c0d044cc <os_parse_bertlv+0xf0>
c0d044ca:	4622      	mov	r2, r4
        || maxlength > mem_len
c0d044cc:	4288      	cmp	r0, r1
c0d044ce:	d81e      	bhi.n	c0d0450e <os_parse_bertlv+0x132>
c0d044d0:	428a      	cmp	r2, r1
c0d044d2:	d81c      	bhi.n	c0d0450e <os_parse_bertlv+0x132>
c0d044d4:	1810      	adds	r0, r2, r0
c0d044d6:	4288      	cmp	r0, r1
c0d044d8:	d819      	bhi.n	c0d0450e <os_parse_bertlv+0x132>
        || (unsigned int)tlv+offset < (unsigned int)mem 
c0d044da:	42bd      	cmp	r5, r7
c0d044dc:	d317      	bcc.n	c0d0450e <os_parse_bertlv+0x132>
c0d044de:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d044e0:	1940      	adds	r0, r0, r5
        || (unsigned int)tlv+offset+maxlength < (unsigned int)mem 
c0d044e2:	42b8      	cmp	r0, r7
c0d044e4:	d313      	bcc.n	c0d0450e <os_parse_bertlv+0x132>
c0d044e6:	900a      	str	r0, [sp, #40]	; 0x28
c0d044e8:	1810      	adds	r0, r2, r0
        || (unsigned int)tlv > (unsigned int)mem+mem_len
c0d044ea:	42b8      	cmp	r0, r7
c0d044ec:	d30f      	bcc.n	c0d0450e <os_parse_bertlv+0x132>
c0d044ee:	1879      	adds	r1, r7, r1
        || (unsigned int)tlv+offset > (unsigned int)mem+mem_len
c0d044f0:	42a9      	cmp	r1, r5
c0d044f2:	d30c      	bcc.n	c0d0450e <os_parse_bertlv+0x132>
c0d044f4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
c0d044f6:	428d      	cmp	r5, r1
c0d044f8:	d809      	bhi.n	c0d0450e <os_parse_bertlv+0x132>
c0d044fa:	4288      	cmp	r0, r1
c0d044fc:	d807      	bhi.n	c0d0450e <os_parse_bertlv+0x132>
      if (get_address) {
c0d044fe:	9804      	ldr	r0, [sp, #16]
c0d04500:	2800      	cmp	r0, #0
c0d04502:	d006      	beq.n	c0d04512 <os_parse_bertlv+0x136>
        *buffer = tlv+offset;
c0d04504:	9801      	ldr	r0, [sp, #4]
c0d04506:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d04508:	6001      	str	r1, [r0, #0]
c0d0450a:	4620      	mov	r0, r4
c0d0450c:	e7c8      	b.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d0450e:	9808      	ldr	r0, [sp, #32]
c0d04510:	e7c6      	b.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d04512:	9801      	ldr	r0, [sp, #4]
c0d04514:	6801      	ldr	r1, [r0, #0]
      if (!check_equals_buffer) {
c0d04516:	9802      	ldr	r0, [sp, #8]
c0d04518:	2800      	cmp	r0, #0
c0d0451a:	db23      	blt.n	c0d04564 <os_parse_bertlv+0x188>
  if (dst > src) {
c0d0451c:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d0451e:	4281      	cmp	r1, r0
c0d04520:	d928      	bls.n	c0d04574 <os_parse_bertlv+0x198>
    while(length--) {
c0d04522:	2a00      	cmp	r2, #0
c0d04524:	9808      	ldr	r0, [sp, #32]
c0d04526:	d0bb      	beq.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d04528:	9c05      	ldr	r4, [sp, #20]
c0d0452a:	1b10      	subs	r0, r2, r4
c0d0452c:	1909      	adds	r1, r1, r4
c0d0452e:	1ae4      	subs	r4, r4, r3
c0d04530:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0d04532:	1e5b      	subs	r3, r3, #1
c0d04534:	1b9b      	subs	r3, r3, r6
c0d04536:	42a3      	cmp	r3, r4
c0d04538:	d800      	bhi.n	c0d0453c <os_parse_bertlv+0x160>
c0d0453a:	4623      	mov	r3, r4
c0d0453c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
c0d0453e:	1824      	adds	r4, r4, r0
c0d04540:	1809      	adds	r1, r1, r0
c0d04542:	9805      	ldr	r0, [sp, #20]
c0d04544:	9d03      	ldr	r5, [sp, #12]
c0d04546:	1b40      	subs	r0, r0, r5
c0d04548:	4283      	cmp	r3, r0
c0d0454a:	d800      	bhi.n	c0d0454e <os_parse_bertlv+0x172>
c0d0454c:	4603      	mov	r3, r0
c0d0454e:	1ea0      	subs	r0, r4, #2
c0d04550:	1e49      	subs	r1, r1, #1
c0d04552:	1c5b      	adds	r3, r3, #1
c0d04554:	9d05      	ldr	r5, [sp, #20]
      DSTCHAR[length] = SRCCHAR[length];
c0d04556:	7804      	ldrb	r4, [r0, #0]
c0d04558:	700c      	strb	r4, [r1, #0]
    while(length--) {
c0d0455a:	1940      	adds	r0, r0, r5
c0d0455c:	1949      	adds	r1, r1, r5
c0d0455e:	1c5b      	adds	r3, r3, #1
c0d04560:	d1f9      	bne.n	c0d04556 <os_parse_bertlv+0x17a>
c0d04562:	e022      	b.n	c0d045aa <os_parse_bertlv+0x1ce>
        ret = os_secure_memcmp(*buffer, tlv+offset, maxlength) == 0;
c0d04564:	4608      	mov	r0, r1
c0d04566:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d04568:	f7ff ff1a 	bl	c0d043a0 <os_secure_memcmp>
c0d0456c:	4601      	mov	r1, r0
c0d0456e:	4240      	negs	r0, r0
c0d04570:	4148      	adcs	r0, r1
c0d04572:	e795      	b.n	c0d044a0 <os_parse_bertlv+0xc4>
    while (length--) {
c0d04574:	2a00      	cmp	r2, #0
c0d04576:	9808      	ldr	r0, [sp, #32]
c0d04578:	d092      	beq.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d0457a:	9805      	ldr	r0, [sp, #20]
c0d0457c:	1ac3      	subs	r3, r0, r3
c0d0457e:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d04580:	1e40      	subs	r0, r0, #1
c0d04582:	1b80      	subs	r0, r0, r6
c0d04584:	4298      	cmp	r0, r3
c0d04586:	d800      	bhi.n	c0d0458a <os_parse_bertlv+0x1ae>
c0d04588:	4618      	mov	r0, r3
c0d0458a:	9b05      	ldr	r3, [sp, #20]
c0d0458c:	9c03      	ldr	r4, [sp, #12]
c0d0458e:	1b1b      	subs	r3, r3, r4
c0d04590:	4298      	cmp	r0, r3
c0d04592:	d800      	bhi.n	c0d04596 <os_parse_bertlv+0x1ba>
c0d04594:	4618      	mov	r0, r3
c0d04596:	1c40      	adds	r0, r0, #1
c0d04598:	2300      	movs	r3, #0
c0d0459a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
      DSTCHAR[l] = SRCCHAR[l];
c0d0459c:	b29c      	uxth	r4, r3
c0d0459e:	5d35      	ldrb	r5, [r6, r4]
c0d045a0:	550d      	strb	r5, [r1, r4]
    while (length--) {
c0d045a2:	1c40      	adds	r0, r0, #1
      l++;
c0d045a4:	1c5b      	adds	r3, r3, #1
    while (length--) {
c0d045a6:	2800      	cmp	r0, #0
c0d045a8:	d1f8      	bne.n	c0d0459c <os_parse_bertlv+0x1c0>
c0d045aa:	4610      	mov	r0, r2
c0d045ac:	e778      	b.n	c0d044a0 <os_parse_bertlv+0xc4>
c0d045ae:	46c0      	nop			; (mov r8, r8)
c0d045b0:	3fffffff 	.word	0x3fffffff

c0d045b4 <io_seproxyhal_general_status>:

#ifndef IO_RAPDU_TRANSMIT_TIMEOUT_MS 
#define IO_RAPDU_TRANSMIT_TIMEOUT_MS 2000UL
#endif // IO_RAPDU_TRANSMIT_TIMEOUT_MS

void io_seproxyhal_general_status(void) {
c0d045b4:	b580      	push	{r7, lr}
  // avoid troubles
  if (io_seproxyhal_spi_is_status_sent()) {
c0d045b6:	f002 fac3 	bl	c0d06b40 <io_seph_is_status_sent>
c0d045ba:	2800      	cmp	r0, #0
c0d045bc:	d000      	beq.n	c0d045c0 <io_seproxyhal_general_status+0xc>
  G_io_seproxyhal_spi_buffer[1] = 0;
  G_io_seproxyhal_spi_buffer[2] = 2;
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND>>8;
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND;
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 5);
}
c0d045be:	bd80      	pop	{r7, pc}
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_GENERAL_STATUS;
c0d045c0:	4806      	ldr	r0, [pc, #24]	; (c0d045dc <io_seproxyhal_general_status+0x28>)
c0d045c2:	2100      	movs	r1, #0
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND;
c0d045c4:	7101      	strb	r1, [r0, #4]
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND>>8;
c0d045c6:	70c1      	strb	r1, [r0, #3]
c0d045c8:	2202      	movs	r2, #2
  G_io_seproxyhal_spi_buffer[2] = 2;
c0d045ca:	7082      	strb	r2, [r0, #2]
  G_io_seproxyhal_spi_buffer[1] = 0;
c0d045cc:	7041      	strb	r1, [r0, #1]
c0d045ce:	2160      	movs	r1, #96	; 0x60
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_GENERAL_STATUS;
c0d045d0:	7001      	strb	r1, [r0, #0]
c0d045d2:	2105      	movs	r1, #5
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 5);
c0d045d4:	f002 faa8 	bl	c0d06b28 <io_seph_send>
}
c0d045d8:	bd80      	pop	{r7, pc}
c0d045da:	46c0      	nop			; (mov r8, r8)
c0d045dc:	20001b00 	.word	0x20001b00

c0d045e0 <io_seproxyhal_handle_usb_event>:
}

#ifdef HAVE_IO_USB
#ifdef HAVE_L4_USBLIB

void io_seproxyhal_handle_usb_event(void) {
c0d045e0:	b5b0      	push	{r4, r5, r7, lr}
  switch(G_io_seproxyhal_spi_buffer[3]) {
c0d045e2:	481a      	ldr	r0, [pc, #104]	; (c0d0464c <io_seproxyhal_handle_usb_event+0x6c>)
c0d045e4:	78c0      	ldrb	r0, [r0, #3]
c0d045e6:	2803      	cmp	r0, #3
c0d045e8:	dc07      	bgt.n	c0d045fa <io_seproxyhal_handle_usb_event+0x1a>
c0d045ea:	2801      	cmp	r0, #1
c0d045ec:	d00d      	beq.n	c0d0460a <io_seproxyhal_handle_usb_event+0x2a>
c0d045ee:	2802      	cmp	r0, #2
c0d045f0:	d128      	bne.n	c0d04644 <io_seproxyhal_handle_usb_event+0x64>
      }
      os_memset(G_io_app.usb_ep_xfer_len, 0, sizeof(G_io_app.usb_ep_xfer_len));
      os_memset(G_io_app.usb_ep_timeouts, 0, sizeof(G_io_app.usb_ep_timeouts));
      break;
    case SEPROXYHAL_TAG_USB_EVENT_SOF:
      USBD_LL_SOF(&USBD_Device);
c0d045f2:	4817      	ldr	r0, [pc, #92]	; (c0d04650 <io_seproxyhal_handle_usb_event+0x70>)
c0d045f4:	f004 fbb3 	bl	c0d08d5e <USBD_LL_SOF>
      break;
    case SEPROXYHAL_TAG_USB_EVENT_RESUMED:
      USBD_LL_Resume(&USBD_Device);
      break;
  }
}
c0d045f8:	bdb0      	pop	{r4, r5, r7, pc}
  switch(G_io_seproxyhal_spi_buffer[3]) {
c0d045fa:	2804      	cmp	r0, #4
c0d045fc:	d01f      	beq.n	c0d0463e <io_seproxyhal_handle_usb_event+0x5e>
c0d045fe:	2808      	cmp	r0, #8
c0d04600:	d120      	bne.n	c0d04644 <io_seproxyhal_handle_usb_event+0x64>
      USBD_LL_Resume(&USBD_Device);
c0d04602:	4813      	ldr	r0, [pc, #76]	; (c0d04650 <io_seproxyhal_handle_usb_event+0x70>)
c0d04604:	f004 fba9 	bl	c0d08d5a <USBD_LL_Resume>
}
c0d04608:	bdb0      	pop	{r4, r5, r7, pc}
      USBD_LL_SetSpeed(&USBD_Device, USBD_SPEED_FULL);  
c0d0460a:	4c11      	ldr	r4, [pc, #68]	; (c0d04650 <io_seproxyhal_handle_usb_event+0x70>)
c0d0460c:	2101      	movs	r1, #1
c0d0460e:	4620      	mov	r0, r4
c0d04610:	f004 fb9e 	bl	c0d08d50 <USBD_LL_SetSpeed>
      USBD_LL_Reset(&USBD_Device);
c0d04614:	4620      	mov	r0, r4
c0d04616:	f004 fb7d 	bl	c0d08d14 <USBD_LL_Reset>
      if (G_io_app.apdu_media != IO_APDU_MEDIA_NONE) {
c0d0461a:	4c0e      	ldr	r4, [pc, #56]	; (c0d04654 <io_seproxyhal_handle_usb_event+0x74>)
c0d0461c:	79a0      	ldrb	r0, [r4, #6]
c0d0461e:	2800      	cmp	r0, #0
c0d04620:	d111      	bne.n	c0d04646 <io_seproxyhal_handle_usb_event+0x66>
      os_memset(G_io_app.usb_ep_xfer_len, 0, sizeof(G_io_app.usb_ep_xfer_len));
c0d04622:	4620      	mov	r0, r4
c0d04624:	300c      	adds	r0, #12
c0d04626:	2500      	movs	r5, #0
c0d04628:	2204      	movs	r2, #4
c0d0462a:	4629      	mov	r1, r5
c0d0462c:	f7ff fe8b 	bl	c0d04346 <os_memset>
      os_memset(G_io_app.usb_ep_timeouts, 0, sizeof(G_io_app.usb_ep_timeouts));
c0d04630:	3410      	adds	r4, #16
c0d04632:	2208      	movs	r2, #8
c0d04634:	4620      	mov	r0, r4
c0d04636:	4629      	mov	r1, r5
c0d04638:	f7ff fe85 	bl	c0d04346 <os_memset>
}
c0d0463c:	bdb0      	pop	{r4, r5, r7, pc}
      USBD_LL_Suspend(&USBD_Device);
c0d0463e:	4804      	ldr	r0, [pc, #16]	; (c0d04650 <io_seproxyhal_handle_usb_event+0x70>)
c0d04640:	f004 fb89 	bl	c0d08d56 <USBD_LL_Suspend>
}
c0d04644:	bdb0      	pop	{r4, r5, r7, pc}
c0d04646:	2010      	movs	r0, #16
        THROW(EXCEPTION_IO_RESET);
c0d04648:	f7ff fe9c 	bl	c0d04384 <os_longjmp>
c0d0464c:	20001b00 	.word	0x20001b00
c0d04650:	2000211c 	.word	0x2000211c
c0d04654:	2000205c 	.word	0x2000205c

c0d04658 <io_seproxyhal_get_ep_rx_size>:

uint16_t io_seproxyhal_get_ep_rx_size(uint8_t epnum) {
c0d04658:	217f      	movs	r1, #127	; 0x7f
  if ((epnum & 0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d0465a:	4001      	ands	r1, r0
c0d0465c:	2903      	cmp	r1, #3
c0d0465e:	d803      	bhi.n	c0d04668 <io_seproxyhal_get_ep_rx_size+0x10>
  return G_io_app.usb_ep_xfer_len[epnum&0x7F];
c0d04660:	4802      	ldr	r0, [pc, #8]	; (c0d0466c <io_seproxyhal_get_ep_rx_size+0x14>)
c0d04662:	1840      	adds	r0, r0, r1
c0d04664:	7b00      	ldrb	r0, [r0, #12]
}
  return 0;
}
c0d04666:	4770      	bx	lr
c0d04668:	2000      	movs	r0, #0
c0d0466a:	4770      	bx	lr
c0d0466c:	2000205c 	.word	0x2000205c

c0d04670 <io_seproxyhal_handle_usb_ep_xfer_event>:

void io_seproxyhal_handle_usb_ep_xfer_event(void) {
c0d04670:	b580      	push	{r7, lr}
  switch(G_io_seproxyhal_spi_buffer[4]) {
c0d04672:	4815      	ldr	r0, [pc, #84]	; (c0d046c8 <io_seproxyhal_handle_usb_ep_xfer_event+0x58>)
c0d04674:	7901      	ldrb	r1, [r0, #4]
c0d04676:	2904      	cmp	r1, #4
c0d04678:	d017      	beq.n	c0d046aa <io_seproxyhal_handle_usb_ep_xfer_event+0x3a>
c0d0467a:	2902      	cmp	r1, #2
c0d0467c:	d006      	beq.n	c0d0468c <io_seproxyhal_handle_usb_ep_xfer_event+0x1c>
c0d0467e:	2901      	cmp	r1, #1
c0d04680:	d120      	bne.n	c0d046c4 <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
    /* This event is received when a new SETUP token had been received on a control endpoint */
    case SEPROXYHAL_TAG_USB_EP_XFER_SETUP:
      // assume length of setup packet, and that it is on endpoint 0
      USBD_LL_SetupStage(&USBD_Device, &G_io_seproxyhal_spi_buffer[6]);
c0d04682:	1d81      	adds	r1, r0, #6
c0d04684:	4812      	ldr	r0, [pc, #72]	; (c0d046d0 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d04686:	f004 fa4e 	bl	c0d08b26 <USBD_LL_SetupStage>
        // prepare reception
        USBD_LL_DataOutStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
      }
      break;
  }
}
c0d0468a:	bd80      	pop	{r7, pc}
      if ((G_io_seproxyhal_spi_buffer[3]&0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d0468c:	78c2      	ldrb	r2, [r0, #3]
c0d0468e:	217f      	movs	r1, #127	; 0x7f
c0d04690:	4011      	ands	r1, r2
c0d04692:	2903      	cmp	r1, #3
c0d04694:	d816      	bhi.n	c0d046c4 <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
        G_io_app.usb_ep_timeouts[G_io_seproxyhal_spi_buffer[3]&0x7F].timeout = 0;
c0d04696:	004a      	lsls	r2, r1, #1
c0d04698:	4b0c      	ldr	r3, [pc, #48]	; (c0d046cc <io_seproxyhal_handle_usb_ep_xfer_event+0x5c>)
c0d0469a:	189a      	adds	r2, r3, r2
c0d0469c:	2300      	movs	r3, #0
c0d0469e:	8213      	strh	r3, [r2, #16]
        USBD_LL_DataInStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
c0d046a0:	1d82      	adds	r2, r0, #6
c0d046a2:	480b      	ldr	r0, [pc, #44]	; (c0d046d0 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d046a4:	f004 fac4 	bl	c0d08c30 <USBD_LL_DataInStage>
}
c0d046a8:	bd80      	pop	{r7, pc}
      if ((G_io_seproxyhal_spi_buffer[3]&0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d046aa:	78c2      	ldrb	r2, [r0, #3]
c0d046ac:	217f      	movs	r1, #127	; 0x7f
c0d046ae:	4011      	ands	r1, r2
c0d046b0:	2903      	cmp	r1, #3
c0d046b2:	d807      	bhi.n	c0d046c4 <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
        G_io_app.usb_ep_xfer_len[G_io_seproxyhal_spi_buffer[3]&0x7F] = G_io_seproxyhal_spi_buffer[5];
c0d046b4:	4a05      	ldr	r2, [pc, #20]	; (c0d046cc <io_seproxyhal_handle_usb_ep_xfer_event+0x5c>)
c0d046b6:	1852      	adds	r2, r2, r1
c0d046b8:	7943      	ldrb	r3, [r0, #5]
c0d046ba:	7313      	strb	r3, [r2, #12]
        USBD_LL_DataOutStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
c0d046bc:	1d82      	adds	r2, r0, #6
c0d046be:	4804      	ldr	r0, [pc, #16]	; (c0d046d0 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d046c0:	f004 fa5f 	bl	c0d08b82 <USBD_LL_DataOutStage>
}
c0d046c4:	bd80      	pop	{r7, pc}
c0d046c6:	46c0      	nop			; (mov r8, r8)
c0d046c8:	20001b00 	.word	0x20001b00
c0d046cc:	2000205c 	.word	0x2000205c
c0d046d0:	2000211c 	.word	0x2000211c

c0d046d4 <io_usb_send_ep>:
#endif // HAVE_L4_USBLIB

// TODO, refactor this using the USB DataIn event like for the U2F tunnel
// TODO add a blocking parameter, for HID KBD sending, or use a USB busy flag per channel to know if 
// the transfer has been processed or not. and move on to the next transfer on the same endpoint
void io_usb_send_ep(unsigned int ep, unsigned char* buffer, unsigned short length, unsigned int timeout) {
c0d046d4:	b570      	push	{r4, r5, r6, lr}
  if (timeout) {
    timeout++;
  }

  // won't send if overflowing seproxyhal buffer format
  if (length > 255) {
c0d046d6:	2aff      	cmp	r2, #255	; 0xff
c0d046d8:	d81e      	bhi.n	c0d04718 <io_usb_send_ep+0x44>
c0d046da:	4615      	mov	r5, r2
c0d046dc:	460e      	mov	r6, r1
c0d046de:	4604      	mov	r4, r0
    return;
  }
  
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d046e0:	480e      	ldr	r0, [pc, #56]	; (c0d0471c <io_usb_send_ep+0x48>)
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
  G_io_seproxyhal_spi_buffer[2] = (3+length);
  G_io_seproxyhal_spi_buffer[3] = ep|0x80;
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
  G_io_seproxyhal_spi_buffer[5] = length;
c0d046e2:	7142      	strb	r2, [r0, #5]
c0d046e4:	2120      	movs	r1, #32
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
c0d046e6:	7101      	strb	r1, [r0, #4]
c0d046e8:	2150      	movs	r1, #80	; 0x50
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d046ea:	7001      	strb	r1, [r0, #0]
c0d046ec:	2180      	movs	r1, #128	; 0x80
  G_io_seproxyhal_spi_buffer[3] = ep|0x80;
c0d046ee:	4321      	orrs	r1, r4
c0d046f0:	70c1      	strb	r1, [r0, #3]
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
c0d046f2:	1cd1      	adds	r1, r2, #3
  G_io_seproxyhal_spi_buffer[2] = (3+length);
c0d046f4:	7081      	strb	r1, [r0, #2]
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
c0d046f6:	0a09      	lsrs	r1, r1, #8
c0d046f8:	7041      	strb	r1, [r0, #1]
c0d046fa:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 6);
c0d046fc:	f002 fa14 	bl	c0d06b28 <io_seph_send>
  io_seproxyhal_spi_send(buffer, length);
c0d04700:	4630      	mov	r0, r6
c0d04702:	4629      	mov	r1, r5
c0d04704:	f002 fa10 	bl	c0d06b28 <io_seph_send>
c0d04708:	207f      	movs	r0, #127	; 0x7f
  // setup timeout of the endpoint
  G_io_app.usb_ep_timeouts[ep&0x7F].timeout = IO_RAPDU_TRANSMIT_TIMEOUT_MS;
c0d0470a:	4020      	ands	r0, r4
c0d0470c:	0040      	lsls	r0, r0, #1
c0d0470e:	4904      	ldr	r1, [pc, #16]	; (c0d04720 <io_usb_send_ep+0x4c>)
c0d04710:	1808      	adds	r0, r1, r0
c0d04712:	217d      	movs	r1, #125	; 0x7d
c0d04714:	0109      	lsls	r1, r1, #4
c0d04716:	8201      	strh	r1, [r0, #16]
}
c0d04718:	bd70      	pop	{r4, r5, r6, pc}
c0d0471a:	46c0      	nop			; (mov r8, r8)
c0d0471c:	20001b00 	.word	0x20001b00
c0d04720:	2000205c 	.word	0x2000205c

c0d04724 <io_usb_send_apdu_data>:

void io_usb_send_apdu_data(unsigned char* buffer, unsigned short length) {
c0d04724:	b580      	push	{r7, lr}
c0d04726:	460a      	mov	r2, r1
c0d04728:	4601      	mov	r1, r0
c0d0472a:	2082      	movs	r0, #130	; 0x82
c0d0472c:	2314      	movs	r3, #20
  // wait for 20 events before hanging up and timeout (~2 seconds of timeout)
  io_usb_send_ep(0x82, buffer, length, 20);
c0d0472e:	f7ff ffd1 	bl	c0d046d4 <io_usb_send_ep>
}
c0d04732:	bd80      	pop	{r7, pc}

c0d04734 <io_usb_send_apdu_data_ep0x83>:

#ifdef HAVE_WEBUSB
void io_usb_send_apdu_data_ep0x83(unsigned char* buffer, unsigned short length) {
c0d04734:	b580      	push	{r7, lr}
c0d04736:	460a      	mov	r2, r1
c0d04738:	4601      	mov	r1, r0
c0d0473a:	2083      	movs	r0, #131	; 0x83
c0d0473c:	2314      	movs	r3, #20
  // wait for 20 events before hanging up and timeout (~2 seconds of timeout)
  io_usb_send_ep(0x83, buffer, length, 20);
c0d0473e:	f7ff ffc9 	bl	c0d046d4 <io_usb_send_ep>
}
c0d04742:	bd80      	pop	{r7, pc}

c0d04744 <io_seproxyhal_handle_capdu_event>:
void io_seproxyhal_handle_bluenrg_event(void) {

}
#endif // HAVE_BLUENRG

void io_seproxyhal_handle_capdu_event(void) {
c0d04744:	b580      	push	{r7, lr}
  if (G_io_app.apdu_state == APDU_IDLE) {
c0d04746:	480b      	ldr	r0, [pc, #44]	; (c0d04774 <io_seproxyhal_handle_capdu_event+0x30>)
c0d04748:	7801      	ldrb	r1, [r0, #0]
c0d0474a:	2900      	cmp	r1, #0
c0d0474c:	d000      	beq.n	c0d04750 <io_seproxyhal_handle_capdu_event+0xc>
    G_io_app.apdu_state = APDU_RAW; // for next call to io_exchange
    G_io_app.apdu_length = MIN(size, max);
    // copy apdu to apdu buffer
    os_memmove(G_io_apdu_buffer, G_io_seproxyhal_spi_buffer+3, G_io_app.apdu_length);
  }
}
c0d0474e:	bd80      	pop	{r7, pc}
c0d04750:	2106      	movs	r1, #6
    G_io_app.apdu_media = IO_APDU_MEDIA_RAW; // for application code
c0d04752:	7181      	strb	r1, [r0, #6]
c0d04754:	210a      	movs	r1, #10
    G_io_app.apdu_state = APDU_RAW; // for next call to io_exchange
c0d04756:	7001      	strb	r1, [r0, #0]
    size_t size = U2BE(G_io_seproxyhal_spi_buffer, 1);
c0d04758:	4907      	ldr	r1, [pc, #28]	; (c0d04778 <io_seproxyhal_handle_capdu_event+0x34>)
c0d0475a:	788a      	ldrb	r2, [r1, #2]
c0d0475c:	784b      	ldrb	r3, [r1, #1]
c0d0475e:	021b      	lsls	r3, r3, #8
c0d04760:	189a      	adds	r2, r3, r2
    G_io_app.apdu_length = MIN(size, max);
c0d04762:	2a45      	cmp	r2, #69	; 0x45
c0d04764:	d300      	bcc.n	c0d04768 <io_seproxyhal_handle_capdu_event+0x24>
c0d04766:	2245      	movs	r2, #69	; 0x45
c0d04768:	8042      	strh	r2, [r0, #2]
    os_memmove(G_io_apdu_buffer, G_io_seproxyhal_spi_buffer+3, G_io_app.apdu_length);
c0d0476a:	1cc9      	adds	r1, r1, #3
c0d0476c:	4803      	ldr	r0, [pc, #12]	; (c0d0477c <io_seproxyhal_handle_capdu_event+0x38>)
c0d0476e:	f7ff fdd4 	bl	c0d0431a <os_memmove>
}
c0d04772:	bd80      	pop	{r7, pc}
c0d04774:	2000205c 	.word	0x2000205c
c0d04778:	20001b00 	.word	0x20001b00
c0d0477c:	20001f09 	.word	0x20001f09

c0d04780 <io_seproxyhal_handle_event>:

unsigned int io_seproxyhal_handle_event(void) {
c0d04780:	b580      	push	{r7, lr}
  unsigned int rx_len = U2BE(G_io_seproxyhal_spi_buffer, 1);
c0d04782:	491f      	ldr	r1, [pc, #124]	; (c0d04800 <io_seproxyhal_handle_event+0x80>)
c0d04784:	7888      	ldrb	r0, [r1, #2]
c0d04786:	784a      	ldrb	r2, [r1, #1]
c0d04788:	0212      	lsls	r2, r2, #8
c0d0478a:	1810      	adds	r0, r2, r0

  switch(G_io_seproxyhal_spi_buffer[0]) {
c0d0478c:	7809      	ldrb	r1, [r1, #0]
c0d0478e:	290f      	cmp	r1, #15
c0d04790:	dc09      	bgt.n	c0d047a6 <io_seproxyhal_handle_event+0x26>
c0d04792:	290e      	cmp	r1, #14
c0d04794:	d00f      	beq.n	c0d047b6 <io_seproxyhal_handle_event+0x36>
c0d04796:	290f      	cmp	r1, #15
c0d04798:	d120      	bne.n	c0d047dc <io_seproxyhal_handle_event+0x5c>
  #ifdef HAVE_IO_USB
    case SEPROXYHAL_TAG_USB_EVENT:
      if (rx_len != 1) {
c0d0479a:	2801      	cmp	r0, #1
c0d0479c:	d124      	bne.n	c0d047e8 <io_seproxyhal_handle_event+0x68>
        return 0;
      }
      io_seproxyhal_handle_usb_event();
c0d0479e:	f7ff ff1f 	bl	c0d045e0 <io_seproxyhal_handle_usb_event>
c0d047a2:	2001      	movs	r0, #1
    default:
      return io_event(CHANNEL_SPI);
  }
  // defaultly return as not processed
  return 0;
}
c0d047a4:	bd80      	pop	{r7, pc}
  switch(G_io_seproxyhal_spi_buffer[0]) {
c0d047a6:	2910      	cmp	r1, #16
c0d047a8:	d01c      	beq.n	c0d047e4 <io_seproxyhal_handle_event+0x64>
c0d047aa:	2916      	cmp	r1, #22
c0d047ac:	d116      	bne.n	c0d047dc <io_seproxyhal_handle_event+0x5c>
      io_seproxyhal_handle_capdu_event();
c0d047ae:	f7ff ffc9 	bl	c0d04744 <io_seproxyhal_handle_capdu_event>
c0d047b2:	2001      	movs	r0, #1
}
c0d047b4:	bd80      	pop	{r7, pc}
      G_io_app.ms += 100; // value is by default, don't change the ticker configuration
c0d047b6:	4813      	ldr	r0, [pc, #76]	; (c0d04804 <io_seproxyhal_handle_event+0x84>)
c0d047b8:	6881      	ldr	r1, [r0, #8]
c0d047ba:	3164      	adds	r1, #100	; 0x64
c0d047bc:	6081      	str	r1, [r0, #8]
c0d047be:	2116      	movs	r1, #22
          if (G_io_app.usb_ep_timeouts[i].timeout) {
c0d047c0:	5a42      	ldrh	r2, [r0, r1]
c0d047c2:	2a00      	cmp	r2, #0
c0d047c4:	d007      	beq.n	c0d047d6 <io_seproxyhal_handle_event+0x56>
            G_io_app.usb_ep_timeouts[i].timeout-=MIN(G_io_app.usb_ep_timeouts[i].timeout, 100);
c0d047c6:	2a64      	cmp	r2, #100	; 0x64
c0d047c8:	4613      	mov	r3, r2
c0d047ca:	d300      	bcc.n	c0d047ce <io_seproxyhal_handle_event+0x4e>
c0d047cc:	2364      	movs	r3, #100	; 0x64
c0d047ce:	1ad2      	subs	r2, r2, r3
c0d047d0:	5242      	strh	r2, [r0, r1]
            if (!G_io_app.usb_ep_timeouts[i].timeout) {
c0d047d2:	0412      	lsls	r2, r2, #16
c0d047d4:	d00e      	beq.n	c0d047f4 <io_seproxyhal_handle_event+0x74>
        while(i--) {
c0d047d6:	1e89      	subs	r1, r1, #2
c0d047d8:	290e      	cmp	r1, #14
c0d047da:	d1f1      	bne.n	c0d047c0 <io_seproxyhal_handle_event+0x40>
c0d047dc:	2002      	movs	r0, #2
      return io_event(CHANNEL_SPI);
c0d047de:	f7ff faab 	bl	c0d03d38 <io_event>
}
c0d047e2:	bd80      	pop	{r7, pc}
      if (rx_len < 3) {
c0d047e4:	2803      	cmp	r0, #3
c0d047e6:	d201      	bcs.n	c0d047ec <io_seproxyhal_handle_event+0x6c>
c0d047e8:	2000      	movs	r0, #0
}
c0d047ea:	bd80      	pop	{r7, pc}
      io_seproxyhal_handle_usb_ep_xfer_event();
c0d047ec:	f7ff ff40 	bl	c0d04670 <io_seproxyhal_handle_usb_ep_xfer_event>
c0d047f0:	2001      	movs	r0, #1
}
c0d047f2:	bd80      	pop	{r7, pc}
c0d047f4:	2100      	movs	r1, #0
              G_io_app.apdu_state = APDU_IDLE;
c0d047f6:	7001      	strb	r1, [r0, #0]
c0d047f8:	2010      	movs	r0, #16
              THROW(EXCEPTION_IO_RESET);
c0d047fa:	f7ff fdc3 	bl	c0d04384 <os_longjmp>
c0d047fe:	46c0      	nop			; (mov r8, r8)
c0d04800:	20001b00 	.word	0x20001b00
c0d04804:	2000205c 	.word	0x2000205c

c0d04808 <io_seproxyhal_init>:
#ifdef HAVE_BOLOS_APP_STACK_CANARY
#define APP_STACK_CANARY_MAGIC 0xDEAD0031
extern unsigned int app_stack_canary;
#endif // HAVE_BOLOS_APP_STACK_CANARY

void io_seproxyhal_init(void) {
c0d04808:	b5b0      	push	{r4, r5, r7, lr}
c0d0480a:	200a      	movs	r0, #10
#ifndef HAVE_BOLOS
  // Enforce OS compatibility
  check_api_level(CX_COMPAT_APILEVEL);
c0d0480c:	f001 ffe2 	bl	c0d067d4 <check_api_level>

  // wipe the io structure before it's used
#ifdef TARGET_NANOX
  unsigned int plane = G_io_app.plane_mode;
#endif // TARGET_NANOX
  os_memset(&G_io_app, 0, sizeof(G_io_app));
c0d04810:	4c09      	ldr	r4, [pc, #36]	; (c0d04838 <io_seproxyhal_init+0x30>)
c0d04812:	2500      	movs	r5, #0
c0d04814:	2218      	movs	r2, #24
c0d04816:	4620      	mov	r0, r4
c0d04818:	4629      	mov	r1, r5
c0d0481a:	f7ff fd94 	bl	c0d04346 <os_memset>

  G_io_app.apdu_state = APDU_IDLE;
  G_io_app.apdu_length = 0;
  G_io_app.apdu_media = IO_APDU_MEDIA_NONE;

  G_io_app.ms = 0;
c0d0481e:	60a5      	str	r5, [r4, #8]
  G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0d04820:	71a5      	strb	r5, [r4, #6]
  G_io_app.apdu_length = 0;
c0d04822:	8065      	strh	r5, [r4, #2]
  G_io_app.apdu_state = APDU_IDLE;
c0d04824:	7025      	strb	r5, [r4, #0]
  #ifdef DEBUG_APDU
  debug_apdus_offset = 0;
  #endif // DEBUG_APDU

  #ifdef HAVE_USB_APDU
  io_usb_hid_init();
c0d04826:	f000 fb53 	bl	c0d04ed0 <io_usb_hid_init>
// #endif // TARGET_NANOX
}

void io_seproxyhal_init_button(void) {
  // no button push so far
  G_ux_os.button_mask = 0;
c0d0482a:	4804      	ldr	r0, [pc, #16]	; (c0d0483c <io_seproxyhal_init+0x34>)
c0d0482c:	6005      	str	r5, [r0, #0]
  G_ux_os.button_same_mask_counter = 0;
c0d0482e:	6045      	str	r5, [r0, #4]
  check_audited_app();
c0d04830:	f7fb fc5c 	bl	c0d000ec <check_audited_app>
}
c0d04834:	bdb0      	pop	{r4, r5, r7, pc}
c0d04836:	46c0      	nop			; (mov r8, r8)
c0d04838:	2000205c 	.word	0x2000205c
c0d0483c:	20002074 	.word	0x20002074

c0d04840 <io_seproxyhal_init_ux>:
}
c0d04840:	4770      	bx	lr
	...

c0d04844 <io_seproxyhal_init_button>:
  G_ux_os.button_mask = 0;
c0d04844:	4802      	ldr	r0, [pc, #8]	; (c0d04850 <io_seproxyhal_init_button+0xc>)
c0d04846:	2100      	movs	r1, #0
c0d04848:	6001      	str	r1, [r0, #0]
  G_ux_os.button_same_mask_counter = 0;
c0d0484a:	6041      	str	r1, [r0, #4]
}
c0d0484c:	4770      	bx	lr
c0d0484e:	46c0      	nop			; (mov r8, r8)
c0d04850:	20002074 	.word	0x20002074

c0d04854 <io_seproxyhal_display_icon>:
    }
  }
}

#else // TARGET_NANOX
void io_seproxyhal_display_icon(bagl_component_t* icon_component, bagl_icon_details_t* icon_det) {
c0d04854:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04856:	b089      	sub	sp, #36	; 0x24
c0d04858:	4605      	mov	r5, r0
  bagl_component_t icon_component_mod;
  const bagl_icon_details_t* icon_details = (bagl_icon_details_t*)PIC(icon_det);
c0d0485a:	4608      	mov	r0, r1
c0d0485c:	f000 ff6c 	bl	c0d05738 <pic>
  if (icon_details && icon_details->bitmap) {
c0d04860:	2800      	cmp	r0, #0
c0d04862:	d043      	beq.n	c0d048ec <io_seproxyhal_display_icon+0x98>
c0d04864:	4604      	mov	r4, r0
c0d04866:	6900      	ldr	r0, [r0, #16]
c0d04868:	2800      	cmp	r0, #0
c0d0486a:	d03f      	beq.n	c0d048ec <io_seproxyhal_display_icon+0x98>
    // ensure not being out of bounds in the icon component agianst the declared icon real size
    os_memmove(&icon_component_mod, (bagl_component_t *)PIC(icon_component), sizeof(bagl_component_t));
c0d0486c:	4628      	mov	r0, r5
c0d0486e:	f000 ff63 	bl	c0d05738 <pic>
c0d04872:	4601      	mov	r1, r0
c0d04874:	ad02      	add	r5, sp, #8
c0d04876:	221c      	movs	r2, #28
c0d04878:	4628      	mov	r0, r5
c0d0487a:	9201      	str	r2, [sp, #4]
c0d0487c:	f7ff fd4d 	bl	c0d0431a <os_memmove>
    icon_component_mod.width = icon_details->width;
c0d04880:	6821      	ldr	r1, [r4, #0]
c0d04882:	80e9      	strh	r1, [r5, #6]
    icon_component_mod.height = icon_details->height;
c0d04884:	6862      	ldr	r2, [r4, #4]
c0d04886:	812a      	strh	r2, [r5, #8]
    // component type = ICON, provided bitmap
    // => bitmap transmitted


    // color index size
    unsigned int h = (1<<(icon_details->bpp))*sizeof(unsigned int); 
c0d04888:	68a0      	ldr	r0, [r4, #8]
    unsigned int w = ((icon_component->width*icon_component->height*icon_details->bpp)/8)+((icon_component->width*icon_component->height*icon_details->bpp)%8?1:0);
    unsigned short length = sizeof(bagl_component_t)
                            +1 /* bpp */
                            +h /* color index */
                            +w; /* image bitmap size */
    G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d0488a:	4f19      	ldr	r7, [pc, #100]	; (c0d048f0 <io_seproxyhal_display_icon+0x9c>)
c0d0488c:	2365      	movs	r3, #101	; 0x65
c0d0488e:	463e      	mov	r6, r7
c0d04890:	703b      	strb	r3, [r7, #0]
    unsigned int w = ((icon_component->width*icon_component->height*icon_details->bpp)/8)+((icon_component->width*icon_component->height*icon_details->bpp)%8?1:0);
c0d04892:	b289      	uxth	r1, r1
c0d04894:	b292      	uxth	r2, r2
c0d04896:	434a      	muls	r2, r1
c0d04898:	4342      	muls	r2, r0
c0d0489a:	0751      	lsls	r1, r2, #29
c0d0489c:	08d2      	lsrs	r2, r2, #3
c0d0489e:	2900      	cmp	r1, #0
c0d048a0:	d000      	beq.n	c0d048a4 <io_seproxyhal_display_icon+0x50>
c0d048a2:	1c52      	adds	r2, r2, #1
c0d048a4:	9200      	str	r2, [sp, #0]
c0d048a6:	2704      	movs	r7, #4
    unsigned int h = (1<<(icon_details->bpp))*sizeof(unsigned int); 
c0d048a8:	4087      	lsls	r7, r0
                            +h /* color index */
c0d048aa:	18b8      	adds	r0, r7, r2
                            +w; /* image bitmap size */
c0d048ac:	301d      	adds	r0, #29
    G_io_seproxyhal_spi_buffer[1] = length>>8;
    G_io_seproxyhal_spi_buffer[2] = length;
c0d048ae:	70b0      	strb	r0, [r6, #2]
    G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d048b0:	0a00      	lsrs	r0, r0, #8
c0d048b2:	7070      	strb	r0, [r6, #1]
c0d048b4:	2103      	movs	r1, #3
    io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d048b6:	4630      	mov	r0, r6
c0d048b8:	f002 f936 	bl	c0d06b28 <io_seph_send>
    io_seproxyhal_spi_send((unsigned char*)icon_component, sizeof(bagl_component_t));
c0d048bc:	4628      	mov	r0, r5
c0d048be:	9901      	ldr	r1, [sp, #4]
c0d048c0:	f002 f932 	bl	c0d06b28 <io_seph_send>
    G_io_seproxyhal_spi_buffer[0] = icon_details->bpp;
c0d048c4:	68a0      	ldr	r0, [r4, #8]
c0d048c6:	7030      	strb	r0, [r6, #0]
c0d048c8:	2101      	movs	r1, #1
    io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 1);
c0d048ca:	4630      	mov	r0, r6
c0d048cc:	f002 f92c 	bl	c0d06b28 <io_seph_send>
    io_seproxyhal_spi_send((unsigned char*)PIC(icon_details->colors), h);
c0d048d0:	68e0      	ldr	r0, [r4, #12]
c0d048d2:	f000 ff31 	bl	c0d05738 <pic>
c0d048d6:	b2b9      	uxth	r1, r7
c0d048d8:	f002 f926 	bl	c0d06b28 <io_seph_send>
    io_seproxyhal_spi_send((unsigned char*)PIC(icon_details->bitmap), w);
c0d048dc:	9800      	ldr	r0, [sp, #0]
c0d048de:	b285      	uxth	r5, r0
c0d048e0:	6920      	ldr	r0, [r4, #16]
c0d048e2:	f000 ff29 	bl	c0d05738 <pic>
c0d048e6:	4629      	mov	r1, r5
c0d048e8:	f002 f91e 	bl	c0d06b28 <io_seph_send>
  #endif // !SEPROXYHAL_TAG_SCREEN_DISPLAY_RAW_STATUS
  }
}
c0d048ec:	b009      	add	sp, #36	; 0x24
c0d048ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d048f0:	20001b00 	.word	0x20001b00

c0d048f4 <io_seproxyhal_display_default>:

void io_seproxyhal_display_default(const bagl_element_t * el) {
c0d048f4:	b570      	push	{r4, r5, r6, lr}

  const bagl_element_t* element = (const bagl_element_t*) PIC(el);
c0d048f6:	f000 ff1f 	bl	c0d05738 <pic>
c0d048fa:	4604      	mov	r4, r0

  // process automagically address from rom and from ram
  unsigned int type = (element->component.type & ~(BAGL_FLAG_TOUCHABLE));
c0d048fc:	7806      	ldrb	r6, [r0, #0]

  // avoid sending another status :), fixes a lot of bugs in the end
  if (io_seproxyhal_spi_is_status_sent()) {
c0d048fe:	f002 f91f 	bl	c0d06b40 <io_seph_is_status_sent>
c0d04902:	2800      	cmp	r0, #0
c0d04904:	d132      	bne.n	c0d0496c <io_seproxyhal_display_default+0x78>
c0d04906:	207f      	movs	r0, #127	; 0x7f
c0d04908:	4006      	ands	r6, r0
c0d0490a:	2e00      	cmp	r6, #0
c0d0490c:	d02e      	beq.n	c0d0496c <io_seproxyhal_display_default+0x78>
    return;
  }

  if (type != BAGL_NONE) {
    if (element->text != NULL) {
c0d0490e:	69e0      	ldr	r0, [r4, #28]
c0d04910:	2800      	cmp	r0, #0
c0d04912:	d01d      	beq.n	c0d04950 <io_seproxyhal_display_default+0x5c>
      unsigned int text_adr = PIC((unsigned int)element->text);
c0d04914:	f000 ff10 	bl	c0d05738 <pic>
c0d04918:	4605      	mov	r5, r0
      // consider an icon details descriptor is pointed by the context
      if (type == BAGL_ICON && element->component.icon_id == 0) {
c0d0491a:	2e05      	cmp	r6, #5
c0d0491c:	d102      	bne.n	c0d04924 <io_seproxyhal_display_default+0x30>
c0d0491e:	7ea0      	ldrb	r0, [r4, #26]
c0d04920:	2800      	cmp	r0, #0
c0d04922:	d024      	beq.n	c0d0496e <io_seproxyhal_display_default+0x7a>
        io_seproxyhal_display_icon((bagl_component_t*)&element->component, (bagl_icon_details_t*)text_adr);
      }
      else {
        unsigned short length = sizeof(bagl_component_t)+strlen((const char*)text_adr);
c0d04924:	4628      	mov	r0, r5
c0d04926:	f006 f867 	bl	c0d0a9f8 <strlen>
c0d0492a:	4606      	mov	r6, r0
        G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d0492c:	4812      	ldr	r0, [pc, #72]	; (c0d04978 <io_seproxyhal_display_default+0x84>)
c0d0492e:	2165      	movs	r1, #101	; 0x65
c0d04930:	7001      	strb	r1, [r0, #0]
        unsigned short length = sizeof(bagl_component_t)+strlen((const char*)text_adr);
c0d04932:	4631      	mov	r1, r6
c0d04934:	311c      	adds	r1, #28
        G_io_seproxyhal_spi_buffer[1] = length>>8;
        G_io_seproxyhal_spi_buffer[2] = length;
c0d04936:	7081      	strb	r1, [r0, #2]
        G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d04938:	0a09      	lsrs	r1, r1, #8
c0d0493a:	7041      	strb	r1, [r0, #1]
c0d0493c:	2103      	movs	r1, #3
        io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d0493e:	f002 f8f3 	bl	c0d06b28 <io_seph_send>
c0d04942:	211c      	movs	r1, #28
        io_seproxyhal_spi_send((unsigned char*)&element->component, sizeof(bagl_component_t));
c0d04944:	4620      	mov	r0, r4
c0d04946:	f002 f8ef 	bl	c0d06b28 <io_seph_send>
        io_seproxyhal_spi_send((unsigned char*)text_adr, length-sizeof(bagl_component_t));
c0d0494a:	b2b1      	uxth	r1, r6
c0d0494c:	4628      	mov	r0, r5
c0d0494e:	e00b      	b.n	c0d04968 <io_seproxyhal_display_default+0x74>
      }
    }
    else {
      unsigned short length = sizeof(bagl_component_t);
      G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d04950:	4809      	ldr	r0, [pc, #36]	; (c0d04978 <io_seproxyhal_display_default+0x84>)
c0d04952:	251c      	movs	r5, #28
      G_io_seproxyhal_spi_buffer[1] = length>>8;
      G_io_seproxyhal_spi_buffer[2] = length;
c0d04954:	7085      	strb	r5, [r0, #2]
c0d04956:	2100      	movs	r1, #0
      G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d04958:	7041      	strb	r1, [r0, #1]
c0d0495a:	2165      	movs	r1, #101	; 0x65
      G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d0495c:	7001      	strb	r1, [r0, #0]
c0d0495e:	2103      	movs	r1, #3
      io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d04960:	f002 f8e2 	bl	c0d06b28 <io_seph_send>
      io_seproxyhal_spi_send((unsigned char*)&element->component, sizeof(bagl_component_t));
c0d04964:	4620      	mov	r0, r4
c0d04966:	4629      	mov	r1, r5
c0d04968:	f002 f8de 	bl	c0d06b28 <io_seph_send>
    }
  }
}
c0d0496c:	bd70      	pop	{r4, r5, r6, pc}
        io_seproxyhal_display_icon((bagl_component_t*)&element->component, (bagl_icon_details_t*)text_adr);
c0d0496e:	4620      	mov	r0, r4
c0d04970:	4629      	mov	r1, r5
c0d04972:	f7ff ff6f 	bl	c0d04854 <io_seproxyhal_display_icon>
}
c0d04976:	bd70      	pop	{r4, r5, r6, pc}
c0d04978:	20001b00 	.word	0x20001b00

c0d0497c <io_seproxyhal_button_push>:
  
  // compute scrolled text length
  return 2*(textlen - e->component.width)*1000/e->component.icon_id + 2*(e->component.stroke & ~(0x80))*100;
}

void io_seproxyhal_button_push(button_push_callback_t button_callback, unsigned int new_button_mask) {
c0d0497c:	b570      	push	{r4, r5, r6, lr}
  if (button_callback) {
c0d0497e:	2800      	cmp	r0, #0
c0d04980:	d027      	beq.n	c0d049d2 <io_seproxyhal_button_push+0x56>
c0d04982:	4604      	mov	r4, r0
    unsigned int button_mask;
    unsigned int button_same_mask_counter;
    // enable speeded up long push
    if (new_button_mask == G_ux_os.button_mask) {
c0d04984:	4813      	ldr	r0, [pc, #76]	; (c0d049d4 <io_seproxyhal_button_push+0x58>)
c0d04986:	c860      	ldmia	r0!, {r5, r6}
c0d04988:	3808      	subs	r0, #8
c0d0498a:	428d      	cmp	r5, r1
c0d0498c:	d101      	bne.n	c0d04992 <io_seproxyhal_button_push+0x16>
      // each 100ms ~
      G_ux_os.button_same_mask_counter++;
c0d0498e:	1c76      	adds	r6, r6, #1
c0d04990:	6046      	str	r6, [r0, #4]
    }

    // when new_button_mask is 0 and 

    // append the button mask
    button_mask = G_ux_os.button_mask | new_button_mask;
c0d04992:	430d      	orrs	r5, r1

    // pre reset variable due to os_sched_exit
    button_same_mask_counter = G_ux_os.button_same_mask_counter;

    // reset button mask
    if (new_button_mask == 0) {
c0d04994:	2900      	cmp	r1, #0
c0d04996:	d002      	beq.n	c0d0499e <io_seproxyhal_button_push+0x22>

      // notify button released event
      button_mask |= BUTTON_EVT_RELEASED;
    }
    else {
      G_ux_os.button_mask = button_mask;
c0d04998:	6005      	str	r5, [r0, #0]
    }

    // reset counter when button mask changes
    if (new_button_mask != G_ux_os.button_mask) {
c0d0499a:	462a      	mov	r2, r5
c0d0499c:	e005      	b.n	c0d049aa <io_seproxyhal_button_push+0x2e>
c0d0499e:	2200      	movs	r2, #0
      G_ux_os.button_mask = 0;
c0d049a0:	6002      	str	r2, [r0, #0]
      G_ux_os.button_same_mask_counter=0;
c0d049a2:	6042      	str	r2, [r0, #4]
c0d049a4:	4b0c      	ldr	r3, [pc, #48]	; (c0d049d8 <io_seproxyhal_button_push+0x5c>)
      button_mask |= BUTTON_EVT_RELEASED;
c0d049a6:	1c5b      	adds	r3, r3, #1
c0d049a8:	431d      	orrs	r5, r3
    if (new_button_mask != G_ux_os.button_mask) {
c0d049aa:	428a      	cmp	r2, r1
c0d049ac:	d001      	beq.n	c0d049b2 <io_seproxyhal_button_push+0x36>
c0d049ae:	2100      	movs	r1, #0
      G_ux_os.button_same_mask_counter=0;
c0d049b0:	6041      	str	r1, [r0, #4]
    }

    if (button_same_mask_counter >= BUTTON_FAST_THRESHOLD_CS) {
c0d049b2:	2e08      	cmp	r6, #8
c0d049b4:	d30a      	bcc.n	c0d049cc <io_seproxyhal_button_push+0x50>
c0d049b6:	2103      	movs	r1, #3
      // fast bit when pressing and timing is right
      if ((button_same_mask_counter%BUTTON_FAST_ACTION_CS) == 0) {
c0d049b8:	4630      	mov	r0, r6
c0d049ba:	f005 fe39 	bl	c0d0a630 <__aeabi_uidivmod>
c0d049be:	2001      	movs	r0, #1
c0d049c0:	2900      	cmp	r1, #0
c0d049c2:	d101      	bne.n	c0d049c8 <io_seproxyhal_button_push+0x4c>
c0d049c4:	0781      	lsls	r1, r0, #30
c0d049c6:	430d      	orrs	r5, r1
c0d049c8:	07c0      	lsls	r0, r0, #31
      }
      */

      // discard the release event after a fastskip has been detected, to avoid strange at release behavior
      // and also to enable user to cancel an operation by starting triggering the fast skip
      button_mask &= ~BUTTON_EVT_RELEASED;
c0d049ca:	4385      	bics	r5, r0
    }

    // indicate if button have been released
    button_callback(button_mask, button_same_mask_counter);
c0d049cc:	4628      	mov	r0, r5
c0d049ce:	4631      	mov	r1, r6
c0d049d0:	47a0      	blx	r4

  }
}
c0d049d2:	bd70      	pop	{r4, r5, r6, pc}
c0d049d4:	20002074 	.word	0x20002074
c0d049d8:	7fffffff 	.word	0x7fffffff

c0d049dc <os_io_seproxyhal_get_app_name_and_version>:
#ifdef HAVE_IO_U2F
u2f_service_t G_io_u2f;
#endif // HAVE_IO_U2F

unsigned int os_io_seproxyhal_get_app_name_and_version(void) __attribute__((weak));
unsigned int os_io_seproxyhal_get_app_name_and_version(void) {
c0d049dc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d049de:	b081      	sub	sp, #4
  unsigned int tx_len, len;
  // build the get app name and version reply
  tx_len = 0;
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d049e0:	4e0f      	ldr	r6, [pc, #60]	; (c0d04a20 <os_io_seproxyhal_get_app_name_and_version+0x44>)
c0d049e2:	2401      	movs	r4, #1
c0d049e4:	7034      	strb	r4, [r6, #0]

#ifndef HAVE_BOLOS
  // append app name
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPNAME, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len-1);
c0d049e6:	1cb1      	adds	r1, r6, #2
c0d049e8:	20a7      	movs	r0, #167	; 0xa7
c0d049ea:	0047      	lsls	r7, r0, #1
c0d049ec:	1c7a      	adds	r2, r7, #1
c0d049ee:	4620      	mov	r0, r4
c0d049f0:	f002 f880 	bl	c0d06af4 <os_registry_get_current_app_tag>
c0d049f4:	4605      	mov	r5, r0
  G_io_apdu_buffer[tx_len++] = len;
c0d049f6:	7070      	strb	r0, [r6, #1]
  tx_len += len;
  // append app version
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPVERSION, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len-1);
c0d049f8:	1a3a      	subs	r2, r7, r0
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d049fa:	1837      	adds	r7, r6, r0
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPVERSION, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len-1);
c0d049fc:	1cf9      	adds	r1, r7, #3
c0d049fe:	2002      	movs	r0, #2
c0d04a00:	f002 f878 	bl	c0d06af4 <os_registry_get_current_app_tag>
  G_io_apdu_buffer[tx_len++] = len;
c0d04a04:	70b8      	strb	r0, [r7, #2]
c0d04a06:	182d      	adds	r5, r5, r0
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d04a08:	1976      	adds	r6, r6, r5
#endif // HAVE_BOLOS

#if !defined(HAVE_IO_TASK) || !defined(HAVE_BOLOS)
  // to be fixed within io tasks
  // return OS flags to notify of platform's global state (pin lock etc)
  G_io_apdu_buffer[tx_len++] = 1; // flags length
c0d04a0a:	70f4      	strb	r4, [r6, #3]
  G_io_apdu_buffer[tx_len++] = os_flags();
c0d04a0c:	f002 f866 	bl	c0d06adc <os_flags>
c0d04a10:	2100      	movs	r1, #0
#endif // !defined(HAVE_IO_TASK) || !defined(HAVE_BOLOS)

  // status words
  G_io_apdu_buffer[tx_len++] = 0x90;
  G_io_apdu_buffer[tx_len++] = 0x00;
c0d04a12:	71b1      	strb	r1, [r6, #6]
c0d04a14:	2190      	movs	r1, #144	; 0x90
  G_io_apdu_buffer[tx_len++] = 0x90;
c0d04a16:	7171      	strb	r1, [r6, #5]
  G_io_apdu_buffer[tx_len++] = os_flags();
c0d04a18:	7130      	strb	r0, [r6, #4]
  G_io_apdu_buffer[tx_len++] = 0x00;
c0d04a1a:	1de8      	adds	r0, r5, #7
  return tx_len;
c0d04a1c:	b001      	add	sp, #4
c0d04a1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04a20:	20001f09 	.word	0x20001f09

c0d04a24 <io_exchange>:
}


unsigned short io_exchange(unsigned char channel, unsigned short tx_len) {
c0d04a24:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04a26:	b08b      	sub	sp, #44	; 0x2c
c0d04a28:	4607      	mov	r7, r0
  }
  after_debug:
#endif // DEBUG_APDU

reply_apdu:
  switch(channel&~(IO_FLAGS)) {
c0d04a2a:	0740      	lsls	r0, r0, #29
c0d04a2c:	d008      	beq.n	c0d04a40 <io_exchange+0x1c>
c0d04a2e:	9707      	str	r7, [sp, #28]
      }
    }
    break;

  default:
    return io_exchange_al(channel, tx_len);
c0d04a30:	9807      	ldr	r0, [sp, #28]
c0d04a32:	b2c0      	uxtb	r0, r0
c0d04a34:	b289      	uxth	r1, r1
c0d04a36:	f7fe ff7d 	bl	c0d03934 <io_exchange_al>
  }
}
c0d04a3a:	b280      	uxth	r0, r0
c0d04a3c:	b00b      	add	sp, #44	; 0x2c
c0d04a3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04a40:	20a5      	movs	r0, #165	; 0xa5
c0d04a42:	0040      	lsls	r0, r0, #1
c0d04a44:	9001      	str	r0, [sp, #4]
c0d04a46:	4ca0      	ldr	r4, [pc, #640]	; (c0d04cc8 <io_exchange+0x2a4>)
c0d04a48:	4e9e      	ldr	r6, [pc, #632]	; (c0d04cc4 <io_exchange+0x2a0>)
c0d04a4a:	9707      	str	r7, [sp, #28]
c0d04a4c:	2010      	movs	r0, #16
    if (tx_len && !(channel&IO_ASYNCH_REPLY)) {
c0d04a4e:	463d      	mov	r5, r7
c0d04a50:	4005      	ands	r5, r0
c0d04a52:	b28a      	uxth	r2, r1
c0d04a54:	2a00      	cmp	r2, #0
c0d04a56:	d100      	bne.n	c0d04a5a <io_exchange+0x36>
c0d04a58:	e0b1      	b.n	c0d04bbe <io_exchange+0x19a>
c0d04a5a:	2d00      	cmp	r5, #0
c0d04a5c:	d000      	beq.n	c0d04a60 <io_exchange+0x3c>
c0d04a5e:	e0ae      	b.n	c0d04bbe <io_exchange+0x19a>
c0d04a60:	9206      	str	r2, [sp, #24]
c0d04a62:	9103      	str	r1, [sp, #12]
c0d04a64:	9004      	str	r0, [sp, #16]
c0d04a66:	9505      	str	r5, [sp, #20]
c0d04a68:	e007      	b.n	c0d04a7a <io_exchange+0x56>
c0d04a6a:	2148      	movs	r1, #72	; 0x48
c0d04a6c:	2200      	movs	r2, #0
        io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d04a6e:	4630      	mov	r0, r6
c0d04a70:	f002 f872 	bl	c0d06b58 <io_seph_recv>
c0d04a74:	2001      	movs	r0, #1
        os_io_seph_recv_and_process(1);
c0d04a76:	f000 f939 	bl	c0d04cec <os_io_seph_recv_and_process>
      while (io_seproxyhal_spi_is_status_sent()) {
c0d04a7a:	f002 f861 	bl	c0d06b40 <io_seph_is_status_sent>
c0d04a7e:	2800      	cmp	r0, #0
c0d04a80:	d1f3      	bne.n	c0d04a6a <io_exchange+0x46>
c0d04a82:	207d      	movs	r0, #125	; 0x7d
c0d04a84:	0100      	lsls	r0, r0, #4
      timeout_ms = G_io_app.ms + IO_RAPDU_TRANSMIT_TIMEOUT_MS;
c0d04a86:	68a1      	ldr	r1, [r4, #8]
c0d04a88:	180d      	adds	r5, r1, r0
        switch(G_io_app.apdu_state) {
c0d04a8a:	7820      	ldrb	r0, [r4, #0]
c0d04a8c:	2809      	cmp	r0, #9
c0d04a8e:	dc3f      	bgt.n	c0d04b10 <io_exchange+0xec>
c0d04a90:	2807      	cmp	r0, #7
c0d04a92:	9906      	ldr	r1, [sp, #24]
c0d04a94:	d047      	beq.n	c0d04b26 <io_exchange+0x102>
c0d04a96:	2809      	cmp	r0, #9
c0d04a98:	d160      	bne.n	c0d04b5c <io_exchange+0x138>
c0d04a9a:	2100      	movs	r1, #0
c0d04a9c:	488b      	ldr	r0, [pc, #556]	; (c0d04ccc <io_exchange+0x2a8>)
c0d04a9e:	9102      	str	r1, [sp, #8]
            u2f_message_set_autoreply_wait_user_presence(&G_io_u2f, false);
c0d04aa0:	f002 fcee 	bl	c0d07480 <u2f_message_set_autoreply_wait_user_presence>
c0d04aa4:	e010      	b.n	c0d04ac8 <io_exchange+0xa4>
              io_seproxyhal_general_status();
c0d04aa6:	f7ff fd85 	bl	c0d045b4 <io_seproxyhal_general_status>
c0d04aaa:	2148      	movs	r1, #72	; 0x48
c0d04aac:	2200      	movs	r2, #0
                io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d04aae:	4630      	mov	r0, r6
c0d04ab0:	f002 f852 	bl	c0d06b58 <io_seph_recv>
                if (G_io_app.ms >= timeout_ms) {
c0d04ab4:	68a0      	ldr	r0, [r4, #8]
c0d04ab6:	42a8      	cmp	r0, r5
c0d04ab8:	d300      	bcc.n	c0d04abc <io_exchange+0x98>
c0d04aba:	e0f7      	b.n	c0d04cac <io_exchange+0x288>
                io_seproxyhal_handle_event();
c0d04abc:	f7ff fe60 	bl	c0d04780 <io_seproxyhal_handle_event>
              } while (io_seproxyhal_spi_is_status_sent());
c0d04ac0:	f002 f83e 	bl	c0d06b40 <io_seph_is_status_sent>
c0d04ac4:	2800      	cmp	r0, #0
c0d04ac6:	d1f0      	bne.n	c0d04aaa <io_exchange+0x86>
            while(!u2f_message_repliable(&G_io_u2f)) {
c0d04ac8:	4880      	ldr	r0, [pc, #512]	; (c0d04ccc <io_exchange+0x2a8>)
c0d04aca:	f002 fa7d 	bl	c0d06fc8 <u2f_message_repliable>
c0d04ace:	2800      	cmp	r0, #0
c0d04ad0:	d0e9      	beq.n	c0d04aa6 <io_exchange+0x82>
            if (1U+ 4U+ tx_len +2U > sizeof(G_io_apdu_buffer)) {
c0d04ad2:	9801      	ldr	r0, [sp, #4]
c0d04ad4:	9a06      	ldr	r2, [sp, #24]
c0d04ad6:	4282      	cmp	r2, r0
c0d04ad8:	d900      	bls.n	c0d04adc <io_exchange+0xb8>
c0d04ada:	e0ed      	b.n	c0d04cb8 <io_exchange+0x294>
c0d04adc:	2090      	movs	r0, #144	; 0x90
c0d04ade:	497c      	ldr	r1, [pc, #496]	; (c0d04cd0 <io_exchange+0x2ac>)
            G_io_apdu_buffer[tx_len] = 0x90; //G_io_apdu_buffer[tx_len-2];
c0d04ae0:	5488      	strb	r0, [r1, r2]
c0d04ae2:	1888      	adds	r0, r1, r2
            G_io_apdu_buffer[tx_len+1] = 0x00; //G_io_apdu_buffer[tx_len-1];
c0d04ae4:	9a02      	ldr	r2, [sp, #8]
c0d04ae6:	7042      	strb	r2, [r0, #1]
            os_memmove(G_io_apdu_buffer+5, G_io_apdu_buffer, tx_len);
c0d04ae8:	1d48      	adds	r0, r1, #5
            tx_len += 2;
c0d04aea:	9a03      	ldr	r2, [sp, #12]
c0d04aec:	1c92      	adds	r2, r2, #2
            os_memmove(G_io_apdu_buffer+5, G_io_apdu_buffer, tx_len);
c0d04aee:	b292      	uxth	r2, r2
c0d04af0:	f7ff fc13 	bl	c0d0431a <os_memmove>
c0d04af4:	2205      	movs	r2, #5
            os_memset(G_io_apdu_buffer, 0, 5);
c0d04af6:	4876      	ldr	r0, [pc, #472]	; (c0d04cd0 <io_exchange+0x2ac>)
c0d04af8:	9902      	ldr	r1, [sp, #8]
c0d04afa:	f7ff fc24 	bl	c0d04346 <os_memset>
            u2f_message_reply(&G_io_u2f, U2F_CMD_MSG, G_io_apdu_buffer, tx_len+5);
c0d04afe:	9803      	ldr	r0, [sp, #12]
c0d04b00:	1dc0      	adds	r0, r0, #7
c0d04b02:	b283      	uxth	r3, r0
c0d04b04:	2183      	movs	r1, #131	; 0x83
c0d04b06:	4871      	ldr	r0, [pc, #452]	; (c0d04ccc <io_exchange+0x2a8>)
c0d04b08:	4a71      	ldr	r2, [pc, #452]	; (c0d04cd0 <io_exchange+0x2ac>)
c0d04b0a:	f002 fccd 	bl	c0d074a8 <u2f_message_reply>
c0d04b0e:	e040      	b.n	c0d04b92 <io_exchange+0x16e>
        switch(G_io_app.apdu_state) {
c0d04b10:	280a      	cmp	r0, #10
c0d04b12:	9a03      	ldr	r2, [sp, #12]
c0d04b14:	9906      	ldr	r1, [sp, #24]
c0d04b16:	d00b      	beq.n	c0d04b30 <io_exchange+0x10c>
c0d04b18:	280b      	cmp	r0, #11
c0d04b1a:	d122      	bne.n	c0d04b62 <io_exchange+0x13e>
            io_usb_hid_send(io_usb_send_apdu_data_ep0x83, tx_len);
c0d04b1c:	486f      	ldr	r0, [pc, #444]	; (c0d04cdc <io_exchange+0x2b8>)
c0d04b1e:	4478      	add	r0, pc
c0d04b20:	f000 fa48 	bl	c0d04fb4 <io_usb_hid_send>
c0d04b24:	e035      	b.n	c0d04b92 <io_exchange+0x16e>
            io_usb_hid_send(io_usb_send_apdu_data, tx_len);
c0d04b26:	486c      	ldr	r0, [pc, #432]	; (c0d04cd8 <io_exchange+0x2b4>)
c0d04b28:	4478      	add	r0, pc
c0d04b2a:	f000 fa43 	bl	c0d04fb4 <io_usb_hid_send>
c0d04b2e:	e030      	b.n	c0d04b92 <io_exchange+0x16e>
            if (tx_len > sizeof(G_io_apdu_buffer)) {
c0d04b30:	9801      	ldr	r0, [sp, #4]
c0d04b32:	1dc0      	adds	r0, r0, #7
c0d04b34:	4281      	cmp	r1, r0
c0d04b36:	d900      	bls.n	c0d04b3a <io_exchange+0x116>
c0d04b38:	e0be      	b.n	c0d04cb8 <io_exchange+0x294>
c0d04b3a:	460d      	mov	r5, r1
            G_io_seproxyhal_spi_buffer[2]  = (tx_len);
c0d04b3c:	70b2      	strb	r2, [r6, #2]
c0d04b3e:	2053      	movs	r0, #83	; 0x53
            G_io_seproxyhal_spi_buffer[0]  = SEPROXYHAL_TAG_RAPDU;
c0d04b40:	7030      	strb	r0, [r6, #0]
            G_io_seproxyhal_spi_buffer[1]  = (tx_len)>>8;
c0d04b42:	0a10      	lsrs	r0, r2, #8
c0d04b44:	7070      	strb	r0, [r6, #1]
c0d04b46:	2103      	movs	r1, #3
            io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d04b48:	4630      	mov	r0, r6
c0d04b4a:	f001 ffed 	bl	c0d06b28 <io_seph_send>
            io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);
c0d04b4e:	4860      	ldr	r0, [pc, #384]	; (c0d04cd0 <io_exchange+0x2ac>)
c0d04b50:	4629      	mov	r1, r5
c0d04b52:	f001 ffe9 	bl	c0d06b28 <io_seph_send>
c0d04b56:	2000      	movs	r0, #0
            G_io_app.apdu_state = APDU_IDLE;
c0d04b58:	7020      	strb	r0, [r4, #0]
c0d04b5a:	e01d      	b.n	c0d04b98 <io_exchange+0x174>
        switch(G_io_app.apdu_state) {
c0d04b5c:	2800      	cmp	r0, #0
c0d04b5e:	d100      	bne.n	c0d04b62 <io_exchange+0x13e>
c0d04b60:	e0a7      	b.n	c0d04cb2 <io_exchange+0x28e>
            if (io_exchange_al(channel, tx_len) == 0) {
c0d04b62:	9807      	ldr	r0, [sp, #28]
c0d04b64:	b2c0      	uxtb	r0, r0
c0d04b66:	f7fe fee5 	bl	c0d03934 <io_exchange_al>
c0d04b6a:	2800      	cmp	r0, #0
c0d04b6c:	d011      	beq.n	c0d04b92 <io_exchange+0x16e>
c0d04b6e:	e0a0      	b.n	c0d04cb2 <io_exchange+0x28e>
          io_seproxyhal_general_status();
c0d04b70:	f7ff fd20 	bl	c0d045b4 <io_seproxyhal_general_status>
c0d04b74:	2148      	movs	r1, #72	; 0x48
c0d04b76:	2200      	movs	r2, #0
            io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d04b78:	4630      	mov	r0, r6
c0d04b7a:	f001 ffed 	bl	c0d06b58 <io_seph_recv>
            if (G_io_app.ms >= timeout_ms) {
c0d04b7e:	68a0      	ldr	r0, [r4, #8]
c0d04b80:	42a8      	cmp	r0, r5
c0d04b82:	d300      	bcc.n	c0d04b86 <io_exchange+0x162>
c0d04b84:	e092      	b.n	c0d04cac <io_exchange+0x288>
            io_seproxyhal_handle_event();
c0d04b86:	f7ff fdfb 	bl	c0d04780 <io_seproxyhal_handle_event>
          } while (io_seproxyhal_spi_is_status_sent());
c0d04b8a:	f001 ffd9 	bl	c0d06b40 <io_seph_is_status_sent>
c0d04b8e:	2800      	cmp	r0, #0
c0d04b90:	d1f0      	bne.n	c0d04b74 <io_exchange+0x150>
        while (G_io_app.apdu_state != APDU_IDLE) {
c0d04b92:	7820      	ldrb	r0, [r4, #0]
c0d04b94:	2800      	cmp	r0, #0
c0d04b96:	d1eb      	bne.n	c0d04b70 <io_exchange+0x14c>
c0d04b98:	2000      	movs	r0, #0
        G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0d04b9a:	71a0      	strb	r0, [r4, #6]
        G_io_app.apdu_state = APDU_IDLE;
c0d04b9c:	7020      	strb	r0, [r4, #0]
        G_io_app.apdu_length = 0;
c0d04b9e:	8060      	strh	r0, [r4, #2]
        if (channel & IO_RETURN_AFTER_TX) {
c0d04ba0:	06b9      	lsls	r1, r7, #26
c0d04ba2:	d500      	bpl.n	c0d04ba6 <io_exchange+0x182>
c0d04ba4:	e749      	b.n	c0d04a3a <io_exchange+0x16>
        io_seproxyhal_general_status();
c0d04ba6:	f7ff fd05 	bl	c0d045b4 <io_seproxyhal_general_status>
      if (channel & IO_RESET_AFTER_REPLIED) {
c0d04baa:	0638      	lsls	r0, r7, #24
c0d04bac:	9d05      	ldr	r5, [sp, #20]
c0d04bae:	9804      	ldr	r0, [sp, #16]
c0d04bb0:	d505      	bpl.n	c0d04bbe <io_exchange+0x19a>
#define SYSCALL_os_sched_exit_ID_IN 0x60009abeUL
#define SYSCALL_os_sched_exit_ID_OUT 0x90009adeUL
__attribute__((always_inline)) inline void
os_sched_exit_inline(bolos_task_status_t exit_code) {
  volatile unsigned int parameters[2 + 1];
  parameters[0] = (unsigned int)exit_code;
c0d04bb2:	9008      	str	r0, [sp, #32]
c0d04bb4:	aa08      	add	r2, sp, #32
  __asm volatile("mov r0, %1\n"
c0d04bb6:	4b47      	ldr	r3, [pc, #284]	; (c0d04cd4 <io_exchange+0x2b0>)
c0d04bb8:	4618      	mov	r0, r3
c0d04bba:	4611      	mov	r1, r2
c0d04bbc:	df01      	svc	1
    if (!(channel&IO_ASYNCH_REPLY)) {
c0d04bbe:	2d00      	cmp	r5, #0
c0d04bc0:	d104      	bne.n	c0d04bcc <io_exchange+0x1a8>
      if ((channel & (CHANNEL_APDU|IO_RECEIVE_DATA)) == (CHANNEL_APDU|IO_RECEIVE_DATA)) {
c0d04bc2:	0678      	lsls	r0, r7, #25
c0d04bc4:	d46d      	bmi.n	c0d04ca2 <io_exchange+0x27e>
c0d04bc6:	2000      	movs	r0, #0
      G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0d04bc8:	71a0      	strb	r0, [r4, #6]
      G_io_app.apdu_state = APDU_IDLE;
c0d04bca:	7020      	strb	r0, [r4, #0]
c0d04bcc:	4f40      	ldr	r7, [pc, #256]	; (c0d04cd0 <io_exchange+0x2ac>)
c0d04bce:	2000      	movs	r0, #0
c0d04bd0:	8060      	strh	r0, [r4, #2]
      if (!io_seproxyhal_spi_is_status_sent()) {
c0d04bd2:	f001 ffb5 	bl	c0d06b40 <io_seph_is_status_sent>
c0d04bd6:	2800      	cmp	r0, #0
c0d04bd8:	d101      	bne.n	c0d04bde <io_exchange+0x1ba>
        io_seproxyhal_general_status();
c0d04bda:	f7ff fceb 	bl	c0d045b4 <io_seproxyhal_general_status>
c0d04bde:	2148      	movs	r1, #72	; 0x48
c0d04be0:	2500      	movs	r5, #0
      rx_len = io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d04be2:	4630      	mov	r0, r6
c0d04be4:	462a      	mov	r2, r5
c0d04be6:	f001 ffb7 	bl	c0d06b58 <io_seph_recv>
      if (rx_len < 3 && rx_len != U2(G_io_seproxyhal_spi_buffer[1],G_io_seproxyhal_spi_buffer[2])+3U) {
c0d04bea:	2802      	cmp	r0, #2
c0d04bec:	d806      	bhi.n	c0d04bfc <io_exchange+0x1d8>
c0d04bee:	78b1      	ldrb	r1, [r6, #2]
c0d04bf0:	7872      	ldrb	r2, [r6, #1]
c0d04bf2:	0212      	lsls	r2, r2, #8
c0d04bf4:	1851      	adds	r1, r2, r1
c0d04bf6:	1cc9      	adds	r1, r1, #3
c0d04bf8:	4281      	cmp	r1, r0
c0d04bfa:	d108      	bne.n	c0d04c0e <io_exchange+0x1ea>
      io_seproxyhal_handle_event();
c0d04bfc:	f7ff fdc0 	bl	c0d04780 <io_seproxyhal_handle_event>
      if (G_io_app.apdu_state != APDU_IDLE && G_io_app.apdu_length > 0) {
c0d04c00:	8860      	ldrh	r0, [r4, #2]
c0d04c02:	7821      	ldrb	r1, [r4, #0]
c0d04c04:	2900      	cmp	r1, #0
c0d04c06:	d0e4      	beq.n	c0d04bd2 <io_exchange+0x1ae>
c0d04c08:	2800      	cmp	r0, #0
c0d04c0a:	d0e2      	beq.n	c0d04bd2 <io_exchange+0x1ae>
c0d04c0c:	e002      	b.n	c0d04c14 <io_exchange+0x1f0>
c0d04c0e:	2000      	movs	r0, #0
        G_io_app.apdu_state = APDU_IDLE;
c0d04c10:	7020      	strb	r0, [r4, #0]
c0d04c12:	e7dc      	b.n	c0d04bce <io_exchange+0x1aa>
        if (os_memcmp(G_io_apdu_buffer, "\xB0\x01\x00\x00", 4) == 0) {
c0d04c14:	4932      	ldr	r1, [pc, #200]	; (c0d04ce0 <io_exchange+0x2bc>)
c0d04c16:	4479      	add	r1, pc
c0d04c18:	2204      	movs	r2, #4
c0d04c1a:	4638      	mov	r0, r7
c0d04c1c:	f7ff fb9c 	bl	c0d04358 <os_memcmp>
c0d04c20:	2800      	cmp	r0, #0
c0d04c22:	d026      	beq.n	c0d04c72 <io_exchange+0x24e>
        else if (os_memcmp(G_io_apdu_buffer, "\xB0\xA7\x00\x00", 4) == 0) {
c0d04c24:	492f      	ldr	r1, [pc, #188]	; (c0d04ce4 <io_exchange+0x2c0>)
c0d04c26:	4479      	add	r1, pc
c0d04c28:	2204      	movs	r2, #4
c0d04c2a:	4638      	mov	r0, r7
c0d04c2c:	f7ff fb94 	bl	c0d04358 <os_memcmp>
c0d04c30:	2800      	cmp	r0, #0
c0d04c32:	d022      	beq.n	c0d04c7a <io_exchange+0x256>
        else if (os_memcmp(G_io_apdu_buffer, "\xB0\x02\x00\x00", 4) == 0) {
c0d04c34:	492c      	ldr	r1, [pc, #176]	; (c0d04ce8 <io_exchange+0x2c4>)
c0d04c36:	4479      	add	r1, pc
c0d04c38:	2204      	movs	r2, #4
c0d04c3a:	4638      	mov	r0, r7
c0d04c3c:	f7ff fb8c 	bl	c0d04358 <os_memcmp>
c0d04c40:	2800      	cmp	r0, #0
c0d04c42:	d131      	bne.n	c0d04ca8 <io_exchange+0x284>
          if (os_global_pin_is_validated() == BOLOS_UX_OK) {
c0d04c44:	f001 ff1c 	bl	c0d06a80 <os_global_pin_is_validated>
c0d04c48:	28aa      	cmp	r0, #170	; 0xaa
c0d04c4a:	d11f      	bne.n	c0d04c8c <io_exchange+0x268>
c0d04c4c:	2001      	movs	r0, #1
            G_io_apdu_buffer[tx_len++] = 0x01;
c0d04c4e:	7038      	strb	r0, [r7, #0]
            i = os_perso_seed_cookie(G_io_apdu_buffer+1+1, MIN(64,sizeof(G_io_apdu_buffer)-1-1-2));
c0d04c50:	1cb8      	adds	r0, r7, #2
c0d04c52:	2140      	movs	r1, #64	; 0x40
c0d04c54:	f001 ff06 	bl	c0d06a64 <os_perso_seed_cookie>
            G_io_apdu_buffer[tx_len++] = i;
c0d04c58:	7078      	strb	r0, [r7, #1]
            tx_len += i;
c0d04c5a:	1c81      	adds	r1, r0, #2
c0d04c5c:	4a18      	ldr	r2, [pc, #96]	; (c0d04cc0 <io_exchange+0x29c>)
c0d04c5e:	4613      	mov	r3, r2
            G_io_apdu_buffer[tx_len++] = 0x90;
c0d04c60:	4011      	ands	r1, r2
c0d04c62:	2290      	movs	r2, #144	; 0x90
c0d04c64:	547a      	strb	r2, [r7, r1]
c0d04c66:	1cc1      	adds	r1, r0, #3
            G_io_apdu_buffer[tx_len++] = 0x00;
c0d04c68:	4019      	ands	r1, r3
c0d04c6a:	2500      	movs	r5, #0
c0d04c6c:	547d      	strb	r5, [r7, r1]
c0d04c6e:	1d01      	adds	r1, r0, #4
c0d04c70:	e011      	b.n	c0d04c96 <io_exchange+0x272>
          tx_len = os_io_seproxyhal_get_app_name_and_version();
c0d04c72:	f7ff feb3 	bl	c0d049dc <os_io_seproxyhal_get_app_name_and_version>
c0d04c76:	4601      	mov	r1, r0
c0d04c78:	e00d      	b.n	c0d04c96 <io_exchange+0x272>
c0d04c7a:	2000      	movs	r0, #0
          G_io_apdu_buffer[tx_len++] = 0x00;
c0d04c7c:	7078      	strb	r0, [r7, #1]
c0d04c7e:	2090      	movs	r0, #144	; 0x90
          G_io_apdu_buffer[tx_len++] = 0x90;
c0d04c80:	7038      	strb	r0, [r7, #0]
c0d04c82:	207f      	movs	r0, #127	; 0x7f
c0d04c84:	43c0      	mvns	r0, r0
c0d04c86:	9d07      	ldr	r5, [sp, #28]
          channel |= IO_RESET_AFTER_REPLIED;
c0d04c88:	4305      	orrs	r5, r0
c0d04c8a:	e003      	b.n	c0d04c94 <io_exchange+0x270>
c0d04c8c:	2085      	movs	r0, #133	; 0x85
            G_io_apdu_buffer[tx_len++] = 0x85;
c0d04c8e:	7078      	strb	r0, [r7, #1]
c0d04c90:	2069      	movs	r0, #105	; 0x69
            G_io_apdu_buffer[tx_len++] = 0x69;
c0d04c92:	7038      	strb	r0, [r7, #0]
c0d04c94:	2102      	movs	r1, #2
  switch(channel&~(IO_FLAGS)) {
c0d04c96:	b2ef      	uxtb	r7, r5
c0d04c98:	9507      	str	r5, [sp, #28]
c0d04c9a:	0768      	lsls	r0, r5, #29
c0d04c9c:	d100      	bne.n	c0d04ca0 <io_exchange+0x27c>
c0d04c9e:	e6d5      	b.n	c0d04a4c <io_exchange+0x28>
c0d04ca0:	e6c6      	b.n	c0d04a30 <io_exchange+0xc>
        return G_io_app.apdu_length-5;
c0d04ca2:	8860      	ldrh	r0, [r4, #2]
c0d04ca4:	1f40      	subs	r0, r0, #5
c0d04ca6:	e6c8      	b.n	c0d04a3a <io_exchange+0x16>
        return G_io_app.apdu_length;
c0d04ca8:	8860      	ldrh	r0, [r4, #2]
c0d04caa:	e6c6      	b.n	c0d04a3a <io_exchange+0x16>
c0d04cac:	2010      	movs	r0, #16
c0d04cae:	f7ff fb69 	bl	c0d04384 <os_longjmp>
c0d04cb2:	2009      	movs	r0, #9
            THROW(INVALID_STATE);
c0d04cb4:	f7ff fb66 	bl	c0d04384 <os_longjmp>
c0d04cb8:	2002      	movs	r0, #2
c0d04cba:	f7ff fb63 	bl	c0d04384 <os_longjmp>
c0d04cbe:	46c0      	nop			; (mov r8, r8)
c0d04cc0:	0000ffff 	.word	0x0000ffff
c0d04cc4:	20001b00 	.word	0x20001b00
c0d04cc8:	2000205c 	.word	0x2000205c
c0d04ccc:	2000207c 	.word	0x2000207c
c0d04cd0:	20001f09 	.word	0x20001f09
c0d04cd4:	60009abe 	.word	0x60009abe
c0d04cd8:	fffffbf9 	.word	0xfffffbf9
c0d04cdc:	fffffc13 	.word	0xfffffc13
c0d04ce0:	0000725c 	.word	0x0000725c
c0d04ce4:	00007251 	.word	0x00007251
c0d04ce8:	00007246 	.word	0x00007246

c0d04cec <os_io_seph_recv_and_process>:

unsigned int os_io_seph_recv_and_process(unsigned int dont_process_ux_events) {
c0d04cec:	b570      	push	{r4, r5, r6, lr}
c0d04cee:	4605      	mov	r5, r0
  // send general status before receiving next event
  if (!io_seproxyhal_spi_is_status_sent()) {
c0d04cf0:	f001 ff26 	bl	c0d06b40 <io_seph_is_status_sent>
c0d04cf4:	2800      	cmp	r0, #0
c0d04cf6:	d101      	bne.n	c0d04cfc <os_io_seph_recv_and_process+0x10>
    io_seproxyhal_general_status();
c0d04cf8:	f7ff fc5c 	bl	c0d045b4 <io_seproxyhal_general_status>
  }

  io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d04cfc:	4e0c      	ldr	r6, [pc, #48]	; (c0d04d30 <os_io_seph_recv_and_process+0x44>)
c0d04cfe:	2148      	movs	r1, #72	; 0x48
c0d04d00:	2400      	movs	r4, #0
c0d04d02:	4630      	mov	r0, r6
c0d04d04:	4622      	mov	r2, r4
c0d04d06:	f001 ff27 	bl	c0d06b58 <io_seph_recv>

  switch (G_io_seproxyhal_spi_buffer[0]) {
c0d04d0a:	7830      	ldrb	r0, [r6, #0]
c0d04d0c:	2815      	cmp	r0, #21
c0d04d0e:	d806      	bhi.n	c0d04d1e <os_io_seph_recv_and_process+0x32>
c0d04d10:	2101      	movs	r1, #1
c0d04d12:	4081      	lsls	r1, r0
c0d04d14:	4807      	ldr	r0, [pc, #28]	; (c0d04d34 <os_io_seph_recv_and_process+0x48>)
c0d04d16:	4201      	tst	r1, r0
c0d04d18:	d001      	beq.n	c0d04d1e <os_io_seph_recv_and_process+0x32>
    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
    case SEPROXYHAL_TAG_TICKER_EVENT:
    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
    case SEPROXYHAL_TAG_STATUS_EVENT:
      // perform UX event on these ones, don't process as an IO event
      if (dont_process_ux_events) {
c0d04d1a:	2d00      	cmp	r5, #0
c0d04d1c:	d106      	bne.n	c0d04d2c <os_io_seph_recv_and_process+0x40>
      }
      /* fallthrough */

    default:
      // if malformed, then a stall is likely to occur
      if (io_seproxyhal_handle_event()) {
c0d04d1e:	f7ff fd2f 	bl	c0d04780 <io_seproxyhal_handle_event>
c0d04d22:	2800      	cmp	r0, #0
c0d04d24:	d101      	bne.n	c0d04d2a <os_io_seph_recv_and_process+0x3e>
c0d04d26:	4604      	mov	r4, r0
c0d04d28:	e000      	b.n	c0d04d2c <os_io_seph_recv_and_process+0x40>
c0d04d2a:	2401      	movs	r4, #1
        return 1;
      }
  }
  return 0;
}
c0d04d2c:	4620      	mov	r0, r4
c0d04d2e:	bd70      	pop	{r4, r5, r6, pc}
c0d04d30:	20001b00 	.word	0x20001b00
c0d04d34:	00207020 	.word	0x00207020

c0d04d38 <mcu_usb_printc>:

  return ret;
} 

// so unoptimized
void mcu_usb_printc(unsigned char c) {
c0d04d38:	b5b0      	push	{r4, r5, r7, lr}
c0d04d3a:	b082      	sub	sp, #8
c0d04d3c:	ac01      	add	r4, sp, #4
#else // TARGET_NANOX
  buf[0] = SEPROXYHAL_TAG_PRINTF_STATUS;
#endif // TARGET_NANOX
  buf[1] = 0;
  buf[2] = 1;
  buf[3] = c;
c0d04d3e:	70e0      	strb	r0, [r4, #3]
c0d04d40:	2001      	movs	r0, #1
  buf[2] = 1;
c0d04d42:	70a0      	strb	r0, [r4, #2]
c0d04d44:	2500      	movs	r5, #0
  buf[1] = 0;
c0d04d46:	7065      	strb	r5, [r4, #1]
c0d04d48:	2066      	movs	r0, #102	; 0x66
  buf[0] = SEPROXYHAL_TAG_PRINTF_STATUS;
c0d04d4a:	7020      	strb	r0, [r4, #0]
c0d04d4c:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(buf, 4);
c0d04d4e:	4620      	mov	r0, r4
c0d04d50:	f001 feea 	bl	c0d06b28 <io_seph_send>
c0d04d54:	2103      	movs	r1, #3
#ifndef TARGET_NANOX
#ifndef IO_SEPROXYHAL_DEBUG
  // wait printf ack (no race kthx)
  io_seproxyhal_spi_recv(buf, 3, 0);
c0d04d56:	4620      	mov	r0, r4
c0d04d58:	462a      	mov	r2, r5
c0d04d5a:	f001 fefd 	bl	c0d06b58 <io_seph_recv>
  buf[0] = 0; // consume tag to avoid misinterpretation (due to IO_CACHE)
#endif // IO_SEPROXYHAL_DEBUG
#endif // TARGET_NANOX
}
c0d04d5e:	b002      	add	sp, #8
c0d04d60:	bdb0      	pop	{r4, r5, r7, pc}
	...

c0d04d64 <io_seproxyhal_io_heartbeat>:
  }
}

#endif // HAVE_IO_TASK

void io_seproxyhal_io_heartbeat(void) {
c0d04d64:	b510      	push	{r4, lr}
  io_seproxyhal_general_status();
c0d04d66:	f7ff fc25 	bl	c0d045b4 <io_seproxyhal_general_status>
c0d04d6a:	4c08      	ldr	r4, [pc, #32]	; (c0d04d8c <io_seproxyhal_io_heartbeat+0x28>)
c0d04d6c:	2148      	movs	r1, #72	; 0x48
c0d04d6e:	2200      	movs	r2, #0
  do {
    io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d04d70:	4620      	mov	r0, r4
c0d04d72:	f001 fef1 	bl	c0d06b58 <io_seph_recv>
    // avoid a general status to be replied
    if(G_io_seproxyhal_spi_buffer[0] != SEPROXYHAL_TAG_TICKER_EVENT) {
c0d04d76:	7820      	ldrb	r0, [r4, #0]
c0d04d78:	280e      	cmp	r0, #14
c0d04d7a:	d001      	beq.n	c0d04d80 <io_seproxyhal_io_heartbeat+0x1c>
      io_seproxyhal_handle_event();
c0d04d7c:	f7ff fd00 	bl	c0d04780 <io_seproxyhal_handle_event>
    }
  } while (io_seproxyhal_spi_is_status_sent());
c0d04d80:	f001 fede 	bl	c0d06b40 <io_seph_is_status_sent>
c0d04d84:	2800      	cmp	r0, #0
c0d04d86:	d1f1      	bne.n	c0d04d6c <io_seproxyhal_io_heartbeat+0x8>
}
c0d04d88:	bd10      	pop	{r4, pc}
c0d04d8a:	46c0      	nop			; (mov r8, r8)
c0d04d8c:	20001b00 	.word	0x20001b00

c0d04d90 <io_usb_hid_receive>:
volatile unsigned int   G_io_usb_hid_channel;
volatile unsigned int   G_io_usb_hid_remaining_length;
volatile unsigned int   G_io_usb_hid_sequence_number;
volatile unsigned char* G_io_usb_hid_current_buffer;

io_usb_hid_receive_status_t io_usb_hid_receive (io_send_t sndfct, unsigned char* buffer, unsigned short l) {
c0d04d90:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04d92:	b081      	sub	sp, #4
c0d04d94:	9200      	str	r2, [sp, #0]
c0d04d96:	4604      	mov	r4, r0
  // avoid over/under flows
  if (buffer != G_io_usb_ep_buffer) {
c0d04d98:	4e46      	ldr	r6, [pc, #280]	; (c0d04eb4 <io_usb_hid_receive+0x124>)
c0d04d9a:	42b1      	cmp	r1, r6
c0d04d9c:	d010      	beq.n	c0d04dc0 <io_usb_hid_receive+0x30>
c0d04d9e:	460f      	mov	r7, r1
    os_memset(G_io_usb_ep_buffer, 0, sizeof(G_io_usb_ep_buffer));
c0d04da0:	4d44      	ldr	r5, [pc, #272]	; (c0d04eb4 <io_usb_hid_receive+0x124>)
c0d04da2:	2100      	movs	r1, #0
c0d04da4:	2640      	movs	r6, #64	; 0x40
c0d04da6:	4628      	mov	r0, r5
c0d04da8:	4632      	mov	r2, r6
c0d04daa:	f7ff facc 	bl	c0d04346 <os_memset>
c0d04dae:	9a00      	ldr	r2, [sp, #0]
    os_memmove(G_io_usb_ep_buffer, buffer, MIN(l, sizeof(G_io_usb_ep_buffer)));
c0d04db0:	2a40      	cmp	r2, #64	; 0x40
c0d04db2:	d300      	bcc.n	c0d04db6 <io_usb_hid_receive+0x26>
c0d04db4:	4632      	mov	r2, r6
c0d04db6:	4628      	mov	r0, r5
c0d04db8:	4639      	mov	r1, r7
c0d04dba:	f7ff faae 	bl	c0d0431a <os_memmove>
c0d04dbe:	4e3d      	ldr	r6, [pc, #244]	; (c0d04eb4 <io_usb_hid_receive+0x124>)
  }

  // process the chunk content
  switch(G_io_usb_ep_buffer[2]) {
c0d04dc0:	78b0      	ldrb	r0, [r6, #2]
c0d04dc2:	2801      	cmp	r0, #1
c0d04dc4:	dc0a      	bgt.n	c0d04ddc <io_usb_hid_receive+0x4c>
c0d04dc6:	2800      	cmp	r0, #0
c0d04dc8:	d025      	beq.n	c0d04e16 <io_usb_hid_receive+0x86>
c0d04dca:	2801      	cmp	r0, #1
c0d04dcc:	d160      	bne.n	c0d04e90 <io_usb_hid_receive+0x100>
    // await for the next chunk
    goto apdu_reset;

  case 0x01: // ALLOCATE CHANNEL
    // do not reset the current apdu reception if any
    cx_rng(G_io_usb_ep_buffer+3, 4);
c0d04dce:	1cf0      	adds	r0, r6, #3
c0d04dd0:	2104      	movs	r1, #4
c0d04dd2:	f001 fd23 	bl	c0d0681c <cx_rng>
c0d04dd6:	2140      	movs	r1, #64	; 0x40
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d04dd8:	4630      	mov	r0, r6
c0d04dda:	e028      	b.n	c0d04e2e <io_usb_hid_receive+0x9e>
  switch(G_io_usb_ep_buffer[2]) {
c0d04ddc:	2802      	cmp	r0, #2
c0d04dde:	d024      	beq.n	c0d04e2a <io_usb_hid_receive+0x9a>
c0d04de0:	2805      	cmp	r0, #5
c0d04de2:	d155      	bne.n	c0d04e90 <io_usb_hid_receive+0x100>
    if ((unsigned int)U2BE(G_io_usb_ep_buffer, 3) != (unsigned int)G_io_usb_hid_sequence_number) {
c0d04de4:	7930      	ldrb	r0, [r6, #4]
c0d04de6:	78f1      	ldrb	r1, [r6, #3]
c0d04de8:	0209      	lsls	r1, r1, #8
c0d04dea:	1808      	adds	r0, r1, r0
c0d04dec:	4c32      	ldr	r4, [pc, #200]	; (c0d04eb8 <io_usb_hid_receive+0x128>)
c0d04dee:	6821      	ldr	r1, [r4, #0]
c0d04df0:	2700      	movs	r7, #0
c0d04df2:	4288      	cmp	r0, r1
c0d04df4:	d153      	bne.n	c0d04e9e <io_usb_hid_receive+0x10e>
    if (G_io_usb_hid_sequence_number == 0) {
c0d04df6:	6820      	ldr	r0, [r4, #0]
c0d04df8:	2800      	cmp	r0, #0
c0d04dfa:	d01b      	beq.n	c0d04e34 <io_usb_hid_receive+0xa4>
    l -= 2+1+2;
c0d04dfc:	9800      	ldr	r0, [sp, #0]
c0d04dfe:	1f40      	subs	r0, r0, #5
      if (l > G_io_usb_hid_remaining_length) {
c0d04e00:	b285      	uxth	r5, r0
c0d04e02:	482e      	ldr	r0, [pc, #184]	; (c0d04ebc <io_usb_hid_receive+0x12c>)
c0d04e04:	6801      	ldr	r1, [r0, #0]
c0d04e06:	42a9      	cmp	r1, r5
c0d04e08:	d201      	bcs.n	c0d04e0e <io_usb_hid_receive+0x7e>
        l = G_io_usb_hid_remaining_length;
c0d04e0a:	6800      	ldr	r0, [r0, #0]
      os_memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+5, l);
c0d04e0c:	b285      	uxth	r5, r0
c0d04e0e:	482c      	ldr	r0, [pc, #176]	; (c0d04ec0 <io_usb_hid_receive+0x130>)
c0d04e10:	6800      	ldr	r0, [r0, #0]
c0d04e12:	1d71      	adds	r1, r6, #5
c0d04e14:	e02e      	b.n	c0d04e74 <io_usb_hid_receive+0xe4>
    os_memset(G_io_usb_ep_buffer+3, 0, 4); // PROTOCOL VERSION is 0
c0d04e16:	1cf0      	adds	r0, r6, #3
c0d04e18:	2700      	movs	r7, #0
c0d04e1a:	2204      	movs	r2, #4
c0d04e1c:	4639      	mov	r1, r7
c0d04e1e:	f7ff fa92 	bl	c0d04346 <os_memset>
c0d04e22:	2140      	movs	r1, #64	; 0x40
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d04e24:	4630      	mov	r0, r6
c0d04e26:	47a0      	blx	r4
c0d04e28:	e039      	b.n	c0d04e9e <io_usb_hid_receive+0x10e>
    goto apdu_reset;

  case 0x02: // ECHO|PING
    // do not reset the current apdu reception if any
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d04e2a:	4822      	ldr	r0, [pc, #136]	; (c0d04eb4 <io_usb_hid_receive+0x124>)
c0d04e2c:	2140      	movs	r1, #64	; 0x40
c0d04e2e:	47a0      	blx	r4
c0d04e30:	2700      	movs	r7, #0
c0d04e32:	e034      	b.n	c0d04e9e <io_usb_hid_receive+0x10e>
      G_io_usb_hid_total_length = U2BE(G_io_usb_ep_buffer, 5); //(G_io_usb_ep_buffer[5]<<8)+(G_io_usb_ep_buffer[6]&0xFF);
c0d04e34:	79b0      	ldrb	r0, [r6, #6]
c0d04e36:	7971      	ldrb	r1, [r6, #5]
c0d04e38:	0209      	lsls	r1, r1, #8
c0d04e3a:	1809      	adds	r1, r1, r0
c0d04e3c:	4821      	ldr	r0, [pc, #132]	; (c0d04ec4 <io_usb_hid_receive+0x134>)
c0d04e3e:	6001      	str	r1, [r0, #0]
      if (G_io_usb_hid_total_length > sizeof(G_io_apdu_buffer)) {
c0d04e40:	6801      	ldr	r1, [r0, #0]
c0d04e42:	0849      	lsrs	r1, r1, #1
c0d04e44:	29a8      	cmp	r1, #168	; 0xa8
c0d04e46:	d82a      	bhi.n	c0d04e9e <io_usb_hid_receive+0x10e>
      G_io_usb_hid_remaining_length = G_io_usb_hid_total_length;
c0d04e48:	6801      	ldr	r1, [r0, #0]
c0d04e4a:	481c      	ldr	r0, [pc, #112]	; (c0d04ebc <io_usb_hid_receive+0x12c>)
c0d04e4c:	6001      	str	r1, [r0, #0]
      G_io_usb_hid_channel = U2BE(G_io_usb_ep_buffer, 0);
c0d04e4e:	7871      	ldrb	r1, [r6, #1]
c0d04e50:	7832      	ldrb	r2, [r6, #0]
c0d04e52:	0212      	lsls	r2, r2, #8
c0d04e54:	1851      	adds	r1, r2, r1
c0d04e56:	4a1c      	ldr	r2, [pc, #112]	; (c0d04ec8 <io_usb_hid_receive+0x138>)
c0d04e58:	6011      	str	r1, [r2, #0]
      G_io_usb_hid_current_buffer = G_io_apdu_buffer;
c0d04e5a:	4919      	ldr	r1, [pc, #100]	; (c0d04ec0 <io_usb_hid_receive+0x130>)
c0d04e5c:	4a1b      	ldr	r2, [pc, #108]	; (c0d04ecc <io_usb_hid_receive+0x13c>)
c0d04e5e:	600a      	str	r2, [r1, #0]
      l -= 2;
c0d04e60:	9900      	ldr	r1, [sp, #0]
c0d04e62:	1fc9      	subs	r1, r1, #7
      if (l > G_io_usb_hid_remaining_length) {
c0d04e64:	b28d      	uxth	r5, r1
c0d04e66:	6801      	ldr	r1, [r0, #0]
c0d04e68:	42a9      	cmp	r1, r5
c0d04e6a:	d201      	bcs.n	c0d04e70 <io_usb_hid_receive+0xe0>
        l = G_io_usb_hid_remaining_length;
c0d04e6c:	6800      	ldr	r0, [r0, #0]
      os_memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+7, l);
c0d04e6e:	b285      	uxth	r5, r0
c0d04e70:	1df1      	adds	r1, r6, #7
c0d04e72:	4816      	ldr	r0, [pc, #88]	; (c0d04ecc <io_usb_hid_receive+0x13c>)
c0d04e74:	462a      	mov	r2, r5
c0d04e76:	f7ff fa50 	bl	c0d0431a <os_memmove>
    G_io_usb_hid_remaining_length -= l;
c0d04e7a:	4810      	ldr	r0, [pc, #64]	; (c0d04ebc <io_usb_hid_receive+0x12c>)
c0d04e7c:	6801      	ldr	r1, [r0, #0]
c0d04e7e:	1b49      	subs	r1, r1, r5
c0d04e80:	6001      	str	r1, [r0, #0]
    G_io_usb_hid_current_buffer += l;
c0d04e82:	480f      	ldr	r0, [pc, #60]	; (c0d04ec0 <io_usb_hid_receive+0x130>)
c0d04e84:	6801      	ldr	r1, [r0, #0]
c0d04e86:	1949      	adds	r1, r1, r5
c0d04e88:	6001      	str	r1, [r0, #0]
    G_io_usb_hid_sequence_number++;
c0d04e8a:	6820      	ldr	r0, [r4, #0]
c0d04e8c:	1c40      	adds	r0, r0, #1
c0d04e8e:	6020      	str	r0, [r4, #0]
    // await for the next chunk
    goto apdu_reset;
  }

  // if more data to be received, notify it
  if (G_io_usb_hid_remaining_length) {
c0d04e90:	480a      	ldr	r0, [pc, #40]	; (c0d04ebc <io_usb_hid_receive+0x12c>)
c0d04e92:	6800      	ldr	r0, [r0, #0]
c0d04e94:	2800      	cmp	r0, #0
c0d04e96:	d001      	beq.n	c0d04e9c <io_usb_hid_receive+0x10c>
c0d04e98:	2701      	movs	r7, #1
c0d04e9a:	e007      	b.n	c0d04eac <io_usb_hid_receive+0x11c>
c0d04e9c:	2702      	movs	r7, #2
c0d04e9e:	4806      	ldr	r0, [pc, #24]	; (c0d04eb8 <io_usb_hid_receive+0x128>)
c0d04ea0:	2100      	movs	r1, #0
c0d04ea2:	6001      	str	r1, [r0, #0]
c0d04ea4:	4806      	ldr	r0, [pc, #24]	; (c0d04ec0 <io_usb_hid_receive+0x130>)
c0d04ea6:	6001      	str	r1, [r0, #0]
c0d04ea8:	4804      	ldr	r0, [pc, #16]	; (c0d04ebc <io_usb_hid_receive+0x12c>)
c0d04eaa:	6001      	str	r1, [r0, #0]
  return IO_USB_APDU_RECEIVED;

apdu_reset:
  io_usb_hid_init();
  return IO_USB_APDU_RESET;
}
c0d04eac:	4638      	mov	r0, r7
c0d04eae:	b001      	add	sp, #4
c0d04eb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04eb2:	46c0      	nop			; (mov r8, r8)
c0d04eb4:	200020c0 	.word	0x200020c0
c0d04eb8:	20002100 	.word	0x20002100
c0d04ebc:	20002108 	.word	0x20002108
c0d04ec0:	2000210c 	.word	0x2000210c
c0d04ec4:	20002104 	.word	0x20002104
c0d04ec8:	20002110 	.word	0x20002110
c0d04ecc:	20001f09 	.word	0x20001f09

c0d04ed0 <io_usb_hid_init>:

void io_usb_hid_init(void) {
  G_io_usb_hid_sequence_number = 0; 
c0d04ed0:	4803      	ldr	r0, [pc, #12]	; (c0d04ee0 <io_usb_hid_init+0x10>)
c0d04ed2:	2100      	movs	r1, #0
c0d04ed4:	6001      	str	r1, [r0, #0]
  G_io_usb_hid_remaining_length = 0;
  G_io_usb_hid_current_buffer = NULL;
c0d04ed6:	4803      	ldr	r0, [pc, #12]	; (c0d04ee4 <io_usb_hid_init+0x14>)
c0d04ed8:	6001      	str	r1, [r0, #0]
  G_io_usb_hid_remaining_length = 0;
c0d04eda:	4803      	ldr	r0, [pc, #12]	; (c0d04ee8 <io_usb_hid_init+0x18>)
c0d04edc:	6001      	str	r1, [r0, #0]
}
c0d04ede:	4770      	bx	lr
c0d04ee0:	20002100 	.word	0x20002100
c0d04ee4:	2000210c 	.word	0x2000210c
c0d04ee8:	20002108 	.word	0x20002108

c0d04eec <io_usb_hid_sent>:

/**
 * sent the next io_usb_hid transport chunk (rx on the host, tx on the device)
 */
void io_usb_hid_sent(io_send_t sndfct) {
c0d04eec:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04eee:	b081      	sub	sp, #4
  unsigned int l;

  // only prepare next chunk if some data to be sent remain
  if (G_io_usb_hid_remaining_length && G_io_usb_hid_current_buffer) {
c0d04ef0:	4f2a      	ldr	r7, [pc, #168]	; (c0d04f9c <io_usb_hid_sent+0xb0>)
c0d04ef2:	683a      	ldr	r2, [r7, #0]
c0d04ef4:	4c2a      	ldr	r4, [pc, #168]	; (c0d04fa0 <io_usb_hid_sent+0xb4>)
c0d04ef6:	6821      	ldr	r1, [r4, #0]
c0d04ef8:	2900      	cmp	r1, #0
c0d04efa:	d01e      	beq.n	c0d04f3a <io_usb_hid_sent+0x4e>
c0d04efc:	2a00      	cmp	r2, #0
c0d04efe:	d01c      	beq.n	c0d04f3a <io_usb_hid_sent+0x4e>
c0d04f00:	9000      	str	r0, [sp, #0]
    // fill the chunk
    os_memset(G_io_usb_ep_buffer, 0, sizeof(G_io_usb_ep_buffer));
c0d04f02:	4d2a      	ldr	r5, [pc, #168]	; (c0d04fac <io_usb_hid_sent+0xc0>)
c0d04f04:	2100      	movs	r1, #0
c0d04f06:	2240      	movs	r2, #64	; 0x40
c0d04f08:	4628      	mov	r0, r5
c0d04f0a:	f7ff fa1c 	bl	c0d04346 <os_memset>
c0d04f0e:	2005      	movs	r0, #5

    // keep the channel identifier
    G_io_usb_ep_buffer[0] = (G_io_usb_hid_channel>>8)&0xFF;
    G_io_usb_ep_buffer[1] = G_io_usb_hid_channel&0xFF;
    G_io_usb_ep_buffer[2] = 0x05;
c0d04f10:	70a8      	strb	r0, [r5, #2]
    G_io_usb_ep_buffer[0] = (G_io_usb_hid_channel>>8)&0xFF;
c0d04f12:	4827      	ldr	r0, [pc, #156]	; (c0d04fb0 <io_usb_hid_sent+0xc4>)
c0d04f14:	6801      	ldr	r1, [r0, #0]
c0d04f16:	0a09      	lsrs	r1, r1, #8
c0d04f18:	7029      	strb	r1, [r5, #0]
    G_io_usb_ep_buffer[1] = G_io_usb_hid_channel&0xFF;
c0d04f1a:	6800      	ldr	r0, [r0, #0]
c0d04f1c:	7068      	strb	r0, [r5, #1]
    G_io_usb_ep_buffer[3] = G_io_usb_hid_sequence_number>>8;
c0d04f1e:	4b21      	ldr	r3, [pc, #132]	; (c0d04fa4 <io_usb_hid_sent+0xb8>)
c0d04f20:	6818      	ldr	r0, [r3, #0]
c0d04f22:	0a00      	lsrs	r0, r0, #8
c0d04f24:	70e8      	strb	r0, [r5, #3]
    G_io_usb_ep_buffer[4] = G_io_usb_hid_sequence_number;
c0d04f26:	6818      	ldr	r0, [r3, #0]
c0d04f28:	7128      	strb	r0, [r5, #4]

    if (G_io_usb_hid_sequence_number == 0) {
c0d04f2a:	6819      	ldr	r1, [r3, #0]
c0d04f2c:	6820      	ldr	r0, [r4, #0]
c0d04f2e:	2900      	cmp	r1, #0
c0d04f30:	d00b      	beq.n	c0d04f4a <io_usb_hid_sent+0x5e>
      os_memmove(G_io_usb_ep_buffer+7, (const void*)G_io_usb_hid_current_buffer, l);
      G_io_usb_hid_current_buffer += l;
      G_io_usb_hid_remaining_length -= l;
    }
    else {
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-5) ? IO_HID_EP_LENGTH-5 : G_io_usb_hid_remaining_length);
c0d04f32:	283b      	cmp	r0, #59	; 0x3b
c0d04f34:	d90d      	bls.n	c0d04f52 <io_usb_hid_sent+0x66>
c0d04f36:	263b      	movs	r6, #59	; 0x3b
c0d04f38:	e00c      	b.n	c0d04f54 <io_usb_hid_sent+0x68>
  G_io_usb_hid_sequence_number = 0; 
c0d04f3a:	481a      	ldr	r0, [pc, #104]	; (c0d04fa4 <io_usb_hid_sent+0xb8>)
c0d04f3c:	2100      	movs	r1, #0
c0d04f3e:	6001      	str	r1, [r0, #0]
  G_io_usb_hid_current_buffer = NULL;
c0d04f40:	6039      	str	r1, [r7, #0]
  // cleanup when everything has been sent (ack for the last sent usb in packet)
  else {
    io_usb_hid_init();

    // we sent the whole response
    G_io_app.apdu_state = APDU_IDLE;
c0d04f42:	4819      	ldr	r0, [pc, #100]	; (c0d04fa8 <io_usb_hid_sent+0xbc>)
c0d04f44:	7001      	strb	r1, [r0, #0]
  G_io_usb_hid_remaining_length = 0;
c0d04f46:	6021      	str	r1, [r4, #0]
c0d04f48:	e026      	b.n	c0d04f98 <io_usb_hid_sent+0xac>
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-7) ? IO_HID_EP_LENGTH-7 : G_io_usb_hid_remaining_length);
c0d04f4a:	2839      	cmp	r0, #57	; 0x39
c0d04f4c:	d90a      	bls.n	c0d04f64 <io_usb_hid_sent+0x78>
c0d04f4e:	2639      	movs	r6, #57	; 0x39
c0d04f50:	e009      	b.n	c0d04f66 <io_usb_hid_sent+0x7a>
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-5) ? IO_HID_EP_LENGTH-5 : G_io_usb_hid_remaining_length);
c0d04f52:	6826      	ldr	r6, [r4, #0]
      os_memmove(G_io_usb_ep_buffer+5, (const void*)G_io_usb_hid_current_buffer, l);
c0d04f54:	6839      	ldr	r1, [r7, #0]
c0d04f56:	1d68      	adds	r0, r5, #5
c0d04f58:	4632      	mov	r2, r6
c0d04f5a:	f7ff f9de 	bl	c0d0431a <os_memmove>
c0d04f5e:	9a00      	ldr	r2, [sp, #0]
c0d04f60:	4910      	ldr	r1, [pc, #64]	; (c0d04fa4 <io_usb_hid_sent+0xb8>)
c0d04f62:	e00d      	b.n	c0d04f80 <io_usb_hid_sent+0x94>
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-7) ? IO_HID_EP_LENGTH-7 : G_io_usb_hid_remaining_length);
c0d04f64:	6826      	ldr	r6, [r4, #0]
      G_io_usb_ep_buffer[5] = G_io_usb_hid_remaining_length>>8;
c0d04f66:	6820      	ldr	r0, [r4, #0]
c0d04f68:	0a00      	lsrs	r0, r0, #8
c0d04f6a:	7168      	strb	r0, [r5, #5]
      G_io_usb_ep_buffer[6] = G_io_usb_hid_remaining_length;
c0d04f6c:	6820      	ldr	r0, [r4, #0]
c0d04f6e:	71a8      	strb	r0, [r5, #6]
      os_memmove(G_io_usb_ep_buffer+7, (const void*)G_io_usb_hid_current_buffer, l);
c0d04f70:	6839      	ldr	r1, [r7, #0]
c0d04f72:	1de8      	adds	r0, r5, #7
c0d04f74:	4632      	mov	r2, r6
c0d04f76:	461d      	mov	r5, r3
c0d04f78:	f7ff f9cf 	bl	c0d0431a <os_memmove>
c0d04f7c:	4629      	mov	r1, r5
c0d04f7e:	9a00      	ldr	r2, [sp, #0]
c0d04f80:	6820      	ldr	r0, [r4, #0]
c0d04f82:	1b80      	subs	r0, r0, r6
c0d04f84:	6020      	str	r0, [r4, #0]
c0d04f86:	6838      	ldr	r0, [r7, #0]
c0d04f88:	1980      	adds	r0, r0, r6
c0d04f8a:	6038      	str	r0, [r7, #0]
    G_io_usb_hid_sequence_number++;
c0d04f8c:	6808      	ldr	r0, [r1, #0]
c0d04f8e:	1c40      	adds	r0, r0, #1
c0d04f90:	6008      	str	r0, [r1, #0]
    sndfct(G_io_usb_ep_buffer, sizeof(G_io_usb_ep_buffer));
c0d04f92:	4806      	ldr	r0, [pc, #24]	; (c0d04fac <io_usb_hid_sent+0xc0>)
c0d04f94:	2140      	movs	r1, #64	; 0x40
c0d04f96:	4790      	blx	r2
  }
}
c0d04f98:	b001      	add	sp, #4
c0d04f9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04f9c:	2000210c 	.word	0x2000210c
c0d04fa0:	20002108 	.word	0x20002108
c0d04fa4:	20002100 	.word	0x20002100
c0d04fa8:	2000205c 	.word	0x2000205c
c0d04fac:	200020c0 	.word	0x200020c0
c0d04fb0:	20002110 	.word	0x20002110

c0d04fb4 <io_usb_hid_send>:

void io_usb_hid_send(io_send_t sndfct, unsigned short sndlength) {
c0d04fb4:	b580      	push	{r7, lr}
  // perform send
  if (sndlength) {
c0d04fb6:	2900      	cmp	r1, #0
c0d04fb8:	d00b      	beq.n	c0d04fd2 <io_usb_hid_send+0x1e>
    G_io_usb_hid_sequence_number = 0; 
c0d04fba:	4a06      	ldr	r2, [pc, #24]	; (c0d04fd4 <io_usb_hid_send+0x20>)
c0d04fbc:	2300      	movs	r3, #0
c0d04fbe:	6013      	str	r3, [r2, #0]
    G_io_usb_hid_current_buffer = G_io_apdu_buffer;
    G_io_usb_hid_remaining_length = sndlength;
c0d04fc0:	4a05      	ldr	r2, [pc, #20]	; (c0d04fd8 <io_usb_hid_send+0x24>)
c0d04fc2:	6011      	str	r1, [r2, #0]
    G_io_usb_hid_current_buffer = G_io_apdu_buffer;
c0d04fc4:	4a05      	ldr	r2, [pc, #20]	; (c0d04fdc <io_usb_hid_send+0x28>)
c0d04fc6:	4b06      	ldr	r3, [pc, #24]	; (c0d04fe0 <io_usb_hid_send+0x2c>)
c0d04fc8:	6013      	str	r3, [r2, #0]
    G_io_usb_hid_total_length = sndlength;
c0d04fca:	4a06      	ldr	r2, [pc, #24]	; (c0d04fe4 <io_usb_hid_send+0x30>)
c0d04fcc:	6011      	str	r1, [r2, #0]
    io_usb_hid_sent(sndfct);
c0d04fce:	f7ff ff8d 	bl	c0d04eec <io_usb_hid_sent>
  }
}
c0d04fd2:	bd80      	pop	{r7, pc}
c0d04fd4:	20002100 	.word	0x20002100
c0d04fd8:	20002108 	.word	0x20002108
c0d04fdc:	2000210c 	.word	0x2000210c
c0d04fe0:	20001f09 	.word	0x20001f09
c0d04fe4:	20002104 	.word	0x20002104

c0d04fe8 <mcu_usb_prints>:
    mcu_usb_printc(*str++);
  }
}

#else
void mcu_usb_prints(const char* str, unsigned int charcount) {
c0d04fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04fea:	b081      	sub	sp, #4
c0d04fec:	460d      	mov	r5, r1
c0d04fee:	4604      	mov	r4, r0
c0d04ff0:	209c      	movs	r0, #156	; 0x9c
  if(USBD_Device.dev_state != USBD_STATE_CONFIGURED){
c0d04ff2:	4911      	ldr	r1, [pc, #68]	; (c0d05038 <mcu_usb_prints+0x50>)
c0d04ff4:	5c08      	ldrb	r0, [r1, r0]
c0d04ff6:	2803      	cmp	r0, #3
c0d04ff8:	d11c      	bne.n	c0d05034 <mcu_usb_prints+0x4c>
    return;
  }
  unsigned char buf[4];
  if(io_seproxyhal_spi_is_status_sent()){
c0d04ffa:	f001 fda1 	bl	c0d06b40 <io_seph_is_status_sent>
c0d04ffe:	2800      	cmp	r0, #0
c0d05000:	d004      	beq.n	c0d0500c <mcu_usb_prints+0x24>
c0d05002:	4668      	mov	r0, sp
c0d05004:	2103      	movs	r1, #3
c0d05006:	2200      	movs	r2, #0
      io_seproxyhal_spi_recv(buf, 3, 0);
c0d05008:	f001 fda6 	bl	c0d06b58 <io_seph_recv>
c0d0500c:	466e      	mov	r6, sp
  }
  buf[0] = SEPROXYHAL_TAG_PRINTF_STATUS;
  buf[1] = charcount >> 8;
  buf[2] = charcount;
c0d0500e:	70b5      	strb	r5, [r6, #2]
c0d05010:	2066      	movs	r0, #102	; 0x66
  buf[0] = SEPROXYHAL_TAG_PRINTF_STATUS;
c0d05012:	7030      	strb	r0, [r6, #0]
  buf[1] = charcount >> 8;
c0d05014:	0a28      	lsrs	r0, r5, #8
c0d05016:	7070      	strb	r0, [r6, #1]
c0d05018:	2703      	movs	r7, #3
  io_seproxyhal_spi_send(buf, 3);
c0d0501a:	4630      	mov	r0, r6
c0d0501c:	4639      	mov	r1, r7
c0d0501e:	f001 fd83 	bl	c0d06b28 <io_seph_send>
  io_seproxyhal_spi_send((const unsigned char *)str, charcount);
c0d05022:	b2a9      	uxth	r1, r5
c0d05024:	4620      	mov	r0, r4
c0d05026:	f001 fd7f 	bl	c0d06b28 <io_seph_send>
c0d0502a:	2200      	movs	r2, #0
#ifndef IO_SEPROXYHAL_DEBUG
  // wait printf ack (no race kthx)
  io_seproxyhal_spi_recv(buf, 3, 0);
c0d0502c:	4630      	mov	r0, r6
c0d0502e:	4639      	mov	r1, r7
c0d05030:	f001 fd92 	bl	c0d06b58 <io_seph_recv>
  buf[0] = 0; // consume tag to avoid misinterpretation (due to IO_CACHE)
#endif // IO_SEPROXYHAL_DEBUG
}
c0d05034:	b001      	add	sp, #4
c0d05036:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05038:	2000211c 	.word	0x2000211c

c0d0503c <mcu_usb_printf>:
 * - screen_printc
 */

void screen_printf(const char* format, ...) __attribute__ ((weak, alias ("mcu_usb_printf")));

void mcu_usb_printf(const char* format, ...) {
c0d0503c:	b083      	sub	sp, #12
c0d0503e:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05040:	b08e      	sub	sp, #56	; 0x38
c0d05042:	ac13      	add	r4, sp, #76	; 0x4c
c0d05044:	c40e      	stmia	r4!, {r1, r2, r3}
    char cStrlenSet;

    //
    // Check the arguments.
    //
    if(format == 0) {
c0d05046:	2800      	cmp	r0, #0
c0d05048:	d100      	bne.n	c0d0504c <mcu_usb_printf+0x10>
c0d0504a:	e18e      	b.n	c0d0536a <mcu_usb_printf+0x32e>
c0d0504c:	4604      	mov	r4, r0
c0d0504e:	a813      	add	r0, sp, #76	; 0x4c
    }

    //
    // Start the varargs processing.
    //
    va_start(vaArgP, format);
c0d05050:	9008      	str	r0, [sp, #32]

    //
    // Loop while there are more characters in the string.
    //
    while(*format)
c0d05052:	7820      	ldrb	r0, [r4, #0]
c0d05054:	2800      	cmp	r0, #0
c0d05056:	d100      	bne.n	c0d0505a <mcu_usb_printf+0x1e>
c0d05058:	e187      	b.n	c0d0536a <mcu_usb_printf+0x32e>
c0d0505a:	2600      	movs	r6, #0
c0d0505c:	43f1      	mvns	r1, r6
c0d0505e:	9100      	str	r1, [sp, #0]
c0d05060:	9604      	str	r6, [sp, #16]
c0d05062:	e019      	b.n	c0d05098 <mcu_usb_printf+0x5c>
                        // if string is empty, then, ' ' padding
                        if (pcStr[0] == '\0') {
                        
                          // padd ulStrlen white space
                          do {
                            mcu_usb_prints(" ", 1);
c0d05064:	9800      	ldr	r0, [sp, #0]
c0d05066:	9907      	ldr	r1, [sp, #28]
c0d05068:	1a46      	subs	r6, r0, r1
c0d0506a:	48c4      	ldr	r0, [pc, #784]	; (c0d0537c <mcu_usb_printf+0x340>)
c0d0506c:	4478      	add	r0, pc
c0d0506e:	2101      	movs	r1, #1
c0d05070:	f7ff ffba 	bl	c0d04fe8 <mcu_usb_prints>
                          } while(ulStrlen-- > 0);
c0d05074:	1c76      	adds	r6, r6, #1
c0d05076:	d1f8      	bne.n	c0d0506a <mcu_usb_printf+0x2e>
c0d05078:	9906      	ldr	r1, [sp, #24]

s_pad:
                    //
                    // Write any required padding spaces
                    //
                    if(ulCount > ulIdx)
c0d0507a:	42a9      	cmp	r1, r5
c0d0507c:	d800      	bhi.n	c0d05080 <mcu_usb_printf+0x44>
c0d0507e:	e16f      	b.n	c0d05360 <mcu_usb_printf+0x324>
                    {
                        ulCount -= ulIdx;
c0d05080:	1b48      	subs	r0, r1, r5
c0d05082:	d100      	bne.n	c0d05086 <mcu_usb_printf+0x4a>
c0d05084:	e16c      	b.n	c0d05360 <mcu_usb_printf+0x324>
                        while(ulCount--)
c0d05086:	1a6d      	subs	r5, r5, r1
                        {
                            mcu_usb_prints(" ", 1);
c0d05088:	48be      	ldr	r0, [pc, #760]	; (c0d05384 <mcu_usb_printf+0x348>)
c0d0508a:	4478      	add	r0, pc
c0d0508c:	2101      	movs	r1, #1
c0d0508e:	f7ff ffab 	bl	c0d04fe8 <mcu_usb_prints>
                        while(ulCount--)
c0d05092:	1c6d      	adds	r5, r5, #1
c0d05094:	d1f8      	bne.n	c0d05088 <mcu_usb_printf+0x4c>
c0d05096:	e163      	b.n	c0d05360 <mcu_usb_printf+0x324>
c0d05098:	4635      	mov	r5, r6
c0d0509a:	e002      	b.n	c0d050a2 <mcu_usb_printf+0x66>
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0d0509c:	1960      	adds	r0, r4, r5
c0d0509e:	7840      	ldrb	r0, [r0, #1]
            ulIdx++)
c0d050a0:	1c6d      	adds	r5, r5, #1
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0d050a2:	b2c0      	uxtb	r0, r0
c0d050a4:	2800      	cmp	r0, #0
c0d050a6:	d001      	beq.n	c0d050ac <mcu_usb_printf+0x70>
c0d050a8:	2825      	cmp	r0, #37	; 0x25
c0d050aa:	d1f7      	bne.n	c0d0509c <mcu_usb_printf+0x60>
        mcu_usb_prints(format, ulIdx);
c0d050ac:	4620      	mov	r0, r4
c0d050ae:	4629      	mov	r1, r5
c0d050b0:	f7ff ff9a 	bl	c0d04fe8 <mcu_usb_prints>
        if(*format == '%')
c0d050b4:	5d60      	ldrb	r0, [r4, r5]
c0d050b6:	2825      	cmp	r0, #37	; 0x25
c0d050b8:	d109      	bne.n	c0d050ce <mcu_usb_printf+0x92>
            ulBase = 10;
c0d050ba:	1960      	adds	r0, r4, r5
c0d050bc:	1c41      	adds	r1, r0, #1
c0d050be:	2300      	movs	r3, #0
c0d050c0:	2020      	movs	r0, #32
c0d050c2:	220a      	movs	r2, #10
c0d050c4:	9205      	str	r2, [sp, #20]
c0d050c6:	9307      	str	r3, [sp, #28]
c0d050c8:	461e      	mov	r6, r3
c0d050ca:	9306      	str	r3, [sp, #24]
c0d050cc:	e008      	b.n	c0d050e0 <mcu_usb_printf+0xa4>
c0d050ce:	1964      	adds	r4, r4, r5
c0d050d0:	e148      	b.n	c0d05364 <mcu_usb_printf+0x328>
c0d050d2:	2302      	movs	r3, #2
c0d050d4:	4621      	mov	r1, r4
c0d050d6:	9a08      	ldr	r2, [sp, #32]
c0d050d8:	1d14      	adds	r4, r2, #4
c0d050da:	9408      	str	r4, [sp, #32]
c0d050dc:	6812      	ldr	r2, [r2, #0]
            switch(*format++)
c0d050de:	9207      	str	r2, [sp, #28]
c0d050e0:	460c      	mov	r4, r1
c0d050e2:	4619      	mov	r1, r3
c0d050e4:	7822      	ldrb	r2, [r4, #0]
c0d050e6:	1c64      	adds	r4, r4, #1
c0d050e8:	2300      	movs	r3, #0
c0d050ea:	2a2d      	cmp	r2, #45	; 0x2d
c0d050ec:	d0f9      	beq.n	c0d050e2 <mcu_usb_printf+0xa6>
c0d050ee:	2a47      	cmp	r2, #71	; 0x47
c0d050f0:	dc18      	bgt.n	c0d05124 <mcu_usb_printf+0xe8>
c0d050f2:	2a2f      	cmp	r2, #47	; 0x2f
c0d050f4:	dd23      	ble.n	c0d0513e <mcu_usb_printf+0x102>
c0d050f6:	4613      	mov	r3, r2
c0d050f8:	3b30      	subs	r3, #48	; 0x30
c0d050fa:	2b0a      	cmp	r3, #10
c0d050fc:	d300      	bcc.n	c0d05100 <mcu_usb_printf+0xc4>
c0d050fe:	e088      	b.n	c0d05212 <mcu_usb_printf+0x1d6>
                    if((format[-1] == '0') && (ulCount == 0))
c0d05100:	2a30      	cmp	r2, #48	; 0x30
c0d05102:	4603      	mov	r3, r0
c0d05104:	d100      	bne.n	c0d05108 <mcu_usb_printf+0xcc>
c0d05106:	4613      	mov	r3, r2
c0d05108:	9f06      	ldr	r7, [sp, #24]
c0d0510a:	2f00      	cmp	r7, #0
c0d0510c:	d000      	beq.n	c0d05110 <mcu_usb_printf+0xd4>
c0d0510e:	4603      	mov	r3, r0
c0d05110:	270a      	movs	r7, #10
                    ulCount *= 10;
c0d05112:	9806      	ldr	r0, [sp, #24]
c0d05114:	4347      	muls	r7, r0
                    ulCount += format[-1] - '0';
c0d05116:	18b8      	adds	r0, r7, r2
c0d05118:	3830      	subs	r0, #48	; 0x30
c0d0511a:	9006      	str	r0, [sp, #24]
c0d0511c:	4618      	mov	r0, r3
c0d0511e:	460b      	mov	r3, r1
c0d05120:	4621      	mov	r1, r4
c0d05122:	e7dd      	b.n	c0d050e0 <mcu_usb_printf+0xa4>
            switch(*format++)
c0d05124:	2a67      	cmp	r2, #103	; 0x67
c0d05126:	dd04      	ble.n	c0d05132 <mcu_usb_printf+0xf6>
c0d05128:	2a72      	cmp	r2, #114	; 0x72
c0d0512a:	dd1b      	ble.n	c0d05164 <mcu_usb_printf+0x128>
c0d0512c:	2a73      	cmp	r2, #115	; 0x73
c0d0512e:	d130      	bne.n	c0d05192 <mcu_usb_printf+0x156>
c0d05130:	e01d      	b.n	c0d0516e <mcu_usb_printf+0x132>
c0d05132:	2a62      	cmp	r2, #98	; 0x62
c0d05134:	dc32      	bgt.n	c0d0519c <mcu_usb_printf+0x160>
c0d05136:	2a48      	cmp	r2, #72	; 0x48
c0d05138:	d140      	bne.n	c0d051bc <mcu_usb_printf+0x180>
c0d0513a:	2601      	movs	r6, #1
c0d0513c:	e015      	b.n	c0d0516a <mcu_usb_printf+0x12e>
c0d0513e:	2a25      	cmp	r2, #37	; 0x25
c0d05140:	d04c      	beq.n	c0d051dc <mcu_usb_printf+0x1a0>
c0d05142:	2a2a      	cmp	r2, #42	; 0x2a
c0d05144:	d021      	beq.n	c0d0518a <mcu_usb_printf+0x14e>
c0d05146:	2a2e      	cmp	r2, #46	; 0x2e
c0d05148:	d163      	bne.n	c0d05212 <mcu_usb_printf+0x1d6>
                  if (format[0] == '*' && (format[1] == 's' || format[1] == 'H' || format[1] == 'h')) {
c0d0514a:	7821      	ldrb	r1, [r4, #0]
c0d0514c:	292a      	cmp	r1, #42	; 0x2a
c0d0514e:	d160      	bne.n	c0d05212 <mcu_usb_printf+0x1d6>
c0d05150:	7862      	ldrb	r2, [r4, #1]
c0d05152:	1c61      	adds	r1, r4, #1
c0d05154:	2301      	movs	r3, #1
c0d05156:	2a48      	cmp	r2, #72	; 0x48
c0d05158:	d0bd      	beq.n	c0d050d6 <mcu_usb_printf+0x9a>
c0d0515a:	2a68      	cmp	r2, #104	; 0x68
c0d0515c:	d0bb      	beq.n	c0d050d6 <mcu_usb_printf+0x9a>
c0d0515e:	2a73      	cmp	r2, #115	; 0x73
c0d05160:	d0b9      	beq.n	c0d050d6 <mcu_usb_printf+0x9a>
c0d05162:	e056      	b.n	c0d05212 <mcu_usb_printf+0x1d6>
            switch(*format++)
c0d05164:	2a68      	cmp	r2, #104	; 0x68
c0d05166:	d12d      	bne.n	c0d051c4 <mcu_usb_printf+0x188>
c0d05168:	2600      	movs	r6, #0
c0d0516a:	2210      	movs	r2, #16
c0d0516c:	9205      	str	r2, [sp, #20]
                    pcStr = va_arg(vaArgP, char *);
c0d0516e:	9b08      	ldr	r3, [sp, #32]
c0d05170:	1d1a      	adds	r2, r3, #4
c0d05172:	9208      	str	r2, [sp, #32]
                    switch(cStrlenSet) {
c0d05174:	b2ca      	uxtb	r2, r1
                    pcStr = va_arg(vaArgP, char *);
c0d05176:	681f      	ldr	r7, [r3, #0]
                    switch(cStrlenSet) {
c0d05178:	2a01      	cmp	r2, #1
c0d0517a:	d044      	beq.n	c0d05206 <mcu_usb_printf+0x1ca>
c0d0517c:	2a02      	cmp	r2, #2
c0d0517e:	d044      	beq.n	c0d0520a <mcu_usb_printf+0x1ce>
c0d05180:	2a03      	cmp	r2, #3
c0d05182:	460b      	mov	r3, r1
c0d05184:	4621      	mov	r1, r4
c0d05186:	d0ab      	beq.n	c0d050e0 <mcu_usb_printf+0xa4>
c0d05188:	e047      	b.n	c0d0521a <mcu_usb_printf+0x1de>
                  if (*format == 's' ) {                    
c0d0518a:	7821      	ldrb	r1, [r4, #0]
c0d0518c:	2973      	cmp	r1, #115	; 0x73
c0d0518e:	d0a0      	beq.n	c0d050d2 <mcu_usb_printf+0x96>
c0d05190:	e03f      	b.n	c0d05212 <mcu_usb_printf+0x1d6>
            switch(*format++)
c0d05192:	2a75      	cmp	r2, #117	; 0x75
c0d05194:	d025      	beq.n	c0d051e2 <mcu_usb_printf+0x1a6>
c0d05196:	2a78      	cmp	r2, #120	; 0x78
c0d05198:	d016      	beq.n	c0d051c8 <mcu_usb_printf+0x18c>
c0d0519a:	e03a      	b.n	c0d05212 <mcu_usb_printf+0x1d6>
c0d0519c:	2a63      	cmp	r2, #99	; 0x63
c0d0519e:	d02a      	beq.n	c0d051f6 <mcu_usb_printf+0x1ba>
c0d051a0:	2a64      	cmp	r2, #100	; 0x64
c0d051a2:	d136      	bne.n	c0d05212 <mcu_usb_printf+0x1d6>
c0d051a4:	9003      	str	r0, [sp, #12]
c0d051a6:	9605      	str	r6, [sp, #20]
                    ulValue = va_arg(vaArgP, unsigned long);
c0d051a8:	9808      	ldr	r0, [sp, #32]
c0d051aa:	1d01      	adds	r1, r0, #4
c0d051ac:	9108      	str	r1, [sp, #32]
c0d051ae:	6800      	ldr	r0, [r0, #0]
c0d051b0:	900d      	str	r0, [sp, #52]	; 0x34
c0d051b2:	260a      	movs	r6, #10
                    if((long)ulValue < 0)
c0d051b4:	2800      	cmp	r0, #0
c0d051b6:	db5c      	blt.n	c0d05272 <mcu_usb_printf+0x236>
c0d051b8:	2100      	movs	r1, #0
c0d051ba:	e05d      	b.n	c0d05278 <mcu_usb_printf+0x23c>
            switch(*format++)
c0d051bc:	2a58      	cmp	r2, #88	; 0x58
c0d051be:	d128      	bne.n	c0d05212 <mcu_usb_printf+0x1d6>
c0d051c0:	2601      	movs	r6, #1
c0d051c2:	e001      	b.n	c0d051c8 <mcu_usb_printf+0x18c>
c0d051c4:	2a70      	cmp	r2, #112	; 0x70
c0d051c6:	d124      	bne.n	c0d05212 <mcu_usb_printf+0x1d6>
c0d051c8:	9003      	str	r0, [sp, #12]
c0d051ca:	9605      	str	r6, [sp, #20]
                case 'p':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);
c0d051cc:	9808      	ldr	r0, [sp, #32]
c0d051ce:	1d01      	adds	r1, r0, #4
c0d051d0:	9108      	str	r1, [sp, #32]
c0d051d2:	6800      	ldr	r0, [r0, #0]
c0d051d4:	900d      	str	r0, [sp, #52]	; 0x34
c0d051d6:	2100      	movs	r1, #0
c0d051d8:	2610      	movs	r6, #16
c0d051da:	e04d      	b.n	c0d05278 <mcu_usb_printf+0x23c>
                case '%':
                {
                    //
                    // Simply write a single %.
                    //
                    mcu_usb_prints(format - 1, 1);
c0d051dc:	9800      	ldr	r0, [sp, #0]
c0d051de:	1820      	adds	r0, r4, r0
c0d051e0:	e00f      	b.n	c0d05202 <mcu_usb_printf+0x1c6>
c0d051e2:	9003      	str	r0, [sp, #12]
c0d051e4:	9605      	str	r6, [sp, #20]
                    ulValue = va_arg(vaArgP, unsigned long);
c0d051e6:	9808      	ldr	r0, [sp, #32]
c0d051e8:	1d01      	adds	r1, r0, #4
c0d051ea:	9108      	str	r1, [sp, #32]
c0d051ec:	6800      	ldr	r0, [r0, #0]
c0d051ee:	900d      	str	r0, [sp, #52]	; 0x34
c0d051f0:	2100      	movs	r1, #0
c0d051f2:	260a      	movs	r6, #10
c0d051f4:	e040      	b.n	c0d05278 <mcu_usb_printf+0x23c>
                    ulValue = va_arg(vaArgP, unsigned long);
c0d051f6:	9808      	ldr	r0, [sp, #32]
c0d051f8:	1d01      	adds	r1, r0, #4
c0d051fa:	9108      	str	r1, [sp, #32]
c0d051fc:	6800      	ldr	r0, [r0, #0]
c0d051fe:	900d      	str	r0, [sp, #52]	; 0x34
c0d05200:	a80d      	add	r0, sp, #52	; 0x34
c0d05202:	2101      	movs	r1, #1
c0d05204:	e0aa      	b.n	c0d0535c <mcu_usb_printf+0x320>
c0d05206:	9907      	ldr	r1, [sp, #28]
c0d05208:	e00d      	b.n	c0d05226 <mcu_usb_printf+0x1ea>
                        if (pcStr[0] == '\0') {
c0d0520a:	7838      	ldrb	r0, [r7, #0]
c0d0520c:	2800      	cmp	r0, #0
c0d0520e:	d100      	bne.n	c0d05212 <mcu_usb_printf+0x1d6>
c0d05210:	e728      	b.n	c0d05064 <mcu_usb_printf+0x28>
                default:
                {
                    //
                    // Indicate an error.
                    //
                    mcu_usb_prints("ERROR", 5);
c0d05212:	4858      	ldr	r0, [pc, #352]	; (c0d05374 <mcu_usb_printf+0x338>)
c0d05214:	4478      	add	r0, pc
c0d05216:	2105      	movs	r1, #5
c0d05218:	e0a0      	b.n	c0d0535c <mcu_usb_printf+0x320>
c0d0521a:	2100      	movs	r1, #0
                        for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
c0d0521c:	5c7a      	ldrb	r2, [r7, r1]
c0d0521e:	1c49      	adds	r1, r1, #1
c0d05220:	2a00      	cmp	r2, #0
c0d05222:	d1fb      	bne.n	c0d0521c <mcu_usb_printf+0x1e0>
                    switch(ulBase) {
c0d05224:	1e49      	subs	r1, r1, #1
c0d05226:	9805      	ldr	r0, [sp, #20]
c0d05228:	2810      	cmp	r0, #16
c0d0522a:	d11d      	bne.n	c0d05268 <mcu_usb_printf+0x22c>
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d0522c:	2900      	cmp	r1, #0
c0d0522e:	9605      	str	r6, [sp, #20]
c0d05230:	d100      	bne.n	c0d05234 <mcu_usb_printf+0x1f8>
c0d05232:	e095      	b.n	c0d05360 <mcu_usb_printf+0x324>
                          nibble1 = (pcStr[ulCount]>>4)&0xF;
c0d05234:	7838      	ldrb	r0, [r7, #0]
c0d05236:	250f      	movs	r5, #15
                          nibble2 = pcStr[ulCount]&0xF;
c0d05238:	4005      	ands	r5, r0
                          nibble1 = (pcStr[ulCount]>>4)&0xF;
c0d0523a:	0900      	lsrs	r0, r0, #4
                          switch(ulCap) {
c0d0523c:	2e01      	cmp	r6, #1
c0d0523e:	d004      	beq.n	c0d0524a <mcu_usb_printf+0x20e>
c0d05240:	2e00      	cmp	r6, #0
c0d05242:	d10d      	bne.n	c0d05260 <mcu_usb_printf+0x224>
                              mcu_usb_printc(g_pcHex[nibble1]);
c0d05244:	4e4c      	ldr	r6, [pc, #304]	; (c0d05378 <mcu_usb_printf+0x33c>)
c0d05246:	447e      	add	r6, pc
c0d05248:	e001      	b.n	c0d0524e <mcu_usb_printf+0x212>
                              mcu_usb_printc(g_pcHex_cap[nibble1]);
c0d0524a:	4e4d      	ldr	r6, [pc, #308]	; (c0d05380 <mcu_usb_printf+0x344>)
c0d0524c:	447e      	add	r6, pc
c0d0524e:	5c30      	ldrb	r0, [r6, r0]
c0d05250:	9107      	str	r1, [sp, #28]
c0d05252:	f7ff fd71 	bl	c0d04d38 <mcu_usb_printc>
c0d05256:	5d70      	ldrb	r0, [r6, r5]
c0d05258:	9e05      	ldr	r6, [sp, #20]
c0d0525a:	f7ff fd6d 	bl	c0d04d38 <mcu_usb_printc>
c0d0525e:	9907      	ldr	r1, [sp, #28]
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d05260:	1c7f      	adds	r7, r7, #1
c0d05262:	1e49      	subs	r1, r1, #1
c0d05264:	d1e6      	bne.n	c0d05234 <mcu_usb_printf+0x1f8>
c0d05266:	e07b      	b.n	c0d05360 <mcu_usb_printf+0x324>
                        mcu_usb_prints(pcStr, ulIdx);
c0d05268:	4638      	mov	r0, r7
c0d0526a:	460d      	mov	r5, r1
c0d0526c:	f7ff febc 	bl	c0d04fe8 <mcu_usb_prints>
c0d05270:	e702      	b.n	c0d05078 <mcu_usb_printf+0x3c>
                        ulValue = -(long)ulValue;
c0d05272:	4240      	negs	r0, r0
c0d05274:	900d      	str	r0, [sp, #52]	; 0x34
c0d05276:	2101      	movs	r1, #1
c0d05278:	9102      	str	r1, [sp, #8]
c0d0527a:	9007      	str	r0, [sp, #28]
                        (((ulIdx * ulBase) <= ulValue) &&
c0d0527c:	4286      	cmp	r6, r0
c0d0527e:	d901      	bls.n	c0d05284 <mcu_usb_printf+0x248>
c0d05280:	2701      	movs	r7, #1
c0d05282:	e012      	b.n	c0d052aa <mcu_usb_printf+0x26e>
c0d05284:	2501      	movs	r5, #1
c0d05286:	4630      	mov	r0, r6
c0d05288:	4607      	mov	r7, r0
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
c0d0528a:	4631      	mov	r1, r6
c0d0528c:	f005 f94a 	bl	c0d0a524 <__udivsi3>
                    for(ulIdx = 1;
c0d05290:	42a8      	cmp	r0, r5
c0d05292:	d109      	bne.n	c0d052a8 <mcu_usb_printf+0x26c>
                        (((ulIdx * ulBase) <= ulValue) &&
c0d05294:	4630      	mov	r0, r6
c0d05296:	4378      	muls	r0, r7
                        ulIdx *= ulBase, ulCount--)
c0d05298:	9906      	ldr	r1, [sp, #24]
c0d0529a:	1e49      	subs	r1, r1, #1
                        (((ulIdx * ulBase) <= ulValue) &&
c0d0529c:	9106      	str	r1, [sp, #24]
c0d0529e:	9907      	ldr	r1, [sp, #28]
c0d052a0:	4288      	cmp	r0, r1
c0d052a2:	463d      	mov	r5, r7
c0d052a4:	d9f0      	bls.n	c0d05288 <mcu_usb_printf+0x24c>
c0d052a6:	e000      	b.n	c0d052aa <mcu_usb_printf+0x26e>
c0d052a8:	462f      	mov	r7, r5
c0d052aa:	9601      	str	r6, [sp, #4]
c0d052ac:	9b02      	ldr	r3, [sp, #8]
                    if(ulNeg)
c0d052ae:	2b00      	cmp	r3, #0
c0d052b0:	d101      	bne.n	c0d052b6 <mcu_usb_printf+0x27a>
c0d052b2:	9906      	ldr	r1, [sp, #24]
c0d052b4:	e001      	b.n	c0d052ba <mcu_usb_printf+0x27e>
c0d052b6:	9806      	ldr	r0, [sp, #24]
c0d052b8:	1e41      	subs	r1, r0, #1
c0d052ba:	2000      	movs	r0, #0
c0d052bc:	2b00      	cmp	r3, #0
c0d052be:	d101      	bne.n	c0d052c4 <mcu_usb_printf+0x288>
c0d052c0:	461e      	mov	r6, r3
c0d052c2:	e000      	b.n	c0d052c6 <mcu_usb_printf+0x28a>
c0d052c4:	43c6      	mvns	r6, r0
                    if(ulNeg && (cFill == '0'))
c0d052c6:	2b00      	cmp	r3, #0
c0d052c8:	d009      	beq.n	c0d052de <mcu_usb_printf+0x2a2>
c0d052ca:	9a03      	ldr	r2, [sp, #12]
c0d052cc:	b2d2      	uxtb	r2, r2
c0d052ce:	2a30      	cmp	r2, #48	; 0x30
c0d052d0:	d106      	bne.n	c0d052e0 <mcu_usb_printf+0x2a4>
c0d052d2:	aa09      	add	r2, sp, #36	; 0x24
c0d052d4:	232d      	movs	r3, #45	; 0x2d
                        pcBuf[ulPos++] = '-';
c0d052d6:	7013      	strb	r3, [r2, #0]
c0d052d8:	2501      	movs	r5, #1
c0d052da:	4603      	mov	r3, r0
c0d052dc:	e001      	b.n	c0d052e2 <mcu_usb_printf+0x2a6>
c0d052de:	4603      	mov	r3, r0
c0d052e0:	4605      	mov	r5, r0
                    if((ulCount > 1) && (ulCount < 16))
c0d052e2:	1e88      	subs	r0, r1, #2
c0d052e4:	280d      	cmp	r0, #13
c0d052e6:	d812      	bhi.n	c0d0530e <mcu_usb_printf+0x2d2>
c0d052e8:	a809      	add	r0, sp, #36	; 0x24
                            pcBuf[ulPos++] = cFill;
c0d052ea:	1940      	adds	r0, r0, r5
c0d052ec:	1e49      	subs	r1, r1, #1
c0d052ee:	9a03      	ldr	r2, [sp, #12]
c0d052f0:	b2d2      	uxtb	r2, r2
c0d052f2:	9603      	str	r6, [sp, #12]
c0d052f4:	461e      	mov	r6, r3
c0d052f6:	f005 f9c7 	bl	c0d0a688 <__aeabi_memset>
c0d052fa:	4633      	mov	r3, r6
c0d052fc:	2001      	movs	r0, #1
c0d052fe:	9906      	ldr	r1, [sp, #24]
c0d05300:	1a40      	subs	r0, r0, r1
c0d05302:	9903      	ldr	r1, [sp, #12]
c0d05304:	1a40      	subs	r0, r0, r1
                        for(ulCount--; ulCount; ulCount--)
c0d05306:	1c40      	adds	r0, r0, #1
                            pcBuf[ulPos++] = cFill;
c0d05308:	1c6d      	adds	r5, r5, #1
                        for(ulCount--; ulCount; ulCount--)
c0d0530a:	2800      	cmp	r0, #0
c0d0530c:	d1fb      	bne.n	c0d05306 <mcu_usb_printf+0x2ca>
                    if(ulNeg)
c0d0530e:	2b00      	cmp	r3, #0
c0d05310:	d003      	beq.n	c0d0531a <mcu_usb_printf+0x2de>
c0d05312:	a809      	add	r0, sp, #36	; 0x24
c0d05314:	212d      	movs	r1, #45	; 0x2d
                        pcBuf[ulPos++] = '-';
c0d05316:	5541      	strb	r1, [r0, r5]
c0d05318:	1c6d      	adds	r5, r5, #1
                    for(; ulIdx; ulIdx /= ulBase)
c0d0531a:	2f00      	cmp	r7, #0
c0d0531c:	d01c      	beq.n	c0d05358 <mcu_usb_printf+0x31c>
c0d0531e:	9805      	ldr	r0, [sp, #20]
c0d05320:	2800      	cmp	r0, #0
c0d05322:	d002      	beq.n	c0d0532a <mcu_usb_printf+0x2ee>
c0d05324:	4819      	ldr	r0, [pc, #100]	; (c0d0538c <mcu_usb_printf+0x350>)
c0d05326:	4478      	add	r0, pc
c0d05328:	e001      	b.n	c0d0532e <mcu_usb_printf+0x2f2>
c0d0532a:	4817      	ldr	r0, [pc, #92]	; (c0d05388 <mcu_usb_printf+0x34c>)
c0d0532c:	4478      	add	r0, pc
c0d0532e:	9006      	str	r0, [sp, #24]
c0d05330:	9e01      	ldr	r6, [sp, #4]
c0d05332:	9807      	ldr	r0, [sp, #28]
c0d05334:	4639      	mov	r1, r7
c0d05336:	f005 f8f5 	bl	c0d0a524 <__udivsi3>
c0d0533a:	4631      	mov	r1, r6
c0d0533c:	f005 f978 	bl	c0d0a630 <__aeabi_uidivmod>
c0d05340:	9806      	ldr	r0, [sp, #24]
c0d05342:	5c40      	ldrb	r0, [r0, r1]
c0d05344:	a909      	add	r1, sp, #36	; 0x24
                          pcBuf[ulPos++] = g_pcHex[(ulValue / ulIdx) % ulBase];
c0d05346:	5548      	strb	r0, [r1, r5]
                    for(; ulIdx; ulIdx /= ulBase)
c0d05348:	4638      	mov	r0, r7
c0d0534a:	4631      	mov	r1, r6
c0d0534c:	f005 f8ea 	bl	c0d0a524 <__udivsi3>
c0d05350:	1c6d      	adds	r5, r5, #1
c0d05352:	42be      	cmp	r6, r7
c0d05354:	4607      	mov	r7, r0
c0d05356:	d9ec      	bls.n	c0d05332 <mcu_usb_printf+0x2f6>
c0d05358:	a809      	add	r0, sp, #36	; 0x24
                    mcu_usb_prints(pcBuf, ulPos);
c0d0535a:	4629      	mov	r1, r5
c0d0535c:	f7ff fe44 	bl	c0d04fe8 <mcu_usb_prints>
    while(*format)
c0d05360:	7820      	ldrb	r0, [r4, #0]
c0d05362:	9e04      	ldr	r6, [sp, #16]
c0d05364:	2800      	cmp	r0, #0
c0d05366:	d000      	beq.n	c0d0536a <mcu_usb_printf+0x32e>
c0d05368:	e696      	b.n	c0d05098 <mcu_usb_printf+0x5c>

    //
    // End the varargs processing.
    //
    va_end(vaArgP);
}
c0d0536a:	b00e      	add	sp, #56	; 0x38
c0d0536c:	bcf0      	pop	{r4, r5, r6, r7}
c0d0536e:	bc01      	pop	{r0}
c0d05370:	b003      	add	sp, #12
c0d05372:	4700      	bx	r0
c0d05374:	00006c6d 	.word	0x00006c6d
c0d05378:	00006c41 	.word	0x00006c41
c0d0537c:	00006dd0 	.word	0x00006dd0
c0d05380:	00006c4b 	.word	0x00006c4b
c0d05384:	00006db2 	.word	0x00006db2
c0d05388:	00006b5b 	.word	0x00006b5b
c0d0538c:	00006b71 	.word	0x00006b71

c0d05390 <snprintf>:
#endif // HAVE_PRINTF

#ifdef HAVE_SPRINTF
//unsigned int snprintf(unsigned char * str, unsigned int str_size, const char* format, ...)
int snprintf(char * str, size_t str_size, const char * format, ...)
 {
c0d05390:	b081      	sub	sp, #4
c0d05392:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05394:	b08e      	sub	sp, #56	; 0x38
c0d05396:	9313      	str	r3, [sp, #76]	; 0x4c
    char cStrlenSet;
    
    //
    // Check the arguments.
    //
    if(format == NULL || str == NULL ||str_size < 2) {
c0d05398:	2902      	cmp	r1, #2
c0d0539a:	d200      	bcs.n	c0d0539e <snprintf+0xe>
c0d0539c:	e1bd      	b.n	c0d0571a <snprintf+0x38a>
c0d0539e:	2800      	cmp	r0, #0
c0d053a0:	d100      	bne.n	c0d053a4 <snprintf+0x14>
c0d053a2:	e1ba      	b.n	c0d0571a <snprintf+0x38a>
c0d053a4:	4615      	mov	r5, r2
c0d053a6:	2a00      	cmp	r2, #0
c0d053a8:	d100      	bne.n	c0d053ac <snprintf+0x1c>
c0d053aa:	e1b6      	b.n	c0d0571a <snprintf+0x38a>
c0d053ac:	460c      	mov	r4, r1
c0d053ae:	4606      	mov	r6, r0
      return 0;
    }

    // ensure terminating string with a \0
    memset(str, 0, str_size);
c0d053b0:	f005 f95c 	bl	c0d0a66c <__aeabi_memclr>
c0d053b4:	a913      	add	r1, sp, #76	; 0x4c


    //
    // Start the varargs processing.
    //
    va_start(vaArgP, format);
c0d053b6:	9109      	str	r1, [sp, #36]	; 0x24

    //
    // Loop while there are more characters in the string.
    //
    while(*format)
c0d053b8:	7829      	ldrb	r1, [r5, #0]
c0d053ba:	2900      	cmp	r1, #0
c0d053bc:	d100      	bne.n	c0d053c0 <snprintf+0x30>
c0d053be:	e1ac      	b.n	c0d0571a <snprintf+0x38a>
c0d053c0:	4630      	mov	r0, r6
    str_size--;
c0d053c2:	1e67      	subs	r7, r4, #1
c0d053c4:	2600      	movs	r6, #0
c0d053c6:	e002      	b.n	c0d053ce <snprintf+0x3e>
    {
        //
        // Find the first non-% character, or the end of the string.
        //
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0d053c8:	19a9      	adds	r1, r5, r6
c0d053ca:	7849      	ldrb	r1, [r1, #1]
            ulIdx++)
c0d053cc:	1c76      	adds	r6, r6, #1
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0d053ce:	b2c9      	uxtb	r1, r1
c0d053d0:	2900      	cmp	r1, #0
c0d053d2:	d001      	beq.n	c0d053d8 <snprintf+0x48>
c0d053d4:	2925      	cmp	r1, #37	; 0x25
c0d053d6:	d1f7      	bne.n	c0d053c8 <snprintf+0x38>
        }

        //
        // Write this portion of the string.
        //
        ulIdx = MIN(ulIdx, str_size);
c0d053d8:	42be      	cmp	r6, r7
c0d053da:	d300      	bcc.n	c0d053de <snprintf+0x4e>
c0d053dc:	463e      	mov	r6, r7
        memmove(str, format, ulIdx);
c0d053de:	4629      	mov	r1, r5
c0d053e0:	4604      	mov	r4, r0
c0d053e2:	4632      	mov	r2, r6
c0d053e4:	f005 f94c 	bl	c0d0a680 <__aeabi_memmove>
        str+= ulIdx;
        str_size -= ulIdx;
c0d053e8:	1bbf      	subs	r7, r7, r6
c0d053ea:	9706      	str	r7, [sp, #24]
c0d053ec:	d100      	bne.n	c0d053f0 <snprintf+0x60>
c0d053ee:	e194      	b.n	c0d0571a <snprintf+0x38a>
c0d053f0:	4620      	mov	r0, r4
c0d053f2:	19a0      	adds	r0, r4, r6
        format += ulIdx;

        //
        // See if the next character is a %.
        //
        if(*format == '%')
c0d053f4:	5da9      	ldrb	r1, [r5, r6]
        format += ulIdx;
c0d053f6:	19ad      	adds	r5, r5, r6
        if(*format == '%')
c0d053f8:	2925      	cmp	r1, #37	; 0x25
c0d053fa:	d000      	beq.n	c0d053fe <snprintf+0x6e>
c0d053fc:	e189      	b.n	c0d05712 <snprintf+0x382>
c0d053fe:	9004      	str	r0, [sp, #16]
        {
            //
            // Skip the %.
            //
            format++;
c0d05400:	1c6b      	adds	r3, r5, #1
c0d05402:	2000      	movs	r0, #0
c0d05404:	2120      	movs	r1, #32
c0d05406:	9105      	str	r1, [sp, #20]
c0d05408:	210a      	movs	r1, #10
c0d0540a:	9108      	str	r1, [sp, #32]
c0d0540c:	4607      	mov	r7, r0
c0d0540e:	9003      	str	r0, [sp, #12]
c0d05410:	4604      	mov	r4, r0
c0d05412:	e005      	b.n	c0d05420 <snprintf+0x90>
c0d05414:	2402      	movs	r4, #2
c0d05416:	462b      	mov	r3, r5
c0d05418:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d0541a:	1d0a      	adds	r2, r1, #4
c0d0541c:	9209      	str	r2, [sp, #36]	; 0x24
c0d0541e:	680f      	ldr	r7, [r1, #0]
c0d05420:	461d      	mov	r5, r3
c0d05422:	4622      	mov	r2, r4
again:

            //
            // Determine how to handle the next character.
            //
            switch(*format++)
c0d05424:	7829      	ldrb	r1, [r5, #0]
c0d05426:	1c6d      	adds	r5, r5, #1
c0d05428:	2400      	movs	r4, #0
c0d0542a:	292d      	cmp	r1, #45	; 0x2d
c0d0542c:	d0f9      	beq.n	c0d05422 <snprintf+0x92>
c0d0542e:	2947      	cmp	r1, #71	; 0x47
c0d05430:	dc15      	bgt.n	c0d0545e <snprintf+0xce>
c0d05432:	292f      	cmp	r1, #47	; 0x2f
c0d05434:	dd23      	ble.n	c0d0547e <snprintf+0xee>
c0d05436:	460b      	mov	r3, r1
c0d05438:	3b30      	subs	r3, #48	; 0x30
c0d0543a:	2b0a      	cmp	r3, #10
c0d0543c:	d300      	bcc.n	c0d05440 <snprintf+0xb0>
c0d0543e:	e104      	b.n	c0d0564a <snprintf+0x2ba>
                {
                    //
                    // If this is a zero, and it is the first digit, then the
                    // fill character is a zero instead of a space.
                    //
                    if((format[-1] == '0') && (ulCount == 0))
c0d05440:	2930      	cmp	r1, #48	; 0x30
c0d05442:	9c05      	ldr	r4, [sp, #20]
c0d05444:	d100      	bne.n	c0d05448 <snprintf+0xb8>
c0d05446:	460c      	mov	r4, r1
c0d05448:	2800      	cmp	r0, #0
c0d0544a:	d000      	beq.n	c0d0544e <snprintf+0xbe>
c0d0544c:	9c05      	ldr	r4, [sp, #20]
c0d0544e:	230a      	movs	r3, #10
                    }

                    //
                    // Update the digit count.
                    //
                    ulCount *= 10;
c0d05450:	4343      	muls	r3, r0
                    ulCount += format[-1] - '0';
c0d05452:	1858      	adds	r0, r3, r1
c0d05454:	3830      	subs	r0, #48	; 0x30
c0d05456:	462b      	mov	r3, r5
c0d05458:	9405      	str	r4, [sp, #20]
c0d0545a:	4614      	mov	r4, r2
c0d0545c:	e7e0      	b.n	c0d05420 <snprintf+0x90>
            switch(*format++)
c0d0545e:	2967      	cmp	r1, #103	; 0x67
c0d05460:	dc06      	bgt.n	c0d05470 <snprintf+0xe0>
c0d05462:	2962      	cmp	r1, #98	; 0x62
c0d05464:	dc37      	bgt.n	c0d054d6 <snprintf+0x146>
c0d05466:	2948      	cmp	r1, #72	; 0x48
c0d05468:	d146      	bne.n	c0d054f8 <snprintf+0x168>
c0d0546a:	2101      	movs	r1, #1
c0d0546c:	9103      	str	r1, [sp, #12]
c0d0546e:	e003      	b.n	c0d05478 <snprintf+0xe8>
c0d05470:	2972      	cmp	r1, #114	; 0x72
c0d05472:	dc1a      	bgt.n	c0d054aa <snprintf+0x11a>
c0d05474:	2968      	cmp	r1, #104	; 0x68
c0d05476:	d145      	bne.n	c0d05504 <snprintf+0x174>
c0d05478:	2110      	movs	r1, #16
c0d0547a:	9108      	str	r1, [sp, #32]
c0d0547c:	e017      	b.n	c0d054ae <snprintf+0x11e>
c0d0547e:	2925      	cmp	r1, #37	; 0x25
c0d05480:	d100      	bne.n	c0d05484 <snprintf+0xf4>
c0d05482:	e0cd      	b.n	c0d05620 <snprintf+0x290>
c0d05484:	292a      	cmp	r1, #42	; 0x2a
c0d05486:	d022      	beq.n	c0d054ce <snprintf+0x13e>
c0d05488:	292e      	cmp	r1, #46	; 0x2e
c0d0548a:	d000      	beq.n	c0d0548e <snprintf+0xfe>
c0d0548c:	e0dd      	b.n	c0d0564a <snprintf+0x2ba>
                // special %.*H or %.*h format to print a given length of hex digits (case: H UPPER, h lower)
                //
                case '.':
                {
                  // ensure next char is '*' and next one is 's'/'h'/'H'
                  if (format[0] == '*' && (format[1] == 's' || format[1] == 'H' || format[1] == 'h')) {
c0d0548e:	7829      	ldrb	r1, [r5, #0]
c0d05490:	292a      	cmp	r1, #42	; 0x2a
c0d05492:	d000      	beq.n	c0d05496 <snprintf+0x106>
c0d05494:	e13c      	b.n	c0d05710 <snprintf+0x380>
c0d05496:	7869      	ldrb	r1, [r5, #1]
c0d05498:	1c6b      	adds	r3, r5, #1
c0d0549a:	2401      	movs	r4, #1
c0d0549c:	2948      	cmp	r1, #72	; 0x48
c0d0549e:	d0bb      	beq.n	c0d05418 <snprintf+0x88>
c0d054a0:	2968      	cmp	r1, #104	; 0x68
c0d054a2:	d0b9      	beq.n	c0d05418 <snprintf+0x88>
c0d054a4:	2973      	cmp	r1, #115	; 0x73
c0d054a6:	d0b7      	beq.n	c0d05418 <snprintf+0x88>
c0d054a8:	e131      	b.n	c0d0570e <snprintf+0x37e>
            switch(*format++)
c0d054aa:	2973      	cmp	r1, #115	; 0x73
c0d054ac:	d12d      	bne.n	c0d0550a <snprintf+0x17a>
                case_s:
                {
                    //
                    // Get the string pointer from the varargs.
                    //
                    pcStr = va_arg(vaArgP, char *);
c0d054ae:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d054b0:	1d0b      	adds	r3, r1, #4
c0d054b2:	9309      	str	r3, [sp, #36]	; 0x24

                    //
                    // Determine the length of the string. (if not specified using .*)
                    //
                    switch(cStrlenSet) {
c0d054b4:	b2d3      	uxtb	r3, r2
                    pcStr = va_arg(vaArgP, char *);
c0d054b6:	6809      	ldr	r1, [r1, #0]
                    switch(cStrlenSet) {
c0d054b8:	2b01      	cmp	r3, #1
c0d054ba:	d100      	bne.n	c0d054be <snprintf+0x12e>
c0d054bc:	e0be      	b.n	c0d0563c <snprintf+0x2ac>
c0d054be:	2b02      	cmp	r3, #2
c0d054c0:	d100      	bne.n	c0d054c4 <snprintf+0x134>
c0d054c2:	e0be      	b.n	c0d05642 <snprintf+0x2b2>
c0d054c4:	2b03      	cmp	r3, #3
c0d054c6:	462b      	mov	r3, r5
c0d054c8:	4614      	mov	r4, r2
c0d054ca:	d0a9      	beq.n	c0d05420 <snprintf+0x90>
c0d054cc:	e0c1      	b.n	c0d05652 <snprintf+0x2c2>
                  if (*format == 's' ) {                    
c0d054ce:	7829      	ldrb	r1, [r5, #0]
c0d054d0:	2973      	cmp	r1, #115	; 0x73
c0d054d2:	d09f      	beq.n	c0d05414 <snprintf+0x84>
c0d054d4:	e11c      	b.n	c0d05710 <snprintf+0x380>
            switch(*format++)
c0d054d6:	2963      	cmp	r1, #99	; 0x63
c0d054d8:	d100      	bne.n	c0d054dc <snprintf+0x14c>
c0d054da:	e0a3      	b.n	c0d05624 <snprintf+0x294>
c0d054dc:	2964      	cmp	r1, #100	; 0x64
c0d054de:	d000      	beq.n	c0d054e2 <snprintf+0x152>
c0d054e0:	e0b3      	b.n	c0d0564a <snprintf+0x2ba>
c0d054e2:	9007      	str	r0, [sp, #28]
                    ulValue = va_arg(vaArgP, unsigned long);
c0d054e4:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d054e6:	1d01      	adds	r1, r0, #4
c0d054e8:	9109      	str	r1, [sp, #36]	; 0x24
c0d054ea:	6800      	ldr	r0, [r0, #0]
c0d054ec:	17c1      	asrs	r1, r0, #31
c0d054ee:	1847      	adds	r7, r0, r1
c0d054f0:	404f      	eors	r7, r1
                    if((long)ulValue < 0)
c0d054f2:	0fc1      	lsrs	r1, r0, #31
c0d054f4:	200a      	movs	r0, #10
c0d054f6:	e012      	b.n	c0d0551e <snprintf+0x18e>
            switch(*format++)
c0d054f8:	2958      	cmp	r1, #88	; 0x58
c0d054fa:	d000      	beq.n	c0d054fe <snprintf+0x16e>
c0d054fc:	e0a5      	b.n	c0d0564a <snprintf+0x2ba>
c0d054fe:	2101      	movs	r1, #1
c0d05500:	9103      	str	r1, [sp, #12]
c0d05502:	e005      	b.n	c0d05510 <snprintf+0x180>
c0d05504:	2970      	cmp	r1, #112	; 0x70
c0d05506:	d003      	beq.n	c0d05510 <snprintf+0x180>
c0d05508:	e09f      	b.n	c0d0564a <snprintf+0x2ba>
c0d0550a:	2978      	cmp	r1, #120	; 0x78
c0d0550c:	d000      	beq.n	c0d05510 <snprintf+0x180>
c0d0550e:	e09c      	b.n	c0d0564a <snprintf+0x2ba>
c0d05510:	9007      	str	r0, [sp, #28]
                case 'p':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);
c0d05512:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d05514:	1d01      	adds	r1, r0, #4
c0d05516:	9109      	str	r1, [sp, #36]	; 0x24
c0d05518:	6807      	ldr	r7, [r0, #0]
c0d0551a:	2100      	movs	r1, #0
c0d0551c:	2010      	movs	r0, #16
                    // Determine the number of digits in the string version of
                    // the value.
                    //
convert:
                    for(ulIdx = 1;
                        (((ulIdx * ulBase) <= ulValue) &&
c0d0551e:	42b8      	cmp	r0, r7
c0d05520:	9708      	str	r7, [sp, #32]
c0d05522:	9102      	str	r1, [sp, #8]
c0d05524:	d902      	bls.n	c0d0552c <snprintf+0x19c>
c0d05526:	2401      	movs	r4, #1
c0d05528:	4607      	mov	r7, r0
c0d0552a:	e012      	b.n	c0d05552 <snprintf+0x1c2>
c0d0552c:	2601      	movs	r6, #1
c0d0552e:	4607      	mov	r7, r0
c0d05530:	4604      	mov	r4, r0
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
c0d05532:	4639      	mov	r1, r7
c0d05534:	f004 fff6 	bl	c0d0a524 <__udivsi3>
                    for(ulIdx = 1;
c0d05538:	42b0      	cmp	r0, r6
c0d0553a:	d109      	bne.n	c0d05550 <snprintf+0x1c0>
                        (((ulIdx * ulBase) <= ulValue) &&
c0d0553c:	4638      	mov	r0, r7
c0d0553e:	4360      	muls	r0, r4
                        ulIdx *= ulBase, ulCount--)
c0d05540:	9907      	ldr	r1, [sp, #28]
c0d05542:	1e49      	subs	r1, r1, #1
                        (((ulIdx * ulBase) <= ulValue) &&
c0d05544:	9107      	str	r1, [sp, #28]
c0d05546:	9908      	ldr	r1, [sp, #32]
c0d05548:	4288      	cmp	r0, r1
c0d0554a:	4626      	mov	r6, r4
c0d0554c:	d9f0      	bls.n	c0d05530 <snprintf+0x1a0>
c0d0554e:	e000      	b.n	c0d05552 <snprintf+0x1c2>
c0d05550:	4634      	mov	r4, r6
c0d05552:	9701      	str	r7, [sp, #4]
c0d05554:	9a02      	ldr	r2, [sp, #8]

                    //
                    // If the value is negative, reduce the count of padding
                    // characters needed.
                    //
                    if(ulNeg)
c0d05556:	2a00      	cmp	r2, #0
c0d05558:	d101      	bne.n	c0d0555e <snprintf+0x1ce>
c0d0555a:	9907      	ldr	r1, [sp, #28]
c0d0555c:	e001      	b.n	c0d05562 <snprintf+0x1d2>
c0d0555e:	9807      	ldr	r0, [sp, #28]
c0d05560:	1e41      	subs	r1, r0, #1
c0d05562:	2300      	movs	r3, #0
c0d05564:	2a00      	cmp	r2, #0
c0d05566:	d101      	bne.n	c0d0556c <snprintf+0x1dc>
c0d05568:	4617      	mov	r7, r2
c0d0556a:	e000      	b.n	c0d0556e <snprintf+0x1de>
c0d0556c:	43df      	mvns	r7, r3

                    //
                    // If the value is negative and the value is padded with
                    // zeros, then place the minus sign before the padding.
                    //
                    if(ulNeg && (cFill == '0'))
c0d0556e:	2a00      	cmp	r2, #0
c0d05570:	d008      	beq.n	c0d05584 <snprintf+0x1f4>
c0d05572:	9805      	ldr	r0, [sp, #20]
c0d05574:	b2c0      	uxtb	r0, r0
c0d05576:	2830      	cmp	r0, #48	; 0x30
c0d05578:	d106      	bne.n	c0d05588 <snprintf+0x1f8>
c0d0557a:	a80a      	add	r0, sp, #40	; 0x28
c0d0557c:	222d      	movs	r2, #45	; 0x2d
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
c0d0557e:	7002      	strb	r2, [r0, #0]
c0d05580:	2601      	movs	r6, #1
c0d05582:	e003      	b.n	c0d0558c <snprintf+0x1fc>
c0d05584:	461e      	mov	r6, r3
c0d05586:	e001      	b.n	c0d0558c <snprintf+0x1fc>
c0d05588:	461e      	mov	r6, r3
c0d0558a:	4613      	mov	r3, r2

                    //
                    // Provide additional padding at the beginning of the
                    // string conversion if needed.
                    //
                    if((ulCount > 1) && (ulCount < 16))
c0d0558c:	1e88      	subs	r0, r1, #2
c0d0558e:	280d      	cmp	r0, #13
c0d05590:	d812      	bhi.n	c0d055b8 <snprintf+0x228>
c0d05592:	a80a      	add	r0, sp, #40	; 0x28
                    {
                        for(ulCount--; ulCount; ulCount--)
                        {
                            pcBuf[ulPos++] = cFill;
c0d05594:	1980      	adds	r0, r0, r6
c0d05596:	1e49      	subs	r1, r1, #1
c0d05598:	9a05      	ldr	r2, [sp, #20]
c0d0559a:	b2d2      	uxtb	r2, r2
c0d0559c:	9705      	str	r7, [sp, #20]
c0d0559e:	461f      	mov	r7, r3
c0d055a0:	f005 f872 	bl	c0d0a688 <__aeabi_memset>
c0d055a4:	463b      	mov	r3, r7
c0d055a6:	2001      	movs	r0, #1
c0d055a8:	9907      	ldr	r1, [sp, #28]
c0d055aa:	1a40      	subs	r0, r0, r1
c0d055ac:	9905      	ldr	r1, [sp, #20]
c0d055ae:	1a40      	subs	r0, r0, r1
                        for(ulCount--; ulCount; ulCount--)
c0d055b0:	1c40      	adds	r0, r0, #1
                            pcBuf[ulPos++] = cFill;
c0d055b2:	1c76      	adds	r6, r6, #1
                        for(ulCount--; ulCount; ulCount--)
c0d055b4:	2800      	cmp	r0, #0
c0d055b6:	d1fb      	bne.n	c0d055b0 <snprintf+0x220>

                    //
                    // If the value is negative, then place the minus sign
                    // before the number.
                    //
                    if(ulNeg)
c0d055b8:	2b00      	cmp	r3, #0
c0d055ba:	d003      	beq.n	c0d055c4 <snprintf+0x234>
c0d055bc:	a80a      	add	r0, sp, #40	; 0x28
c0d055be:	212d      	movs	r1, #45	; 0x2d
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
c0d055c0:	5581      	strb	r1, [r0, r6]
c0d055c2:	1c76      	adds	r6, r6, #1
                    }

                    //
                    // Convert the value into a string.
                    //
                    for(; ulIdx; ulIdx /= ulBase)
c0d055c4:	2c00      	cmp	r4, #0
c0d055c6:	d01c      	beq.n	c0d05602 <snprintf+0x272>
c0d055c8:	9803      	ldr	r0, [sp, #12]
c0d055ca:	2800      	cmp	r0, #0
c0d055cc:	d002      	beq.n	c0d055d4 <snprintf+0x244>
c0d055ce:	4859      	ldr	r0, [pc, #356]	; (c0d05734 <snprintf+0x3a4>)
c0d055d0:	4478      	add	r0, pc
c0d055d2:	e001      	b.n	c0d055d8 <snprintf+0x248>
c0d055d4:	4856      	ldr	r0, [pc, #344]	; (c0d05730 <snprintf+0x3a0>)
c0d055d6:	4478      	add	r0, pc
c0d055d8:	9007      	str	r0, [sp, #28]
c0d055da:	9f01      	ldr	r7, [sp, #4]
c0d055dc:	9808      	ldr	r0, [sp, #32]
c0d055de:	4621      	mov	r1, r4
c0d055e0:	f004 ffa0 	bl	c0d0a524 <__udivsi3>
c0d055e4:	4639      	mov	r1, r7
c0d055e6:	f005 f823 	bl	c0d0a630 <__aeabi_uidivmod>
c0d055ea:	9807      	ldr	r0, [sp, #28]
c0d055ec:	5c40      	ldrb	r0, [r0, r1]
c0d055ee:	a90a      	add	r1, sp, #40	; 0x28
                    {
                        if (!ulCap) {
                          pcBuf[ulPos++] = g_pcHex[(ulValue / ulIdx) % ulBase];
c0d055f0:	5588      	strb	r0, [r1, r6]
                    for(; ulIdx; ulIdx /= ulBase)
c0d055f2:	4620      	mov	r0, r4
c0d055f4:	4639      	mov	r1, r7
c0d055f6:	f004 ff95 	bl	c0d0a524 <__udivsi3>
c0d055fa:	1c76      	adds	r6, r6, #1
c0d055fc:	42a7      	cmp	r7, r4
c0d055fe:	4604      	mov	r4, r0
c0d05600:	d9ec      	bls.n	c0d055dc <snprintf+0x24c>
c0d05602:	9f06      	ldr	r7, [sp, #24]
                    }

                    //
                    // Write the string.
                    //
                    ulPos = MIN(ulPos, str_size);
c0d05604:	42be      	cmp	r6, r7
c0d05606:	d300      	bcc.n	c0d0560a <snprintf+0x27a>
c0d05608:	463e      	mov	r6, r7
c0d0560a:	a90a      	add	r1, sp, #40	; 0x28
c0d0560c:	9c04      	ldr	r4, [sp, #16]
                    memmove(str, pcBuf, ulPos);
c0d0560e:	4620      	mov	r0, r4
c0d05610:	4632      	mov	r2, r6
c0d05612:	f005 f835 	bl	c0d0a680 <__aeabi_memmove>
                    str+= ulPos;
                    str_size -= ulPos;
c0d05616:	1bbf      	subs	r7, r7, r6
                    if (str_size == 0) {
c0d05618:	d07f      	beq.n	c0d0571a <snprintf+0x38a>
c0d0561a:	4620      	mov	r0, r4
c0d0561c:	19a0      	adds	r0, r4, r6
c0d0561e:	e016      	b.n	c0d0564e <snprintf+0x2be>
c0d05620:	2125      	movs	r1, #37	; 0x25
c0d05622:	e003      	b.n	c0d0562c <snprintf+0x29c>
                    ulValue = va_arg(vaArgP, unsigned long);
c0d05624:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d05626:	1d01      	adds	r1, r0, #4
c0d05628:	9109      	str	r1, [sp, #36]	; 0x24
c0d0562a:	6801      	ldr	r1, [r0, #0]
c0d0562c:	9804      	ldr	r0, [sp, #16]
c0d0562e:	7001      	strb	r1, [r0, #0]
c0d05630:	9906      	ldr	r1, [sp, #24]
c0d05632:	1e49      	subs	r1, r1, #1
c0d05634:	9106      	str	r1, [sp, #24]
c0d05636:	d070      	beq.n	c0d0571a <snprintf+0x38a>
c0d05638:	1c40      	adds	r0, r0, #1
c0d0563a:	e007      	b.n	c0d0564c <snprintf+0x2bc>
c0d0563c:	9007      	str	r0, [sp, #28]
c0d0563e:	463e      	mov	r6, r7
c0d05640:	e00e      	b.n	c0d05660 <snprintf+0x2d0>
c0d05642:	9007      	str	r0, [sp, #28]
                        if (pcStr[0] == '\0') {
c0d05644:	7808      	ldrb	r0, [r1, #0]
c0d05646:	2800      	cmp	r0, #0
c0d05648:	d042      	beq.n	c0d056d0 <snprintf+0x340>
c0d0564a:	9804      	ldr	r0, [sp, #16]
c0d0564c:	9f06      	ldr	r7, [sp, #24]
    while(*format)
c0d0564e:	7829      	ldrb	r1, [r5, #0]
c0d05650:	e060      	b.n	c0d05714 <snprintf+0x384>
c0d05652:	9007      	str	r0, [sp, #28]
c0d05654:	2200      	movs	r2, #0
                        for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
c0d05656:	5c8b      	ldrb	r3, [r1, r2]
c0d05658:	1c52      	adds	r2, r2, #1
c0d0565a:	2b00      	cmp	r3, #0
c0d0565c:	d1fb      	bne.n	c0d05656 <snprintf+0x2c6>
                    switch(ulBase) {
c0d0565e:	1e56      	subs	r6, r2, #1
c0d05660:	9804      	ldr	r0, [sp, #16]
c0d05662:	9f06      	ldr	r7, [sp, #24]
c0d05664:	9a08      	ldr	r2, [sp, #32]
c0d05666:	2a10      	cmp	r2, #16
c0d05668:	d127      	bne.n	c0d056ba <snprintf+0x32a>
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d0566a:	2e00      	cmp	r6, #0
c0d0566c:	d0ef      	beq.n	c0d0564e <snprintf+0x2be>
c0d0566e:	2200      	movs	r2, #0
                          nibble1 = (pcStr[ulCount]>>4)&0xF;
c0d05670:	9207      	str	r2, [sp, #28]
                          if (str_size < 2) {
c0d05672:	2f02      	cmp	r7, #2
c0d05674:	d351      	bcc.n	c0d0571a <snprintf+0x38a>
c0d05676:	463c      	mov	r4, r7
c0d05678:	9a07      	ldr	r2, [sp, #28]
c0d0567a:	5c8a      	ldrb	r2, [r1, r2]
c0d0567c:	9b03      	ldr	r3, [sp, #12]
                          switch(ulCap) {
c0d0567e:	2b00      	cmp	r3, #0
c0d05680:	d005      	beq.n	c0d0568e <snprintf+0x2fe>
c0d05682:	2b01      	cmp	r3, #1
c0d05684:	d10e      	bne.n	c0d056a4 <snprintf+0x314>
c0d05686:	4607      	mov	r7, r0
c0d05688:	4828      	ldr	r0, [pc, #160]	; (c0d0572c <snprintf+0x39c>)
c0d0568a:	4478      	add	r0, pc
c0d0568c:	e002      	b.n	c0d05694 <snprintf+0x304>
c0d0568e:	4607      	mov	r7, r0
c0d05690:	4825      	ldr	r0, [pc, #148]	; (c0d05728 <snprintf+0x398>)
c0d05692:	4478      	add	r0, pc
c0d05694:	230f      	movs	r3, #15
c0d05696:	4013      	ands	r3, r2
c0d05698:	0912      	lsrs	r2, r2, #4
c0d0569a:	5cc3      	ldrb	r3, [r0, r3]
c0d0569c:	707b      	strb	r3, [r7, #1]
c0d0569e:	5c82      	ldrb	r2, [r0, r2]
c0d056a0:	4638      	mov	r0, r7
c0d056a2:	703a      	strb	r2, [r7, #0]
                          if (str_size == 0) {
c0d056a4:	2c02      	cmp	r4, #2
c0d056a6:	d038      	beq.n	c0d0571a <snprintf+0x38a>
c0d056a8:	4627      	mov	r7, r4
c0d056aa:	1ea7      	subs	r7, r4, #2
c0d056ac:	9a07      	ldr	r2, [sp, #28]
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d056ae:	1c52      	adds	r2, r2, #1
                          str+= 2;
c0d056b0:	1c80      	adds	r0, r0, #2
c0d056b2:	9207      	str	r2, [sp, #28]
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d056b4:	42b2      	cmp	r2, r6
c0d056b6:	d3dc      	bcc.n	c0d05672 <snprintf+0x2e2>
c0d056b8:	e018      	b.n	c0d056ec <snprintf+0x35c>
                        ulIdx = MIN(ulIdx, str_size);
c0d056ba:	42be      	cmp	r6, r7
c0d056bc:	d300      	bcc.n	c0d056c0 <snprintf+0x330>
c0d056be:	463e      	mov	r6, r7
                        memmove(str, pcStr, ulIdx);
c0d056c0:	4632      	mov	r2, r6
c0d056c2:	f004 ffdd 	bl	c0d0a680 <__aeabi_memmove>
c0d056c6:	9804      	ldr	r0, [sp, #16]
                        str_size -= ulIdx;
c0d056c8:	1bbf      	subs	r7, r7, r6
                        if (str_size == 0) {
c0d056ca:	d026      	beq.n	c0d0571a <snprintf+0x38a>
c0d056cc:	1980      	adds	r0, r0, r6
c0d056ce:	e00d      	b.n	c0d056ec <snprintf+0x35c>
c0d056d0:	9c06      	ldr	r4, [sp, #24]
                          ulStrlen = MIN(ulStrlen, str_size);
c0d056d2:	42a7      	cmp	r7, r4
c0d056d4:	d300      	bcc.n	c0d056d8 <snprintf+0x348>
c0d056d6:	4627      	mov	r7, r4
c0d056d8:	2220      	movs	r2, #32
                          memset(str, ' ', ulStrlen);
c0d056da:	9804      	ldr	r0, [sp, #16]
c0d056dc:	4639      	mov	r1, r7
c0d056de:	f004 ffd3 	bl	c0d0a688 <__aeabi_memset>
c0d056e2:	9804      	ldr	r0, [sp, #16]
                          str_size -= ulStrlen;
c0d056e4:	1be4      	subs	r4, r4, r7
                          if (str_size == 0) {
c0d056e6:	d018      	beq.n	c0d0571a <snprintf+0x38a>
c0d056e8:	19c0      	adds	r0, r0, r7
c0d056ea:	4627      	mov	r7, r4
c0d056ec:	9907      	ldr	r1, [sp, #28]
                    if(ulCount > ulIdx)
c0d056ee:	42b1      	cmp	r1, r6
c0d056f0:	d9ad      	bls.n	c0d0564e <snprintf+0x2be>
                        ulCount -= ulIdx;
c0d056f2:	1b8c      	subs	r4, r1, r6
                        ulCount = MIN(ulCount, str_size);
c0d056f4:	42bc      	cmp	r4, r7
c0d056f6:	d300      	bcc.n	c0d056fa <snprintf+0x36a>
c0d056f8:	463c      	mov	r4, r7
c0d056fa:	2220      	movs	r2, #32
c0d056fc:	4606      	mov	r6, r0
                        memset(str, ' ', ulCount);
c0d056fe:	4621      	mov	r1, r4
c0d05700:	f004 ffc2 	bl	c0d0a688 <__aeabi_memset>
                        str_size -= ulCount;
c0d05704:	1b3f      	subs	r7, r7, r4
                        if (str_size == 0) {
c0d05706:	d008      	beq.n	c0d0571a <snprintf+0x38a>
c0d05708:	4630      	mov	r0, r6
c0d0570a:	1930      	adds	r0, r6, r4
c0d0570c:	e79f      	b.n	c0d0564e <snprintf+0x2be>
c0d0570e:	212a      	movs	r1, #42	; 0x2a
c0d05710:	9804      	ldr	r0, [sp, #16]
c0d05712:	9f06      	ldr	r7, [sp, #24]
    while(*format)
c0d05714:	2900      	cmp	r1, #0
c0d05716:	d000      	beq.n	c0d0571a <snprintf+0x38a>
c0d05718:	e654      	b.n	c0d053c4 <snprintf+0x34>
c0d0571a:	2000      	movs	r0, #0
    // End the varargs processing.
    //
    va_end(vaArgP);

    return 0;
}
c0d0571c:	b00e      	add	sp, #56	; 0x38
c0d0571e:	bcf0      	pop	{r4, r5, r6, r7}
c0d05720:	bc02      	pop	{r1}
c0d05722:	b001      	add	sp, #4
c0d05724:	4708      	bx	r1
c0d05726:	46c0      	nop			; (mov r8, r8)
c0d05728:	000067f5 	.word	0x000067f5
c0d0572c:	0000680d 	.word	0x0000680d
c0d05730:	000068b1 	.word	0x000068b1
c0d05734:	000068c7 	.word	0x000068c7

c0d05738 <pic>:

// only apply PIC conversion if link_address is in linked code (over 0xC0D00000 in our example)
// this way, PIC call are armless if the address is not meant to be converted
extern unsigned int _nvram;
extern unsigned int _envram;
unsigned int pic(unsigned int link_address) {
c0d05738:	b580      	push	{r7, lr}
//  screen_printf(" %08X", link_address);
	if (link_address >= ((unsigned int)&_nvram) && link_address < ((unsigned int)&_envram)) {
c0d0573a:	4904      	ldr	r1, [pc, #16]	; (c0d0574c <pic+0x14>)
c0d0573c:	4288      	cmp	r0, r1
c0d0573e:	d304      	bcc.n	c0d0574a <pic+0x12>
c0d05740:	4903      	ldr	r1, [pc, #12]	; (c0d05750 <pic+0x18>)
c0d05742:	4288      	cmp	r0, r1
c0d05744:	d201      	bcs.n	c0d0574a <pic+0x12>
		link_address = pic_internal(link_address);
c0d05746:	f000 f805 	bl	c0d05754 <pic_internal>
//    screen_printf(" -> %08X\n", link_address);
  }
	return link_address;
c0d0574a:	bd80      	pop	{r7, pc}
c0d0574c:	c0d00000 	.word	0xc0d00000
c0d05750:	c0d0d800 	.word	0xc0d0d800

c0d05754 <pic_internal>:

unsigned int pic_internal(unsigned int link_address) __attribute__((naked));
unsigned int pic_internal(unsigned int link_address) 
{
  // compute the delta offset between LinkMemAddr & ExecMemAddr
  __asm volatile ("mov r2, pc\n");          // r2 = 0x109004
c0d05754:	467a      	mov	r2, pc
  __asm volatile ("ldr r1, =pic_internal\n");        // r1 = 0xC0D00001
c0d05756:	4902      	ldr	r1, [pc, #8]	; (c0d05760 <pic_internal+0xc>)
  __asm volatile ("adds r1, r1, #3\n");     // r1 = 0xC0D00004
c0d05758:	1cc9      	adds	r1, r1, #3
  __asm volatile ("subs r1, r1, r2\n");     // r1 = 0xC0BF7000 (delta between load and exec address)
c0d0575a:	1a89      	subs	r1, r1, r2

  // adjust value of the given parameter
  __asm volatile ("subs r0, r0, r1\n");     // r0 = 0xC0D0C244 => r0 = 0x115244
c0d0575c:	1a40      	subs	r0, r0, r1
  __asm volatile ("bx lr\n");
c0d0575e:	4770      	bx	lr
c0d05760:	c0d05755 	.word	0xc0d05755

c0d05764 <poorstream_init>:
#ifdef HAVE_STARKWARE

#include "poorstream.h"

void poorstream_init(poorstream_t *stream, uint8_t *buffer) {
c0d05764:	b5b0      	push	{r4, r5, r7, lr}
c0d05766:	460c      	mov	r4, r1
c0d05768:	4605      	mov	r5, r0
c0d0576a:	1d00      	adds	r0, r0, #4
c0d0576c:	2114      	movs	r1, #20
    memset((void *) stream, 0, sizeof(poorstream_t));
c0d0576e:	f004 ff7d 	bl	c0d0a66c <__aeabi_memclr>
    stream->pointer = buffer;
c0d05772:	602c      	str	r4, [r5, #0]
}
c0d05774:	bdb0      	pop	{r4, r5, r7, pc}

c0d05776 <poorstream_flush>:

void poorstream_flush(poorstream_t *stream) {
    // PRINTF("Flush\n");
    *(stream->pointer + 0) = (stream->accumulator >> 56);
c0d05776:	6801      	ldr	r1, [r0, #0]
c0d05778:	7dc2      	ldrb	r2, [r0, #23]
c0d0577a:	700a      	strb	r2, [r1, #0]
    *(stream->pointer + 1) = (stream->accumulator >> 48);
c0d0577c:	6801      	ldr	r1, [r0, #0]
c0d0577e:	7d82      	ldrb	r2, [r0, #22]
c0d05780:	704a      	strb	r2, [r1, #1]
    *(stream->pointer + 2) = (stream->accumulator >> 40);
c0d05782:	6801      	ldr	r1, [r0, #0]
c0d05784:	7d42      	ldrb	r2, [r0, #21]
c0d05786:	708a      	strb	r2, [r1, #2]
    *(stream->pointer + 3) = (stream->accumulator >> 32);
c0d05788:	6801      	ldr	r1, [r0, #0]
c0d0578a:	7d02      	ldrb	r2, [r0, #20]
c0d0578c:	70ca      	strb	r2, [r1, #3]
    *(stream->pointer + 4) = (stream->accumulator >> 24);
c0d0578e:	6801      	ldr	r1, [r0, #0]
c0d05790:	7cc2      	ldrb	r2, [r0, #19]
c0d05792:	710a      	strb	r2, [r1, #4]
    *(stream->pointer + 5) = (stream->accumulator >> 16);
c0d05794:	6801      	ldr	r1, [r0, #0]
c0d05796:	7c82      	ldrb	r2, [r0, #18]
c0d05798:	714a      	strb	r2, [r1, #5]
    *(stream->pointer + 6) = (stream->accumulator >> 8);
c0d0579a:	6801      	ldr	r1, [r0, #0]
c0d0579c:	7c42      	ldrb	r2, [r0, #17]
c0d0579e:	718a      	strb	r2, [r1, #6]
    *(stream->pointer + 7) = (stream->accumulator >> 0);
c0d057a0:	6801      	ldr	r1, [r0, #0]
c0d057a2:	7c00      	ldrb	r0, [r0, #16]
c0d057a4:	71c8      	strb	r0, [r1, #7]
}
c0d057a6:	4770      	bx	lr

c0d057a8 <poorstream_write_bits>:

void poorstream_write_bits(poorstream_t *stream, uint64_t bits, uint32_t num_bits) {
c0d057a8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d057aa:	b087      	sub	sp, #28
c0d057ac:	4614      	mov	r4, r2
c0d057ae:	4606      	mov	r6, r0
    stream->offset += num_bits;
c0d057b0:	6841      	ldr	r1, [r0, #4]
c0d057b2:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d057b4:	180a      	adds	r2, r1, r0
c0d057b6:	6072      	str	r2, [r6, #4]
    if (stream->offset < 64) {
c0d057b8:	2a3f      	cmp	r2, #63	; 0x3f
c0d057ba:	d80c      	bhi.n	c0d057d6 <poorstream_write_bits+0x2e>
c0d057bc:	2040      	movs	r0, #64	; 0x40
        stream->accumulator |= (bits << (64 - stream->offset));
c0d057be:	1a82      	subs	r2, r0, r2
c0d057c0:	4620      	mov	r0, r4
c0d057c2:	4619      	mov	r1, r3
c0d057c4:	f004 ff46 	bl	c0d0a654 <__aeabi_llsl>
c0d057c8:	6972      	ldr	r2, [r6, #20]
c0d057ca:	430a      	orrs	r2, r1
c0d057cc:	6172      	str	r2, [r6, #20]
c0d057ce:	6931      	ldr	r1, [r6, #16]
c0d057d0:	4301      	orrs	r1, r0
c0d057d2:	6131      	str	r1, [r6, #16]
c0d057d4:	e03b      	b.n	c0d0584e <poorstream_write_bits+0xa6>
c0d057d6:	4637      	mov	r7, r6
c0d057d8:	3708      	adds	r7, #8
c0d057da:	4631      	mov	r1, r6
c0d057dc:	3110      	adds	r1, #16
c0d057de:	9105      	str	r1, [sp, #20]
        // PRINTF("ACC |= << %d\n", (64 - stream->offset));
    } else {
        stream->offset -= 64;
c0d057e0:	3a40      	subs	r2, #64	; 0x40
c0d057e2:	6072      	str	r2, [r6, #4]
        stream->mask = ((1 << (num_bits - stream->offset)) - 1);
c0d057e4:	1a80      	subs	r0, r0, r2
c0d057e6:	2100      	movs	r1, #0
c0d057e8:	9106      	str	r1, [sp, #24]
c0d057ea:	43cd      	mvns	r5, r1
c0d057ec:	9501      	str	r5, [sp, #4]
c0d057ee:	4085      	lsls	r5, r0
c0d057f0:	43e9      	mvns	r1, r5
c0d057f2:	4620      	mov	r0, r4
c0d057f4:	17cc      	asrs	r4, r1, #31
c0d057f6:	6039      	str	r1, [r7, #0]
c0d057f8:	9702      	str	r7, [sp, #8]
c0d057fa:	607c      	str	r4, [r7, #4]
c0d057fc:	9003      	str	r0, [sp, #12]
c0d057fe:	9304      	str	r3, [sp, #16]
        // PRINTF("Mask %lx\n", stream->mask);
        // PRINTF("Offset %d\n", stream->offset);
        stream->accumulator |= ((bits >> stream->offset) & stream->mask);
c0d05800:	4619      	mov	r1, r3
c0d05802:	f004 ff1b 	bl	c0d0a63c <__aeabi_llsr>
c0d05806:	4021      	ands	r1, r4
c0d05808:	9c05      	ldr	r4, [sp, #20]
c0d0580a:	6862      	ldr	r2, [r4, #4]
c0d0580c:	430a      	orrs	r2, r1
c0d0580e:	6062      	str	r2, [r4, #4]
c0d05810:	43a8      	bics	r0, r5
c0d05812:	6821      	ldr	r1, [r4, #0]
c0d05814:	4301      	orrs	r1, r0
c0d05816:	6021      	str	r1, [r4, #0]
        poorstream_flush(stream);
c0d05818:	4630      	mov	r0, r6
c0d0581a:	f7ff ffac 	bl	c0d05776 <poorstream_flush>
c0d0581e:	9806      	ldr	r0, [sp, #24]
        stream->accumulator = 0;
c0d05820:	6020      	str	r0, [r4, #0]
c0d05822:	6060      	str	r0, [r4, #4]
        stream->pointer += 8;
c0d05824:	6830      	ldr	r0, [r6, #0]
c0d05826:	3008      	adds	r0, #8
c0d05828:	6030      	str	r0, [r6, #0]
        if (stream->offset) {
c0d0582a:	6870      	ldr	r0, [r6, #4]
c0d0582c:	2800      	cmp	r0, #0
c0d0582e:	d00e      	beq.n	c0d0584e <poorstream_write_bits+0xa6>
c0d05830:	9d01      	ldr	r5, [sp, #4]
            stream->mask = ((1 << stream->offset) - 1);
c0d05832:	4085      	lsls	r5, r0
c0d05834:	43e9      	mvns	r1, r5
c0d05836:	17cb      	asrs	r3, r1, #31
c0d05838:	9a02      	ldr	r2, [sp, #8]
c0d0583a:	c20a      	stmia	r2!, {r1, r3}
c0d0583c:	2140      	movs	r1, #64	; 0x40
            stream->accumulator |= ((bits & stream->mask) << (64 - stream->offset));
c0d0583e:	1a0a      	subs	r2, r1, r0
c0d05840:	9803      	ldr	r0, [sp, #12]
c0d05842:	43a8      	bics	r0, r5
c0d05844:	9904      	ldr	r1, [sp, #16]
c0d05846:	4019      	ands	r1, r3
c0d05848:	f004 ff04 	bl	c0d0a654 <__aeabi_llsl>
c0d0584c:	c403      	stmia	r4!, {r0, r1}
        }
    }
}
c0d0584e:	b007      	add	sp, #28
c0d05850:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d05854 <starkDerivePrivateKey>:
// C_cx_secp256k1_n - (C_cx_secp256k1_n % C_cx_Stark256_n)
static unsigned char const STARK_DERIVE_BIAS[] = {
    0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7,
    0x38, 0xa1, 0x3b, 0x4b, 0x92, 0x0e, 0x94, 0x11, 0xae, 0x6d, 0xa5, 0xf4, 0x0b, 0x03, 0x58, 0xb1};

void starkDerivePrivateKey(uint32_t *bip32Path, uint32_t bip32PathLength, uint8_t *privateKeyData) {
c0d05854:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05856:	b08d      	sub	sp, #52	; 0x34
c0d05858:	4614      	mov	r4, r2
c0d0585a:	460a      	mov	r2, r1
c0d0585c:	4603      	mov	r3, r0
c0d0585e:	6801      	ldr	r1, [r0, #0]
  PRINTF("Private key after processing %.*H\n", 32, privateKeyData);
#else
    uint8_t tmp[33];
    uint8_t index = 0;
    // Sanity check
    if ((bip32PathLength < 2) || (bip32Path[0] != STARK_BIP32_PATH_0) ||
c0d05860:	2a02      	cmp	r2, #2
c0d05862:	d343      	bcc.n	c0d058ec <starkDerivePrivateKey+0x98>
c0d05864:	4826      	ldr	r0, [pc, #152]	; (c0d05900 <starkDerivePrivateKey+0xac>)
c0d05866:	4281      	cmp	r1, r0
c0d05868:	d140      	bne.n	c0d058ec <starkDerivePrivateKey+0x98>
        (bip32Path[1] != STARK_BIP32_PATH_1)) {
c0d0586a:	6859      	ldr	r1, [r3, #4]
c0d0586c:	4d25      	ldr	r5, [pc, #148]	; (c0d05904 <starkDerivePrivateKey+0xb0>)
    if ((bip32PathLength < 2) || (bip32Path[0] != STARK_BIP32_PATH_0) ||
c0d0586e:	42a9      	cmp	r1, r5
        PRINTF("Invalid Stark derivation path %d %d\n", bip32Path[0], bip32Path[1]);
c0d05870:	4601      	mov	r1, r0
    if ((bip32PathLength < 2) || (bip32Path[0] != STARK_BIP32_PATH_0) ||
c0d05872:	d13b      	bne.n	c0d058ec <starkDerivePrivateKey+0x98>
c0d05874:	2600      	movs	r6, #0
        THROW(0x6a80);
    }
    os_perso_derive_node_bip32(CX_CURVE_256K1, bip32Path, bip32PathLength, tmp, NULL);
c0d05876:	4668      	mov	r0, sp
c0d05878:	6006      	str	r6, [r0, #0]
c0d0587a:	2021      	movs	r0, #33	; 0x21
c0d0587c:	ad04      	add	r5, sp, #16
c0d0587e:	4619      	mov	r1, r3
c0d05880:	462b      	mov	r3, r5
c0d05882:	f001 f8df 	bl	c0d06a44 <os_perso_derive_node_bip32>
    PRINTF("Private key before processing %.*H\n", 32, tmp);
c0d05886:	4820      	ldr	r0, [pc, #128]	; (c0d05908 <starkDerivePrivateKey+0xb4>)
c0d05888:	4478      	add	r0, pc
c0d0588a:	2120      	movs	r1, #32
c0d0588c:	462a      	mov	r2, r5
c0d0588e:	f7ff fbd5 	bl	c0d0503c <mcu_usb_printf>
c0d05892:	3520      	adds	r5, #32
c0d05894:	9503      	str	r5, [sp, #12]
c0d05896:	481d      	ldr	r0, [pc, #116]	; (c0d0590c <starkDerivePrivateKey+0xb8>)
c0d05898:	4478      	add	r0, pc
c0d0589a:	9002      	str	r0, [sp, #8]
c0d0589c:	4f1c      	ldr	r7, [pc, #112]	; (c0d05910 <starkDerivePrivateKey+0xbc>)
c0d0589e:	447f      	add	r7, pc
    for (;;) {
        tmp[32] = index;
c0d058a0:	9803      	ldr	r0, [sp, #12]
c0d058a2:	7006      	strb	r6, [r0, #0]
c0d058a4:	a804      	add	r0, sp, #16
c0d058a6:	2121      	movs	r1, #33	; 0x21
c0d058a8:	2520      	movs	r5, #32
        cx_hash_sha256(tmp, 33, privateKeyData, 32);
c0d058aa:	4622      	mov	r2, r4
c0d058ac:	462b      	mov	r3, r5
c0d058ae:	f000 ffe3 	bl	c0d06878 <cx_hash_sha256>
        PRINTF("Key hash %.*H\n", 32, privateKeyData);
c0d058b2:	9802      	ldr	r0, [sp, #8]
c0d058b4:	4629      	mov	r1, r5
c0d058b6:	4622      	mov	r2, r4
c0d058b8:	f7ff fbc0 	bl	c0d0503c <mcu_usb_printf>
        if (cx_math_cmp(privateKeyData, STARK_DERIVE_BIAS, 32) < 0) {
c0d058bc:	4620      	mov	r0, r4
c0d058be:	4639      	mov	r1, r7
c0d058c0:	462a      	mov	r2, r5
c0d058c2:	f001 f889 	bl	c0d069d8 <cx_math_cmp>
            cx_math_modm(privateKeyData, 32, C_cx_Stark256_n, 32);
            break;
        }
        index++;
c0d058c6:	1c76      	adds	r6, r6, #1
        if (cx_math_cmp(privateKeyData, STARK_DERIVE_BIAS, 32) < 0) {
c0d058c8:	2800      	cmp	r0, #0
c0d058ca:	dae9      	bge.n	c0d058a0 <starkDerivePrivateKey+0x4c>
            cx_math_modm(privateKeyData, 32, C_cx_Stark256_n, 32);
c0d058cc:	4a11      	ldr	r2, [pc, #68]	; (c0d05914 <starkDerivePrivateKey+0xc0>)
c0d058ce:	447a      	add	r2, pc
c0d058d0:	2520      	movs	r5, #32
c0d058d2:	4620      	mov	r0, r4
c0d058d4:	4629      	mov	r1, r5
c0d058d6:	462b      	mov	r3, r5
c0d058d8:	f001 f89a 	bl	c0d06a10 <cx_math_modm>
    }
    PRINTF("Key result %.*H\n", 32, privateKeyData);
c0d058dc:	480e      	ldr	r0, [pc, #56]	; (c0d05918 <starkDerivePrivateKey+0xc4>)
c0d058de:	4478      	add	r0, pc
c0d058e0:	4629      	mov	r1, r5
c0d058e2:	4622      	mov	r2, r4
c0d058e4:	f7ff fbaa 	bl	c0d0503c <mcu_usb_printf>

#endif
}
c0d058e8:	b00d      	add	sp, #52	; 0x34
c0d058ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
        PRINTF("Invalid Stark derivation path %d %d\n", bip32Path[0], bip32Path[1]);
c0d058ec:	685a      	ldr	r2, [r3, #4]
c0d058ee:	480b      	ldr	r0, [pc, #44]	; (c0d0591c <starkDerivePrivateKey+0xc8>)
c0d058f0:	4478      	add	r0, pc
c0d058f2:	f7ff fba3 	bl	c0d0503c <mcu_usb_printf>
c0d058f6:	20d5      	movs	r0, #213	; 0xd5
c0d058f8:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0d058fa:	f7fe fd43 	bl	c0d04384 <os_longjmp>
c0d058fe:	46c0      	nop			; (mov r8, r8)
c0d05900:	80000a55 	.word	0x80000a55
c0d05904:	a2862ad3 	.word	0xa2862ad3
c0d05908:	00006644 	.word	0x00006644
c0d0590c:	00006658 	.word	0x00006658
c0d05910:	0000671b 	.word	0x0000671b
c0d05914:	0000670b 	.word	0x0000670b
c0d05918:	00006621 	.word	0x00006621
c0d0591c:	000065b7 	.word	0x000065b7

c0d05920 <stark_get_amount_string>:

void stark_get_amount_string(uint8_t *contractAddress,
                             uint8_t *quantum256,
                             uint8_t *amount64,
                             char *tmp100,
                             char *target100) {
c0d05920:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05922:	b09f      	sub	sp, #124	; 0x7c
c0d05924:	461c      	mov	r4, r3
c0d05926:	9203      	str	r2, [sp, #12]
c0d05928:	9104      	str	r1, [sp, #16]
c0d0592a:	4607      	mov	r7, r0
    uint256_t amountPre, quantum, amount;
    uint8_t decimals;
    char *ticker = (char *) PIC(chainConfig->coinName);
c0d0592c:	4834      	ldr	r0, [pc, #208]	; (c0d05a00 <stark_get_amount_string+0xe0>)
c0d0592e:	6800      	ldr	r0, [r0, #0]
c0d05930:	f7ff ff02 	bl	c0d05738 <pic>
c0d05934:	4605      	mov	r5, r0

    PRINTF("stark_get_amount_string %.*H\n", 20, contractAddress);
c0d05936:	4833      	ldr	r0, [pc, #204]	; (c0d05a04 <stark_get_amount_string+0xe4>)
c0d05938:	4478      	add	r0, pc
c0d0593a:	2114      	movs	r1, #20
c0d0593c:	463a      	mov	r2, r7
c0d0593e:	f7ff fb7d 	bl	c0d0503c <mcu_usb_printf>
c0d05942:	2000      	movs	r0, #0
c0d05944:	9e24      	ldr	r6, [sp, #144]	; 0x90
c0d05946:	9405      	str	r4, [sp, #20]
        if (buf[i]) {
c0d05948:	5c39      	ldrb	r1, [r7, r0]
c0d0594a:	2900      	cmp	r1, #0
c0d0594c:	d10a      	bne.n	c0d05964 <stark_get_amount_string+0x44>
c0d0594e:	1c40      	adds	r0, r0, #1
    for (int i = 0; i < n; ++i) {
c0d05950:	2813      	cmp	r0, #19
c0d05952:	d9f9      	bls.n	c0d05948 <stark_get_amount_string+0x28>

    if (allzeroes(contractAddress, 20)) {
        decimals = WEI_TO_ETHER;
        PRINTF("stark_get_amount_string - ETH\n");
c0d05954:	482f      	ldr	r0, [pc, #188]	; (c0d05a14 <stark_get_amount_string+0xf4>)
c0d05956:	4478      	add	r0, pc
c0d05958:	f7ff fb70 	bl	c0d0503c <mcu_usb_printf>
c0d0595c:	2012      	movs	r0, #18
c0d0595e:	9002      	str	r0, [sp, #8]
c0d05960:	9501      	str	r5, [sp, #4]
c0d05962:	e00e      	b.n	c0d05982 <stark_get_amount_string+0x62>
    } else {
        tokenDefinition_t *token = getKnownToken(contractAddress);
c0d05964:	4638      	mov	r0, r7
c0d05966:	f7fe f807 	bl	c0d03978 <getKnownToken>
        if (token == NULL) {  // caught earlier
c0d0596a:	2800      	cmp	r0, #0
c0d0596c:	d043      	beq.n	c0d059f6 <stark_get_amount_string+0xd6>
c0d0596e:	4602      	mov	r2, r0
c0d05970:	2020      	movs	r0, #32
            THROW(0x6A80);
        }
        decimals = token->decimals;
c0d05972:	5c11      	ldrb	r1, [r2, r0]
        ticker = (char *) token->ticker;
c0d05974:	3214      	adds	r2, #20
        PRINTF("stark_get_amount_string - decimals %d ticker %s\n", decimals, ticker);
c0d05976:	9201      	str	r2, [sp, #4]
c0d05978:	4823      	ldr	r0, [pc, #140]	; (c0d05a08 <stark_get_amount_string+0xe8>)
c0d0597a:	4478      	add	r0, pc
c0d0597c:	9102      	str	r1, [sp, #8]
c0d0597e:	f7ff fb5d 	bl	c0d0503c <mcu_usb_printf>
c0d05982:	2108      	movs	r1, #8
c0d05984:	af16      	add	r7, sp, #88	; 0x58
    }
    convertUint256BE(amount64, 8, &amountPre);
c0d05986:	9803      	ldr	r0, [sp, #12]
c0d05988:	463a      	mov	r2, r7
c0d0598a:	f003 ff27 	bl	c0d097dc <convertUint256BE>
c0d0598e:	ad0e      	add	r5, sp, #56	; 0x38
    readu256BE(quantum256, &quantum);
c0d05990:	9804      	ldr	r0, [sp, #16]
c0d05992:	4629      	mov	r1, r5
c0d05994:	f002 fa00 	bl	c0d07d98 <readu256BE>
c0d05998:	ac06      	add	r4, sp, #24
    mul256(&amountPre, &quantum, &amount);
c0d0599a:	4638      	mov	r0, r7
c0d0599c:	4629      	mov	r1, r5
c0d0599e:	4622      	mov	r2, r4
c0d059a0:	f002 fd1a 	bl	c0d083d8 <mul256>
c0d059a4:	210a      	movs	r1, #10
c0d059a6:	2364      	movs	r3, #100	; 0x64
    tostring256(&amount, 10, tmp100, 100);
c0d059a8:	9304      	str	r3, [sp, #16]
c0d059aa:	4620      	mov	r0, r4
c0d059ac:	9d05      	ldr	r5, [sp, #20]
c0d059ae:	462a      	mov	r2, r5
c0d059b0:	f002 feaa 	bl	c0d08708 <tostring256>
    PRINTF("stark_get_amount_string - mul256 %s\n", tmp100);
c0d059b4:	4815      	ldr	r0, [pc, #84]	; (c0d05a0c <stark_get_amount_string+0xec>)
c0d059b6:	4478      	add	r0, pc
c0d059b8:	4629      	mov	r1, r5
c0d059ba:	f7ff fb3f 	bl	c0d0503c <mcu_usb_printf>
    strcpy(target100, ticker);
c0d059be:	4630      	mov	r0, r6
c0d059c0:	9f01      	ldr	r7, [sp, #4]
c0d059c2:	4639      	mov	r1, r7
c0d059c4:	f005 f810 	bl	c0d0a9e8 <strcpy>
    adjustDecimals(tmp100, strlen(tmp100), target100 + strlen(ticker), 100, decimals);
c0d059c8:	4628      	mov	r0, r5
c0d059ca:	f005 f815 	bl	c0d0a9f8 <strlen>
c0d059ce:	4604      	mov	r4, r0
c0d059d0:	4638      	mov	r0, r7
c0d059d2:	f005 f811 	bl	c0d0a9f8 <strlen>
c0d059d6:	4669      	mov	r1, sp
c0d059d8:	9a02      	ldr	r2, [sp, #8]
c0d059da:	600a      	str	r2, [r1, #0]
c0d059dc:	1832      	adds	r2, r6, r0
c0d059de:	4628      	mov	r0, r5
c0d059e0:	4621      	mov	r1, r4
c0d059e2:	9b04      	ldr	r3, [sp, #16]
c0d059e4:	f7fc fed2 	bl	c0d0278c <adjustDecimals>
    PRINTF("get_amount_string %s\n", target100);
c0d059e8:	4809      	ldr	r0, [pc, #36]	; (c0d05a10 <stark_get_amount_string+0xf0>)
c0d059ea:	4478      	add	r0, pc
c0d059ec:	4631      	mov	r1, r6
c0d059ee:	f7ff fb25 	bl	c0d0503c <mcu_usb_printf>
}
c0d059f2:	b01f      	add	sp, #124	; 0x7c
c0d059f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d059f6:	20d5      	movs	r0, #213	; 0xd5
c0d059f8:	01c0      	lsls	r0, r0, #7
            THROW(0x6A80);
c0d059fa:	f7fe fcc3 	bl	c0d04384 <os_longjmp>
c0d059fe:	46c0      	nop			; (mov r8, r8)
c0d05a00:	20001be0 	.word	0x20001be0
c0d05a04:	000065d8 	.word	0x000065d8
c0d05a08:	000065d3 	.word	0x000065d3
c0d05a0c:	000065c8 	.word	0x000065c8
c0d05a10:	000065b9 	.word	0x000065b9
c0d05a14:	000065d8 	.word	0x000065d8

c0d05a18 <accum_ec_mul>:
        0x01, 0xb7, 0x7b, 0x3e, 0x37, 0xd1, 0x35, 0x04, 0xb3, 0x48, 0x04,
        0x62, 0x68, 0xd8, 0xae, 0x25, 0xce, 0x98, 0xad, 0x78, 0x3c, 0x25,
        0x56, 0x1a, 0x87, 0x9d, 0xcc, 0x77, 0xe9, 0x9c, 0x24, 0x26,
    }};

void accum_ec_mul(ECPoint *hash, uint8_t *buf, int len, int pedersen_idx) {
c0d05a18:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05a1a:	b093      	sub	sp, #76	; 0x4c
c0d05a1c:	4616      	mov	r6, r2
c0d05a1e:	2a01      	cmp	r2, #1
c0d05a20:	db29      	blt.n	c0d05a76 <accum_ec_mul+0x5e>
c0d05a22:	460d      	mov	r5, r1
c0d05a24:	4602      	mov	r2, r0
c0d05a26:	2000      	movs	r0, #0
        if (buf[i]) {
c0d05a28:	5c29      	ldrb	r1, [r5, r0]
c0d05a2a:	2900      	cmp	r1, #0
c0d05a2c:	d103      	bne.n	c0d05a36 <accum_ec_mul+0x1e>
c0d05a2e:	1c40      	adds	r0, r0, #1
    for (int i = 0; i < n; ++i) {
c0d05a30:	42b0      	cmp	r0, r6
c0d05a32:	dbf9      	blt.n	c0d05a28 <accum_ec_mul+0x10>
c0d05a34:	e01f      	b.n	c0d05a76 <accum_ec_mul+0x5e>
c0d05a36:	2741      	movs	r7, #65	; 0x41
    ECPoint tmp;
    if (!allzeroes(buf, len)) {
        memcpy(tmp, PEDERSEN_POINTS[pedersen_idx], sizeof(ECPoint));
c0d05a38:	437b      	muls	r3, r7
c0d05a3a:	4810      	ldr	r0, [pc, #64]	; (c0d05a7c <accum_ec_mul+0x64>)
c0d05a3c:	4478      	add	r0, pc
c0d05a3e:	18c1      	adds	r1, r0, r3
c0d05a40:	ac02      	add	r4, sp, #8
c0d05a42:	4620      	mov	r0, r4
c0d05a44:	9201      	str	r2, [sp, #4]
c0d05a46:	463a      	mov	r2, r7
c0d05a48:	f004 fe16 	bl	c0d0a678 <__aeabi_memcpy>
        io_seproxyhal_io_heartbeat();
c0d05a4c:	f7ff f98a 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
        cx_ecfp_scalar_mult(CX_CURVE_Stark256, tmp, sizeof(ECPoint), buf, len);
c0d05a50:	4668      	mov	r0, sp
c0d05a52:	6006      	str	r6, [r0, #0]
c0d05a54:	262e      	movs	r6, #46	; 0x2e
c0d05a56:	4630      	mov	r0, r6
c0d05a58:	4621      	mov	r1, r4
c0d05a5a:	463a      	mov	r2, r7
c0d05a5c:	462b      	mov	r3, r5
c0d05a5e:	f000 ff3b 	bl	c0d068d8 <cx_ecfp_scalar_mult>
        io_seproxyhal_io_heartbeat();
c0d05a62:	f7ff f97f 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
        cx_ecfp_add_point(CX_CURVE_Stark256, *hash, *hash, tmp, sizeof(ECPoint));
c0d05a66:	4668      	mov	r0, sp
c0d05a68:	6007      	str	r7, [r0, #0]
c0d05a6a:	4630      	mov	r0, r6
c0d05a6c:	9901      	ldr	r1, [sp, #4]
c0d05a6e:	460a      	mov	r2, r1
c0d05a70:	4623      	mov	r3, r4
c0d05a72:	f000 ff1f 	bl	c0d068b4 <cx_ecfp_add_point>
    }
}
c0d05a76:	b013      	add	sp, #76	; 0x4c
c0d05a78:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05a7a:	46c0      	nop			; (mov r8, r8)
c0d05a7c:	000065bd 	.word	0x000065bd

c0d05a80 <pedersen>:

void pedersen(FieldElement res, /* out */
              FieldElement a,
              FieldElement b) {
c0d05a80:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05a82:	b093      	sub	sp, #76	; 0x4c
c0d05a84:	4616      	mov	r6, r2
c0d05a86:	460c      	mov	r4, r1
c0d05a88:	9001      	str	r0, [sp, #4]
c0d05a8a:	ad02      	add	r5, sp, #8
    ECPoint hash;

    memcpy(hash, PEDERSEN_SHIFT, sizeof(hash));
c0d05a8c:	4913      	ldr	r1, [pc, #76]	; (c0d05adc <pedersen+0x5c>)
c0d05a8e:	4479      	add	r1, pc
c0d05a90:	2241      	movs	r2, #65	; 0x41
c0d05a92:	4628      	mov	r0, r5
c0d05a94:	f004 fdf0 	bl	c0d0a678 <__aeabi_memcpy>
c0d05a98:	2701      	movs	r7, #1

    accum_ec_mul(&hash, a, 1, 1);
c0d05a9a:	4628      	mov	r0, r5
c0d05a9c:	4621      	mov	r1, r4
c0d05a9e:	463a      	mov	r2, r7
c0d05aa0:	463b      	mov	r3, r7
c0d05aa2:	f7ff ffb9 	bl	c0d05a18 <accum_ec_mul>
    accum_ec_mul(&hash, a + 1, FIELD_ELEMENT_SIZE - 1, 0);
c0d05aa6:	1c61      	adds	r1, r4, #1
c0d05aa8:	241f      	movs	r4, #31
c0d05aaa:	2300      	movs	r3, #0
c0d05aac:	4628      	mov	r0, r5
c0d05aae:	4622      	mov	r2, r4
c0d05ab0:	f7ff ffb2 	bl	c0d05a18 <accum_ec_mul>
c0d05ab4:	2303      	movs	r3, #3
    accum_ec_mul(&hash, b, 1, 3);
c0d05ab6:	4628      	mov	r0, r5
c0d05ab8:	4631      	mov	r1, r6
c0d05aba:	463a      	mov	r2, r7
c0d05abc:	f7ff ffac 	bl	c0d05a18 <accum_ec_mul>
    accum_ec_mul(&hash, b + 1, FIELD_ELEMENT_SIZE - 1, 2);
c0d05ac0:	1c71      	adds	r1, r6, #1
c0d05ac2:	2302      	movs	r3, #2
c0d05ac4:	4628      	mov	r0, r5
c0d05ac6:	4622      	mov	r2, r4
c0d05ac8:	f7ff ffa6 	bl	c0d05a18 <accum_ec_mul>

    memcpy(res, hash + 1, FIELD_ELEMENT_SIZE);
c0d05acc:	1c69      	adds	r1, r5, #1
c0d05ace:	2220      	movs	r2, #32
c0d05ad0:	9801      	ldr	r0, [sp, #4]
c0d05ad2:	f004 fdd1 	bl	c0d0a678 <__aeabi_memcpy>
}
c0d05ad6:	b013      	add	sp, #76	; 0x4c
c0d05ad8:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05ada:	46c0      	nop			; (mov r8, r8)
c0d05adc:	00006672 	.word	0x00006672

c0d05ae0 <stark_sign>:
int stark_sign(uint8_t *signature, /* out */
               uint8_t *privateKeyData,
               FieldElement token1,
               FieldElement token2,
               FieldElement msg,
               FieldElement condition) {
c0d05ae0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05ae2:	b09d      	sub	sp, #116	; 0x74
c0d05ae4:	461c      	mov	r4, r3
c0d05ae6:	9108      	str	r1, [sp, #32]
c0d05ae8:	9009      	str	r0, [sp, #36]	; 0x24
c0d05aea:	2000      	movs	r0, #0
    unsigned int info = 0;
c0d05aec:	901c      	str	r0, [sp, #112]	; 0x70
    FieldElement hash;
    cx_ecfp_private_key_t privateKey;
    PRINTF("Stark sign msg w1 %.*H\n", 32, token1);
c0d05aee:	4838      	ldr	r0, [pc, #224]	; (c0d05bd0 <stark_sign+0xf0>)
c0d05af0:	4478      	add	r0, pc
c0d05af2:	2520      	movs	r5, #32
c0d05af4:	4629      	mov	r1, r5
c0d05af6:	9206      	str	r2, [sp, #24]
c0d05af8:	f7ff faa0 	bl	c0d0503c <mcu_usb_printf>
    PRINTF("Stark sign msg w2 %.*H\n", 32, token2);
c0d05afc:	4835      	ldr	r0, [pc, #212]	; (c0d05bd4 <stark_sign+0xf4>)
c0d05afe:	4478      	add	r0, pc
c0d05b00:	4629      	mov	r1, r5
c0d05b02:	9407      	str	r4, [sp, #28]
c0d05b04:	4622      	mov	r2, r4
c0d05b06:	f7ff fa99 	bl	c0d0503c <mcu_usb_printf>
    PRINTF("Stark sign w3 %.*H\n", 32, msg);
c0d05b0a:	4833      	ldr	r0, [pc, #204]	; (c0d05bd8 <stark_sign+0xf8>)
c0d05b0c:	4478      	add	r0, pc
c0d05b0e:	9e22      	ldr	r6, [sp, #136]	; 0x88
c0d05b10:	4629      	mov	r1, r5
c0d05b12:	4632      	mov	r2, r6
c0d05b14:	f7ff fa92 	bl	c0d0503c <mcu_usb_printf>
c0d05b18:	9f23      	ldr	r7, [sp, #140]	; 0x8c
    if (condition != NULL) {
c0d05b1a:	2f00      	cmp	r7, #0
c0d05b1c:	d01d      	beq.n	c0d05b5a <stark_sign+0x7a>
        PRINTF("Stark sign w4 %.*H\n", 32, condition);
c0d05b1e:	482f      	ldr	r0, [pc, #188]	; (c0d05bdc <stark_sign+0xfc>)
c0d05b20:	4478      	add	r0, pc
c0d05b22:	9605      	str	r6, [sp, #20]
c0d05b24:	2620      	movs	r6, #32
c0d05b26:	4631      	mov	r1, r6
c0d05b28:	463a      	mov	r2, r7
c0d05b2a:	f7ff fa87 	bl	c0d0503c <mcu_usb_printf>
c0d05b2e:	ac14      	add	r4, sp, #80	; 0x50
    }
    pedersen(hash, token1, token2);
c0d05b30:	4620      	mov	r0, r4
c0d05b32:	9906      	ldr	r1, [sp, #24]
c0d05b34:	9a07      	ldr	r2, [sp, #28]
c0d05b36:	f7ff ffa3 	bl	c0d05a80 <pedersen>
    PRINTF("Pedersen hash 1 %.*H\n", 32, hash);
c0d05b3a:	4829      	ldr	r0, [pc, #164]	; (c0d05be0 <stark_sign+0x100>)
c0d05b3c:	4478      	add	r0, pc
c0d05b3e:	4631      	mov	r1, r6
c0d05b40:	4622      	mov	r2, r4
c0d05b42:	f7ff fa7b 	bl	c0d0503c <mcu_usb_printf>
    if (condition != NULL) {
        pedersen(hash, hash, condition);
c0d05b46:	4620      	mov	r0, r4
c0d05b48:	4621      	mov	r1, r4
c0d05b4a:	463a      	mov	r2, r7
c0d05b4c:	f7ff ff98 	bl	c0d05a80 <pedersen>
        PRINTF("Pedersen hash condition %.*H\n", 32, hash);
c0d05b50:	4824      	ldr	r0, [pc, #144]	; (c0d05be4 <stark_sign+0x104>)
c0d05b52:	4478      	add	r0, pc
c0d05b54:	4631      	mov	r1, r6
c0d05b56:	9e05      	ldr	r6, [sp, #20]
c0d05b58:	e008      	b.n	c0d05b6c <stark_sign+0x8c>
c0d05b5a:	ac14      	add	r4, sp, #80	; 0x50
    pedersen(hash, token1, token2);
c0d05b5c:	4620      	mov	r0, r4
c0d05b5e:	9906      	ldr	r1, [sp, #24]
c0d05b60:	9a07      	ldr	r2, [sp, #28]
c0d05b62:	f7ff ff8d 	bl	c0d05a80 <pedersen>
    PRINTF("Pedersen hash 1 %.*H\n", 32, hash);
c0d05b66:	4820      	ldr	r0, [pc, #128]	; (c0d05be8 <stark_sign+0x108>)
c0d05b68:	4478      	add	r0, pc
c0d05b6a:	2120      	movs	r1, #32
c0d05b6c:	4622      	mov	r2, r4
c0d05b6e:	f7ff fa65 	bl	c0d0503c <mcu_usb_printf>
c0d05b72:	ac14      	add	r4, sp, #80	; 0x50
    }
    pedersen(hash, hash, msg);
c0d05b74:	4620      	mov	r0, r4
c0d05b76:	4621      	mov	r1, r4
c0d05b78:	4632      	mov	r2, r6
c0d05b7a:	f7ff ff81 	bl	c0d05a80 <pedersen>
    PRINTF("Pedersen hash 2 %.*H\n", 32, hash);
c0d05b7e:	481b      	ldr	r0, [pc, #108]	; (c0d05bec <stark_sign+0x10c>)
c0d05b80:	4478      	add	r0, pc
c0d05b82:	4629      	mov	r1, r5
c0d05b84:	4622      	mov	r2, r4
c0d05b86:	f7ff fa59 	bl	c0d0503c <mcu_usb_printf>
c0d05b8a:	202e      	movs	r0, #46	; 0x2e
c0d05b8c:	ae0a      	add	r6, sp, #40	; 0x28
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d05b8e:	9908      	ldr	r1, [sp, #32]
c0d05b90:	462a      	mov	r2, r5
c0d05b92:	4633      	mov	r3, r6
c0d05b94:	f000 fec2 	bl	c0d0691c <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d05b98:	f7ff f8e4 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d05b9c:	a81c      	add	r0, sp, #112	; 0x70
    int signatureLength = cx_ecdsa_sign(&privateKey,
c0d05b9e:	4669      	mov	r1, sp
c0d05ba0:	2248      	movs	r2, #72	; 0x48
c0d05ba2:	600d      	str	r5, [r1, #0]
c0d05ba4:	9d09      	ldr	r5, [sp, #36]	; 0x24
c0d05ba6:	604d      	str	r5, [r1, #4]
c0d05ba8:	608a      	str	r2, [r1, #8]
c0d05baa:	60c8      	str	r0, [r1, #12]
c0d05bac:	4907      	ldr	r1, [pc, #28]	; (c0d05bcc <stark_sign+0xec>)
c0d05bae:	2203      	movs	r2, #3
c0d05bb0:	4630      	mov	r0, r6
c0d05bb2:	4623      	mov	r3, r4
c0d05bb4:	f000 fed2 	bl	c0d0695c <cx_ecdsa_sign>
c0d05bb8:	4604      	mov	r4, r0
                                        hash,
                                        sizeof(hash),
                                        signature,
                                        SIGNATURE_MAX_LEN,
                                        &info);
    PRINTF("Stark signature %.*H\n", signatureLength, signature);
c0d05bba:	480d      	ldr	r0, [pc, #52]	; (c0d05bf0 <stark_sign+0x110>)
c0d05bbc:	4478      	add	r0, pc
c0d05bbe:	4621      	mov	r1, r4
c0d05bc0:	462a      	mov	r2, r5
c0d05bc2:	f7ff fa3b 	bl	c0d0503c <mcu_usb_printf>
    return signatureLength;
c0d05bc6:	4620      	mov	r0, r4
c0d05bc8:	b01d      	add	sp, #116	; 0x74
c0d05bca:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05bcc:	00000601 	.word	0x00000601
c0d05bd0:	00006651 	.word	0x00006651
c0d05bd4:	0000665b 	.word	0x0000665b
c0d05bd8:	00006665 	.word	0x00006665
c0d05bdc:	00006665 	.word	0x00006665
c0d05be0:	0000665d 	.word	0x0000665d
c0d05be4:	0000665d 	.word	0x0000665d
c0d05be8:	00006631 	.word	0x00006631
c0d05bec:	0000664d 	.word	0x0000664d
c0d05bf0:	00006627 	.word	0x00006627

c0d05bf4 <compute_token_id>:
                      uint8_t *contractAddress,
                      uint8_t quantumType,
                      uint8_t *quantum,
                      uint8_t *mintingBlob,
                      bool assetTypeOnly,
                      uint8_t *output) {
c0d05bf4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05bf6:	b091      	sub	sp, #68	; 0x44
c0d05bf8:	461f      	mov	r7, r3
c0d05bfa:	4615      	mov	r5, r2
c0d05bfc:	460e      	mov	r6, r1
c0d05bfe:	2101      	movs	r1, #1
c0d05c00:	9105      	str	r1, [sp, #20]
c0d05c02:	0209      	lsls	r1, r1, #8
c0d05c04:	9007      	str	r0, [sp, #28]
c0d05c06:	9104      	str	r1, [sp, #16]
    uint8_t tmp[36];
    cx_keccak_init(sha3, 256);
c0d05c08:	f000 fe46 	bl	c0d06898 <cx_keccak_init>
    if ((contractAddress != NULL) && (!allzeroes(contractAddress, 20))) {
c0d05c0c:	2e00      	cmp	r6, #0
c0d05c0e:	9506      	str	r5, [sp, #24]
c0d05c10:	d006      	beq.n	c0d05c20 <compute_token_id+0x2c>
c0d05c12:	2000      	movs	r0, #0
        if (buf[i]) {
c0d05c14:	5c31      	ldrb	r1, [r6, r0]
c0d05c16:	2900      	cmp	r1, #0
c0d05c18:	d111      	bne.n	c0d05c3e <compute_token_id+0x4a>
c0d05c1a:	1c40      	adds	r0, r0, #1
    for (int i = 0; i < n; ++i) {
c0d05c1c:	2813      	cmp	r0, #19
c0d05c1e:	d9f9      	bls.n	c0d05c14 <compute_token_id+0x20>
        memset(tmp, 0, sizeof(tmp));
        memmove(tmp, selector, 4);
        memmove(tmp + 16, contractAddress, 20);
        cx_hash((cx_hash_t *) sha3, 0, tmp, sizeof(tmp), NULL, 0);
    } else {
        PRINTF("compute_token_id for ETH\n");
c0d05c20:	486f      	ldr	r0, [pc, #444]	; (c0d05de0 <compute_token_id+0x1ec>)
c0d05c22:	4478      	add	r0, pc
c0d05c24:	f7ff fa0a 	bl	c0d0503c <mcu_usb_printf>
c0d05c28:	2100      	movs	r1, #0
        cx_hash((cx_hash_t *) sha3, 0, ETH_SELECTOR, sizeof(ETH_SELECTOR), NULL, 0);
c0d05c2a:	4668      	mov	r0, sp
c0d05c2c:	6001      	str	r1, [r0, #0]
c0d05c2e:	6041      	str	r1, [r0, #4]
c0d05c30:	4a6c      	ldr	r2, [pc, #432]	; (c0d05de4 <compute_token_id+0x1f0>)
c0d05c32:	447a      	add	r2, pc
c0d05c34:	2304      	movs	r3, #4
c0d05c36:	9807      	ldr	r0, [sp, #28]
c0d05c38:	f000 fdfe 	bl	c0d06838 <cx_hash>
c0d05c3c:	e043      	b.n	c0d05cc6 <compute_token_id+0xd2>
        switch (quantumType) {
c0d05c3e:	2d02      	cmp	r5, #2
c0d05c40:	9703      	str	r7, [sp, #12]
c0d05c42:	dd08      	ble.n	c0d05c56 <compute_token_id+0x62>
c0d05c44:	2d05      	cmp	r5, #5
c0d05c46:	d011      	beq.n	c0d05c6c <compute_token_id+0x78>
c0d05c48:	2d04      	cmp	r5, #4
c0d05c4a:	d012      	beq.n	c0d05c72 <compute_token_id+0x7e>
c0d05c4c:	2d03      	cmp	r5, #3
c0d05c4e:	d109      	bne.n	c0d05c64 <compute_token_id+0x70>
c0d05c50:	4d5f      	ldr	r5, [pc, #380]	; (c0d05dd0 <compute_token_id+0x1dc>)
c0d05c52:	447d      	add	r5, pc
c0d05c54:	e00f      	b.n	c0d05c76 <compute_token_id+0x82>
c0d05c56:	4628      	mov	r0, r5
c0d05c58:	4d5b      	ldr	r5, [pc, #364]	; (c0d05dc8 <compute_token_id+0x1d4>)
c0d05c5a:	447d      	add	r5, pc
c0d05c5c:	2800      	cmp	r0, #0
c0d05c5e:	d00a      	beq.n	c0d05c76 <compute_token_id+0x82>
c0d05c60:	2802      	cmp	r0, #2
c0d05c62:	d008      	beq.n	c0d05c76 <compute_token_id+0x82>
                PRINTF("Unsupported quantum type %d\n", quantumType);
c0d05c64:	4859      	ldr	r0, [pc, #356]	; (c0d05dcc <compute_token_id+0x1d8>)
c0d05c66:	4478      	add	r0, pc
c0d05c68:	9906      	ldr	r1, [sp, #24]
c0d05c6a:	e0aa      	b.n	c0d05dc2 <compute_token_id+0x1ce>
c0d05c6c:	4d59      	ldr	r5, [pc, #356]	; (c0d05dd4 <compute_token_id+0x1e0>)
c0d05c6e:	447d      	add	r5, pc
c0d05c70:	e001      	b.n	c0d05c76 <compute_token_id+0x82>
c0d05c72:	4d59      	ldr	r5, [pc, #356]	; (c0d05dd8 <compute_token_id+0x1e4>)
c0d05c74:	447d      	add	r5, pc
        PRINTF("compute_token_id for %.*H\n", 20, contractAddress);
c0d05c76:	4859      	ldr	r0, [pc, #356]	; (c0d05ddc <compute_token_id+0x1e8>)
c0d05c78:	4478      	add	r0, pc
c0d05c7a:	2414      	movs	r4, #20
c0d05c7c:	4621      	mov	r1, r4
c0d05c7e:	4632      	mov	r2, r6
c0d05c80:	f7ff f9dc 	bl	c0d0503c <mcu_usb_printf>
c0d05c84:	2700      	movs	r7, #0
        memset(tmp, 0, sizeof(tmp));
c0d05c86:	970b      	str	r7, [sp, #44]	; 0x2c
c0d05c88:	970a      	str	r7, [sp, #40]	; 0x28
c0d05c8a:	9709      	str	r7, [sp, #36]	; 0x24
        memmove(tmp, selector, 4);
c0d05c8c:	7828      	ldrb	r0, [r5, #0]
c0d05c8e:	7869      	ldrb	r1, [r5, #1]
c0d05c90:	0209      	lsls	r1, r1, #8
c0d05c92:	1808      	adds	r0, r1, r0
c0d05c94:	78a9      	ldrb	r1, [r5, #2]
c0d05c96:	78ea      	ldrb	r2, [r5, #3]
c0d05c98:	0212      	lsls	r2, r2, #8
c0d05c9a:	1851      	adds	r1, r2, r1
c0d05c9c:	0409      	lsls	r1, r1, #16
c0d05c9e:	1808      	adds	r0, r1, r0
c0d05ca0:	9008      	str	r0, [sp, #32]
c0d05ca2:	ad08      	add	r5, sp, #32
        memmove(tmp + 16, contractAddress, 20);
c0d05ca4:	4628      	mov	r0, r5
c0d05ca6:	3010      	adds	r0, #16
c0d05ca8:	4631      	mov	r1, r6
c0d05caa:	4622      	mov	r2, r4
c0d05cac:	f004 fce4 	bl	c0d0a678 <__aeabi_memcpy>
        cx_hash((cx_hash_t *) sha3, 0, tmp, sizeof(tmp), NULL, 0);
c0d05cb0:	4668      	mov	r0, sp
c0d05cb2:	6007      	str	r7, [r0, #0]
c0d05cb4:	6047      	str	r7, [r0, #4]
c0d05cb6:	2324      	movs	r3, #36	; 0x24
c0d05cb8:	9807      	ldr	r0, [sp, #28]
c0d05cba:	4639      	mov	r1, r7
c0d05cbc:	462a      	mov	r2, r5
c0d05cbe:	f000 fdbb 	bl	c0d06838 <cx_hash>
c0d05cc2:	9f03      	ldr	r7, [sp, #12]
c0d05cc4:	9d06      	ldr	r5, [sp, #24]
c0d05cc6:	9e18      	ldr	r6, [sp, #96]	; 0x60
    }
    if ((quantumType == STARK_QUANTUM_ERC721) || (quantumType == STARK_QUANTUM_MINTABLE_ERC721)) {
c0d05cc8:	2d05      	cmp	r5, #5
c0d05cca:	d001      	beq.n	c0d05cd0 <compute_token_id+0xdc>
c0d05ccc:	2d03      	cmp	r5, #3
c0d05cce:	d115      	bne.n	c0d05cfc <compute_token_id+0x108>
c0d05cd0:	ad08      	add	r5, sp, #32
c0d05cd2:	2720      	movs	r7, #32
        memset(tmp, 0, 32);
c0d05cd4:	4628      	mov	r0, r5
c0d05cd6:	4639      	mov	r1, r7
c0d05cd8:	f004 fcc8 	bl	c0d0a66c <__aeabi_memclr>
c0d05cdc:	9c05      	ldr	r4, [sp, #20]
        tmp[31] = 1;
c0d05cde:	77ec      	strb	r4, [r5, #31]
        PRINTF("compute_token_id quantum %.*H\n", 32, tmp);
c0d05ce0:	4841      	ldr	r0, [pc, #260]	; (c0d05de8 <compute_token_id+0x1f4>)
c0d05ce2:	4478      	add	r0, pc
c0d05ce4:	4639      	mov	r1, r7
c0d05ce6:	462a      	mov	r2, r5
c0d05ce8:	f7ff f9a8 	bl	c0d0503c <mcu_usb_printf>
        cx_hash((cx_hash_t *) sha3, CX_LAST, tmp, 32, output, 32);
c0d05cec:	4668      	mov	r0, sp
c0d05cee:	c0c0      	stmia	r0!, {r6, r7}
c0d05cf0:	9807      	ldr	r0, [sp, #28]
c0d05cf2:	4621      	mov	r1, r4
c0d05cf4:	462a      	mov	r2, r5
c0d05cf6:	9c06      	ldr	r4, [sp, #24]
c0d05cf8:	463b      	mov	r3, r7
c0d05cfa:	e00e      	b.n	c0d05d1a <compute_token_id+0x126>
    } else {
        PRINTF("compute_token_id quantum %.*H\n", 32, quantum);
c0d05cfc:	483b      	ldr	r0, [pc, #236]	; (c0d05dec <compute_token_id+0x1f8>)
c0d05cfe:	4478      	add	r0, pc
c0d05d00:	2520      	movs	r5, #32
c0d05d02:	4629      	mov	r1, r5
c0d05d04:	463a      	mov	r2, r7
c0d05d06:	f7ff f999 	bl	c0d0503c <mcu_usb_printf>
        cx_hash((cx_hash_t *) sha3, CX_LAST, quantum, 32, output, 32);
c0d05d0a:	4668      	mov	r0, sp
c0d05d0c:	6006      	str	r6, [r0, #0]
c0d05d0e:	6045      	str	r5, [r0, #4]
c0d05d10:	2101      	movs	r1, #1
c0d05d12:	9807      	ldr	r0, [sp, #28]
c0d05d14:	463a      	mov	r2, r7
c0d05d16:	462b      	mov	r3, r5
c0d05d18:	9c06      	ldr	r4, [sp, #24]
c0d05d1a:	f000 fd8d 	bl	c0d06838 <cx_hash>
    }
    if (!assetTypeOnly &&
c0d05d1e:	2c03      	cmp	r4, #3
c0d05d20:	d340      	bcc.n	c0d05da4 <compute_token_id+0x1b0>
c0d05d22:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0d05d24:	2800      	cmp	r0, #0
c0d05d26:	d13d      	bne.n	c0d05da4 <compute_token_id+0x1b0>
        ((quantumType != STARK_QUANTUM_LEGACY) && (quantumType != STARK_QUANTUM_ETH) &&
         (quantumType != STARK_QUANTUM_ERC20))) {
        const char *prefix = NULL;
        output[0] &= 0x03;
c0d05d28:	7830      	ldrb	r0, [r6, #0]
c0d05d2a:	2103      	movs	r1, #3
c0d05d2c:	4001      	ands	r1, r0
c0d05d2e:	7031      	strb	r1, [r6, #0]
        cx_keccak_init(sha3, 256);
c0d05d30:	9807      	ldr	r0, [sp, #28]
c0d05d32:	9904      	ldr	r1, [sp, #16]
c0d05d34:	f000 fdb0 	bl	c0d06898 <cx_keccak_init>
        switch (quantumType) {
c0d05d38:	1f20      	subs	r0, r4, #4
c0d05d3a:	2802      	cmp	r0, #2
c0d05d3c:	d202      	bcs.n	c0d05d44 <compute_token_id+0x150>
c0d05d3e:	4d2e      	ldr	r5, [pc, #184]	; (c0d05df8 <compute_token_id+0x204>)
c0d05d40:	447d      	add	r5, pc
c0d05d42:	e003      	b.n	c0d05d4c <compute_token_id+0x158>
c0d05d44:	2c03      	cmp	r4, #3
c0d05d46:	d139      	bne.n	c0d05dbc <compute_token_id+0x1c8>
c0d05d48:	4d29      	ldr	r5, [pc, #164]	; (c0d05df0 <compute_token_id+0x1fc>)
c0d05d4a:	447d      	add	r5, pc
c0d05d4c:	9816      	ldr	r0, [sp, #88]	; 0x58
                break;
            default:
                PRINTF("Unsupported non default quantum type %d\n", quantumType);
                return;
        }
        cx_hash((cx_hash_t *) sha3, 0, (const uint8_t *) prefix, strlen(prefix), NULL, 0);
c0d05d4e:	9005      	str	r0, [sp, #20]
c0d05d50:	4628      	mov	r0, r5
c0d05d52:	f004 fe51 	bl	c0d0a9f8 <strlen>
c0d05d56:	4603      	mov	r3, r0
c0d05d58:	2700      	movs	r7, #0
c0d05d5a:	4668      	mov	r0, sp
c0d05d5c:	6007      	str	r7, [r0, #0]
c0d05d5e:	6047      	str	r7, [r0, #4]
c0d05d60:	9c07      	ldr	r4, [sp, #28]
c0d05d62:	4620      	mov	r0, r4
c0d05d64:	4639      	mov	r1, r7
c0d05d66:	462a      	mov	r2, r5
c0d05d68:	f000 fd66 	bl	c0d06838 <cx_hash>
        cx_hash((cx_hash_t *) sha3, 0, output, 32, NULL, 0);
c0d05d6c:	4668      	mov	r0, sp
c0d05d6e:	6007      	str	r7, [r0, #0]
c0d05d70:	6047      	str	r7, [r0, #4]
c0d05d72:	2520      	movs	r5, #32
c0d05d74:	4620      	mov	r0, r4
c0d05d76:	4639      	mov	r1, r7
c0d05d78:	4632      	mov	r2, r6
c0d05d7a:	462b      	mov	r3, r5
c0d05d7c:	f000 fd5c 	bl	c0d06838 <cx_hash>
        cx_hash((cx_hash_t *) sha3, CX_LAST, mintingBlob, 32, output, 32);
c0d05d80:	4668      	mov	r0, sp
c0d05d82:	6006      	str	r6, [r0, #0]
c0d05d84:	6045      	str	r5, [r0, #4]
c0d05d86:	2101      	movs	r1, #1
c0d05d88:	4620      	mov	r0, r4
c0d05d8a:	9a05      	ldr	r2, [sp, #20]
c0d05d8c:	462b      	mov	r3, r5
c0d05d8e:	f000 fd53 	bl	c0d06838 <cx_hash>
c0d05d92:	20fe      	movs	r0, #254	; 0xfe
c0d05d94:	9906      	ldr	r1, [sp, #24]
    }
    if (!assetTypeOnly && ((quantumType == STARK_QUANTUM_MINTABLE_ERC20) ||
c0d05d96:	4001      	ands	r1, r0
c0d05d98:	2904      	cmp	r1, #4
c0d05d9a:	d103      	bne.n	c0d05da4 <compute_token_id+0x1b0>
                           (quantumType == STARK_QUANTUM_MINTABLE_ERC721))) {
        output[0] = 0x04;
        output[1] = 0x00;
c0d05d9c:	7077      	strb	r7, [r6, #1]
c0d05d9e:	2004      	movs	r0, #4
        output[0] = 0x04;
c0d05da0:	7030      	strb	r0, [r6, #0]
c0d05da2:	e003      	b.n	c0d05dac <compute_token_id+0x1b8>
    } else {
        output[0] &= 0x03;
c0d05da4:	7830      	ldrb	r0, [r6, #0]
c0d05da6:	2103      	movs	r1, #3
c0d05da8:	4001      	ands	r1, r0
c0d05daa:	7031      	strb	r1, [r6, #0]
    }
    PRINTF("compute_token_id computed token %.*H\n", 32, output);
c0d05dac:	4813      	ldr	r0, [pc, #76]	; (c0d05dfc <compute_token_id+0x208>)
c0d05dae:	4478      	add	r0, pc
c0d05db0:	2120      	movs	r1, #32
c0d05db2:	4632      	mov	r2, r6
c0d05db4:	f7ff f942 	bl	c0d0503c <mcu_usb_printf>
}
c0d05db8:	b011      	add	sp, #68	; 0x44
c0d05dba:	bdf0      	pop	{r4, r5, r6, r7, pc}
                PRINTF("Unsupported non default quantum type %d\n", quantumType);
c0d05dbc:	480d      	ldr	r0, [pc, #52]	; (c0d05df4 <compute_token_id+0x200>)
c0d05dbe:	4478      	add	r0, pc
c0d05dc0:	4621      	mov	r1, r4
c0d05dc2:	f7ff f93b 	bl	c0d0503c <mcu_usb_printf>
c0d05dc6:	e7f7      	b.n	c0d05db8 <compute_token_id+0x1c4>
c0d05dc8:	0000665f 	.word	0x0000665f
c0d05dcc:	00006593 	.word	0x00006593
c0d05dd0:	0000666b 	.word	0x0000666b
c0d05dd4:	00006657 	.word	0x00006657
c0d05dd8:	0000664d 	.word	0x0000664d
c0d05ddc:	0000659e 	.word	0x0000659e
c0d05de0:	0000660f 	.word	0x0000660f
c0d05de4:	00006697 	.word	0x00006697
c0d05de8:	00006569 	.word	0x00006569
c0d05dec:	0000654d 	.word	0x0000654d
c0d05df0:	00007a42 	.word	0x00007a42
c0d05df4:	000064ac 	.word	0x000064ac
c0d05df8:	0000658d 	.word	0x0000658d
c0d05dfc:	000064e5 	.word	0x000064e5

c0d05e00 <starkware_verify_asset_id>:
    }
    return false;
}

// TODO : rewrite as independant code
bool starkware_verify_asset_id(uint8_t *tmp32, uint8_t *tokenId, bool assetTypeOnly) {
c0d05e00:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05e02:	b0f1      	sub	sp, #452	; 0x1c4
c0d05e04:	4607      	mov	r7, r0
    if (quantumSet) {
c0d05e06:	4826      	ldr	r0, [pc, #152]	; (c0d05ea0 <starkware_verify_asset_id+0xa0>)
c0d05e08:	7800      	ldrb	r0, [r0, #0]
c0d05e0a:	2800      	cmp	r0, #0
c0d05e0c:	d01d      	beq.n	c0d05e4a <starkware_verify_asset_id+0x4a>
c0d05e0e:	9104      	str	r1, [sp, #16]
c0d05e10:	20e4      	movs	r0, #228	; 0xe4
        cx_sha3_t sha3;
        tokenDefinition_t *currentToken = NULL;
        if (dataContext.tokenContext.quantumIndex != MAX_TOKEN) {
c0d05e12:	4e24      	ldr	r6, [pc, #144]	; (c0d05ea4 <starkware_verify_asset_id+0xa4>)
c0d05e14:	5c30      	ldrb	r0, [r6, r0]
            currentToken = &tmpCtx.transactionContext.tokens[dataContext.tokenContext.quantumIndex];
        }
        cx_keccak_init(&sha3, 256);
c0d05e16:	9005      	str	r0, [sp, #20]
c0d05e18:	2001      	movs	r0, #1
c0d05e1a:	9003      	str	r0, [sp, #12]
c0d05e1c:	0201      	lsls	r1, r0, #8
c0d05e1e:	ac06      	add	r4, sp, #24
c0d05e20:	4620      	mov	r0, r4
c0d05e22:	4615      	mov	r5, r2
c0d05e24:	f000 fd38 	bl	c0d06898 <cx_keccak_init>
c0d05e28:	20e5      	movs	r0, #229	; 0xe5
        compute_token_id(&sha3,
                         (currentToken != NULL ? currentToken->address : NULL),
                         dataContext.tokenContext.quantumType,
c0d05e2a:	5c32      	ldrb	r2, [r6, r0]
        compute_token_id(&sha3,
c0d05e2c:	4668      	mov	r0, sp
c0d05e2e:	4631      	mov	r1, r6
c0d05e30:	31c4      	adds	r1, #196	; 0xc4
c0d05e32:	6001      	str	r1, [r0, #0]
c0d05e34:	9905      	ldr	r1, [sp, #20]
c0d05e36:	6045      	str	r5, [r0, #4]
c0d05e38:	6087      	str	r7, [r0, #8]
        if (dataContext.tokenContext.quantumIndex != MAX_TOKEN) {
c0d05e3a:	2902      	cmp	r1, #2
c0d05e3c:	d00a      	beq.n	c0d05e54 <starkware_verify_asset_id+0x54>
c0d05e3e:	2021      	movs	r0, #33	; 0x21
c0d05e40:	4348      	muls	r0, r1
c0d05e42:	4919      	ldr	r1, [pc, #100]	; (c0d05ea8 <starkware_verify_asset_id+0xa8>)
c0d05e44:	1809      	adds	r1, r1, r0
c0d05e46:	314c      	adds	r1, #76	; 0x4c
c0d05e48:	e005      	b.n	c0d05e56 <starkware_verify_asset_id+0x56>
            PRINTF("Current quantum %.*H\n", 32, dataContext.tokenContext.quantum);
            PRINTF("Requested %.*H\n", 32, tokenId);
            return false;
        }
    } else {
        PRINTF("Quantum not set\n");
c0d05e4a:	481b      	ldr	r0, [pc, #108]	; (c0d05eb8 <starkware_verify_asset_id+0xb8>)
c0d05e4c:	4478      	add	r0, pc
c0d05e4e:	f7ff f8f5 	bl	c0d0503c <mcu_usb_printf>
c0d05e52:	e020      	b.n	c0d05e96 <starkware_verify_asset_id+0x96>
c0d05e54:	2100      	movs	r1, #0
c0d05e56:	9d04      	ldr	r5, [sp, #16]
        compute_token_id(&sha3,
c0d05e58:	36a4      	adds	r6, #164	; 0xa4
c0d05e5a:	4620      	mov	r0, r4
c0d05e5c:	4633      	mov	r3, r6
c0d05e5e:	f7ff fec9 	bl	c0d05bf4 <compute_token_id>
c0d05e62:	2220      	movs	r2, #32
        if (memcmp(tokenId, tmp32, 32) != 0) {
c0d05e64:	4628      	mov	r0, r5
c0d05e66:	4639      	mov	r1, r7
c0d05e68:	f004 fc1a 	bl	c0d0a6a0 <memcmp>
c0d05e6c:	2800      	cmp	r0, #0
c0d05e6e:	d014      	beq.n	c0d05e9a <starkware_verify_asset_id+0x9a>
            PRINTF("Token ID not matching - computed %.*H\n", 32, tmp32);
c0d05e70:	480e      	ldr	r0, [pc, #56]	; (c0d05eac <starkware_verify_asset_id+0xac>)
c0d05e72:	4478      	add	r0, pc
c0d05e74:	2420      	movs	r4, #32
c0d05e76:	4621      	mov	r1, r4
c0d05e78:	463a      	mov	r2, r7
c0d05e7a:	f7ff f8df 	bl	c0d0503c <mcu_usb_printf>
            PRINTF("Current quantum %.*H\n", 32, dataContext.tokenContext.quantum);
c0d05e7e:	480c      	ldr	r0, [pc, #48]	; (c0d05eb0 <starkware_verify_asset_id+0xb0>)
c0d05e80:	4478      	add	r0, pc
c0d05e82:	4621      	mov	r1, r4
c0d05e84:	4632      	mov	r2, r6
c0d05e86:	f7ff f8d9 	bl	c0d0503c <mcu_usb_printf>
            PRINTF("Requested %.*H\n", 32, tokenId);
c0d05e8a:	480a      	ldr	r0, [pc, #40]	; (c0d05eb4 <starkware_verify_asset_id+0xb4>)
c0d05e8c:	4478      	add	r0, pc
c0d05e8e:	4621      	mov	r1, r4
c0d05e90:	462a      	mov	r2, r5
c0d05e92:	f7ff f8d3 	bl	c0d0503c <mcu_usb_printf>
c0d05e96:	2000      	movs	r0, #0
c0d05e98:	e000      	b.n	c0d05e9c <starkware_verify_asset_id+0x9c>
c0d05e9a:	9803      	ldr	r0, [sp, #12]
c0d05e9c:	b071      	add	sp, #452	; 0x1c4
c0d05e9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05ea0:	2000189d 	.word	0x2000189d
c0d05ea4:	20001be4 	.word	0x20001be4
c0d05ea8:	20001804 	.word	0x20001804
c0d05eac:	0000647a 	.word	0x0000647a
c0d05eb0:	00006493 	.word	0x00006493
c0d05eb4:	0000649d 	.word	0x0000649d
c0d05eb8:	000064ed 	.word	0x000064ed

c0d05ebc <starkware_verify_nft_token_id>:
        return false;
    }
    return true;
}

bool starkware_verify_nft_token_id(uint8_t *tokenId) {
c0d05ebc:	b570      	push	{r4, r5, r6, lr}
c0d05ebe:	4604      	mov	r4, r0
    if (!quantumSet) {
c0d05ec0:	4816      	ldr	r0, [pc, #88]	; (c0d05f1c <starkware_verify_nft_token_id+0x60>)
c0d05ec2:	7800      	ldrb	r0, [r0, #0]
c0d05ec4:	2800      	cmp	r0, #0
c0d05ec6:	d01c      	beq.n	c0d05f02 <starkware_verify_nft_token_id+0x46>
c0d05ec8:	20e5      	movs	r0, #229	; 0xe5
        PRINTF("Quantum not set\n");
        return false;
    }
    switch (dataContext.tokenContext.quantumType) {
c0d05eca:	4d15      	ldr	r5, [pc, #84]	; (c0d05f20 <starkware_verify_nft_token_id+0x64>)
c0d05ecc:	5c29      	ldrb	r1, [r5, r0]
c0d05ece:	2903      	cmp	r1, #3
c0d05ed0:	d001      	beq.n	c0d05ed6 <starkware_verify_nft_token_id+0x1a>
c0d05ed2:	2905      	cmp	r1, #5
c0d05ed4:	d11a      	bne.n	c0d05f0c <starkware_verify_nft_token_id+0x50>
        default:
            PRINTF("Unexpected quantum type for NFT token id check %d\n",
                   dataContext.tokenContext.quantumType);
            return false;
    }
    if (memcmp(dataContext.tokenContext.quantum, tokenId, 32) != 0) {
c0d05ed6:	35a4      	adds	r5, #164	; 0xa4
c0d05ed8:	2220      	movs	r2, #32
c0d05eda:	4628      	mov	r0, r5
c0d05edc:	4621      	mov	r1, r4
c0d05ede:	f004 fbdf 	bl	c0d0a6a0 <memcmp>
c0d05ee2:	2800      	cmp	r0, #0
c0d05ee4:	d018      	beq.n	c0d05f18 <starkware_verify_nft_token_id+0x5c>
        PRINTF("Token ID not matching - expected %.*H\n", 32, dataContext.tokenContext.quantum);
c0d05ee6:	4811      	ldr	r0, [pc, #68]	; (c0d05f2c <starkware_verify_nft_token_id+0x70>)
c0d05ee8:	4478      	add	r0, pc
c0d05eea:	2620      	movs	r6, #32
c0d05eec:	4631      	mov	r1, r6
c0d05eee:	462a      	mov	r2, r5
c0d05ef0:	f7ff f8a4 	bl	c0d0503c <mcu_usb_printf>
        PRINTF("Current token ID %.*H\n", 32, tokenId);
c0d05ef4:	480e      	ldr	r0, [pc, #56]	; (c0d05f30 <starkware_verify_nft_token_id+0x74>)
c0d05ef6:	4478      	add	r0, pc
c0d05ef8:	4631      	mov	r1, r6
c0d05efa:	4622      	mov	r2, r4
c0d05efc:	f7ff f89e 	bl	c0d0503c <mcu_usb_printf>
c0d05f00:	e008      	b.n	c0d05f14 <starkware_verify_nft_token_id+0x58>
        PRINTF("Quantum not set\n");
c0d05f02:	4808      	ldr	r0, [pc, #32]	; (c0d05f24 <starkware_verify_nft_token_id+0x68>)
c0d05f04:	4478      	add	r0, pc
c0d05f06:	f7ff f899 	bl	c0d0503c <mcu_usb_printf>
c0d05f0a:	e003      	b.n	c0d05f14 <starkware_verify_nft_token_id+0x58>
            PRINTF("Unexpected quantum type for NFT token id check %d\n",
c0d05f0c:	4806      	ldr	r0, [pc, #24]	; (c0d05f28 <starkware_verify_nft_token_id+0x6c>)
c0d05f0e:	4478      	add	r0, pc
c0d05f10:	f7ff f894 	bl	c0d0503c <mcu_usb_printf>
c0d05f14:	2000      	movs	r0, #0
        return false;
    }
    return true;
}
c0d05f16:	bd70      	pop	{r4, r5, r6, pc}
c0d05f18:	2001      	movs	r0, #1
c0d05f1a:	bd70      	pop	{r4, r5, r6, pc}
c0d05f1c:	2000189d 	.word	0x2000189d
c0d05f20:	20001be4 	.word	0x20001be4
c0d05f24:	00006435 	.word	0x00006435
c0d05f28:	0000643c 	.word	0x0000643c
c0d05f2c:	00006495 	.word	0x00006495
c0d05f30:	000064ae 	.word	0x000064ae

c0d05f34 <starkware_print_stark_key>:

void starkware_print_vault_id(uint32_t vaultId, char *destination) {
    snprintf(destination, 10, "%d", vaultId);
}

void starkware_print_stark_key(uint8_t *starkKey, char *destination) {
c0d05f34:	b510      	push	{r4, lr}
c0d05f36:	b082      	sub	sp, #8
c0d05f38:	460c      	mov	r4, r1
    snprintf(destination, 70, "0x%.*H", 32, starkKey);
c0d05f3a:	4669      	mov	r1, sp
c0d05f3c:	6008      	str	r0, [r1, #0]
c0d05f3e:	2146      	movs	r1, #70	; 0x46
c0d05f40:	4a03      	ldr	r2, [pc, #12]	; (c0d05f50 <starkware_print_stark_key+0x1c>)
c0d05f42:	447a      	add	r2, pc
c0d05f44:	2320      	movs	r3, #32
c0d05f46:	4620      	mov	r0, r4
c0d05f48:	f7ff fa22 	bl	c0d05390 <snprintf>
}
c0d05f4c:	b002      	add	sp, #8
c0d05f4e:	bd10      	pop	{r4, pc}
c0d05f50:	00004e0a 	.word	0x00004e0a

c0d05f54 <starkware_print_eth_address>:

// TODO : rewrite as independant code
void starkware_print_eth_address(uint8_t *address, char *destination) {
c0d05f54:	b510      	push	{r4, lr}
c0d05f56:	460c      	mov	r4, r1
c0d05f58:	2178      	movs	r1, #120	; 0x78
    destination[0] = '0';
    destination[1] = 'x';
c0d05f5a:	7061      	strb	r1, [r4, #1]
c0d05f5c:	2130      	movs	r1, #48	; 0x30
    destination[0] = '0';
c0d05f5e:	7021      	strb	r1, [r4, #0]
    getEthAddressStringFromBinary(address, destination + 2, &global_sha3, chainConfig);
c0d05f60:	4904      	ldr	r1, [pc, #16]	; (c0d05f74 <starkware_print_eth_address+0x20>)
c0d05f62:	680b      	ldr	r3, [r1, #0]
c0d05f64:	1ca1      	adds	r1, r4, #2
c0d05f66:	4a04      	ldr	r2, [pc, #16]	; (c0d05f78 <starkware_print_eth_address+0x24>)
c0d05f68:	f7fc fabe 	bl	c0d024e8 <getEthAddressStringFromBinary>
c0d05f6c:	202a      	movs	r0, #42	; 0x2a
c0d05f6e:	2100      	movs	r1, #0
    destination[42] = '\0';
c0d05f70:	5421      	strb	r1, [r4, r0]
}
c0d05f72:	bd10      	pop	{r4, pc}
c0d05f74:	20001be0 	.word	0x20001be0
c0d05f78:	20001d60 	.word	0x20001d60

c0d05f7c <starkware_print_amount>:

// TODO : rewrite as independant code
void starkware_print_amount(uint8_t *amountData, char *destination, bool forEscape) {
c0d05f7c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05f7e:	b09b      	sub	sp, #108	; 0x6c
c0d05f80:	4617      	mov	r7, r2
c0d05f82:	460c      	mov	r4, r1
c0d05f84:	4606      	mov	r6, r0
    uint256_t amount, amountPre, quantum;
    uint8_t decimals;
    char *ticker = (char *) PIC(chainConfig->coinName);
c0d05f86:	482b      	ldr	r0, [pc, #172]	; (c0d06034 <starkware_print_amount+0xb8>)
c0d05f88:	6800      	ldr	r0, [r0, #0]
c0d05f8a:	f7ff fbd5 	bl	c0d05738 <pic>
c0d05f8e:	4605      	mov	r5, r0

    if ((amountData == NULL) ||
c0d05f90:	2e00      	cmp	r6, #0
c0d05f92:	d006      	beq.n	c0d05fa2 <starkware_print_amount+0x26>
c0d05f94:	20e4      	movs	r0, #228	; 0xe4
        (forEscape && (dataContext.tokenContext.quantumIndex == MAX_TOKEN))) {
c0d05f96:	4928      	ldr	r1, [pc, #160]	; (c0d06038 <starkware_print_amount+0xbc>)
c0d05f98:	5c08      	ldrb	r0, [r1, r0]
c0d05f9a:	2802      	cmp	r0, #2
c0d05f9c:	d108      	bne.n	c0d05fb0 <starkware_print_amount+0x34>
c0d05f9e:	2f00      	cmp	r7, #0
c0d05fa0:	d006      	beq.n	c0d05fb0 <starkware_print_amount+0x34>
        decimals = WEI_TO_ETHER;
        if (!forEscape) {
c0d05fa2:	2f00      	cmp	r7, #0
c0d05fa4:	d011      	beq.n	c0d05fca <starkware_print_amount+0x4e>
c0d05fa6:	a90a      	add	r1, sp, #40	; 0x28
            convertUint256BE(tmpContent.txContent.value.value,
                             tmpContent.txContent.value.length,
                             &amount);
        } else {
            readu256BE(amountData, &amountPre);
c0d05fa8:	4630      	mov	r0, r6
c0d05faa:	f001 fef5 	bl	c0d07d98 <readu256BE>
c0d05fae:	e013      	b.n	c0d05fd8 <starkware_print_amount+0x5c>
c0d05fb0:	2121      	movs	r1, #33	; 0x21
        }
    } else {
        tokenDefinition_t *token =
            &tmpCtx.transactionContext.tokens[dataContext.tokenContext.quantumIndex];
        decimals = token->decimals;
c0d05fb2:	4341      	muls	r1, r0
c0d05fb4:	4821      	ldr	r0, [pc, #132]	; (c0d0603c <starkware_print_amount+0xc0>)
c0d05fb6:	1845      	adds	r5, r0, r1
c0d05fb8:	206c      	movs	r0, #108	; 0x6c
c0d05fba:	5c28      	ldrb	r0, [r5, r0]
        ticker = (char *) token->ticker;
        readu256BE(amountData, &amountPre);
c0d05fbc:	9001      	str	r0, [sp, #4]
c0d05fbe:	a90a      	add	r1, sp, #40	; 0x28
c0d05fc0:	4630      	mov	r0, r6
c0d05fc2:	f001 fee9 	bl	c0d07d98 <readu256BE>
        ticker = (char *) token->ticker;
c0d05fc6:	3560      	adds	r5, #96	; 0x60
c0d05fc8:	e00a      	b.n	c0d05fe0 <starkware_print_amount+0x64>
c0d05fca:	2162      	movs	r1, #98	; 0x62
                             tmpContent.txContent.value.length,
c0d05fcc:	481c      	ldr	r0, [pc, #112]	; (c0d06040 <starkware_print_amount+0xc4>)
c0d05fce:	5c41      	ldrb	r1, [r0, r1]
c0d05fd0:	3042      	adds	r0, #66	; 0x42
c0d05fd2:	aa12      	add	r2, sp, #72	; 0x48
            convertUint256BE(tmpContent.txContent.value.value,
c0d05fd4:	f003 fc02 	bl	c0d097dc <convertUint256BE>
c0d05fd8:	2012      	movs	r0, #18
    }
    if (amountData != NULL) {
c0d05fda:	9001      	str	r0, [sp, #4]
c0d05fdc:	2e00      	cmp	r6, #0
c0d05fde:	d00a      	beq.n	c0d05ff6 <starkware_print_amount+0x7a>
        readu256BE(dataContext.tokenContext.quantum, &quantum);
c0d05fe0:	4815      	ldr	r0, [pc, #84]	; (c0d06038 <starkware_print_amount+0xbc>)
c0d05fe2:	30a4      	adds	r0, #164	; 0xa4
c0d05fe4:	ae02      	add	r6, sp, #8
c0d05fe6:	4631      	mov	r1, r6
c0d05fe8:	f001 fed6 	bl	c0d07d98 <readu256BE>
c0d05fec:	a80a      	add	r0, sp, #40	; 0x28
c0d05fee:	aa12      	add	r2, sp, #72	; 0x48
        mul256(&amountPre, &quantum, &amount);
c0d05ff0:	4631      	mov	r1, r6
c0d05ff2:	f002 f9f1 	bl	c0d083d8 <mul256>
    }
    tostring256(&amount, 10, (char *) (G_io_apdu_buffer + 100), 100);
c0d05ff6:	4e13      	ldr	r6, [pc, #76]	; (c0d06044 <starkware_print_amount+0xc8>)
c0d05ff8:	3664      	adds	r6, #100	; 0x64
c0d05ffa:	a812      	add	r0, sp, #72	; 0x48
c0d05ffc:	210a      	movs	r1, #10
c0d05ffe:	2364      	movs	r3, #100	; 0x64
c0d06000:	4632      	mov	r2, r6
c0d06002:	f002 fb81 	bl	c0d08708 <tostring256>
    strcpy(destination, ticker);
c0d06006:	4620      	mov	r0, r4
c0d06008:	4629      	mov	r1, r5
c0d0600a:	f004 fced 	bl	c0d0a9e8 <strcpy>
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
                   strlen((char *) (G_io_apdu_buffer + 100)),
c0d0600e:	4630      	mov	r0, r6
c0d06010:	f004 fcf2 	bl	c0d0a9f8 <strlen>
c0d06014:	4607      	mov	r7, r0
                   destination + strlen(ticker),
c0d06016:	4628      	mov	r0, r5
c0d06018:	f004 fcee 	bl	c0d0a9f8 <strlen>
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
c0d0601c:	4669      	mov	r1, sp
c0d0601e:	9a01      	ldr	r2, [sp, #4]
c0d06020:	600a      	str	r2, [r1, #0]
                   destination + strlen(ticker),
c0d06022:	1822      	adds	r2, r4, r0
c0d06024:	2132      	movs	r1, #50	; 0x32
                   50 - strlen(ticker),
c0d06026:	1a0b      	subs	r3, r1, r0
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
c0d06028:	4630      	mov	r0, r6
c0d0602a:	4639      	mov	r1, r7
c0d0602c:	f7fc fbae 	bl	c0d0278c <adjustDecimals>
                   decimals);
}
c0d06030:	b01b      	add	sp, #108	; 0x6c
c0d06032:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d06034:	20001be0 	.word	0x20001be0
c0d06038:	20001be4 	.word	0x20001be4
c0d0603c:	20001804 	.word	0x20001804
c0d06040:	200018dc 	.word	0x200018dc
c0d06044:	20001f09 	.word	0x20001f09

c0d06048 <starkware_print_asset_contract>:
    }
    strcpy(destination, ticker);
}

// TODO : rewrite as independant code
void starkware_print_asset_contract(char *destination) {
c0d06048:	b510      	push	{r4, lr}
c0d0604a:	4604      	mov	r4, r0
c0d0604c:	20e4      	movs	r0, #228	; 0xe4
    // token has been validated to be present previously
    if (dataContext.tokenContext.quantumIndex != MAX_TOKEN) {
c0d0604e:	4913      	ldr	r1, [pc, #76]	; (c0d0609c <starkware_print_asset_contract+0x54>)
c0d06050:	5c08      	ldrb	r0, [r1, r0]
c0d06052:	2802      	cmp	r0, #2
c0d06054:	d10e      	bne.n	c0d06074 <starkware_print_asset_contract+0x2c>
c0d06056:	2000      	movs	r0, #0
        tokenDefinition_t *token =
            &tmpCtx.transactionContext.tokens[dataContext.tokenContext.quantumIndex];
        starkware_print_eth_address(token->address, destination);
    } else {
        strcpy(destination, "UNKNOWN");
c0d06058:	71e0      	strb	r0, [r4, #7]
c0d0605a:	204e      	movs	r0, #78	; 0x4e
c0d0605c:	71a0      	strb	r0, [r4, #6]
c0d0605e:	2157      	movs	r1, #87	; 0x57
c0d06060:	7161      	strb	r1, [r4, #5]
c0d06062:	214f      	movs	r1, #79	; 0x4f
c0d06064:	7121      	strb	r1, [r4, #4]
c0d06066:	70e0      	strb	r0, [r4, #3]
c0d06068:	214b      	movs	r1, #75	; 0x4b
c0d0606a:	70a1      	strb	r1, [r4, #2]
c0d0606c:	7060      	strb	r0, [r4, #1]
c0d0606e:	2055      	movs	r0, #85	; 0x55
c0d06070:	7020      	strb	r0, [r4, #0]
    }
}
c0d06072:	bd10      	pop	{r4, pc}
c0d06074:	2178      	movs	r1, #120	; 0x78
    destination[1] = 'x';
c0d06076:	7061      	strb	r1, [r4, #1]
c0d06078:	2130      	movs	r1, #48	; 0x30
    destination[0] = '0';
c0d0607a:	7021      	strb	r1, [r4, #0]
c0d0607c:	2121      	movs	r1, #33	; 0x21
        starkware_print_eth_address(token->address, destination);
c0d0607e:	4341      	muls	r1, r0
c0d06080:	4807      	ldr	r0, [pc, #28]	; (c0d060a0 <starkware_print_asset_contract+0x58>)
c0d06082:	1840      	adds	r0, r0, r1
c0d06084:	304c      	adds	r0, #76	; 0x4c
    getEthAddressStringFromBinary(address, destination + 2, &global_sha3, chainConfig);
c0d06086:	4907      	ldr	r1, [pc, #28]	; (c0d060a4 <starkware_print_asset_contract+0x5c>)
c0d06088:	680b      	ldr	r3, [r1, #0]
c0d0608a:	1ca1      	adds	r1, r4, #2
c0d0608c:	4a06      	ldr	r2, [pc, #24]	; (c0d060a8 <starkware_print_asset_contract+0x60>)
c0d0608e:	f7fc fa2b 	bl	c0d024e8 <getEthAddressStringFromBinary>
c0d06092:	202a      	movs	r0, #42	; 0x2a
c0d06094:	2100      	movs	r1, #0
    destination[42] = '\0';
c0d06096:	5421      	strb	r1, [r4, r0]
}
c0d06098:	bd10      	pop	{r4, pc}
c0d0609a:	46c0      	nop			; (mov r8, r8)
c0d0609c:	20001be4 	.word	0x20001be4
c0d060a0:	20001804 	.word	0x20001804
c0d060a4:	20001be0 	.word	0x20001be0
c0d060a8:	20001d60 	.word	0x20001d60

c0d060ac <starkware_get_source_address>:

// TODO : rewrite as independant code
void starkware_get_source_address(char *destination) {
c0d060ac:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d060ae:	b0a9      	sub	sp, #164	; 0xa4
c0d060b0:	9002      	str	r0, [sp, #8]
    uint8_t privateKeyData[32];
    cx_ecfp_private_key_t privateKey;
    cx_ecfp_public_key_t publicKey;
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.transactionContext.bip32Path,
                               tmpCtx.transactionContext.pathLength,
c0d060b2:	481d      	ldr	r0, [pc, #116]	; (c0d06128 <starkware_get_source_address+0x7c>)
c0d060b4:	7802      	ldrb	r2, [r0, #0]
c0d060b6:	2300      	movs	r3, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d060b8:	9303      	str	r3, [sp, #12]
c0d060ba:	4669      	mov	r1, sp
c0d060bc:	600b      	str	r3, [r1, #0]
c0d060be:	1d01      	adds	r1, r0, #4
c0d060c0:	2621      	movs	r6, #33	; 0x21
c0d060c2:	ad21      	add	r5, sp, #132	; 0x84
c0d060c4:	4630      	mov	r0, r6
c0d060c6:	462b      	mov	r3, r5
c0d060c8:	f000 fcbc 	bl	c0d06a44 <os_perso_derive_node_bip32>
c0d060cc:	2720      	movs	r7, #32
c0d060ce:	ac17      	add	r4, sp, #92	; 0x5c
                               privateKeyData,
                               NULL);
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d060d0:	4630      	mov	r0, r6
c0d060d2:	4629      	mov	r1, r5
c0d060d4:	463a      	mov	r2, r7
c0d060d6:	4623      	mov	r3, r4
c0d060d8:	f000 fc20 	bl	c0d0691c <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d060dc:	f7fe fe42 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d060e0:	a904      	add	r1, sp, #16
c0d060e2:	2301      	movs	r3, #1
    cx_ecfp_generate_pair(CX_CURVE_256K1, &publicKey, &privateKey, 1);
c0d060e4:	4630      	mov	r0, r6
c0d060e6:	460e      	mov	r6, r1
c0d060e8:	4622      	mov	r2, r4
c0d060ea:	f000 fc27 	bl	c0d0693c <cx_ecfp_generate_pair>
c0d060ee:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d060f0:	4620      	mov	r0, r4
c0d060f2:	f004 fad1 	bl	c0d0a698 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d060f6:	4628      	mov	r0, r5
c0d060f8:	4639      	mov	r1, r7
c0d060fa:	f004 facd 	bl	c0d0a698 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0d060fe:	f7fe fe31 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d06102:	2078      	movs	r0, #120	; 0x78
c0d06104:	9a02      	ldr	r2, [sp, #8]
    destination[0] = '0';
    destination[1] = 'x';
c0d06106:	7050      	strb	r0, [r2, #1]
c0d06108:	2030      	movs	r0, #48	; 0x30
    destination[0] = '0';
c0d0610a:	7010      	strb	r0, [r2, #0]
    getEthAddressStringFromKey(&publicKey, destination + 2, &global_sha3, chainConfig);
c0d0610c:	4807      	ldr	r0, [pc, #28]	; (c0d0612c <starkware_get_source_address+0x80>)
c0d0610e:	6803      	ldr	r3, [r0, #0]
c0d06110:	1c91      	adds	r1, r2, #2
c0d06112:	4614      	mov	r4, r2
c0d06114:	4a06      	ldr	r2, [pc, #24]	; (c0d06130 <starkware_get_source_address+0x84>)
c0d06116:	4630      	mov	r0, r6
c0d06118:	f7fc f9c6 	bl	c0d024a8 <getEthAddressStringFromKey>
c0d0611c:	202a      	movs	r0, #42	; 0x2a
    destination[42] = '\0';
c0d0611e:	9903      	ldr	r1, [sp, #12]
c0d06120:	5421      	strb	r1, [r4, r0]
}
c0d06122:	b029      	add	sp, #164	; 0xa4
c0d06124:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d06126:	46c0      	nop			; (mov r8, r8)
c0d06128:	20001804 	.word	0x20001804
c0d0612c:	20001be0 	.word	0x20001be0
c0d06130:	20001d60 	.word	0x20001d60

c0d06134 <starkware_plugin_call>:

void starkware_plugin_call(int message, void *parameters) {
c0d06134:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06136:	b083      	sub	sp, #12
c0d06138:	460c      	mov	r4, r1
c0d0613a:	4601      	mov	r1, r0
c0d0613c:	2081      	movs	r0, #129	; 0x81
c0d0613e:	0040      	lsls	r0, r0, #1
    switch (message) {
c0d06140:	4281      	cmp	r1, r0
c0d06142:	dd3a      	ble.n	c0d061ba <starkware_plugin_call+0x86>
c0d06144:	20ff      	movs	r0, #255	; 0xff
c0d06146:	4602      	mov	r2, r0
c0d06148:	3204      	adds	r2, #4
c0d0614a:	4291      	cmp	r1, r2
c0d0614c:	d065      	beq.n	c0d0621a <starkware_plugin_call+0xe6>
c0d0614e:	3006      	adds	r0, #6
c0d06150:	4281      	cmp	r1, r0
c0d06152:	d076      	beq.n	c0d06242 <starkware_plugin_call+0x10e>
c0d06154:	2083      	movs	r0, #131	; 0x83
c0d06156:	0040      	lsls	r0, r0, #1
c0d06158:	4281      	cmp	r1, r0
c0d0615a:	d000      	beq.n	c0d0615e <starkware_plugin_call+0x2a>
c0d0615c:	e0b9      	b.n	c0d062d2 <starkware_plugin_call+0x19e>
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0d0615e:	7b21      	ldrb	r1, [r4, #12]
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d06160:	68a5      	ldr	r5, [r4, #8]
            switch (msg->screenIndex) {
c0d06162:	2901      	cmp	r1, #1
c0d06164:	dc00      	bgt.n	c0d06168 <starkware_plugin_call+0x34>
c0d06166:	e0cb      	b.n	c0d06300 <starkware_plugin_call+0x1cc>
c0d06168:	2902      	cmp	r1, #2
c0d0616a:	d100      	bne.n	c0d0616e <starkware_plugin_call+0x3a>
c0d0616c:	e12c      	b.n	c0d063c8 <starkware_plugin_call+0x294>
c0d0616e:	2903      	cmp	r1, #3
c0d06170:	d100      	bne.n	c0d06174 <starkware_plugin_call+0x40>
c0d06172:	e137      	b.n	c0d063e4 <starkware_plugin_call+0x2b0>
c0d06174:	2904      	cmp	r1, #4
c0d06176:	d000      	beq.n	c0d0617a <starkware_plugin_call+0x46>
c0d06178:	e16c      	b.n	c0d06454 <starkware_plugin_call+0x320>
                    }
                    msg->result = ETH_PLUGIN_RESULT_OK;
                    break;

                case 4:
                    switch (context->selectorIndex) {
c0d0617a:	792a      	ldrb	r2, [r5, #4]
c0d0617c:	2a0f      	cmp	r2, #15
c0d0617e:	d900      	bls.n	c0d06182 <starkware_plugin_call+0x4e>
c0d06180:	e293      	b.n	c0d066aa <starkware_plugin_call+0x576>
c0d06182:	2001      	movs	r0, #1
c0d06184:	4090      	lsls	r0, r2
c0d06186:	231b      	movs	r3, #27
c0d06188:	02db      	lsls	r3, r3, #11
c0d0618a:	4218      	tst	r0, r3
c0d0618c:	d100      	bne.n	c0d06190 <starkware_plugin_call+0x5c>
c0d0618e:	e28c      	b.n	c0d066aa <starkware_plugin_call+0x576>
                        case STARKWARE_WITHDRAW_NFT:
                        case STARKWARE_WITHDRAW_NFT_TO:
                        case STARKWARE_DEPOSIT_NFT:
                        case STARKWARE_DEPOSIT_NFT_RECLAIM:
                            strcpy(msg->title, "TokenID");
c0d06190:	6920      	ldr	r0, [r4, #16]
c0d06192:	2100      	movs	r1, #0
c0d06194:	71c1      	strb	r1, [r0, #7]
c0d06196:	2144      	movs	r1, #68	; 0x44
c0d06198:	7181      	strb	r1, [r0, #6]
c0d0619a:	2149      	movs	r1, #73	; 0x49
c0d0619c:	7141      	strb	r1, [r0, #5]
c0d0619e:	216e      	movs	r1, #110	; 0x6e
c0d061a0:	7101      	strb	r1, [r0, #4]
c0d061a2:	2165      	movs	r1, #101	; 0x65
c0d061a4:	70c1      	strb	r1, [r0, #3]
c0d061a6:	216b      	movs	r1, #107	; 0x6b
c0d061a8:	7081      	strb	r1, [r0, #2]
c0d061aa:	216f      	movs	r1, #111	; 0x6f
c0d061ac:	7041      	strb	r1, [r0, #1]
c0d061ae:	2154      	movs	r1, #84	; 0x54
c0d061b0:	7001      	strb	r1, [r0, #0]
                            starkware_print_stark_key(dataContext.tokenContext.quantum, msg->msg);
c0d061b2:	69a0      	ldr	r0, [r4, #24]
    snprintf(destination, 70, "0x%.*H", 32, starkKey);
c0d061b4:	49fa      	ldr	r1, [pc, #1000]	; (c0d065a0 <starkware_plugin_call+0x46c>)
c0d061b6:	31a4      	adds	r1, #164	; 0xa4
c0d061b8:	e0ba      	b.n	c0d06330 <starkware_plugin_call+0x1fc>
c0d061ba:	22ff      	movs	r2, #255	; 0xff
c0d061bc:	3202      	adds	r2, #2
    switch (message) {
c0d061be:	4291      	cmp	r1, r2
c0d061c0:	d059      	beq.n	c0d06276 <starkware_plugin_call+0x142>
c0d061c2:	4281      	cmp	r1, r0
c0d061c4:	d000      	beq.n	c0d061c8 <starkware_plugin_call+0x94>
c0d061c6:	e084      	b.n	c0d062d2 <starkware_plugin_call+0x19e>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d061c8:	68a5      	ldr	r5, [r4, #8]
                   msg->parameter);
c0d061ca:	68e3      	ldr	r3, [r4, #12]
                   msg->parameterOffset,
c0d061cc:	6921      	ldr	r1, [r4, #16]
            PRINTF("starkware plugin provide parameter %d %.*H\n",
c0d061ce:	48f5      	ldr	r0, [pc, #980]	; (c0d065a4 <starkware_plugin_call+0x470>)
c0d061d0:	4478      	add	r0, pc
c0d061d2:	2220      	movs	r2, #32
c0d061d4:	f7fe ff32 	bl	c0d0503c <mcu_usb_printf>
            if (context->selectorIndex == STARKWARE_VERIFY_ESCAPE) {
c0d061d8:	7928      	ldrb	r0, [r5, #4]
c0d061da:	2809      	cmp	r0, #9
c0d061dc:	d100      	bne.n	c0d061e0 <starkware_plugin_call+0xac>
c0d061de:	e2ad      	b.n	c0d0673c <starkware_plugin_call+0x608>
            switch (msg->parameterOffset) {
c0d061e0:	6921      	ldr	r1, [r4, #16]
c0d061e2:	1f09      	subs	r1, r1, #4
c0d061e4:	2205      	movs	r2, #5
c0d061e6:	41d1      	rors	r1, r2
c0d061e8:	2901      	cmp	r1, #1
c0d061ea:	dd00      	ble.n	c0d061ee <starkware_plugin_call+0xba>
c0d061ec:	e0aa      	b.n	c0d06344 <starkware_plugin_call+0x210>
c0d061ee:	2900      	cmp	r1, #0
c0d061f0:	d100      	bne.n	c0d061f4 <starkware_plugin_call+0xc0>
c0d061f2:	e15c      	b.n	c0d064ae <starkware_plugin_call+0x37a>
c0d061f4:	2901      	cmp	r1, #1
c0d061f6:	d000      	beq.n	c0d061fa <starkware_plugin_call+0xc6>
c0d061f8:	e170      	b.n	c0d064dc <starkware_plugin_call+0x3a8>
                    switch (context->selectorIndex) {
c0d061fa:	280f      	cmp	r0, #15
c0d061fc:	d900      	bls.n	c0d06200 <starkware_plugin_call+0xcc>
c0d061fe:	e27c      	b.n	c0d066fa <starkware_plugin_call+0x5c6>
c0d06200:	2101      	movs	r1, #1
c0d06202:	4081      	lsls	r1, r0
c0d06204:	4afd      	ldr	r2, [pc, #1012]	; (c0d065fc <starkware_plugin_call+0x4c8>)
c0d06206:	4211      	tst	r1, r2
c0d06208:	d100      	bne.n	c0d0620c <starkware_plugin_call+0xd8>
c0d0620a:	e211      	b.n	c0d06630 <starkware_plugin_call+0x4fc>
c0d0620c:	68e1      	ldr	r1, [r4, #12]
c0d0620e:	4628      	mov	r0, r5
c0d06210:	3025      	adds	r0, #37	; 0x25
c0d06212:	2201      	movs	r2, #1
c0d06214:	f7ff fdf4 	bl	c0d05e00 <starkware_verify_asset_id>
c0d06218:	e1d2      	b.n	c0d065c0 <starkware_plugin_call+0x48c>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d0621a:	68a5      	ldr	r5, [r4, #8]
            PRINTF("starkware plugin finalize\n");
c0d0621c:	48f8      	ldr	r0, [pc, #992]	; (c0d06600 <starkware_plugin_call+0x4cc>)
c0d0621e:	4478      	add	r0, pc
c0d06220:	f7fe ff0c 	bl	c0d0503c <mcu_usb_printf>
c0d06224:	2045      	movs	r0, #69	; 0x45
            if (!context->validToken) {
c0d06226:	5c28      	ldrb	r0, [r5, r0]
c0d06228:	2800      	cmp	r0, #0
c0d0622a:	d100      	bne.n	c0d0622e <starkware_plugin_call+0xfa>
c0d0622c:	e087      	b.n	c0d0633e <starkware_plugin_call+0x20a>
c0d0622e:	2002      	movs	r0, #2
                msg->uiType = ETH_UI_TYPE_GENERIC;
c0d06230:	7720      	strb	r0, [r4, #28]
                msg->numScreens = STARKWARE_NUM_SCREENS[context->selectorIndex];
c0d06232:	7928      	ldrb	r0, [r5, #4]
c0d06234:	2101      	movs	r1, #1
                msg->result = ETH_PLUGIN_RESULT_OK;
c0d06236:	77a1      	strb	r1, [r4, #30]
                msg->numScreens = STARKWARE_NUM_SCREENS[context->selectorIndex];
c0d06238:	49f2      	ldr	r1, [pc, #968]	; (c0d06604 <starkware_plugin_call+0x4d0>)
c0d0623a:	4479      	add	r1, pc
c0d0623c:	5c08      	ldrb	r0, [r1, r0]
c0d0623e:	7760      	strb	r0, [r4, #29]
c0d06240:	e27e      	b.n	c0d06740 <starkware_plugin_call+0x60c>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d06242:	68a5      	ldr	r5, [r4, #8]
            PRINTF("starkware query contract id\n");
c0d06244:	48f0      	ldr	r0, [pc, #960]	; (c0d06608 <starkware_plugin_call+0x4d4>)
c0d06246:	4478      	add	r0, pc
c0d06248:	f7fe fef8 	bl	c0d0503c <mcu_usb_printf>
            switch (context->selectorIndex) {
c0d0624c:	7928      	ldrb	r0, [r5, #4]
c0d0624e:	2807      	cmp	r0, #7
c0d06250:	dc47      	bgt.n	c0d062e2 <starkware_plugin_call+0x1ae>
c0d06252:	2803      	cmp	r0, #3
c0d06254:	dd00      	ble.n	c0d06258 <starkware_plugin_call+0x124>
c0d06256:	e087      	b.n	c0d06368 <starkware_plugin_call+0x234>
c0d06258:	1e41      	subs	r1, r0, #1
c0d0625a:	2902      	cmp	r1, #2
c0d0625c:	d200      	bcs.n	c0d06260 <starkware_plugin_call+0x12c>
c0d0625e:	e103      	b.n	c0d06468 <starkware_plugin_call+0x334>
c0d06260:	2800      	cmp	r0, #0
c0d06262:	d100      	bne.n	c0d06266 <starkware_plugin_call+0x132>
c0d06264:	e156      	b.n	c0d06514 <starkware_plugin_call+0x3e0>
c0d06266:	2803      	cmp	r0, #3
c0d06268:	d000      	beq.n	c0d0626c <starkware_plugin_call+0x138>
c0d0626a:	e163      	b.n	c0d06534 <starkware_plugin_call+0x400>
                    strcpy(msg->name, "Cancel Deposit");
c0d0626c:	68e0      	ldr	r0, [r4, #12]
c0d0626e:	49e7      	ldr	r1, [pc, #924]	; (c0d0660c <starkware_plugin_call+0x4d8>)
c0d06270:	4479      	add	r1, pc
c0d06272:	220f      	movs	r2, #15
c0d06274:	e15c      	b.n	c0d06530 <starkware_plugin_call+0x3fc>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d06276:	68a0      	ldr	r0, [r4, #8]
            PRINTF("starkware plugin init\n");
c0d06278:	9002      	str	r0, [sp, #8]
c0d0627a:	48e5      	ldr	r0, [pc, #916]	; (c0d06610 <starkware_plugin_call+0x4dc>)
c0d0627c:	4478      	add	r0, pc
c0d0627e:	f7fe fedd 	bl	c0d0503c <mcu_usb_printf>
c0d06282:	2600      	movs	r6, #0
c0d06284:	4fe3      	ldr	r7, [pc, #908]	; (c0d06614 <starkware_plugin_call+0x4e0>)
c0d06286:	447f      	add	r7, pc
                if (memcmp(PIC(STARKWARE_SELECTORS[i]), msg->selector, SELECTOR_SIZE) == 0) {
c0d06288:	6838      	ldr	r0, [r7, #0]
c0d0628a:	f7ff fa55 	bl	c0d05738 <pic>
c0d0628e:	7801      	ldrb	r1, [r0, #0]
c0d06290:	7842      	ldrb	r2, [r0, #1]
c0d06292:	0212      	lsls	r2, r2, #8
c0d06294:	1851      	adds	r1, r2, r1
c0d06296:	7882      	ldrb	r2, [r0, #2]
c0d06298:	78c0      	ldrb	r0, [r0, #3]
c0d0629a:	0200      	lsls	r0, r0, #8
c0d0629c:	1880      	adds	r0, r0, r2
c0d0629e:	0400      	lsls	r0, r0, #16
c0d062a0:	1840      	adds	r0, r0, r1
c0d062a2:	6922      	ldr	r2, [r4, #16]
c0d062a4:	7811      	ldrb	r1, [r2, #0]
c0d062a6:	7853      	ldrb	r3, [r2, #1]
c0d062a8:	021b      	lsls	r3, r3, #8
c0d062aa:	1859      	adds	r1, r3, r1
c0d062ac:	7893      	ldrb	r3, [r2, #2]
c0d062ae:	78d5      	ldrb	r5, [r2, #3]
c0d062b0:	022d      	lsls	r5, r5, #8
c0d062b2:	18eb      	adds	r3, r5, r3
c0d062b4:	041b      	lsls	r3, r3, #16
c0d062b6:	1859      	adds	r1, r3, r1
c0d062b8:	4288      	cmp	r0, r1
c0d062ba:	d00f      	beq.n	c0d062dc <starkware_plugin_call+0x1a8>
            for (i = 0; i < NUM_STARKWARE_SELECTORS; i++) {
c0d062bc:	1d3f      	adds	r7, r7, #4
c0d062be:	1c76      	adds	r6, r6, #1
c0d062c0:	2e10      	cmp	r6, #16
c0d062c2:	d3e1      	bcc.n	c0d06288 <starkware_plugin_call+0x154>
            uint8_t i;
c0d062c4:	b2f0      	uxtb	r0, r6
            if (i == NUM_STARKWARE_SELECTORS) {
c0d062c6:	2810      	cmp	r0, #16
c0d062c8:	d162      	bne.n	c0d06390 <starkware_plugin_call+0x25c>
                PRINTF("Unknown selector %.*H\n", SELECTOR_SIZE, msg->selector);
c0d062ca:	48d3      	ldr	r0, [pc, #844]	; (c0d06618 <starkware_plugin_call+0x4e4>)
c0d062cc:	4478      	add	r0, pc
c0d062ce:	2104      	movs	r1, #4
c0d062d0:	e0c3      	b.n	c0d0645a <starkware_plugin_call+0x326>
                    break;
            }
        } break;

        default:
            PRINTF("Unhandled message %d\n", message);
c0d062d2:	48d2      	ldr	r0, [pc, #840]	; (c0d0661c <starkware_plugin_call+0x4e8>)
c0d062d4:	4478      	add	r0, pc
c0d062d6:	f7fe feb1 	bl	c0d0503c <mcu_usb_printf>
c0d062da:	e231      	b.n	c0d06740 <starkware_plugin_call+0x60c>
c0d062dc:	9d02      	ldr	r5, [sp, #8]
                    context->selectorIndex = i;
c0d062de:	712e      	strb	r6, [r5, #4]
c0d062e0:	e058      	b.n	c0d06394 <starkware_plugin_call+0x260>
            switch (context->selectorIndex) {
c0d062e2:	280b      	cmp	r0, #11
c0d062e4:	dc49      	bgt.n	c0d0637a <starkware_plugin_call+0x246>
c0d062e6:	2809      	cmp	r0, #9
c0d062e8:	dd00      	ble.n	c0d062ec <starkware_plugin_call+0x1b8>
c0d062ea:	e0b9      	b.n	c0d06460 <starkware_plugin_call+0x32c>
c0d062ec:	2808      	cmp	r0, #8
c0d062ee:	d100      	bne.n	c0d062f2 <starkware_plugin_call+0x1be>
c0d062f0:	e115      	b.n	c0d0651e <starkware_plugin_call+0x3ea>
c0d062f2:	2809      	cmp	r0, #9
c0d062f4:	d000      	beq.n	c0d062f8 <starkware_plugin_call+0x1c4>
c0d062f6:	e11d      	b.n	c0d06534 <starkware_plugin_call+0x400>
                    strcpy(msg->name, "Verify Escape");
c0d062f8:	68e0      	ldr	r0, [r4, #12]
c0d062fa:	49c9      	ldr	r1, [pc, #804]	; (c0d06620 <starkware_plugin_call+0x4ec>)
c0d062fc:	4479      	add	r1, pc
c0d062fe:	e0d4      	b.n	c0d064aa <starkware_plugin_call+0x376>
            switch (msg->screenIndex) {
c0d06300:	2900      	cmp	r1, #0
c0d06302:	d100      	bne.n	c0d06306 <starkware_plugin_call+0x1d2>
c0d06304:	e083      	b.n	c0d0640e <starkware_plugin_call+0x2da>
c0d06306:	2901      	cmp	r1, #1
c0d06308:	d000      	beq.n	c0d0630c <starkware_plugin_call+0x1d8>
c0d0630a:	e0a3      	b.n	c0d06454 <starkware_plugin_call+0x320>
                    switch (context->selectorIndex) {
c0d0630c:	792a      	ldrb	r2, [r5, #4]
c0d0630e:	2a0f      	cmp	r2, #15
c0d06310:	d900      	bls.n	c0d06314 <starkware_plugin_call+0x1e0>
c0d06312:	e1ca      	b.n	c0d066aa <starkware_plugin_call+0x576>
c0d06314:	2001      	movs	r0, #1
c0d06316:	4090      	lsls	r0, r2
c0d06318:	49c2      	ldr	r1, [pc, #776]	; (c0d06624 <starkware_plugin_call+0x4f0>)
c0d0631a:	4208      	tst	r0, r1
c0d0631c:	d100      	bne.n	c0d06320 <starkware_plugin_call+0x1ec>
c0d0631e:	e1d3      	b.n	c0d066c8 <starkware_plugin_call+0x594>
c0d06320:	6920      	ldr	r0, [r4, #16]
c0d06322:	49c1      	ldr	r1, [pc, #772]	; (c0d06628 <starkware_plugin_call+0x4f4>)
c0d06324:	4479      	add	r1, pc
c0d06326:	220f      	movs	r2, #15
c0d06328:	f004 f9a6 	bl	c0d0a678 <__aeabi_memcpy>
c0d0632c:	69a0      	ldr	r0, [r4, #24]
c0d0632e:	1d69      	adds	r1, r5, #5
c0d06330:	466a      	mov	r2, sp
c0d06332:	6011      	str	r1, [r2, #0]
c0d06334:	2146      	movs	r1, #70	; 0x46
c0d06336:	4abd      	ldr	r2, [pc, #756]	; (c0d0662c <starkware_plugin_call+0x4f8>)
c0d06338:	447a      	add	r2, pc
c0d0633a:	2320      	movs	r3, #32
c0d0633c:	e19d      	b.n	c0d0667a <starkware_plugin_call+0x546>
c0d0633e:	2003      	movs	r0, #3
                msg->result = ETH_PLUGIN_RESULT_FALLBACK;
c0d06340:	77a0      	strb	r0, [r4, #30]
c0d06342:	e1fd      	b.n	c0d06740 <starkware_plugin_call+0x60c>
            switch (msg->parameterOffset) {
c0d06344:	2902      	cmp	r1, #2
c0d06346:	d100      	bne.n	c0d0634a <starkware_plugin_call+0x216>
c0d06348:	e0be      	b.n	c0d064c8 <starkware_plugin_call+0x394>
c0d0634a:	2903      	cmp	r1, #3
c0d0634c:	d000      	beq.n	c0d06350 <starkware_plugin_call+0x21c>
c0d0634e:	e0c5      	b.n	c0d064dc <starkware_plugin_call+0x3a8>
                    switch (context->selectorIndex) {
c0d06350:	280a      	cmp	r0, #10
c0d06352:	dc00      	bgt.n	c0d06356 <starkware_plugin_call+0x222>
c0d06354:	e137      	b.n	c0d065c6 <starkware_plugin_call+0x492>
c0d06356:	4601      	mov	r1, r0
c0d06358:	390b      	subs	r1, #11
c0d0635a:	2902      	cmp	r1, #2
c0d0635c:	d200      	bcs.n	c0d06360 <starkware_plugin_call+0x22c>
c0d0635e:	e12c      	b.n	c0d065ba <starkware_plugin_call+0x486>
c0d06360:	280f      	cmp	r0, #15
c0d06362:	d100      	bne.n	c0d06366 <starkware_plugin_call+0x232>
c0d06364:	e1e3      	b.n	c0d0672e <starkware_plugin_call+0x5fa>
c0d06366:	e1e9      	b.n	c0d0673c <starkware_plugin_call+0x608>
            switch (context->selectorIndex) {
c0d06368:	2805      	cmp	r0, #5
c0d0636a:	dd00      	ble.n	c0d0636e <starkware_plugin_call+0x23a>
c0d0636c:	e08e      	b.n	c0d0648c <starkware_plugin_call+0x358>
c0d0636e:	2804      	cmp	r0, #4
c0d06370:	d100      	bne.n	c0d06374 <starkware_plugin_call+0x240>
c0d06372:	e093      	b.n	c0d0649c <starkware_plugin_call+0x368>
c0d06374:	2805      	cmp	r0, #5
c0d06376:	d022      	beq.n	c0d063be <starkware_plugin_call+0x28a>
c0d06378:	e0dc      	b.n	c0d06534 <starkware_plugin_call+0x400>
c0d0637a:	4601      	mov	r1, r0
c0d0637c:	390d      	subs	r1, #13
c0d0637e:	2902      	cmp	r1, #2
c0d06380:	d31d      	bcc.n	c0d063be <starkware_plugin_call+0x28a>
c0d06382:	280c      	cmp	r0, #12
c0d06384:	d100      	bne.n	c0d06388 <starkware_plugin_call+0x254>
c0d06386:	e089      	b.n	c0d0649c <starkware_plugin_call+0x368>
c0d06388:	280f      	cmp	r0, #15
c0d0638a:	d100      	bne.n	c0d0638e <starkware_plugin_call+0x25a>
c0d0638c:	e08a      	b.n	c0d064a4 <starkware_plugin_call+0x370>
c0d0638e:	e0d1      	b.n	c0d06534 <starkware_plugin_call+0x400>
c0d06390:	9d02      	ldr	r5, [sp, #8]
            if (STARKWARE_EXPECTED_DATA_SIZE[context->selectorIndex] != 0) {
c0d06392:	792e      	ldrb	r6, [r5, #4]
c0d06394:	b2f1      	uxtb	r1, r6
c0d06396:	48f1      	ldr	r0, [pc, #964]	; (c0d0675c <starkware_plugin_call+0x628>)
c0d06398:	40c8      	lsrs	r0, r1
c0d0639a:	07c0      	lsls	r0, r0, #31
c0d0639c:	d005      	beq.n	c0d063aa <starkware_plugin_call+0x276>
c0d0639e:	48f0      	ldr	r0, [pc, #960]	; (c0d06760 <starkware_plugin_call+0x62c>)
c0d063a0:	4478      	add	r0, pc
c0d063a2:	5c42      	ldrb	r2, [r0, r1]
                if (msg->dataSize != STARKWARE_EXPECTED_DATA_SIZE[context->selectorIndex]) {
c0d063a4:	6963      	ldr	r3, [r4, #20]
c0d063a6:	4293      	cmp	r3, r2
c0d063a8:	d104      	bne.n	c0d063b4 <starkware_plugin_call+0x280>
c0d063aa:	2045      	movs	r0, #69	; 0x45
c0d063ac:	2101      	movs	r1, #1
            context->validToken = true;
c0d063ae:	5429      	strb	r1, [r5, r0]
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d063b0:	7721      	strb	r1, [r4, #28]
c0d063b2:	e1c5      	b.n	c0d06740 <starkware_plugin_call+0x60c>
                    PRINTF("Unexpected data size for command %d expected %d got %d\n",
c0d063b4:	48eb      	ldr	r0, [pc, #940]	; (c0d06764 <starkware_plugin_call+0x630>)
c0d063b6:	4478      	add	r0, pc
c0d063b8:	f7fe fe40 	bl	c0d0503c <mcu_usb_printf>
c0d063bc:	e1c0      	b.n	c0d06740 <starkware_plugin_call+0x60c>
                    strcpy(msg->name, "Withdrawal");
c0d063be:	68e0      	ldr	r0, [r4, #12]
c0d063c0:	49ea      	ldr	r1, [pc, #936]	; (c0d0676c <starkware_plugin_call+0x638>)
c0d063c2:	4479      	add	r1, pc
c0d063c4:	220b      	movs	r2, #11
c0d063c6:	e0b3      	b.n	c0d06530 <starkware_plugin_call+0x3fc>
                    switch (context->selectorIndex) {
c0d063c8:	792a      	ldrb	r2, [r5, #4]
c0d063ca:	2a07      	cmp	r2, #7
c0d063cc:	dd00      	ble.n	c0d063d0 <starkware_plugin_call+0x29c>
c0d063ce:	e08d      	b.n	c0d064ec <starkware_plugin_call+0x3b8>
c0d063d0:	2a04      	cmp	r2, #4
c0d063d2:	dd00      	ble.n	c0d063d6 <starkware_plugin_call+0x2a2>
c0d063d4:	e100      	b.n	c0d065d8 <starkware_plugin_call+0x4a4>
c0d063d6:	1e50      	subs	r0, r2, #1
c0d063d8:	2804      	cmp	r0, #4
c0d063da:	d200      	bcs.n	c0d063de <starkware_plugin_call+0x2aa>
c0d063dc:	e139      	b.n	c0d06652 <starkware_plugin_call+0x51e>
c0d063de:	2a00      	cmp	r2, #0
c0d063e0:	d09e      	beq.n	c0d06320 <starkware_plugin_call+0x1ec>
c0d063e2:	e162      	b.n	c0d066aa <starkware_plugin_call+0x576>
                    switch (context->selectorIndex) {
c0d063e4:	792a      	ldrb	r2, [r5, #4]
c0d063e6:	2a0f      	cmp	r2, #15
c0d063e8:	d900      	bls.n	c0d063ec <starkware_plugin_call+0x2b8>
c0d063ea:	e14c      	b.n	c0d06686 <starkware_plugin_call+0x552>
c0d063ec:	2001      	movs	r0, #1
c0d063ee:	4090      	lsls	r0, r2
c0d063f0:	231b      	movs	r3, #27
c0d063f2:	02db      	lsls	r3, r3, #11
c0d063f4:	4218      	tst	r0, r3
c0d063f6:	d100      	bne.n	c0d063fa <starkware_plugin_call+0x2c6>
c0d063f8:	e0b5      	b.n	c0d06566 <starkware_plugin_call+0x432>
                            strcpy(msg->title, "NFT Contract");
c0d063fa:	6920      	ldr	r0, [r4, #16]
c0d063fc:	49f2      	ldr	r1, [pc, #968]	; (c0d067c8 <starkware_plugin_call+0x694>)
c0d063fe:	4479      	add	r1, pc
c0d06400:	220d      	movs	r2, #13
c0d06402:	f004 f939 	bl	c0d0a678 <__aeabi_memcpy>
c0d06406:	69a0      	ldr	r0, [r4, #24]
c0d06408:	f7ff fe1e 	bl	c0d06048 <starkware_print_asset_contract>
c0d0640c:	e137      	b.n	c0d0667e <starkware_plugin_call+0x54a>
                    strcpy(msg->title, "Contract Name");
c0d0640e:	6920      	ldr	r0, [r4, #16]
c0d06410:	49e0      	ldr	r1, [pc, #896]	; (c0d06794 <starkware_plugin_call+0x660>)
c0d06412:	4479      	add	r1, pc
c0d06414:	220e      	movs	r2, #14
c0d06416:	f004 f92f 	bl	c0d0a678 <__aeabi_memcpy>
c0d0641a:	2021      	movs	r0, #33	; 0x21
c0d0641c:	00c0      	lsls	r0, r0, #3
        if (memcmp(address, DEVERSIFI_CONTRACT + offset + 1, 20) == 0) {
c0d0641e:	49cd      	ldr	r1, [pc, #820]	; (c0d06754 <starkware_plugin_call+0x620>)
c0d06420:	180e      	adds	r6, r1, r0
c0d06422:	48dd      	ldr	r0, [pc, #884]	; (c0d06798 <starkware_plugin_call+0x664>)
c0d06424:	4478      	add	r0, pc
c0d06426:	1c41      	adds	r1, r0, #1
c0d06428:	2214      	movs	r2, #20
c0d0642a:	4630      	mov	r0, r6
c0d0642c:	f004 f938 	bl	c0d0a6a0 <memcmp>
c0d06430:	69a5      	ldr	r5, [r4, #24]
                    if (is_deversify_contract(tmpContent.txContent.destination)) {
c0d06432:	2800      	cmp	r0, #0
c0d06434:	d067      	beq.n	c0d06506 <starkware_plugin_call+0x3d2>
c0d06436:	2078      	movs	r0, #120	; 0x78
    destination[1] = 'x';
c0d06438:	7068      	strb	r0, [r5, #1]
c0d0643a:	2030      	movs	r0, #48	; 0x30
    destination[0] = '0';
c0d0643c:	7028      	strb	r0, [r5, #0]
    getEthAddressStringFromBinary(address, destination + 2, &global_sha3, chainConfig);
c0d0643e:	48c2      	ldr	r0, [pc, #776]	; (c0d06748 <starkware_plugin_call+0x614>)
c0d06440:	6803      	ldr	r3, [r0, #0]
c0d06442:	1ca9      	adds	r1, r5, #2
c0d06444:	4ac2      	ldr	r2, [pc, #776]	; (c0d06750 <starkware_plugin_call+0x61c>)
c0d06446:	4630      	mov	r0, r6
c0d06448:	f7fc f84e 	bl	c0d024e8 <getEthAddressStringFromBinary>
c0d0644c:	202a      	movs	r0, #42	; 0x2a
c0d0644e:	2100      	movs	r1, #0
    destination[42] = '\0';
c0d06450:	5429      	strb	r1, [r5, r0]
c0d06452:	e114      	b.n	c0d0667e <starkware_plugin_call+0x54a>
                           context->selectorIndex);
c0d06454:	792a      	ldrb	r2, [r5, #4]
                    PRINTF("Unexpected screen %d for %d\n",
c0d06456:	48dd      	ldr	r0, [pc, #884]	; (c0d067cc <starkware_plugin_call+0x698>)
c0d06458:	4478      	add	r0, pc
c0d0645a:	f7fe fdef 	bl	c0d0503c <mcu_usb_printf>
c0d0645e:	e16f      	b.n	c0d06740 <starkware_plugin_call+0x60c>
            switch (context->selectorIndex) {
c0d06460:	280a      	cmp	r0, #10
c0d06462:	d01f      	beq.n	c0d064a4 <starkware_plugin_call+0x370>
c0d06464:	280b      	cmp	r0, #11
c0d06466:	d165      	bne.n	c0d06534 <starkware_plugin_call+0x400>
                    strcpy(msg->name, "Deposit");
c0d06468:	68e0      	ldr	r0, [r4, #12]
c0d0646a:	2100      	movs	r1, #0
c0d0646c:	71c1      	strb	r1, [r0, #7]
c0d0646e:	2174      	movs	r1, #116	; 0x74
c0d06470:	7181      	strb	r1, [r0, #6]
c0d06472:	2169      	movs	r1, #105	; 0x69
c0d06474:	7141      	strb	r1, [r0, #5]
c0d06476:	2173      	movs	r1, #115	; 0x73
c0d06478:	7101      	strb	r1, [r0, #4]
c0d0647a:	216f      	movs	r1, #111	; 0x6f
c0d0647c:	70c1      	strb	r1, [r0, #3]
c0d0647e:	2170      	movs	r1, #112	; 0x70
c0d06480:	7081      	strb	r1, [r0, #2]
c0d06482:	2165      	movs	r1, #101	; 0x65
c0d06484:	7041      	strb	r1, [r0, #1]
c0d06486:	2144      	movs	r1, #68	; 0x44
c0d06488:	7001      	strb	r1, [r0, #0]
c0d0648a:	e053      	b.n	c0d06534 <starkware_plugin_call+0x400>
            switch (context->selectorIndex) {
c0d0648c:	2806      	cmp	r0, #6
c0d0648e:	d04b      	beq.n	c0d06528 <starkware_plugin_call+0x3f4>
c0d06490:	2807      	cmp	r0, #7
c0d06492:	d14f      	bne.n	c0d06534 <starkware_plugin_call+0x400>
                    strcpy(msg->name, "Freeze");
c0d06494:	68e0      	ldr	r0, [r4, #12]
c0d06496:	49b6      	ldr	r1, [pc, #728]	; (c0d06770 <starkware_plugin_call+0x63c>)
c0d06498:	4479      	add	r1, pc
c0d0649a:	e043      	b.n	c0d06524 <starkware_plugin_call+0x3f0>
                    strcpy(msg->name, "Reclaim Deposit");
c0d0649c:	68e0      	ldr	r0, [r4, #12]
c0d0649e:	49b9      	ldr	r1, [pc, #740]	; (c0d06784 <starkware_plugin_call+0x650>)
c0d064a0:	4479      	add	r1, pc
c0d064a2:	e044      	b.n	c0d0652e <starkware_plugin_call+0x3fa>
                    strcpy(msg->name, "Withdrawal To");
c0d064a4:	68e0      	ldr	r0, [r4, #12]
c0d064a6:	49b5      	ldr	r1, [pc, #724]	; (c0d0677c <starkware_plugin_call+0x648>)
c0d064a8:	4479      	add	r1, pc
c0d064aa:	220e      	movs	r2, #14
c0d064ac:	e040      	b.n	c0d06530 <starkware_plugin_call+0x3fc>
                    switch (context->selectorIndex) {
c0d064ae:	280f      	cmp	r0, #15
c0d064b0:	d900      	bls.n	c0d064b4 <starkware_plugin_call+0x380>
c0d064b2:	e143      	b.n	c0d0673c <starkware_plugin_call+0x608>
c0d064b4:	2101      	movs	r1, #1
c0d064b6:	4081      	lsls	r1, r0
c0d064b8:	4aa7      	ldr	r2, [pc, #668]	; (c0d06758 <starkware_plugin_call+0x624>)
c0d064ba:	4211      	tst	r1, r2
c0d064bc:	d100      	bne.n	c0d064c0 <starkware_plugin_call+0x38c>
c0d064be:	e134      	b.n	c0d0672a <starkware_plugin_call+0x5f6>
c0d064c0:	68e1      	ldr	r1, [r4, #12]
c0d064c2:	1d68      	adds	r0, r5, #5
c0d064c4:	2220      	movs	r2, #32
c0d064c6:	e137      	b.n	c0d06738 <starkware_plugin_call+0x604>
                    switch (context->selectorIndex) {
c0d064c8:	2809      	cmp	r0, #9
c0d064ca:	dc6d      	bgt.n	c0d065a8 <starkware_plugin_call+0x474>
c0d064cc:	1e41      	subs	r1, r0, #1
c0d064ce:	2904      	cmp	r1, #4
c0d064d0:	d200      	bcs.n	c0d064d4 <starkware_plugin_call+0x3a0>
c0d064d2:	e0b2      	b.n	c0d0663a <starkware_plugin_call+0x506>
c0d064d4:	2808      	cmp	r0, #8
c0d064d6:	d100      	bne.n	c0d064da <starkware_plugin_call+0x3a6>
c0d064d8:	e698      	b.n	c0d0620c <starkware_plugin_call+0xd8>
c0d064da:	e12f      	b.n	c0d0673c <starkware_plugin_call+0x608>
                    switch (context->selectorIndex) {
c0d064dc:	2800      	cmp	r0, #0
c0d064de:	d100      	bne.n	c0d064e2 <starkware_plugin_call+0x3ae>
c0d064e0:	e12c      	b.n	c0d0673c <starkware_plugin_call+0x608>
                            PRINTF("Unhandled parameter offset\n");
c0d064e2:	48a1      	ldr	r0, [pc, #644]	; (c0d06768 <starkware_plugin_call+0x634>)
c0d064e4:	4478      	add	r0, pc
c0d064e6:	f7fe fda9 	bl	c0d0503c <mcu_usb_printf>
c0d064ea:	e129      	b.n	c0d06740 <starkware_plugin_call+0x60c>
                    switch (context->selectorIndex) {
c0d064ec:	2a0c      	cmp	r2, #12
c0d064ee:	dc79      	bgt.n	c0d065e4 <starkware_plugin_call+0x4b0>
c0d064f0:	4610      	mov	r0, r2
c0d064f2:	380b      	subs	r0, #11
c0d064f4:	2802      	cmp	r0, #2
c0d064f6:	d200      	bcs.n	c0d064fa <starkware_plugin_call+0x3c6>
c0d064f8:	e0ab      	b.n	c0d06652 <starkware_plugin_call+0x51e>
c0d064fa:	2a08      	cmp	r2, #8
c0d064fc:	d100      	bne.n	c0d06500 <starkware_plugin_call+0x3cc>
c0d064fe:	e70f      	b.n	c0d06320 <starkware_plugin_call+0x1ec>
c0d06500:	2a0a      	cmp	r2, #10
c0d06502:	d076      	beq.n	c0d065f2 <starkware_plugin_call+0x4be>
c0d06504:	e0d1      	b.n	c0d066aa <starkware_plugin_call+0x576>
                        strcpy(msg->msg, "DeversiFi");
c0d06506:	49a5      	ldr	r1, [pc, #660]	; (c0d0679c <starkware_plugin_call+0x668>)
c0d06508:	4479      	add	r1, pc
c0d0650a:	220a      	movs	r2, #10
c0d0650c:	4628      	mov	r0, r5
c0d0650e:	f004 f8b3 	bl	c0d0a678 <__aeabi_memcpy>
c0d06512:	e0b4      	b.n	c0d0667e <starkware_plugin_call+0x54a>
                    strcpy(msg->name, "Register");
c0d06514:	68e0      	ldr	r0, [r4, #12]
c0d06516:	499a      	ldr	r1, [pc, #616]	; (c0d06780 <starkware_plugin_call+0x64c>)
c0d06518:	4479      	add	r1, pc
c0d0651a:	2209      	movs	r2, #9
c0d0651c:	e008      	b.n	c0d06530 <starkware_plugin_call+0x3fc>
                    strcpy(msg->name, "Escape");
c0d0651e:	68e0      	ldr	r0, [r4, #12]
c0d06520:	499a      	ldr	r1, [pc, #616]	; (c0d0678c <starkware_plugin_call+0x658>)
c0d06522:	4479      	add	r1, pc
c0d06524:	2207      	movs	r2, #7
c0d06526:	e003      	b.n	c0d06530 <starkware_plugin_call+0x3fc>
                    strcpy(msg->name, "Full Withdrawal");
c0d06528:	68e0      	ldr	r0, [r4, #12]
c0d0652a:	4997      	ldr	r1, [pc, #604]	; (c0d06788 <starkware_plugin_call+0x654>)
c0d0652c:	4479      	add	r1, pc
c0d0652e:	2210      	movs	r2, #16
c0d06530:	f004 f8a2 	bl	c0d0a678 <__aeabi_memcpy>
c0d06534:	2021      	movs	r0, #33	; 0x21
c0d06536:	00c0      	lsls	r0, r0, #3
        if (memcmp(address, DEVERSIFI_CONTRACT + offset + 1, 20) == 0) {
c0d06538:	4986      	ldr	r1, [pc, #536]	; (c0d06754 <starkware_plugin_call+0x620>)
c0d0653a:	1808      	adds	r0, r1, r0
            strcpy(msg->version,
c0d0653c:	6965      	ldr	r5, [r4, #20]
        if (memcmp(address, DEVERSIFI_CONTRACT + offset + 1, 20) == 0) {
c0d0653e:	498d      	ldr	r1, [pc, #564]	; (c0d06774 <starkware_plugin_call+0x640>)
c0d06540:	4479      	add	r1, pc
c0d06542:	1c49      	adds	r1, r1, #1
c0d06544:	2214      	movs	r2, #20
c0d06546:	f004 f8ab 	bl	c0d0a6a0 <memcmp>
                   is_deversify_contract(tmpContent.txContent.destination) ? "DeversiFi"
c0d0654a:	2800      	cmp	r0, #0
c0d0654c:	d002      	beq.n	c0d06554 <starkware_plugin_call+0x420>
c0d0654e:	4990      	ldr	r1, [pc, #576]	; (c0d06790 <starkware_plugin_call+0x65c>)
c0d06550:	4479      	add	r1, pc
c0d06552:	e001      	b.n	c0d06558 <starkware_plugin_call+0x424>
c0d06554:	4988      	ldr	r1, [pc, #544]	; (c0d06778 <starkware_plugin_call+0x644>)
c0d06556:	4479      	add	r1, pc
c0d06558:	220a      	movs	r2, #10
            strcpy(msg->version,
c0d0655a:	4628      	mov	r0, r5
c0d0655c:	f004 f88c 	bl	c0d0a678 <__aeabi_memcpy>
c0d06560:	2001      	movs	r0, #1
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d06562:	7720      	strb	r0, [r4, #28]
c0d06564:	e0ec      	b.n	c0d06740 <starkware_plugin_call+0x60c>
c0d06566:	2621      	movs	r6, #33	; 0x21
c0d06568:	0173      	lsls	r3, r6, #5
c0d0656a:	4218      	tst	r0, r3
c0d0656c:	d06f      	beq.n	c0d0664e <starkware_plugin_call+0x51a>
                            strcpy(msg->title, "Token Symbol");
c0d0656e:	6920      	ldr	r0, [r4, #16]
c0d06570:	4994      	ldr	r1, [pc, #592]	; (c0d067c4 <starkware_plugin_call+0x690>)
c0d06572:	4479      	add	r1, pc
c0d06574:	220d      	movs	r2, #13
c0d06576:	f004 f87f 	bl	c0d0a678 <__aeabi_memcpy>
                            starkware_print_ticker(msg->msg);
c0d0657a:	69a5      	ldr	r5, [r4, #24]
    char *ticker = (char *) PIC(chainConfig->coinName);
c0d0657c:	4872      	ldr	r0, [pc, #456]	; (c0d06748 <starkware_plugin_call+0x614>)
c0d0657e:	6800      	ldr	r0, [r0, #0]
c0d06580:	f7ff f8da 	bl	c0d05738 <pic>
c0d06584:	4601      	mov	r1, r0
c0d06586:	20e4      	movs	r0, #228	; 0xe4
    if (dataContext.tokenContext.quantumIndex != MAX_TOKEN) {
c0d06588:	4a6e      	ldr	r2, [pc, #440]	; (c0d06744 <starkware_plugin_call+0x610>)
c0d0658a:	5c10      	ldrb	r0, [r2, r0]
c0d0658c:	2802      	cmp	r0, #2
c0d0658e:	d003      	beq.n	c0d06598 <starkware_plugin_call+0x464>
c0d06590:	4346      	muls	r6, r0
c0d06592:	486e      	ldr	r0, [pc, #440]	; (c0d0674c <starkware_plugin_call+0x618>)
c0d06594:	1981      	adds	r1, r0, r6
c0d06596:	3160      	adds	r1, #96	; 0x60
    strcpy(destination, ticker);
c0d06598:	4628      	mov	r0, r5
c0d0659a:	f004 fa25 	bl	c0d0a9e8 <strcpy>
c0d0659e:	e06e      	b.n	c0d0667e <starkware_plugin_call+0x54a>
c0d065a0:	20001be4 	.word	0x20001be4
c0d065a4:	00006202 	.word	0x00006202
                    switch (context->selectorIndex) {
c0d065a8:	4601      	mov	r1, r0
c0d065aa:	390b      	subs	r1, #11
c0d065ac:	2902      	cmp	r1, #2
c0d065ae:	d344      	bcc.n	c0d0663a <starkware_plugin_call+0x506>
c0d065b0:	4601      	mov	r1, r0
c0d065b2:	390e      	subs	r1, #14
c0d065b4:	2902      	cmp	r1, #2
c0d065b6:	d300      	bcc.n	c0d065ba <starkware_plugin_call+0x486>
c0d065b8:	e0a2      	b.n	c0d06700 <starkware_plugin_call+0x5cc>
c0d065ba:	68e0      	ldr	r0, [r4, #12]
c0d065bc:	f7ff fc7e 	bl	c0d05ebc <starkware_verify_nft_token_id>
c0d065c0:	2145      	movs	r1, #69	; 0x45
c0d065c2:	5468      	strb	r0, [r5, r1]
c0d065c4:	e0ba      	b.n	c0d0673c <starkware_plugin_call+0x608>
                    switch (context->selectorIndex) {
c0d065c6:	2801      	cmp	r0, #1
c0d065c8:	d002      	beq.n	c0d065d0 <starkware_plugin_call+0x49c>
c0d065ca:	2808      	cmp	r0, #8
c0d065cc:	d000      	beq.n	c0d065d0 <starkware_plugin_call+0x49c>
c0d065ce:	e0b5      	b.n	c0d0673c <starkware_plugin_call+0x608>
                            memmove(context->amount, msg->parameter, 32);
c0d065d0:	68e1      	ldr	r1, [r4, #12]
c0d065d2:	3525      	adds	r5, #37	; 0x25
c0d065d4:	2220      	movs	r2, #32
c0d065d6:	e0ae      	b.n	c0d06736 <starkware_plugin_call+0x602>
                    switch (context->selectorIndex) {
c0d065d8:	1f90      	subs	r0, r2, #6
c0d065da:	2802      	cmp	r0, #2
c0d065dc:	d339      	bcc.n	c0d06652 <starkware_plugin_call+0x51e>
c0d065de:	2a05      	cmp	r2, #5
c0d065e0:	d068      	beq.n	c0d066b4 <starkware_plugin_call+0x580>
c0d065e2:	e062      	b.n	c0d066aa <starkware_plugin_call+0x576>
c0d065e4:	2a0d      	cmp	r2, #13
c0d065e6:	d100      	bne.n	c0d065ea <starkware_plugin_call+0x4b6>
c0d065e8:	e08d      	b.n	c0d06706 <starkware_plugin_call+0x5d2>
c0d065ea:	2a0e      	cmp	r2, #14
c0d065ec:	d062      	beq.n	c0d066b4 <starkware_plugin_call+0x580>
c0d065ee:	2a0f      	cmp	r2, #15
c0d065f0:	d15b      	bne.n	c0d066aa <starkware_plugin_call+0x576>
                            strcpy(msg->title, "To ETH Address");
c0d065f2:	6920      	ldr	r0, [r4, #16]
c0d065f4:	496e      	ldr	r1, [pc, #440]	; (c0d067b0 <starkware_plugin_call+0x67c>)
c0d065f6:	4479      	add	r1, pc
c0d065f8:	220f      	movs	r2, #15
c0d065fa:	e06b      	b.n	c0d066d4 <starkware_plugin_call+0x5a0>
c0d065fc:	0000fc26 	.word	0x0000fc26
c0d06600:	000061e0 	.word	0x000061e0
c0d06604:	00006241 	.word	0x00006241
c0d06608:	000061d3 	.word	0x000061d3
c0d0660c:	00006228 	.word	0x00006228
c0d06610:	0000613f 	.word	0x0000613f
c0d06614:	0000552a 	.word	0x0000552a
c0d06618:	00004c4a 	.word	0x00004c4a
c0d0661c:	00004d71 	.word	0x00004d71
c0d06620:	000061d8 	.word	0x000061d8
c0d06624:	0000fefe 	.word	0x0000fefe
c0d06628:	000061f0 	.word	0x000061f0
c0d0662c:	00004a14 	.word	0x00004a14
c0d06630:	0609      	lsls	r1, r1, #24
c0d06632:	0f89      	lsrs	r1, r1, #30
c0d06634:	d101      	bne.n	c0d0663a <starkware_plugin_call+0x506>
c0d06636:	2808      	cmp	r0, #8
c0d06638:	d15f      	bne.n	c0d066fa <starkware_plugin_call+0x5c6>
c0d0663a:	68e0      	ldr	r0, [r4, #12]
c0d0663c:	7f01      	ldrb	r1, [r0, #28]
c0d0663e:	7f42      	ldrb	r2, [r0, #29]
c0d06640:	7f83      	ldrb	r3, [r0, #30]
c0d06642:	7fc0      	ldrb	r0, [r0, #31]
c0d06644:	70e8      	strb	r0, [r5, #3]
c0d06646:	70ab      	strb	r3, [r5, #2]
c0d06648:	706a      	strb	r2, [r5, #1]
c0d0664a:	7029      	strb	r1, [r5, #0]
c0d0664c:	e076      	b.n	c0d0673c <starkware_plugin_call+0x608>
c0d0664e:	2a08      	cmp	r2, #8
c0d06650:	d119      	bne.n	c0d06686 <starkware_plugin_call+0x552>
c0d06652:	6920      	ldr	r0, [r4, #16]
c0d06654:	4959      	ldr	r1, [pc, #356]	; (c0d067bc <starkware_plugin_call+0x688>)
c0d06656:	4479      	add	r1, pc
c0d06658:	220e      	movs	r2, #14
c0d0665a:	f004 f80d 	bl	c0d0a678 <__aeabi_memcpy>
c0d0665e:	78e8      	ldrb	r0, [r5, #3]
c0d06660:	78a9      	ldrb	r1, [r5, #2]
c0d06662:	0209      	lsls	r1, r1, #8
c0d06664:	1808      	adds	r0, r1, r0
c0d06666:	7869      	ldrb	r1, [r5, #1]
c0d06668:	782a      	ldrb	r2, [r5, #0]
c0d0666a:	0212      	lsls	r2, r2, #8
c0d0666c:	1851      	adds	r1, r2, r1
c0d0666e:	0409      	lsls	r1, r1, #16
c0d06670:	1843      	adds	r3, r0, r1
c0d06672:	69a0      	ldr	r0, [r4, #24]
c0d06674:	210a      	movs	r1, #10
c0d06676:	4a52      	ldr	r2, [pc, #328]	; (c0d067c0 <starkware_plugin_call+0x68c>)
c0d06678:	447a      	add	r2, pc
c0d0667a:	f7fe fe89 	bl	c0d05390 <snprintf>
c0d0667e:	2020      	movs	r0, #32
c0d06680:	2101      	movs	r1, #1
c0d06682:	5421      	strb	r1, [r4, r0]
c0d06684:	e05c      	b.n	c0d06740 <starkware_plugin_call+0x60c>
                    switch (context->selectorIndex) {
c0d06686:	1e50      	subs	r0, r2, #1
c0d06688:	2802      	cmp	r0, #2
c0d0668a:	d20e      	bcs.n	c0d066aa <starkware_plugin_call+0x576>
                            strcpy(msg->title, "Amount");
c0d0668c:	6920      	ldr	r0, [r4, #16]
c0d0668e:	494a      	ldr	r1, [pc, #296]	; (c0d067b8 <starkware_plugin_call+0x684>)
c0d06690:	4479      	add	r1, pc
c0d06692:	2207      	movs	r2, #7
c0d06694:	f003 fff0 	bl	c0d0a678 <__aeabi_memcpy>
                                (context->selectorIndex == STARKWARE_DEPOSIT_ETH ? NULL
c0d06698:	7928      	ldrb	r0, [r5, #4]
c0d0669a:	2200      	movs	r2, #0
c0d0669c:	2802      	cmp	r0, #2
c0d0669e:	4610      	mov	r0, r2
c0d066a0:	d001      	beq.n	c0d066a6 <starkware_plugin_call+0x572>
c0d066a2:	3525      	adds	r5, #37	; 0x25
c0d066a4:	4628      	mov	r0, r5
                                msg->msg,
c0d066a6:	69a1      	ldr	r1, [r4, #24]
c0d066a8:	e03c      	b.n	c0d06724 <starkware_plugin_call+0x5f0>
c0d066aa:	4840      	ldr	r0, [pc, #256]	; (c0d067ac <starkware_plugin_call+0x678>)
c0d066ac:	4478      	add	r0, pc
c0d066ae:	f7fe fcc5 	bl	c0d0503c <mcu_usb_printf>
c0d066b2:	e7e4      	b.n	c0d0667e <starkware_plugin_call+0x54a>
                            strcpy(msg->title, "To ETH Address");
c0d066b4:	6920      	ldr	r0, [r4, #16]
c0d066b6:	493c      	ldr	r1, [pc, #240]	; (c0d067a8 <starkware_plugin_call+0x674>)
c0d066b8:	4479      	add	r1, pc
c0d066ba:	220f      	movs	r2, #15
c0d066bc:	f003 ffdc 	bl	c0d0a678 <__aeabi_memcpy>
                            starkware_get_source_address(msg->msg);
c0d066c0:	69a0      	ldr	r0, [r4, #24]
c0d066c2:	f7ff fcf3 	bl	c0d060ac <starkware_get_source_address>
c0d066c6:	e7da      	b.n	c0d0667e <starkware_plugin_call+0x54a>
c0d066c8:	2a00      	cmp	r2, #0
c0d066ca:	d121      	bne.n	c0d06710 <starkware_plugin_call+0x5dc>
                            strcpy(msg->title, "From ETH Address");
c0d066cc:	6920      	ldr	r0, [r4, #16]
c0d066ce:	4934      	ldr	r1, [pc, #208]	; (c0d067a0 <starkware_plugin_call+0x66c>)
c0d066d0:	4479      	add	r1, pc
c0d066d2:	2211      	movs	r2, #17
c0d066d4:	f003 ffd0 	bl	c0d0a678 <__aeabi_memcpy>
c0d066d8:	69a6      	ldr	r6, [r4, #24]
c0d066da:	2078      	movs	r0, #120	; 0x78
c0d066dc:	7070      	strb	r0, [r6, #1]
c0d066de:	2030      	movs	r0, #48	; 0x30
c0d066e0:	7030      	strb	r0, [r6, #0]
c0d066e2:	4819      	ldr	r0, [pc, #100]	; (c0d06748 <starkware_plugin_call+0x614>)
c0d066e4:	6803      	ldr	r3, [r0, #0]
c0d066e6:	3525      	adds	r5, #37	; 0x25
c0d066e8:	1cb1      	adds	r1, r6, #2
c0d066ea:	4a19      	ldr	r2, [pc, #100]	; (c0d06750 <starkware_plugin_call+0x61c>)
c0d066ec:	4628      	mov	r0, r5
c0d066ee:	f7fb fefb 	bl	c0d024e8 <getEthAddressStringFromBinary>
c0d066f2:	202a      	movs	r0, #42	; 0x2a
c0d066f4:	2100      	movs	r1, #0
c0d066f6:	5431      	strb	r1, [r6, r0]
c0d066f8:	e7c1      	b.n	c0d0667e <starkware_plugin_call+0x54a>
                    switch (context->selectorIndex) {
c0d066fa:	2800      	cmp	r0, #0
c0d066fc:	d11e      	bne.n	c0d0673c <starkware_plugin_call+0x608>
c0d066fe:	e6df      	b.n	c0d064c0 <starkware_plugin_call+0x38c>
                    switch (context->selectorIndex) {
c0d06700:	280a      	cmp	r0, #10
c0d06702:	d014      	beq.n	c0d0672e <starkware_plugin_call+0x5fa>
c0d06704:	e01a      	b.n	c0d0673c <starkware_plugin_call+0x608>
                            strcpy(msg->title, "Asset Contract");
c0d06706:	6920      	ldr	r0, [r4, #16]
c0d06708:	492a      	ldr	r1, [pc, #168]	; (c0d067b4 <starkware_plugin_call+0x680>)
c0d0670a:	4479      	add	r1, pc
c0d0670c:	220f      	movs	r2, #15
c0d0670e:	e678      	b.n	c0d06402 <starkware_plugin_call+0x2ce>
                            strcpy(msg->title, "Amount");
c0d06710:	6920      	ldr	r0, [r4, #16]
c0d06712:	4924      	ldr	r1, [pc, #144]	; (c0d067a4 <starkware_plugin_call+0x670>)
c0d06714:	4479      	add	r1, pc
c0d06716:	2207      	movs	r2, #7
c0d06718:	f003 ffae 	bl	c0d0a678 <__aeabi_memcpy>
                            starkware_print_amount(context->amount, msg->msg, true);
c0d0671c:	69a1      	ldr	r1, [r4, #24]
c0d0671e:	3525      	adds	r5, #37	; 0x25
c0d06720:	2201      	movs	r2, #1
c0d06722:	4628      	mov	r0, r5
c0d06724:	f7ff fc2a 	bl	c0d05f7c <starkware_print_amount>
c0d06728:	e7a9      	b.n	c0d0667e <starkware_plugin_call+0x54a>
c0d0672a:	2800      	cmp	r0, #0
c0d0672c:	d106      	bne.n	c0d0673c <starkware_plugin_call+0x608>
c0d0672e:	68e1      	ldr	r1, [r4, #12]
c0d06730:	3525      	adds	r5, #37	; 0x25
c0d06732:	310c      	adds	r1, #12
c0d06734:	2214      	movs	r2, #20
c0d06736:	4628      	mov	r0, r5
c0d06738:	f003 ffa2 	bl	c0d0a680 <__aeabi_memmove>
c0d0673c:	2001      	movs	r0, #1
c0d0673e:	7520      	strb	r0, [r4, #20]
c0d06740:	b003      	add	sp, #12
c0d06742:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d06744:	20001be4 	.word	0x20001be4
c0d06748:	20001be0 	.word	0x20001be0
c0d0674c:	20001804 	.word	0x20001804
c0d06750:	20001d60 	.word	0x20001d60
c0d06754:	200018dc 	.word	0x200018dc
c0d06758:	0000fdfe 	.word	0x0000fdfe
c0d0675c:	0000ddfe 	.word	0x0000ddfe
c0d06760:	000060cb 	.word	0x000060cb
c0d06764:	00004b77 	.word	0x00004b77
c0d06768:	00004acb 	.word	0x00004acb
c0d0676c:	000060f6 	.word	0x000060f6
c0d06770:	00005f9e 	.word	0x00005f9e
c0d06774:	00005d97 	.word	0x00005d97
c0d06778:	00005f9e 	.word	0x00005f9e
c0d0677c:	0000603c 	.word	0x0000603c
c0d06780:	00005f74 	.word	0x00005f74
c0d06784:	00006008 	.word	0x00006008
c0d06788:	00005f98 	.word	0x00005f98
c0d0678c:	00005f1b 	.word	0x00005f1b
c0d06790:	00005ef4 	.word	0x00005ef4
c0d06794:	00004eea 	.word	0x00004eea
c0d06798:	00005eb3 	.word	0x00005eb3
c0d0679c:	00005fec 	.word	0x00005fec
c0d067a0:	00005e30 	.word	0x00005e30
c0d067a4:	0000492a 	.word	0x0000492a
c0d067a8:	00005e7c 	.word	0x00005e7c
c0d067ac:	00005da2 	.word	0x00005da2
c0d067b0:	00005f3e 	.word	0x00005f3e
c0d067b4:	00005e3a 	.word	0x00005e3a
c0d067b8:	000049ae 	.word	0x000049ae
c0d067bc:	00005ece 	.word	0x00005ece
c0d067c0:	000056c2 	.word	0x000056c2
c0d067c4:	00005fe2 	.word	0x00005fe2
c0d067c8:	00004f0e 	.word	0x00004f0e
c0d067cc:	00005ff6 	.word	0x00005ff6

c0d067d0 <SVC_Call>:

// avoid a separate asm file, but avoid any intrusion from the compiler
__attribute__((naked)) void SVC_Call(unsigned int syscall_id, volatile unsigned int * parameters);
__attribute__((naked)) void SVC_Call(__attribute__((unused)) unsigned int syscall_id, __attribute__((unused)) volatile unsigned int * parameters) {
  // delegate svc, ensure no optimization by gcc with naked and r0, r1 marked as clobbered
  asm volatile("svc #1":::"r0","r1");
c0d067d0:	df01      	svc	1
  asm volatile("bx  lr");
c0d067d2:	4770      	bx	lr

c0d067d4 <check_api_level>:
}
void check_api_level ( unsigned int apiLevel ) 
{
c0d067d4:	b580      	push	{r7, lr}
c0d067d6:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
  parameters[0] = (unsigned int)apiLevel;
c0d067d8:	9001      	str	r0, [sp, #4]
c0d067da:	4803      	ldr	r0, [pc, #12]	; (c0d067e8 <check_api_level+0x14>)
c0d067dc:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_check_api_level_ID_IN, parameters);
c0d067de:	f7ff fff7 	bl	c0d067d0 <SVC_Call>
}
c0d067e2:	b004      	add	sp, #16
c0d067e4:	bd80      	pop	{r7, pc}
c0d067e6:	46c0      	nop			; (mov r8, r8)
c0d067e8:	60000137 	.word	0x60000137

c0d067ec <halt>:

void halt ( void ) 
{
c0d067ec:	b580      	push	{r7, lr}
c0d067ee:	b082      	sub	sp, #8
c0d067f0:	4802      	ldr	r0, [pc, #8]	; (c0d067fc <halt+0x10>)
c0d067f2:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
  SVC_Call(SYSCALL_halt_ID_IN, parameters);
c0d067f4:	f7ff ffec 	bl	c0d067d0 <SVC_Call>
}
c0d067f8:	b002      	add	sp, #8
c0d067fa:	bd80      	pop	{r7, pc}
c0d067fc:	6000023c 	.word	0x6000023c

c0d06800 <nvm_write>:

void nvm_write ( void * dst_adr, void * src_adr, unsigned int src_len ) 
{
c0d06800:	b580      	push	{r7, lr}
c0d06802:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)dst_adr;
c0d06804:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)src_adr;
c0d06806:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)src_len;
c0d06808:	9203      	str	r2, [sp, #12]
c0d0680a:	4803      	ldr	r0, [pc, #12]	; (c0d06818 <nvm_write+0x18>)
c0d0680c:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_nvm_write_ID_IN, parameters);
c0d0680e:	f7ff ffdf 	bl	c0d067d0 <SVC_Call>
}
c0d06812:	b006      	add	sp, #24
c0d06814:	bd80      	pop	{r7, pc}
c0d06816:	46c0      	nop			; (mov r8, r8)
c0d06818:	6000037f 	.word	0x6000037f

c0d0681c <cx_rng>:
  SVC_Call(SYSCALL_cx_rng_u8_ID_IN, parameters);
  return (unsigned char)(((volatile unsigned int*)parameters)[1]);
}

unsigned char * cx_rng ( unsigned char * buffer, unsigned int len ) 
{
c0d0681c:	b580      	push	{r7, lr}
c0d0681e:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+2];
  parameters[0] = (unsigned int)buffer;
c0d06820:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)len;
c0d06822:	9101      	str	r1, [sp, #4]
c0d06824:	4803      	ldr	r0, [pc, #12]	; (c0d06834 <cx_rng+0x18>)
c0d06826:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_rng_ID_IN, parameters);
c0d06828:	f7ff ffd2 	bl	c0d067d0 <SVC_Call>
  return (unsigned char *)(((volatile unsigned int*)parameters)[1]);
c0d0682c:	9801      	ldr	r0, [sp, #4]
c0d0682e:	b004      	add	sp, #16
c0d06830:	bd80      	pop	{r7, pc}
c0d06832:	46c0      	nop			; (mov r8, r8)
c0d06834:	6000052c 	.word	0x6000052c

c0d06838 <cx_hash>:
}

int cx_hash ( cx_hash_t * hash, int mode, const unsigned char * in, unsigned int len, unsigned char * out, unsigned int out_len ) 
{
c0d06838:	b580      	push	{r7, lr}
c0d0683a:	b088      	sub	sp, #32
  volatile unsigned int parameters [2+6];
  parameters[0] = (unsigned int)hash;
c0d0683c:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)mode;
c0d0683e:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)in;
c0d06840:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)len;
c0d06842:	9303      	str	r3, [sp, #12]
c0d06844:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[4] = (unsigned int)out;
c0d06846:	9004      	str	r0, [sp, #16]
c0d06848:	980b      	ldr	r0, [sp, #44]	; 0x2c
  parameters[5] = (unsigned int)out_len;
c0d0684a:	9005      	str	r0, [sp, #20]
c0d0684c:	4803      	ldr	r0, [pc, #12]	; (c0d0685c <cx_hash+0x24>)
c0d0684e:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_hash_ID_IN, parameters);
c0d06850:	f7ff ffbe 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d06854:	9801      	ldr	r0, [sp, #4]
c0d06856:	b008      	add	sp, #32
c0d06858:	bd80      	pop	{r7, pc}
c0d0685a:	46c0      	nop			; (mov r8, r8)
c0d0685c:	6000073b 	.word	0x6000073b

c0d06860 <cx_sha256_init>:
  SVC_Call(SYSCALL_cx_sha224_init_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

int cx_sha256_init ( cx_sha256_t * hash ) 
{
c0d06860:	b580      	push	{r7, lr}
c0d06862:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  parameters[0] = (unsigned int)hash;
c0d06864:	9001      	str	r0, [sp, #4]
c0d06866:	4803      	ldr	r0, [pc, #12]	; (c0d06874 <cx_sha256_init+0x14>)
c0d06868:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_sha256_init_ID_IN, parameters);
c0d0686a:	f7ff ffb1 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d0686e:	9802      	ldr	r0, [sp, #8]
c0d06870:	b004      	add	sp, #16
c0d06872:	bd80      	pop	{r7, pc}
c0d06874:	60000adb 	.word	0x60000adb

c0d06878 <cx_hash_sha256>:
}

int cx_hash_sha256 ( const unsigned char * in, unsigned int len, unsigned char * out, unsigned int out_len ) 
{
c0d06878:	b580      	push	{r7, lr}
c0d0687a:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)in;
c0d0687c:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)len;
c0d0687e:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)out;
c0d06880:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)out_len;
c0d06882:	9303      	str	r3, [sp, #12]
c0d06884:	4803      	ldr	r0, [pc, #12]	; (c0d06894 <cx_hash_sha256+0x1c>)
c0d06886:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_hash_sha256_ID_IN, parameters);
c0d06888:	f7ff ffa2 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d0688c:	9801      	ldr	r0, [sp, #4]
c0d0688e:	b006      	add	sp, #24
c0d06890:	bd80      	pop	{r7, pc}
c0d06892:	46c0      	nop			; (mov r8, r8)
c0d06894:	60000b2c 	.word	0x60000b2c

c0d06898 <cx_keccak_init>:
  SVC_Call(SYSCALL_cx_sha3_init_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

int cx_keccak_init ( cx_sha3_t * hash, unsigned int size ) 
{
c0d06898:	b580      	push	{r7, lr}
c0d0689a:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+2];
  parameters[0] = (unsigned int)hash;
c0d0689c:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)size;
c0d0689e:	9101      	str	r1, [sp, #4]
c0d068a0:	4803      	ldr	r0, [pc, #12]	; (c0d068b0 <cx_keccak_init+0x18>)
c0d068a2:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_keccak_init_ID_IN, parameters);
c0d068a4:	f7ff ff94 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d068a8:	9801      	ldr	r0, [sp, #4]
c0d068aa:	b004      	add	sp, #16
c0d068ac:	bd80      	pop	{r7, pc}
c0d068ae:	46c0      	nop			; (mov r8, r8)
c0d068b0:	600010cf 	.word	0x600010cf

c0d068b4 <cx_ecfp_add_point>:
  SVC_Call(SYSCALL_cx_ecfp_is_cryptographic_point_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

int cx_ecfp_add_point ( cx_curve_t curve, unsigned char * R, const unsigned char * P, const unsigned char * Q, unsigned int X_len ) 
{
c0d068b4:	b580      	push	{r7, lr}
c0d068b6:	b088      	sub	sp, #32
  volatile unsigned int parameters [2+5];
  parameters[0] = (unsigned int)curve;
c0d068b8:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)R;
c0d068ba:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)P;
c0d068bc:	9203      	str	r2, [sp, #12]
  parameters[3] = (unsigned int)Q;
c0d068be:	9304      	str	r3, [sp, #16]
c0d068c0:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[4] = (unsigned int)X_len;
c0d068c2:	9005      	str	r0, [sp, #20]
c0d068c4:	4803      	ldr	r0, [pc, #12]	; (c0d068d4 <cx_ecfp_add_point+0x20>)
c0d068c6:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_ecfp_add_point_ID_IN, parameters);
c0d068c8:	f7ff ff82 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d068cc:	9802      	ldr	r0, [sp, #8]
c0d068ce:	b008      	add	sp, #32
c0d068d0:	bd80      	pop	{r7, pc}
c0d068d2:	46c0      	nop			; (mov r8, r8)
c0d068d4:	60002b17 	.word	0x60002b17

c0d068d8 <cx_ecfp_scalar_mult>:
}

int cx_ecfp_scalar_mult ( cx_curve_t curve, unsigned char * P, unsigned int P_len, const unsigned char * k, unsigned int k_len ) 
{
c0d068d8:	b580      	push	{r7, lr}
c0d068da:	b088      	sub	sp, #32
  volatile unsigned int parameters [2+5];
  parameters[0] = (unsigned int)curve;
c0d068dc:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)P;
c0d068de:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)P_len;
c0d068e0:	9203      	str	r2, [sp, #12]
  parameters[3] = (unsigned int)k;
c0d068e2:	9304      	str	r3, [sp, #16]
c0d068e4:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[4] = (unsigned int)k_len;
c0d068e6:	9005      	str	r0, [sp, #20]
c0d068e8:	4803      	ldr	r0, [pc, #12]	; (c0d068f8 <cx_ecfp_scalar_mult+0x20>)
c0d068ea:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_ecfp_scalar_mult_ID_IN, parameters);
c0d068ec:	f7ff ff70 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d068f0:	9802      	ldr	r0, [sp, #8]
c0d068f2:	b008      	add	sp, #32
c0d068f4:	bd80      	pop	{r7, pc}
c0d068f6:	46c0      	nop			; (mov r8, r8)
c0d068f8:	60002cf3 	.word	0x60002cf3

c0d068fc <cx_ecfp_init_public_key>:
}

int cx_ecfp_init_public_key ( cx_curve_t curve, const unsigned char * rawkey, unsigned int key_len, cx_ecfp_public_key_t * key ) 
{
c0d068fc:	b580      	push	{r7, lr}
c0d068fe:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)curve;
c0d06900:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)rawkey;
c0d06902:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)key_len;
c0d06904:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)key;
c0d06906:	9303      	str	r3, [sp, #12]
c0d06908:	4803      	ldr	r0, [pc, #12]	; (c0d06918 <cx_ecfp_init_public_key+0x1c>)
c0d0690a:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_ecfp_init_public_key_ID_IN, parameters);
c0d0690c:	f7ff ff60 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d06910:	9801      	ldr	r0, [sp, #4]
c0d06912:	b006      	add	sp, #24
c0d06914:	bd80      	pop	{r7, pc}
c0d06916:	46c0      	nop			; (mov r8, r8)
c0d06918:	60002ded 	.word	0x60002ded

c0d0691c <cx_ecfp_init_private_key>:
}

int cx_ecfp_init_private_key ( cx_curve_t curve, const unsigned char * rawkey, unsigned int key_len, cx_ecfp_private_key_t * pvkey ) 
{
c0d0691c:	b580      	push	{r7, lr}
c0d0691e:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)curve;
c0d06920:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)rawkey;
c0d06922:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)key_len;
c0d06924:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)pvkey;
c0d06926:	9303      	str	r3, [sp, #12]
c0d06928:	4803      	ldr	r0, [pc, #12]	; (c0d06938 <cx_ecfp_init_private_key+0x1c>)
c0d0692a:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_ecfp_init_private_key_ID_IN, parameters);
c0d0692c:	f7ff ff50 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d06930:	9801      	ldr	r0, [sp, #4]
c0d06932:	b006      	add	sp, #24
c0d06934:	bd80      	pop	{r7, pc}
c0d06936:	46c0      	nop			; (mov r8, r8)
c0d06938:	60002eea 	.word	0x60002eea

c0d0693c <cx_ecfp_generate_pair>:
}

int cx_ecfp_generate_pair ( cx_curve_t curve, cx_ecfp_public_key_t * pubkey, cx_ecfp_private_key_t * privkey, int keepprivate ) 
{
c0d0693c:	b580      	push	{r7, lr}
c0d0693e:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)curve;
c0d06940:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)pubkey;
c0d06942:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)privkey;
c0d06944:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)keepprivate;
c0d06946:	9303      	str	r3, [sp, #12]
c0d06948:	4803      	ldr	r0, [pc, #12]	; (c0d06958 <cx_ecfp_generate_pair+0x1c>)
c0d0694a:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_ecfp_generate_pair_ID_IN, parameters);
c0d0694c:	f7ff ff40 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d06950:	9801      	ldr	r0, [sp, #4]
c0d06952:	b006      	add	sp, #24
c0d06954:	bd80      	pop	{r7, pc}
c0d06956:	46c0      	nop			; (mov r8, r8)
c0d06958:	60002f2e 	.word	0x60002f2e

c0d0695c <cx_ecdsa_sign>:
  SVC_Call(SYSCALL_cx_ecfp_generate_pair2_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

int cx_ecdsa_sign ( const cx_ecfp_private_key_t * pvkey, int mode, cx_md_t hashID, const unsigned char * hash, unsigned int hash_len, unsigned char * sig, unsigned int sig_len, unsigned int * info ) 
{
c0d0695c:	b580      	push	{r7, lr}
c0d0695e:	b08a      	sub	sp, #40	; 0x28
  volatile unsigned int parameters [2+8];
  parameters[0] = (unsigned int)pvkey;
c0d06960:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)mode;
c0d06962:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)hashID;
c0d06964:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)hash;
c0d06966:	9303      	str	r3, [sp, #12]
c0d06968:	980c      	ldr	r0, [sp, #48]	; 0x30
  parameters[4] = (unsigned int)hash_len;
c0d0696a:	9004      	str	r0, [sp, #16]
c0d0696c:	980d      	ldr	r0, [sp, #52]	; 0x34
  parameters[5] = (unsigned int)sig;
c0d0696e:	9005      	str	r0, [sp, #20]
c0d06970:	980e      	ldr	r0, [sp, #56]	; 0x38
  parameters[6] = (unsigned int)sig_len;
c0d06972:	9006      	str	r0, [sp, #24]
c0d06974:	980f      	ldr	r0, [sp, #60]	; 0x3c
  parameters[7] = (unsigned int)info;
c0d06976:	9007      	str	r0, [sp, #28]
c0d06978:	4803      	ldr	r0, [pc, #12]	; (c0d06988 <cx_ecdsa_sign+0x2c>)
c0d0697a:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_ecdsa_sign_ID_IN, parameters);
c0d0697c:	f7ff ff28 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d06980:	9801      	ldr	r0, [sp, #4]
c0d06982:	b00a      	add	sp, #40	; 0x28
c0d06984:	bd80      	pop	{r7, pc}
c0d06986:	46c0      	nop			; (mov r8, r8)
c0d06988:	600038f3 	.word	0x600038f3

c0d0698c <cx_ecdsa_verify>:
}

int cx_ecdsa_verify ( const cx_ecfp_public_key_t * pukey, int mode, cx_md_t hashID, const unsigned char * hash, unsigned int hash_len, const unsigned char * sig, unsigned int sig_len ) 
{
c0d0698c:	b580      	push	{r7, lr}
c0d0698e:	b08a      	sub	sp, #40	; 0x28
  volatile unsigned int parameters [2+7];
  parameters[0] = (unsigned int)pukey;
c0d06990:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)mode;
c0d06992:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)hashID;
c0d06994:	9203      	str	r2, [sp, #12]
  parameters[3] = (unsigned int)hash;
c0d06996:	9304      	str	r3, [sp, #16]
c0d06998:	980c      	ldr	r0, [sp, #48]	; 0x30
  parameters[4] = (unsigned int)hash_len;
c0d0699a:	9005      	str	r0, [sp, #20]
c0d0699c:	980d      	ldr	r0, [sp, #52]	; 0x34
  parameters[5] = (unsigned int)sig;
c0d0699e:	9006      	str	r0, [sp, #24]
c0d069a0:	980e      	ldr	r0, [sp, #56]	; 0x38
  parameters[6] = (unsigned int)sig_len;
c0d069a2:	9007      	str	r0, [sp, #28]
c0d069a4:	4803      	ldr	r0, [pc, #12]	; (c0d069b4 <cx_ecdsa_verify+0x28>)
c0d069a6:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_ecdsa_verify_ID_IN, parameters);
c0d069a8:	f7ff ff12 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d069ac:	9802      	ldr	r0, [sp, #8]
c0d069ae:	b00a      	add	sp, #40	; 0x28
c0d069b0:	bd80      	pop	{r7, pc}
c0d069b2:	46c0      	nop			; (mov r8, r8)
c0d069b4:	600039f1 	.word	0x600039f1

c0d069b8 <cx_crc16_update>:
  SVC_Call(SYSCALL_cx_crc16_ID_IN, parameters);
  return (unsigned short)(((volatile unsigned int*)parameters)[1]);
}

unsigned short cx_crc16_update ( unsigned short crc, const void * buffer, size_t len ) 
{
c0d069b8:	b580      	push	{r7, lr}
c0d069ba:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)crc;
c0d069bc:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)buffer;
c0d069be:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)len;
c0d069c0:	9203      	str	r2, [sp, #12]
c0d069c2:	4804      	ldr	r0, [pc, #16]	; (c0d069d4 <cx_crc16_update+0x1c>)
c0d069c4:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_crc16_update_ID_IN, parameters);
c0d069c6:	f7ff ff03 	bl	c0d067d0 <SVC_Call>
  return (unsigned short)(((volatile unsigned int*)parameters)[1]);
c0d069ca:	9802      	ldr	r0, [sp, #8]
c0d069cc:	b280      	uxth	r0, r0
c0d069ce:	b006      	add	sp, #24
c0d069d0:	bd80      	pop	{r7, pc}
c0d069d2:	46c0      	nop			; (mov r8, r8)
c0d069d4:	6000926e 	.word	0x6000926e

c0d069d8 <cx_math_cmp>:
}

int cx_math_cmp ( const unsigned char * a, const unsigned char * b, unsigned int len ) 
{
c0d069d8:	b580      	push	{r7, lr}
c0d069da:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)a;
c0d069dc:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)b;
c0d069de:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)len;
c0d069e0:	9203      	str	r2, [sp, #12]
c0d069e2:	4803      	ldr	r0, [pc, #12]	; (c0d069f0 <cx_math_cmp+0x18>)
c0d069e4:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_math_cmp_ID_IN, parameters);
c0d069e6:	f7ff fef3 	bl	c0d067d0 <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d069ea:	9802      	ldr	r0, [sp, #8]
c0d069ec:	b006      	add	sp, #24
c0d069ee:	bd80      	pop	{r7, pc}
c0d069f0:	60003d5b 	.word	0x60003d5b

c0d069f4 <cx_math_mult>:
  SVC_Call(SYSCALL_cx_math_sub_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

void cx_math_mult ( unsigned char * r, const unsigned char * a, const unsigned char * b, unsigned int len ) 
{
c0d069f4:	b580      	push	{r7, lr}
c0d069f6:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)r;
c0d069f8:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)a;
c0d069fa:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)b;
c0d069fc:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)len;
c0d069fe:	9303      	str	r3, [sp, #12]
c0d06a00:	4802      	ldr	r0, [pc, #8]	; (c0d06a0c <cx_math_mult+0x18>)
c0d06a02:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_math_mult_ID_IN, parameters);
c0d06a04:	f7ff fee4 	bl	c0d067d0 <SVC_Call>
}
c0d06a08:	b006      	add	sp, #24
c0d06a0a:	bd80      	pop	{r7, pc}
c0d06a0c:	6000413e 	.word	0x6000413e

c0d06a10 <cx_math_modm>:
  parameters[5] = (unsigned int)len;
  SVC_Call(SYSCALL_cx_math_powm_ID_IN, parameters);
}

void cx_math_modm ( unsigned char * v, unsigned int len_v, const unsigned char * m, unsigned int len_m ) 
{
c0d06a10:	b580      	push	{r7, lr}
c0d06a12:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)v;
c0d06a14:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)len_v;
c0d06a16:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)m;
c0d06a18:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)len_m;
c0d06a1a:	9303      	str	r3, [sp, #12]
c0d06a1c:	4802      	ldr	r0, [pc, #8]	; (c0d06a28 <cx_math_modm+0x18>)
c0d06a1e:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_math_modm_ID_IN, parameters);
c0d06a20:	f7ff fed6 	bl	c0d067d0 <SVC_Call>
}
c0d06a24:	b006      	add	sp, #24
c0d06a26:	bd80      	pop	{r7, pc}
c0d06a28:	60004645 	.word	0x60004645

c0d06a2c <os_perso_isonboarded>:
  volatile unsigned int parameters [2];
  SVC_Call(SYSCALL_os_perso_finalize_ID_IN, parameters);
}

bolos_bool_t os_perso_isonboarded ( void ) 
{
c0d06a2c:	b580      	push	{r7, lr}
c0d06a2e:	b082      	sub	sp, #8
c0d06a30:	4803      	ldr	r0, [pc, #12]	; (c0d06a40 <os_perso_isonboarded+0x14>)
c0d06a32:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_os_perso_isonboarded_ID_IN, parameters);
c0d06a34:	f7ff fecc 	bl	c0d067d0 <SVC_Call>
  return (bolos_bool_t)(((volatile unsigned int*)parameters)[1]);
c0d06a38:	9801      	ldr	r0, [sp, #4]
c0d06a3a:	b2c0      	uxtb	r0, r0
c0d06a3c:	b002      	add	sp, #8
c0d06a3e:	bd80      	pop	{r7, pc}
c0d06a40:	60009f4f 	.word	0x60009f4f

c0d06a44 <os_perso_derive_node_bip32>:
}

void os_perso_derive_node_bip32 ( cx_curve_t curve, const unsigned int * path, unsigned int pathLength, unsigned char * privateKey, unsigned char * chain ) 
{
c0d06a44:	b580      	push	{r7, lr}
c0d06a46:	b088      	sub	sp, #32
  volatile unsigned int parameters [2+5];
  parameters[0] = (unsigned int)curve;
c0d06a48:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)path;
c0d06a4a:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)pathLength;
c0d06a4c:	9203      	str	r2, [sp, #12]
  parameters[3] = (unsigned int)privateKey;
c0d06a4e:	9304      	str	r3, [sp, #16]
c0d06a50:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[4] = (unsigned int)chain;
c0d06a52:	9005      	str	r0, [sp, #20]
c0d06a54:	4802      	ldr	r0, [pc, #8]	; (c0d06a60 <os_perso_derive_node_bip32+0x1c>)
c0d06a56:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_perso_derive_node_bip32_ID_IN, parameters);
c0d06a58:	f7ff feba 	bl	c0d067d0 <SVC_Call>
}
c0d06a5c:	b008      	add	sp, #32
c0d06a5e:	bd80      	pop	{r7, pc}
c0d06a60:	600053ba 	.word	0x600053ba

c0d06a64 <os_perso_seed_cookie>:
  parameters[7] = (unsigned int)seed_key_length;
  SVC_Call(SYSCALL_os_perso_derive_node_with_seed_key_ID_IN, parameters);
}

unsigned int os_perso_seed_cookie ( unsigned char * seed_cookie, unsigned int seed_cookie_length ) 
{
c0d06a64:	b580      	push	{r7, lr}
c0d06a66:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+2];
  parameters[0] = (unsigned int)seed_cookie;
c0d06a68:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)seed_cookie_length;
c0d06a6a:	9101      	str	r1, [sp, #4]
c0d06a6c:	4803      	ldr	r0, [pc, #12]	; (c0d06a7c <os_perso_seed_cookie+0x18>)
c0d06a6e:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_os_perso_seed_cookie_ID_IN, parameters);
c0d06a70:	f7ff feae 	bl	c0d067d0 <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d06a74:	9801      	ldr	r0, [sp, #4]
c0d06a76:	b004      	add	sp, #16
c0d06a78:	bd80      	pop	{r7, pc}
c0d06a7a:	46c0      	nop			; (mov r8, r8)
c0d06a7c:	6000a8fc 	.word	0x6000a8fc

c0d06a80 <os_global_pin_is_validated>:
  SVC_Call(SYSCALL_os_endorsement_key2_derive_sign_data_ID_IN, parameters);
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
}

bolos_bool_t os_global_pin_is_validated ( void ) 
{
c0d06a80:	b580      	push	{r7, lr}
c0d06a82:	b082      	sub	sp, #8
c0d06a84:	4803      	ldr	r0, [pc, #12]	; (c0d06a94 <os_global_pin_is_validated+0x14>)
c0d06a86:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_os_global_pin_is_validated_ID_IN, parameters);
c0d06a88:	f7ff fea2 	bl	c0d067d0 <SVC_Call>
  return (bolos_bool_t)(((volatile unsigned int*)parameters)[1]);
c0d06a8c:	9801      	ldr	r0, [sp, #4]
c0d06a8e:	b2c0      	uxtb	r0, r0
c0d06a90:	b002      	add	sp, #8
c0d06a92:	bd80      	pop	{r7, pc}
c0d06a94:	6000a03c 	.word	0x6000a03c

c0d06a98 <os_ux>:
  parameters[1] = (unsigned int)out_application_entry;
  SVC_Call(SYSCALL_os_registry_get_ID_IN, parameters);
}

unsigned int os_ux ( bolos_ux_params_t * params ) 
{
c0d06a98:	b580      	push	{r7, lr}
c0d06a9a:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  parameters[0] = (unsigned int)params;
c0d06a9c:	9001      	str	r0, [sp, #4]
c0d06a9e:	4803      	ldr	r0, [pc, #12]	; (c0d06aac <os_ux+0x14>)
c0d06aa0:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_ux_ID_IN, parameters);
c0d06aa2:	f7ff fe95 	bl	c0d067d0 <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d06aa6:	9802      	ldr	r0, [sp, #8]
c0d06aa8:	b004      	add	sp, #16
c0d06aaa:	bd80      	pop	{r7, pc}
c0d06aac:	60006458 	.word	0x60006458

c0d06ab0 <os_lib_call>:
  parameters[0] = (unsigned int)params;
  SVC_Call(SYSCALL_os_ux_read_parameters_ID_IN, parameters);
}

void os_lib_call ( unsigned int * call_parameters ) 
{
c0d06ab0:	b580      	push	{r7, lr}
c0d06ab2:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
  parameters[0] = (unsigned int)call_parameters;
c0d06ab4:	9001      	str	r0, [sp, #4]
c0d06ab6:	4803      	ldr	r0, [pc, #12]	; (c0d06ac4 <os_lib_call+0x14>)
c0d06ab8:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_lib_call_ID_IN, parameters);
c0d06aba:	f7ff fe89 	bl	c0d067d0 <SVC_Call>
}
c0d06abe:	b004      	add	sp, #16
c0d06ac0:	bd80      	pop	{r7, pc}
c0d06ac2:	46c0      	nop			; (mov r8, r8)
c0d06ac4:	6000670d 	.word	0x6000670d

c0d06ac8 <os_lib_end>:

void os_lib_end ( void ) 
{
c0d06ac8:	b580      	push	{r7, lr}
c0d06aca:	b082      	sub	sp, #8
c0d06acc:	4802      	ldr	r0, [pc, #8]	; (c0d06ad8 <os_lib_end+0x10>)
c0d06ace:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
  SVC_Call(SYSCALL_os_lib_end_ID_IN, parameters);
c0d06ad0:	f7ff fe7e 	bl	c0d067d0 <SVC_Call>
}
c0d06ad4:	b002      	add	sp, #8
c0d06ad6:	bd80      	pop	{r7, pc}
c0d06ad8:	6000688d 	.word	0x6000688d

c0d06adc <os_flags>:
  parameters[0] = (unsigned int)exception;
  SVC_Call(SYSCALL_os_lib_throw_ID_IN, parameters);
}

unsigned int os_flags ( void ) 
{
c0d06adc:	b580      	push	{r7, lr}
c0d06ade:	b082      	sub	sp, #8
c0d06ae0:	4803      	ldr	r0, [pc, #12]	; (c0d06af0 <os_flags+0x14>)
c0d06ae2:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_os_flags_ID_IN, parameters);
c0d06ae4:	f7ff fe74 	bl	c0d067d0 <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d06ae8:	9801      	ldr	r0, [sp, #4]
c0d06aea:	b002      	add	sp, #8
c0d06aec:	bd80      	pop	{r7, pc}
c0d06aee:	46c0      	nop			; (mov r8, r8)
c0d06af0:	60006a6e 	.word	0x60006a6e

c0d06af4 <os_registry_get_current_app_tag>:
  SVC_Call(SYSCALL_os_registry_get_tag_ID_IN, parameters);
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
}

unsigned int os_registry_get_current_app_tag ( unsigned int tag, unsigned char * buffer, unsigned int maxlen ) 
{
c0d06af4:	b580      	push	{r7, lr}
c0d06af6:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)tag;
c0d06af8:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)buffer;
c0d06afa:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)maxlen;
c0d06afc:	9203      	str	r2, [sp, #12]
c0d06afe:	4803      	ldr	r0, [pc, #12]	; (c0d06b0c <os_registry_get_current_app_tag+0x18>)
c0d06b00:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_registry_get_current_app_tag_ID_IN, parameters);
c0d06b02:	f7ff fe65 	bl	c0d067d0 <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d06b06:	9802      	ldr	r0, [sp, #8]
c0d06b08:	b006      	add	sp, #24
c0d06b0a:	bd80      	pop	{r7, pc}
c0d06b0c:	600074d4 	.word	0x600074d4

c0d06b10 <os_sched_exit>:
  parameters[0] = (unsigned int)application_index;
  SVC_Call(SYSCALL_os_sched_exec_ID_IN, parameters);
}

void os_sched_exit ( bolos_task_status_t exit_code ) 
{
c0d06b10:	b580      	push	{r7, lr}
c0d06b12:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
  parameters[0] = (unsigned int)exit_code;
c0d06b14:	9001      	str	r0, [sp, #4]
c0d06b16:	4803      	ldr	r0, [pc, #12]	; (c0d06b24 <os_sched_exit+0x14>)
c0d06b18:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_sched_exit_ID_IN, parameters);
c0d06b1a:	f7ff fe59 	bl	c0d067d0 <SVC_Call>
}
c0d06b1e:	b004      	add	sp, #16
c0d06b20:	bd80      	pop	{r7, pc}
c0d06b22:	46c0      	nop			; (mov r8, r8)
c0d06b24:	60009abe 	.word	0x60009abe

c0d06b28 <io_seph_send>:
  parameters[0] = (unsigned int)taskidx;
  SVC_Call(SYSCALL_os_sched_kill_ID_IN, parameters);
}

void io_seph_send ( const unsigned char * buffer, unsigned short length ) 
{
c0d06b28:	b580      	push	{r7, lr}
c0d06b2a:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+2];
  parameters[0] = (unsigned int)buffer;
c0d06b2c:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)length;
c0d06b2e:	9101      	str	r1, [sp, #4]
c0d06b30:	4802      	ldr	r0, [pc, #8]	; (c0d06b3c <io_seph_send+0x14>)
c0d06b32:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_io_seph_send_ID_IN, parameters);
c0d06b34:	f7ff fe4c 	bl	c0d067d0 <SVC_Call>
}
c0d06b38:	b004      	add	sp, #16
c0d06b3a:	bd80      	pop	{r7, pc}
c0d06b3c:	60008381 	.word	0x60008381

c0d06b40 <io_seph_is_status_sent>:

unsigned int io_seph_is_status_sent ( void ) 
{
c0d06b40:	b580      	push	{r7, lr}
c0d06b42:	b082      	sub	sp, #8
c0d06b44:	4803      	ldr	r0, [pc, #12]	; (c0d06b54 <io_seph_is_status_sent+0x14>)
c0d06b46:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_io_seph_is_status_sent_ID_IN, parameters);
c0d06b48:	f7ff fe42 	bl	c0d067d0 <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d06b4c:	9801      	ldr	r0, [sp, #4]
c0d06b4e:	b002      	add	sp, #8
c0d06b50:	bd80      	pop	{r7, pc}
c0d06b52:	46c0      	nop			; (mov r8, r8)
c0d06b54:	600084bb 	.word	0x600084bb

c0d06b58 <io_seph_recv>:
}

unsigned short io_seph_recv ( unsigned char * buffer, unsigned short maxlength, unsigned int flags ) 
{
c0d06b58:	b580      	push	{r7, lr}
c0d06b5a:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)buffer;
c0d06b5c:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)maxlength;
c0d06b5e:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)flags;
c0d06b60:	9203      	str	r2, [sp, #12]
c0d06b62:	4804      	ldr	r0, [pc, #16]	; (c0d06b74 <io_seph_recv+0x1c>)
c0d06b64:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_io_seph_recv_ID_IN, parameters);
c0d06b66:	f7ff fe33 	bl	c0d067d0 <SVC_Call>
  return (unsigned short)(((volatile unsigned int*)parameters)[1]);
c0d06b6a:	9802      	ldr	r0, [sp, #8]
c0d06b6c:	b280      	uxth	r0, r0
c0d06b6e:	b006      	add	sp, #24
c0d06b70:	bd80      	pop	{r7, pc}
c0d06b72:	46c0      	nop			; (mov r8, r8)
c0d06b74:	600085e4 	.word	0x600085e4

c0d06b78 <try_context_get>:
  parameters[0] = (unsigned int)page_adr;
  SVC_Call(SYSCALL_nvm_write_page_ID_IN, parameters);
}

try_context_t * try_context_get ( void ) 
{
c0d06b78:	b580      	push	{r7, lr}
c0d06b7a:	b082      	sub	sp, #8
c0d06b7c:	4803      	ldr	r0, [pc, #12]	; (c0d06b8c <try_context_get+0x14>)
c0d06b7e:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_try_context_get_ID_IN, parameters);
c0d06b80:	f7ff fe26 	bl	c0d067d0 <SVC_Call>
  return (try_context_t *)(((volatile unsigned int*)parameters)[1]);
c0d06b84:	9801      	ldr	r0, [sp, #4]
c0d06b86:	b002      	add	sp, #8
c0d06b88:	bd80      	pop	{r7, pc}
c0d06b8a:	46c0      	nop			; (mov r8, r8)
c0d06b8c:	600087b1 	.word	0x600087b1

c0d06b90 <try_context_set>:
}

try_context_t * try_context_set ( try_context_t * context ) 
{
c0d06b90:	b580      	push	{r7, lr}
c0d06b92:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  parameters[0] = (unsigned int)context;
c0d06b94:	9001      	str	r0, [sp, #4]
c0d06b96:	4803      	ldr	r0, [pc, #12]	; (c0d06ba4 <try_context_set+0x14>)
c0d06b98:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_try_context_set_ID_IN, parameters);
c0d06b9a:	f7ff fe19 	bl	c0d067d0 <SVC_Call>
  return (try_context_t *)(((volatile unsigned int*)parameters)[1]);
c0d06b9e:	9802      	ldr	r0, [sp, #8]
c0d06ba0:	b004      	add	sp, #16
c0d06ba2:	bd80      	pop	{r7, pc}
c0d06ba4:	60008875 	.word	0x60008875

c0d06ba8 <os_sched_last_status>:
  SVC_Call(SYSCALL_cx_rng_u32_ID_IN, parameters);
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
}

bolos_task_status_t os_sched_last_status ( unsigned int task_idx ) 
{
c0d06ba8:	b580      	push	{r7, lr}
c0d06baa:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  parameters[0] = (unsigned int)task_idx;
c0d06bac:	9001      	str	r0, [sp, #4]
c0d06bae:	4804      	ldr	r0, [pc, #16]	; (c0d06bc0 <os_sched_last_status+0x18>)
c0d06bb0:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_sched_last_status_ID_IN, parameters);
c0d06bb2:	f7ff fe0d 	bl	c0d067d0 <SVC_Call>
  return (bolos_task_status_t)(((volatile unsigned int*)parameters)[1]);
c0d06bb6:	9802      	ldr	r0, [sp, #8]
c0d06bb8:	b2c0      	uxtb	r0, r0
c0d06bba:	b004      	add	sp, #16
c0d06bbc:	bd80      	pop	{r7, pc}
c0d06bbe:	46c0      	nop			; (mov r8, r8)
c0d06bc0:	60009c8b 	.word	0x60009c8b

c0d06bc4 <u2f_apdu_sign>:

    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)SW_INTERNAL, sizeof(SW_INTERNAL));
}

void u2f_apdu_sign(u2f_service_t *service, uint8_t p1, uint8_t p2,
                     uint8_t *buffer, uint16_t length) {
c0d06bc4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06bc6:	b083      	sub	sp, #12
    UNUSED(p2);
    uint8_t keyHandleLength;
    uint8_t i;

    // can't process the apdu if another one is already scheduled in
    if (G_io_app.apdu_state != APDU_IDLE) {
c0d06bc8:	4a36      	ldr	r2, [pc, #216]	; (c0d06ca4 <u2f_apdu_sign+0xe0>)
c0d06bca:	7812      	ldrb	r2, [r2, #0]
c0d06bcc:	2a00      	cmp	r2, #0
c0d06bce:	d003      	beq.n	c0d06bd8 <u2f_apdu_sign+0x14>
c0d06bd0:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d06bd2:	4a36      	ldr	r2, [pc, #216]	; (c0d06cac <u2f_apdu_sign+0xe8>)
c0d06bd4:	447a      	add	r2, pc
c0d06bd6:	e00b      	b.n	c0d06bf0 <u2f_apdu_sign+0x2c>
c0d06bd8:	9a08      	ldr	r2, [sp, #32]
                  (uint8_t *)SW_BUSY,
                  sizeof(SW_BUSY));
        return;        
    }

    if (length < U2F_HANDLE_SIGN_HEADER_SIZE + 5 /*at least an apdu header*/) {
c0d06bda:	2a45      	cmp	r2, #69	; 0x45
c0d06bdc:	d803      	bhi.n	c0d06be6 <u2f_apdu_sign+0x22>
c0d06bde:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d06be0:	4a33      	ldr	r2, [pc, #204]	; (c0d06cb0 <u2f_apdu_sign+0xec>)
c0d06be2:	447a      	add	r2, pc
c0d06be4:	e004      	b.n	c0d06bf0 <u2f_apdu_sign+0x2c>
                  sizeof(SW_WRONG_LENGTH));
        return;
    }

    // Confirm immediately if it's just a validation call
    if (p1 == P1_SIGN_CHECK_ONLY) {
c0d06be6:	2907      	cmp	r1, #7
c0d06be8:	d107      	bne.n	c0d06bfa <u2f_apdu_sign+0x36>
c0d06bea:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d06bec:	4a31      	ldr	r2, [pc, #196]	; (c0d06cb4 <u2f_apdu_sign+0xf0>)
c0d06bee:	447a      	add	r2, pc
c0d06bf0:	2302      	movs	r3, #2
c0d06bf2:	f000 fc59 	bl	c0d074a8 <u2f_message_reply>
    app_dispatch();
    if ((btchip_context_D.io_flags & IO_ASYNCH_REPLY) == 0) {
        u2f_proxy_response(service, btchip_context_D.outLength);
    }
    */
}
c0d06bf6:	b003      	add	sp, #12
c0d06bf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d06bfa:	9200      	str	r2, [sp, #0]
c0d06bfc:	9001      	str	r0, [sp, #4]
c0d06bfe:	2040      	movs	r0, #64	; 0x40
c0d06c00:	9302      	str	r3, [sp, #8]
    keyHandleLength = buffer[U2F_HANDLE_SIGN_HEADER_SIZE-1];
c0d06c02:	5c1e      	ldrb	r6, [r3, r0]
    if (keyHandleLength == 5) {
c0d06c04:	2e00      	cmp	r6, #0
c0d06c06:	d01b      	beq.n	c0d06c40 <u2f_apdu_sign+0x7c>
c0d06c08:	2e05      	cmp	r6, #5
c0d06c0a:	9d02      	ldr	r5, [sp, #8]
c0d06c0c:	d109      	bne.n	c0d06c22 <u2f_apdu_sign+0x5e>
        if (os_memcmp(buffer+U2F_HANDLE_SIGN_HEADER_SIZE, "\xF1\xD0\x00\x00\x00", 5) == 0 ) {
c0d06c0e:	4628      	mov	r0, r5
c0d06c10:	3041      	adds	r0, #65	; 0x41
c0d06c12:	4929      	ldr	r1, [pc, #164]	; (c0d06cb8 <u2f_apdu_sign+0xf4>)
c0d06c14:	4479      	add	r1, pc
c0d06c16:	2405      	movs	r4, #5
c0d06c18:	4622      	mov	r2, r4
c0d06c1a:	f7fd fb9d 	bl	c0d04358 <os_memcmp>
c0d06c1e:	2800      	cmp	r0, #0
c0d06c20:	d02b      	beq.n	c0d06c7a <u2f_apdu_sign+0xb6>
        buffer[U2F_HANDLE_SIGN_HEADER_SIZE + i] ^= U2F_PROXY_MAGIC[i % (sizeof(U2F_PROXY_MAGIC)-1)];
c0d06c22:	3541      	adds	r5, #65	; 0x41
c0d06c24:	2400      	movs	r4, #0
c0d06c26:	4f25      	ldr	r7, [pc, #148]	; (c0d06cbc <u2f_apdu_sign+0xf8>)
c0d06c28:	447f      	add	r7, pc
c0d06c2a:	b2e0      	uxtb	r0, r4
c0d06c2c:	2105      	movs	r1, #5
c0d06c2e:	f003 fcff 	bl	c0d0a630 <__aeabi_uidivmod>
c0d06c32:	5d28      	ldrb	r0, [r5, r4]
c0d06c34:	5c79      	ldrb	r1, [r7, r1]
c0d06c36:	4041      	eors	r1, r0
c0d06c38:	5529      	strb	r1, [r5, r4]
    for (i = 0; i < keyHandleLength; i++) {
c0d06c3a:	1c64      	adds	r4, r4, #1
c0d06c3c:	42a6      	cmp	r6, r4
c0d06c3e:	d1f4      	bne.n	c0d06c2a <u2f_apdu_sign+0x66>
c0d06c40:	2045      	movs	r0, #69	; 0x45
c0d06c42:	9902      	ldr	r1, [sp, #8]
    if (length != U2F_HANDLE_SIGN_HEADER_SIZE + 5 + buffer[U2F_HANDLE_SIGN_HEADER_SIZE + 4]) {
c0d06c44:	5c08      	ldrb	r0, [r1, r0]
c0d06c46:	3046      	adds	r0, #70	; 0x46
c0d06c48:	9a00      	ldr	r2, [sp, #0]
c0d06c4a:	4290      	cmp	r0, r2
c0d06c4c:	d10f      	bne.n	c0d06c6e <u2f_apdu_sign+0xaa>
    os_memmove(G_io_apdu_buffer, buffer + U2F_HANDLE_SIGN_HEADER_SIZE, keyHandleLength);
c0d06c4e:	3141      	adds	r1, #65	; 0x41
c0d06c50:	4815      	ldr	r0, [pc, #84]	; (c0d06ca8 <u2f_apdu_sign+0xe4>)
c0d06c52:	4632      	mov	r2, r6
c0d06c54:	f7fd fb61 	bl	c0d0431a <os_memmove>
c0d06c58:	2007      	movs	r0, #7
c0d06c5a:	4912      	ldr	r1, [pc, #72]	; (c0d06ca4 <u2f_apdu_sign+0xe0>)
    G_io_app.apdu_media = IO_APDU_MEDIA_U2F; // the effective transport is managed by the U2F layer
c0d06c5c:	7188      	strb	r0, [r1, #6]
    G_io_app.apdu_length = keyHandleLength;
c0d06c5e:	804e      	strh	r6, [r1, #2]
c0d06c60:	2009      	movs	r0, #9
    G_io_app.apdu_state = APDU_U2F;
c0d06c62:	7008      	strb	r0, [r1, #0]
c0d06c64:	2101      	movs	r1, #1
    u2f_message_set_autoreply_wait_user_presence(service, true);
c0d06c66:	9801      	ldr	r0, [sp, #4]
c0d06c68:	f000 fc0a 	bl	c0d07480 <u2f_message_set_autoreply_wait_user_presence>
c0d06c6c:	e7c3      	b.n	c0d06bf6 <u2f_apdu_sign+0x32>
c0d06c6e:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d06c70:	4a13      	ldr	r2, [pc, #76]	; (c0d06cc0 <u2f_apdu_sign+0xfc>)
c0d06c72:	447a      	add	r2, pc
c0d06c74:	2302      	movs	r3, #2
c0d06c76:	9801      	ldr	r0, [sp, #4]
c0d06c78:	e7bb      	b.n	c0d06bf2 <u2f_apdu_sign+0x2e>
            G_io_apdu_buffer[0] = sizeof(U2F_PROXY_MAGIC)-1;
c0d06c7a:	4d0b      	ldr	r5, [pc, #44]	; (c0d06ca8 <u2f_apdu_sign+0xe4>)
c0d06c7c:	702c      	strb	r4, [r5, #0]
            os_memmove(G_io_apdu_buffer+1, U2F_PROXY_MAGIC, sizeof(U2F_PROXY_MAGIC)-1);
c0d06c7e:	1c68      	adds	r0, r5, #1
c0d06c80:	4910      	ldr	r1, [pc, #64]	; (c0d06cc4 <u2f_apdu_sign+0x100>)
c0d06c82:	4479      	add	r1, pc
c0d06c84:	4622      	mov	r2, r4
c0d06c86:	f7fd fb48 	bl	c0d0431a <os_memmove>
            os_memmove(G_io_apdu_buffer+1+sizeof(U2F_PROXY_MAGIC)-1, "\x90\x00\x90\x00", 4);
c0d06c8a:	1da8      	adds	r0, r5, #6
c0d06c8c:	490e      	ldr	r1, [pc, #56]	; (c0d06cc8 <u2f_apdu_sign+0x104>)
c0d06c8e:	4479      	add	r1, pc
c0d06c90:	2204      	movs	r2, #4
c0d06c92:	f7fd fb42 	bl	c0d0431a <os_memmove>
                              G_io_apdu_buffer[0]+1+2+2);
c0d06c96:	7828      	ldrb	r0, [r5, #0]
c0d06c98:	1d43      	adds	r3, r0, #5
c0d06c9a:	2183      	movs	r1, #131	; 0x83
            u2f_message_reply(service, U2F_CMD_MSG,
c0d06c9c:	9801      	ldr	r0, [sp, #4]
c0d06c9e:	462a      	mov	r2, r5
c0d06ca0:	e7a7      	b.n	c0d06bf2 <u2f_apdu_sign+0x2e>
c0d06ca2:	46c0      	nop			; (mov r8, r8)
c0d06ca4:	2000205c 	.word	0x2000205c
c0d06ca8:	20001f09 	.word	0x20001f09
c0d06cac:	0000598f 	.word	0x0000598f
c0d06cb0:	00005983 	.word	0x00005983
c0d06cb4:	00005979 	.word	0x00005979
c0d06cb8:	00005955 	.word	0x00005955
c0d06cbc:	00005947 	.word	0x00005947
c0d06cc0:	00005908 	.word	0x00005908
c0d06cc4:	000058ed 	.word	0x000058ed
c0d06cc8:	000058e7 	.word	0x000058e7

c0d06ccc <u2f_handle_cmd_init>:
}

#endif // U2F_PROXY_MAGIC

void u2f_handle_cmd_init(u2f_service_t *service, uint8_t *buffer,
                         uint16_t length, uint8_t *channelInit) {
c0d06ccc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06cce:	b081      	sub	sp, #4
c0d06cd0:	461d      	mov	r5, r3
c0d06cd2:	460e      	mov	r6, r1
c0d06cd4:	4604      	mov	r4, r0
    // screen_printf("U2F init\n");
    uint8_t channel[4];
    (void)length;
    if (u2f_is_channel_broadcast(channelInit)) {
c0d06cd6:	4618      	mov	r0, r3
c0d06cd8:	f000 fbc6 	bl	c0d07468 <u2f_is_channel_broadcast>
c0d06cdc:	2800      	cmp	r0, #0
c0d06cde:	d00e      	beq.n	c0d06cfe <u2f_handle_cmd_init+0x32>
        // cx_rng(channel, 4); // not available within the IO task
        U4BE_ENCODE(channel, 0, ++service->next_channel);
c0d06ce0:	6820      	ldr	r0, [r4, #0]
c0d06ce2:	1cc1      	adds	r1, r0, #3
c0d06ce4:	0a09      	lsrs	r1, r1, #8
c0d06ce6:	466a      	mov	r2, sp
c0d06ce8:	7091      	strb	r1, [r2, #2]
c0d06cea:	1c81      	adds	r1, r0, #2
c0d06cec:	0c09      	lsrs	r1, r1, #16
c0d06cee:	7051      	strb	r1, [r2, #1]
c0d06cf0:	1c41      	adds	r1, r0, #1
c0d06cf2:	0e09      	lsrs	r1, r1, #24
c0d06cf4:	7011      	strb	r1, [r2, #0]
c0d06cf6:	1d00      	adds	r0, r0, #4
c0d06cf8:	6020      	str	r0, [r4, #0]
c0d06cfa:	70d0      	strb	r0, [r2, #3]
c0d06cfc:	e004      	b.n	c0d06d08 <u2f_handle_cmd_init+0x3c>
c0d06cfe:	4668      	mov	r0, sp
c0d06d00:	2204      	movs	r2, #4
    } else {
        os_memmove(channel, channelInit, 4);
c0d06d02:	4629      	mov	r1, r5
c0d06d04:	f7fd fb09 	bl	c0d0431a <os_memmove>
    }
    os_memmove(G_io_apdu_buffer, buffer, 8);
c0d06d08:	4f15      	ldr	r7, [pc, #84]	; (c0d06d60 <u2f_handle_cmd_init+0x94>)
c0d06d0a:	2208      	movs	r2, #8
c0d06d0c:	4638      	mov	r0, r7
c0d06d0e:	4631      	mov	r1, r6
c0d06d10:	f7fd fb03 	bl	c0d0431a <os_memmove>
    os_memmove(G_io_apdu_buffer + 8, channel, 4);
c0d06d14:	4638      	mov	r0, r7
c0d06d16:	3008      	adds	r0, #8
c0d06d18:	4669      	mov	r1, sp
c0d06d1a:	2204      	movs	r2, #4
c0d06d1c:	f7fd fafd 	bl	c0d0431a <os_memmove>
c0d06d20:	2000      	movs	r0, #0
    G_io_apdu_buffer[12] = INIT_U2F_VERSION;
    G_io_apdu_buffer[13] = INIT_DEVICE_VERSION_MAJOR;
    G_io_apdu_buffer[14] = INIT_DEVICE_VERSION_MINOR;
    G_io_apdu_buffer[15] = INIT_BUILD_VERSION;
    G_io_apdu_buffer[16] = INIT_CAPABILITIES;
c0d06d22:	7438      	strb	r0, [r7, #16]
    G_io_apdu_buffer[15] = INIT_BUILD_VERSION;
c0d06d24:	73f8      	strb	r0, [r7, #15]
c0d06d26:	2101      	movs	r1, #1
    G_io_apdu_buffer[14] = INIT_DEVICE_VERSION_MINOR;
c0d06d28:	73b9      	strb	r1, [r7, #14]
    G_io_apdu_buffer[13] = INIT_DEVICE_VERSION_MAJOR;
c0d06d2a:	7378      	strb	r0, [r7, #13]
c0d06d2c:	2002      	movs	r0, #2
    G_io_apdu_buffer[12] = INIT_U2F_VERSION;
c0d06d2e:	7338      	strb	r0, [r7, #12]

    if (u2f_is_channel_broadcast(channelInit)) {
c0d06d30:	4628      	mov	r0, r5
c0d06d32:	f000 fb99 	bl	c0d07468 <u2f_is_channel_broadcast>
c0d06d36:	4601      	mov	r1, r0
c0d06d38:	1d20      	adds	r0, r4, #4
c0d06d3a:	2900      	cmp	r1, #0
c0d06d3c:	d004      	beq.n	c0d06d48 <u2f_handle_cmd_init+0x7c>
c0d06d3e:	21ff      	movs	r1, #255	; 0xff
c0d06d40:	2204      	movs	r2, #4
        os_memset(service->channel, 0xff, 4);
c0d06d42:	f7fd fb00 	bl	c0d04346 <os_memset>
c0d06d46:	e003      	b.n	c0d06d50 <u2f_handle_cmd_init+0x84>
c0d06d48:	4669      	mov	r1, sp
c0d06d4a:	2204      	movs	r2, #4
    } else {
        os_memmove(service->channel, channel, 4);
c0d06d4c:	f7fd fae5 	bl	c0d0431a <os_memmove>
c0d06d50:	2186      	movs	r1, #134	; 0x86
    }
    u2f_message_reply(service, U2F_CMD_INIT, G_io_apdu_buffer, 17);
c0d06d52:	4a03      	ldr	r2, [pc, #12]	; (c0d06d60 <u2f_handle_cmd_init+0x94>)
c0d06d54:	2311      	movs	r3, #17
c0d06d56:	4620      	mov	r0, r4
c0d06d58:	f000 fba6 	bl	c0d074a8 <u2f_message_reply>
}
c0d06d5c:	b001      	add	sp, #4
c0d06d5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d06d60:	20001f09 	.word	0x20001f09

c0d06d64 <u2f_handle_cmd_msg>:
    // screen_printf("U2F ping\n");
    u2f_message_reply(service, U2F_CMD_PING, buffer, length);
}

void u2f_handle_cmd_msg(u2f_service_t *service, uint8_t *buffer,
                        uint16_t length) {
c0d06d64:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06d66:	b083      	sub	sp, #12
c0d06d68:	9002      	str	r0, [sp, #8]
    uint8_t cla = buffer[0];
    uint8_t ins = buffer[1];
    uint8_t p1 = buffer[2];
    uint8_t p2 = buffer[3];
    // in extended length buffer[4] must be 0
    uint32_t dataLength = /*(buffer[4] << 16) |*/ (buffer[5] << 8) | (buffer[6]);
c0d06d6a:	7988      	ldrb	r0, [r1, #6]
c0d06d6c:	794b      	ldrb	r3, [r1, #5]
c0d06d6e:	021b      	lsls	r3, r3, #8
c0d06d70:	181f      	adds	r7, r3, r0
    uint8_t p1 = buffer[2];
c0d06d72:	7888      	ldrb	r0, [r1, #2]
    uint8_t ins = buffer[1];
c0d06d74:	9001      	str	r0, [sp, #4]
c0d06d76:	7848      	ldrb	r0, [r1, #1]
    uint8_t cla = buffer[0];
c0d06d78:	780e      	ldrb	r6, [r1, #0]
    if (dataLength == (uint16_t)(length - 9) || dataLength == (uint16_t)(length - 7)) {
c0d06d7a:	4615      	mov	r5, r2
c0d06d7c:	3d09      	subs	r5, #9
c0d06d7e:	b2ab      	uxth	r3, r5
c0d06d80:	429f      	cmp	r7, r3
c0d06d82:	d003      	beq.n	c0d06d8c <u2f_handle_cmd_msg+0x28>
c0d06d84:	1fd4      	subs	r4, r2, #7
c0d06d86:	b2a4      	uxth	r4, r4
c0d06d88:	42a7      	cmp	r7, r4
c0d06d8a:	d11b      	bne.n	c0d06dc4 <u2f_handle_cmd_msg+0x60>
c0d06d8c:	463d      	mov	r5, r7
    G_io_app.apdu_media = IO_APDU_MEDIA_U2F; // the effective transport is managed by the U2F layer
    G_io_app.apdu_state = APDU_U2F;

#else // U2F_PROXY_MAGIC

    if (cla != FIDO_CLA) {
c0d06d8e:	2e00      	cmp	r6, #0
c0d06d90:	d008      	beq.n	c0d06da4 <u2f_handle_cmd_msg+0x40>
c0d06d92:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d06d94:	4a1c      	ldr	r2, [pc, #112]	; (c0d06e08 <u2f_handle_cmd_msg+0xa4>)
c0d06d96:	447a      	add	r2, pc
c0d06d98:	2302      	movs	r3, #2
c0d06d9a:	9802      	ldr	r0, [sp, #8]
c0d06d9c:	f000 fb84 	bl	c0d074a8 <u2f_message_reply>
                 sizeof(SW_UNKNOWN_INSTRUCTION));
        return;
    }

#endif // U2F_PROXY_MAGIC
}
c0d06da0:	b003      	add	sp, #12
c0d06da2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (ins) {
c0d06da4:	2802      	cmp	r0, #2
c0d06da6:	dc15      	bgt.n	c0d06dd4 <u2f_handle_cmd_msg+0x70>
c0d06da8:	2801      	cmp	r0, #1
c0d06daa:	d020      	beq.n	c0d06dee <u2f_handle_cmd_msg+0x8a>
c0d06dac:	2802      	cmp	r0, #2
c0d06dae:	d11a      	bne.n	c0d06de6 <u2f_handle_cmd_msg+0x82>
        u2f_apdu_sign(service, p1, p2, buffer + 7, dataLength);
c0d06db0:	b2a8      	uxth	r0, r5
c0d06db2:	466a      	mov	r2, sp
c0d06db4:	6010      	str	r0, [r2, #0]
c0d06db6:	1dcb      	adds	r3, r1, #7
c0d06db8:	2200      	movs	r2, #0
c0d06dba:	9802      	ldr	r0, [sp, #8]
c0d06dbc:	9901      	ldr	r1, [sp, #4]
c0d06dbe:	f7ff ff01 	bl	c0d06bc4 <u2f_apdu_sign>
c0d06dc2:	e7ed      	b.n	c0d06da0 <u2f_handle_cmd_msg+0x3c>
    else if (dataLength == (uint16_t)(length - 9)%256) {
c0d06dc4:	b2db      	uxtb	r3, r3
c0d06dc6:	429f      	cmp	r7, r3
c0d06dc8:	d0e1      	beq.n	c0d06d8e <u2f_handle_cmd_msg+0x2a>
    else if (dataLength == (uint16_t)(length - 7)%256) {
c0d06dca:	b2e3      	uxtb	r3, r4
c0d06dcc:	429f      	cmp	r7, r3
c0d06dce:	d112      	bne.n	c0d06df6 <u2f_handle_cmd_msg+0x92>
c0d06dd0:	1fd5      	subs	r5, r2, #7
c0d06dd2:	e7dc      	b.n	c0d06d8e <u2f_handle_cmd_msg+0x2a>
    switch (ins) {
c0d06dd4:	2803      	cmp	r0, #3
c0d06dd6:	d012      	beq.n	c0d06dfe <u2f_handle_cmd_msg+0x9a>
c0d06dd8:	28c1      	cmp	r0, #193	; 0xc1
c0d06dda:	d104      	bne.n	c0d06de6 <u2f_handle_cmd_msg+0x82>
c0d06ddc:	2183      	movs	r1, #131	; 0x83
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)INFO, sizeof(INFO));
c0d06dde:	4a0b      	ldr	r2, [pc, #44]	; (c0d06e0c <u2f_handle_cmd_msg+0xa8>)
c0d06de0:	447a      	add	r2, pc
c0d06de2:	2304      	movs	r3, #4
c0d06de4:	e7d9      	b.n	c0d06d9a <u2f_handle_cmd_msg+0x36>
c0d06de6:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d06de8:	4a0b      	ldr	r2, [pc, #44]	; (c0d06e18 <u2f_handle_cmd_msg+0xb4>)
c0d06dea:	447a      	add	r2, pc
c0d06dec:	e7d4      	b.n	c0d06d98 <u2f_handle_cmd_msg+0x34>
c0d06dee:	2183      	movs	r1, #131	; 0x83
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)SW_INTERNAL, sizeof(SW_INTERNAL));
c0d06df0:	4a07      	ldr	r2, [pc, #28]	; (c0d06e10 <u2f_handle_cmd_msg+0xac>)
c0d06df2:	447a      	add	r2, pc
c0d06df4:	e7d0      	b.n	c0d06d98 <u2f_handle_cmd_msg+0x34>
c0d06df6:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d06df8:	4a08      	ldr	r2, [pc, #32]	; (c0d06e1c <u2f_handle_cmd_msg+0xb8>)
c0d06dfa:	447a      	add	r2, pc
c0d06dfc:	e7cc      	b.n	c0d06d98 <u2f_handle_cmd_msg+0x34>
c0d06dfe:	2183      	movs	r1, #131	; 0x83
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)U2F_VERSION, sizeof(U2F_VERSION));
c0d06e00:	4a04      	ldr	r2, [pc, #16]	; (c0d06e14 <u2f_handle_cmd_msg+0xb0>)
c0d06e02:	447a      	add	r2, pc
c0d06e04:	2308      	movs	r3, #8
c0d06e06:	e7c8      	b.n	c0d06d9a <u2f_handle_cmd_msg+0x36>
c0d06e08:	000057f2 	.word	0x000057f2
c0d06e0c:	000057a4 	.word	0x000057a4
c0d06e10:	0000576f 	.word	0x0000576f
c0d06e14:	0000577a 	.word	0x0000577a
c0d06e18:	000057a0 	.word	0x000057a0
c0d06e1c:	0000576b 	.word	0x0000576b

c0d06e20 <u2f_message_complete>:

void u2f_message_complete(u2f_service_t *service) {
c0d06e20:	b580      	push	{r7, lr}
    uint8_t cmd = service->transportBuffer[0];
c0d06e22:	69c1      	ldr	r1, [r0, #28]
    uint16_t length = (service->transportBuffer[1] << 8) | (service->transportBuffer[2]);
c0d06e24:	788a      	ldrb	r2, [r1, #2]
c0d06e26:	784b      	ldrb	r3, [r1, #1]
c0d06e28:	021b      	lsls	r3, r3, #8
c0d06e2a:	189b      	adds	r3, r3, r2
    uint8_t cmd = service->transportBuffer[0];
c0d06e2c:	780a      	ldrb	r2, [r1, #0]
    switch (cmd) {
c0d06e2e:	2a81      	cmp	r2, #129	; 0x81
c0d06e30:	d009      	beq.n	c0d06e46 <u2f_message_complete+0x26>
c0d06e32:	2a83      	cmp	r2, #131	; 0x83
c0d06e34:	d00d      	beq.n	c0d06e52 <u2f_message_complete+0x32>
c0d06e36:	2a86      	cmp	r2, #134	; 0x86
c0d06e38:	d10f      	bne.n	c0d06e5a <u2f_message_complete+0x3a>
    case U2F_CMD_INIT:
        u2f_handle_cmd_init(service, service->transportBuffer + 3, length, service->channel);
c0d06e3a:	1cc9      	adds	r1, r1, #3
c0d06e3c:	1d03      	adds	r3, r0, #4
c0d06e3e:	2200      	movs	r2, #0
c0d06e40:	f7ff ff44 	bl	c0d06ccc <u2f_handle_cmd_init>
        break;
    case U2F_CMD_MSG:
        u2f_handle_cmd_msg(service, service->transportBuffer + 3, length);
        break;
    }
}
c0d06e44:	bd80      	pop	{r7, pc}
        u2f_handle_cmd_ping(service, service->transportBuffer + 3, length);
c0d06e46:	1cca      	adds	r2, r1, #3
    u2f_message_reply(service, U2F_CMD_PING, buffer, length);
c0d06e48:	b29b      	uxth	r3, r3
c0d06e4a:	2181      	movs	r1, #129	; 0x81
c0d06e4c:	f000 fb2c 	bl	c0d074a8 <u2f_message_reply>
}
c0d06e50:	bd80      	pop	{r7, pc}
        u2f_handle_cmd_msg(service, service->transportBuffer + 3, length);
c0d06e52:	1cc9      	adds	r1, r1, #3
c0d06e54:	b29a      	uxth	r2, r3
c0d06e56:	f7ff ff85 	bl	c0d06d64 <u2f_handle_cmd_msg>
}
c0d06e5a:	bd80      	pop	{r7, pc}

c0d06e5c <u2f_io_send>:
#include "u2f_processing.h"
#include "u2f_impl.h"

#include "os_io_seproxyhal.h"

void u2f_io_send(uint8_t *buffer, uint16_t length, u2f_transport_media_t media) {
c0d06e5c:	b570      	push	{r4, r5, r6, lr}
    if (media == U2F_MEDIA_USB) {
c0d06e5e:	2a01      	cmp	r2, #1
c0d06e60:	d114      	bne.n	c0d06e8c <u2f_io_send+0x30>
c0d06e62:	460d      	mov	r5, r1
c0d06e64:	4601      	mov	r1, r0
        os_memmove(G_io_usb_ep_buffer, buffer, length);
c0d06e66:	4c0c      	ldr	r4, [pc, #48]	; (c0d06e98 <u2f_io_send+0x3c>)
c0d06e68:	4620      	mov	r0, r4
c0d06e6a:	462a      	mov	r2, r5
c0d06e6c:	f7fd fa55 	bl	c0d0431a <os_memmove>
        // wipe the remaining to avoid :
        // 1/ data leaks
        // 2/ invalid junk
        os_memset(G_io_usb_ep_buffer+length, 0, sizeof(G_io_usb_ep_buffer)-length);
c0d06e70:	1960      	adds	r0, r4, r5
c0d06e72:	2640      	movs	r6, #64	; 0x40
c0d06e74:	1b72      	subs	r2, r6, r5
c0d06e76:	2500      	movs	r5, #0
c0d06e78:	4629      	mov	r1, r5
c0d06e7a:	f7fd fa64 	bl	c0d04346 <os_memset>
c0d06e7e:	2081      	movs	r0, #129	; 0x81
    }
    switch (media) {
    case U2F_MEDIA_USB:
        io_usb_send_ep(U2F_EPIN_ADDR, G_io_usb_ep_buffer, USB_SEGMENT_SIZE, 0);
c0d06e80:	4621      	mov	r1, r4
c0d06e82:	4632      	mov	r2, r6
c0d06e84:	462b      	mov	r3, r5
c0d06e86:	f7fd fc25 	bl	c0d046d4 <io_usb_send_ep>
#endif
    default:
        PRINTF("Request to send on unsupported media %d\n", media);
        break;
    }
}
c0d06e8a:	bd70      	pop	{r4, r5, r6, pc}
        PRINTF("Request to send on unsupported media %d\n", media);
c0d06e8c:	4803      	ldr	r0, [pc, #12]	; (c0d06e9c <u2f_io_send+0x40>)
c0d06e8e:	4478      	add	r0, pc
c0d06e90:	4611      	mov	r1, r2
c0d06e92:	f7fe f8d3 	bl	c0d0503c <mcu_usb_printf>
}
c0d06e96:	bd70      	pop	{r4, r5, r6, pc}
c0d06e98:	200020c0 	.word	0x200020c0
c0d06e9c:	000056fe 	.word	0x000056fe

c0d06ea0 <u2f_transport_init>:
}

/**
 * Initialize the u2f transport and provide the buffer into which to store incoming message
 */
void u2f_transport_init(u2f_service_t *service, uint8_t* message_buffer, uint16_t message_buffer_length) {
c0d06ea0:	2300      	movs	r3, #0
    service->transportPacketIndex = 0;
c0d06ea2:	7683      	strb	r3, [r0, #26]
    service->transportOffset = 0;
c0d06ea4:	82c3      	strh	r3, [r0, #22]
    service->transportReceiveBuffer = message_buffer;
    service->transportReceiveBufferLength = message_buffer_length;
c0d06ea6:	8202      	strh	r2, [r0, #16]
    service->transportReceiveBuffer = message_buffer;
c0d06ea8:	60c1      	str	r1, [r0, #12]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d06eaa:	8543      	strh	r3, [r0, #42]	; 0x2a
    service->transportMedia = 0;
c0d06eac:	8483      	strh	r3, [r0, #36]	; 0x24
    service->transportBuffer = service->transportReceiveBuffer;
c0d06eae:	61c1      	str	r1, [r0, #28]
    service->transportMedia = 0;
c0d06eb0:	6203      	str	r3, [r0, #32]
    u2f_transport_reset(service);
}
c0d06eb2:	4770      	bx	lr

c0d06eb4 <u2f_transport_sent>:

/**
 * Function called when the previously scheduled message to be sent on the media is effectively sent.
 * And a new message can be scheduled.
 */
void u2f_transport_sent(u2f_service_t* service, u2f_transport_media_t media) {
c0d06eb4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06eb6:	b083      	sub	sp, #12
c0d06eb8:	4604      	mov	r4, r0
c0d06eba:	202a      	movs	r0, #42	; 0x2a

bool u2f_message_repliable(u2f_service_t* service) {
    // no more asynch replies
    // finished receiving the command
    // and not sending a user presence required status
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d06ebc:	5c20      	ldrb	r0, [r4, r0]
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0d06ebe:	2801      	cmp	r0, #1
c0d06ec0:	d026      	beq.n	c0d06f10 <u2f_transport_sent+0x5c>
c0d06ec2:	460d      	mov	r5, r1
c0d06ec4:	2800      	cmp	r0, #0
c0d06ec6:	d118      	bne.n	c0d06efa <u2f_transport_sent+0x46>
c0d06ec8:	202b      	movs	r0, #43	; 0x2b
c0d06eca:	2100      	movs	r1, #0
c0d06ecc:	5421      	strb	r1, [r4, r0]
c0d06ece:	4620      	mov	r0, r4
c0d06ed0:	302b      	adds	r0, #43	; 0x2b
c0d06ed2:	2120      	movs	r1, #32
    if (service->transportState != U2F_SENDING_RESPONSE 
c0d06ed4:	5c62      	ldrb	r2, [r4, r1]
        && service->transportState != U2F_SENDING_ERROR) {
c0d06ed6:	1ed2      	subs	r2, r2, #3
c0d06ed8:	b2d2      	uxtb	r2, r2
c0d06eda:	2a01      	cmp	r2, #1
c0d06edc:	d81b      	bhi.n	c0d06f16 <u2f_transport_sent+0x62>
c0d06ede:	4626      	mov	r6, r4
c0d06ee0:	362a      	adds	r6, #42	; 0x2a
c0d06ee2:	4627      	mov	r7, r4
c0d06ee4:	3720      	adds	r7, #32
    if (service->transportOffset < service->transportLength) {
c0d06ee6:	8b22      	ldrh	r2, [r4, #24]
c0d06ee8:	8ae3      	ldrh	r3, [r4, #22]
c0d06eea:	429a      	cmp	r2, r3
c0d06eec:	d915      	bls.n	c0d06f1a <u2f_transport_sent+0x66>
            (service->transportPacketIndex == 0 ? (channelHeader + 3)
c0d06eee:	7ea0      	ldrb	r0, [r4, #26]
c0d06ef0:	2800      	cmp	r0, #0
c0d06ef2:	9001      	str	r0, [sp, #4]
c0d06ef4:	d01e      	beq.n	c0d06f34 <u2f_transport_sent+0x80>
c0d06ef6:	2601      	movs	r6, #1
c0d06ef8:	e01d      	b.n	c0d06f36 <u2f_transport_sent+0x82>
c0d06efa:	2025      	movs	r0, #37	; 0x25
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0d06efc:	5c20      	ldrb	r0, [r4, r0]
            && service->sending == false)
c0d06efe:	2806      	cmp	r0, #6
c0d06f00:	d106      	bne.n	c0d06f10 <u2f_transport_sent+0x5c>
c0d06f02:	202b      	movs	r0, #43	; 0x2b
c0d06f04:	5c21      	ldrb	r1, [r4, r0]
c0d06f06:	2200      	movs	r2, #0
c0d06f08:	5422      	strb	r2, [r4, r0]
    if (!u2f_message_repliable(service)) {
c0d06f0a:	2900      	cmp	r1, #0
c0d06f0c:	d103      	bne.n	c0d06f16 <u2f_transport_sent+0x62>
c0d06f0e:	e7de      	b.n	c0d06ece <u2f_transport_sent+0x1a>
c0d06f10:	202b      	movs	r0, #43	; 0x2b
c0d06f12:	2100      	movs	r1, #0
c0d06f14:	5421      	strb	r1, [r4, r0]
}
c0d06f16:	b003      	add	sp, #12
c0d06f18:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (service->transportOffset == service->transportLength) {
c0d06f1a:	d1fc      	bne.n	c0d06f16 <u2f_transport_sent+0x62>
c0d06f1c:	2100      	movs	r1, #0
    service->transportPacketIndex = 0;
c0d06f1e:	76a1      	strb	r1, [r4, #26]
    service->transportOffset = 0;
c0d06f20:	82e1      	strh	r1, [r4, #22]
    service->sending = false;
c0d06f22:	7001      	strb	r1, [r0, #0]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d06f24:	7031      	strb	r1, [r6, #0]
    service->transportMedia = 0;
c0d06f26:	80b9      	strh	r1, [r7, #4]
c0d06f28:	6039      	str	r1, [r7, #0]
    service->transportBuffer = service->transportReceiveBuffer;
c0d06f2a:	68e0      	ldr	r0, [r4, #12]
c0d06f2c:	61e0      	str	r0, [r4, #28]
        G_io_app.apdu_state = APDU_IDLE;
c0d06f2e:	4824      	ldr	r0, [pc, #144]	; (c0d06fc0 <u2f_transport_sent+0x10c>)
c0d06f30:	7001      	strb	r1, [r0, #0]
c0d06f32:	e7f0      	b.n	c0d06f16 <u2f_transport_sent+0x62>
c0d06f34:	2603      	movs	r6, #3
        uint16_t mtu = (media == U2F_MEDIA_USB) ? USB_SEGMENT_SIZE : BLE_SEGMENT_SIZE;
c0d06f36:	1e6f      	subs	r7, r5, #1
c0d06f38:	4278      	negs	r0, r7
c0d06f3a:	4178      	adcs	r0, r7
c0d06f3c:	0080      	lsls	r0, r0, #2
            (service->transportPacketIndex == 0 ? (channelHeader + 3)
c0d06f3e:	1830      	adds	r0, r6, r0
                                      (mtu - headerSize)
c0d06f40:	2d01      	cmp	r5, #1
c0d06f42:	d100      	bne.n	c0d06f46 <u2f_transport_sent+0x92>
c0d06f44:	2140      	movs	r1, #64	; 0x40
c0d06f46:	1a0f      	subs	r7, r1, r0
        uint16_t blockSize = ((service->transportLength - service->transportOffset) >
c0d06f48:	1ad1      	subs	r1, r2, r3
c0d06f4a:	42b9      	cmp	r1, r7
c0d06f4c:	dc00      	bgt.n	c0d06f50 <u2f_transport_sent+0x9c>
c0d06f4e:	460f      	mov	r7, r1
        if (media == U2F_MEDIA_USB) {
c0d06f50:	2d01      	cmp	r5, #1
c0d06f52:	9002      	str	r0, [sp, #8]
c0d06f54:	d107      	bne.n	c0d06f66 <u2f_transport_sent+0xb2>
            os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d06f56:	1d21      	adds	r1, r4, #4
c0d06f58:	481a      	ldr	r0, [pc, #104]	; (c0d06fc4 <u2f_transport_sent+0x110>)
c0d06f5a:	2604      	movs	r6, #4
c0d06f5c:	4632      	mov	r2, r6
c0d06f5e:	f7fd f9dc 	bl	c0d0431a <os_memmove>
        if (service->transportPacketIndex == 0) {
c0d06f62:	7ea0      	ldrb	r0, [r4, #26]
c0d06f64:	e001      	b.n	c0d06f6a <u2f_transport_sent+0xb6>
c0d06f66:	2600      	movs	r6, #0
c0d06f68:	9801      	ldr	r0, [sp, #4]
c0d06f6a:	2800      	cmp	r0, #0
c0d06f6c:	d001      	beq.n	c0d06f72 <u2f_transport_sent+0xbe>
            G_io_usb_ep_buffer[offset++] = (service->transportPacketIndex - 1);
c0d06f6e:	1e40      	subs	r0, r0, #1
c0d06f70:	e009      	b.n	c0d06f86 <u2f_transport_sent+0xd2>
c0d06f72:	2040      	movs	r0, #64	; 0x40
            G_io_usb_ep_buffer[offset++] = service->sendCmd;
c0d06f74:	5c20      	ldrb	r0, [r4, r0]
c0d06f76:	4913      	ldr	r1, [pc, #76]	; (c0d06fc4 <u2f_transport_sent+0x110>)
c0d06f78:	5588      	strb	r0, [r1, r6]
c0d06f7a:	2001      	movs	r0, #1
c0d06f7c:	4330      	orrs	r0, r6
            G_io_usb_ep_buffer[offset++] = (service->transportLength >> 8);
c0d06f7e:	7e62      	ldrb	r2, [r4, #25]
c0d06f80:	540a      	strb	r2, [r1, r0]
c0d06f82:	1c46      	adds	r6, r0, #1
            G_io_usb_ep_buffer[offset++] = (service->transportLength & 0xff);
c0d06f84:	7e20      	ldrb	r0, [r4, #24]
c0d06f86:	9b02      	ldr	r3, [sp, #8]
c0d06f88:	18f9      	adds	r1, r7, r3
c0d06f8a:	9101      	str	r1, [sp, #4]
c0d06f8c:	4a0d      	ldr	r2, [pc, #52]	; (c0d06fc4 <u2f_transport_sent+0x110>)
c0d06f8e:	5590      	strb	r0, [r2, r6]
        if (service->transportBuffer != NULL) {
c0d06f90:	69e1      	ldr	r1, [r4, #28]
c0d06f92:	2900      	cmp	r1, #0
c0d06f94:	d006      	beq.n	c0d06fa4 <u2f_transport_sent+0xf0>
c0d06f96:	b2be      	uxth	r6, r7
            os_memmove(G_io_usb_ep_buffer + headerSize,
c0d06f98:	18d0      	adds	r0, r2, r3
                       service->transportBuffer + service->transportOffset, blockSize);
c0d06f9a:	8ae3      	ldrh	r3, [r4, #22]
c0d06f9c:	18c9      	adds	r1, r1, r3
            os_memmove(G_io_usb_ep_buffer + headerSize,
c0d06f9e:	4632      	mov	r2, r6
c0d06fa0:	f7fd f9bb 	bl	c0d0431a <os_memmove>
        service->transportOffset += blockSize;
c0d06fa4:	8ae0      	ldrh	r0, [r4, #22]
c0d06fa6:	19c0      	adds	r0, r0, r7
c0d06fa8:	82e0      	strh	r0, [r4, #22]
        service->transportPacketIndex++;
c0d06faa:	7ea0      	ldrb	r0, [r4, #26]
c0d06fac:	1c40      	adds	r0, r0, #1
c0d06fae:	76a0      	strb	r0, [r4, #26]
        u2f_io_send(G_io_usb_ep_buffer, dataSize, media);
c0d06fb0:	9801      	ldr	r0, [sp, #4]
c0d06fb2:	b281      	uxth	r1, r0
c0d06fb4:	4803      	ldr	r0, [pc, #12]	; (c0d06fc4 <u2f_transport_sent+0x110>)
c0d06fb6:	462a      	mov	r2, r5
c0d06fb8:	f7ff ff50 	bl	c0d06e5c <u2f_io_send>
c0d06fbc:	e7ab      	b.n	c0d06f16 <u2f_transport_sent+0x62>
c0d06fbe:	46c0      	nop			; (mov r8, r8)
c0d06fc0:	2000205c 	.word	0x2000205c
c0d06fc4:	200020c0 	.word	0x200020c0

c0d06fc8 <u2f_message_repliable>:
bool u2f_message_repliable(u2f_service_t* service) {
c0d06fc8:	212a      	movs	r1, #42	; 0x2a
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d06fca:	5c41      	ldrb	r1, [r0, r1]
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0d06fcc:	2900      	cmp	r1, #0
c0d06fce:	d00c      	beq.n	c0d06fea <u2f_message_repliable+0x22>
c0d06fd0:	2901      	cmp	r1, #1
c0d06fd2:	d008      	beq.n	c0d06fe6 <u2f_message_repliable+0x1e>
c0d06fd4:	2125      	movs	r1, #37	; 0x25
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0d06fd6:	5c41      	ldrb	r1, [r0, r1]
            && service->sending == false)
c0d06fd8:	2906      	cmp	r1, #6
c0d06fda:	d104      	bne.n	c0d06fe6 <u2f_message_repliable+0x1e>
c0d06fdc:	212b      	movs	r1, #43	; 0x2b
c0d06fde:	5c41      	ldrb	r1, [r0, r1]
c0d06fe0:	4248      	negs	r0, r1
c0d06fe2:	4148      	adcs	r0, r1
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d06fe4:	4770      	bx	lr
c0d06fe6:	2000      	movs	r0, #0
c0d06fe8:	4770      	bx	lr
c0d06fea:	2001      	movs	r0, #1
c0d06fec:	4770      	bx	lr
	...

c0d06ff0 <u2f_transport_send_usb_user_presence_required>:
void u2f_transport_send_usb_user_presence_required(u2f_service_t *service) {
c0d06ff0:	b5b0      	push	{r4, r5, r7, lr}
c0d06ff2:	212b      	movs	r1, #43	; 0x2b
c0d06ff4:	2401      	movs	r4, #1
    service->sending = true;
c0d06ff6:	5444      	strb	r4, [r0, r1]
    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d06ff8:	1d01      	adds	r1, r0, #4
c0d06ffa:	4d0a      	ldr	r5, [pc, #40]	; (c0d07024 <u2f_transport_send_usb_user_presence_required+0x34>)
c0d06ffc:	2204      	movs	r2, #4
c0d06ffe:	4628      	mov	r0, r5
c0d07000:	f7fd f98b 	bl	c0d0431a <os_memmove>
c0d07004:	2085      	movs	r0, #133	; 0x85
    G_io_usb_ep_buffer[offset++] = 0x85;
c0d07006:	7228      	strb	r0, [r5, #8]
c0d07008:	2069      	movs	r0, #105	; 0x69
    G_io_usb_ep_buffer[offset++] = 0x69;
c0d0700a:	71e8      	strb	r0, [r5, #7]
c0d0700c:	2002      	movs	r0, #2
    G_io_usb_ep_buffer[offset++] = 2;
c0d0700e:	71a8      	strb	r0, [r5, #6]
c0d07010:	2000      	movs	r0, #0
    G_io_usb_ep_buffer[offset++] = 0;
c0d07012:	7168      	strb	r0, [r5, #5]
c0d07014:	2083      	movs	r0, #131	; 0x83
    G_io_usb_ep_buffer[offset++] = U2F_CMD_MSG;
c0d07016:	7128      	strb	r0, [r5, #4]
c0d07018:	2109      	movs	r1, #9
    u2f_io_send(G_io_usb_ep_buffer, offset, U2F_MEDIA_USB);
c0d0701a:	4628      	mov	r0, r5
c0d0701c:	4622      	mov	r2, r4
c0d0701e:	f7ff ff1d 	bl	c0d06e5c <u2f_io_send>
}
c0d07022:	bdb0      	pop	{r4, r5, r7, pc}
c0d07024:	200020c0 	.word	0x200020c0

c0d07028 <u2f_transport_send_wink>:
void u2f_transport_send_wink(u2f_service_t *service) {
c0d07028:	b5b0      	push	{r4, r5, r7, lr}
c0d0702a:	212b      	movs	r1, #43	; 0x2b
c0d0702c:	2401      	movs	r4, #1
    service->sending = true;
c0d0702e:	5444      	strb	r4, [r0, r1]
    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d07030:	1d01      	adds	r1, r0, #4
c0d07032:	4d08      	ldr	r5, [pc, #32]	; (c0d07054 <u2f_transport_send_wink+0x2c>)
c0d07034:	2204      	movs	r2, #4
c0d07036:	4628      	mov	r0, r5
c0d07038:	f7fd f96f 	bl	c0d0431a <os_memmove>
c0d0703c:	2000      	movs	r0, #0
    G_io_usb_ep_buffer[offset++] = 0;
c0d0703e:	71a8      	strb	r0, [r5, #6]
    G_io_usb_ep_buffer[offset++] = 0;
c0d07040:	7168      	strb	r0, [r5, #5]
c0d07042:	2088      	movs	r0, #136	; 0x88
    G_io_usb_ep_buffer[offset++] = U2F_CMD_WINK;
c0d07044:	7128      	strb	r0, [r5, #4]
c0d07046:	2107      	movs	r1, #7
    u2f_io_send(G_io_usb_ep_buffer, offset, U2F_MEDIA_USB);
c0d07048:	4628      	mov	r0, r5
c0d0704a:	4622      	mov	r2, r4
c0d0704c:	f7ff ff06 	bl	c0d06e5c <u2f_io_send>
}
c0d07050:	bdb0      	pop	{r4, r5, r7, pc}
c0d07052:	46c0      	nop			; (mov r8, r8)
c0d07054:	200020c0 	.word	0x200020c0

c0d07058 <u2f_transport_receive_fakeChannel>:
bool u2f_transport_receive_fakeChannel(u2f_service_t *service, uint8_t *buffer, uint16_t size) {
c0d07058:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0705a:	b081      	sub	sp, #4
c0d0705c:	4604      	mov	r4, r0
c0d0705e:	2025      	movs	r0, #37	; 0x25
    if (service->fakeChannelTransportState == U2F_INTERNAL_ERROR) {
c0d07060:	5c20      	ldrb	r0, [r4, r0]
c0d07062:	2805      	cmp	r0, #5
c0d07064:	d101      	bne.n	c0d0706a <u2f_transport_receive_fakeChannel+0x12>
c0d07066:	2500      	movs	r5, #0
c0d07068:	e065      	b.n	c0d07136 <u2f_transport_receive_fakeChannel+0xde>
c0d0706a:	4626      	mov	r6, r4
c0d0706c:	3625      	adds	r6, #37	; 0x25
    if (memcmp(service->channel, buffer, 4) != 0) {
c0d0706e:	7808      	ldrb	r0, [r1, #0]
c0d07070:	784b      	ldrb	r3, [r1, #1]
c0d07072:	021b      	lsls	r3, r3, #8
c0d07074:	1818      	adds	r0, r3, r0
c0d07076:	788b      	ldrb	r3, [r1, #2]
c0d07078:	78cd      	ldrb	r5, [r1, #3]
c0d0707a:	022d      	lsls	r5, r5, #8
c0d0707c:	18eb      	adds	r3, r5, r3
c0d0707e:	041b      	lsls	r3, r3, #16
c0d07080:	1818      	adds	r0, r3, r0
c0d07082:	7923      	ldrb	r3, [r4, #4]
c0d07084:	7965      	ldrb	r5, [r4, #5]
c0d07086:	022d      	lsls	r5, r5, #8
c0d07088:	18eb      	adds	r3, r5, r3
c0d0708a:	79a5      	ldrb	r5, [r4, #6]
c0d0708c:	79e7      	ldrb	r7, [r4, #7]
c0d0708e:	023f      	lsls	r7, r7, #8
c0d07090:	197d      	adds	r5, r7, r5
c0d07092:	042d      	lsls	r5, r5, #16
c0d07094:	18eb      	adds	r3, r5, r3
c0d07096:	4283      	cmp	r3, r0
c0d07098:	d150      	bne.n	c0d0713c <u2f_transport_receive_fakeChannel+0xe4>
c0d0709a:	790b      	ldrb	r3, [r1, #4]
    if (service->fakeChannelTransportOffset == 0) {        
c0d0709c:	8c60      	ldrh	r0, [r4, #34]	; 0x22
c0d0709e:	2800      	cmp	r0, #0
c0d070a0:	d013      	beq.n	c0d070ca <u2f_transport_receive_fakeChannel+0x72>
c0d070a2:	2524      	movs	r5, #36	; 0x24
        if (buffer[4] != service->fakeChannelTransportPacketIndex) {
c0d070a4:	5d65      	ldrb	r5, [r4, r5]
c0d070a6:	42ab      	cmp	r3, r5
c0d070a8:	d148      	bne.n	c0d0713c <u2f_transport_receive_fakeChannel+0xe4>
c0d070aa:	4625      	mov	r5, r4
c0d070ac:	3524      	adds	r5, #36	; 0x24
        uint16_t xfer_len = MIN(size - 5, service->transportLength - service->fakeChannelTransportOffset);
c0d070ae:	8b27      	ldrh	r7, [r4, #24]
        service->fakeChannelTransportPacketIndex++;
c0d070b0:	1c5b      	adds	r3, r3, #1
c0d070b2:	702b      	strb	r3, [r5, #0]
        uint16_t xfer_len = MIN(size - 5, service->transportLength - service->fakeChannelTransportOffset);
c0d070b4:	1a3b      	subs	r3, r7, r0
c0d070b6:	1f52      	subs	r2, r2, #5
c0d070b8:	429a      	cmp	r2, r3
c0d070ba:	db00      	blt.n	c0d070be <u2f_transport_receive_fakeChannel+0x66>
c0d070bc:	461a      	mov	r2, r3
        service->fakeChannelTransportOffset += xfer_len;
c0d070be:	1880      	adds	r0, r0, r2
c0d070c0:	8460      	strh	r0, [r4, #34]	; 0x22
c0d070c2:	b292      	uxth	r2, r2
        service->fakeChannelCrc = cx_crc16_update(service->fakeChannelCrc, buffer + 5, xfer_len);   
c0d070c4:	8d20      	ldrh	r0, [r4, #40]	; 0x28
c0d070c6:	1d49      	adds	r1, r1, #5
c0d070c8:	e01e      	b.n	c0d07108 <u2f_transport_receive_fakeChannel+0xb0>
        if (buffer[4] == U2F_CMD_WINK) {
c0d070ca:	2b88      	cmp	r3, #136	; 0x88
c0d070cc:	d104      	bne.n	c0d070d8 <u2f_transport_receive_fakeChannel+0x80>
            u2f_transport_send_wink(service);
c0d070ce:	4620      	mov	r0, r4
c0d070d0:	f7ff ffaa 	bl	c0d07028 <u2f_transport_send_wink>
c0d070d4:	2501      	movs	r5, #1
c0d070d6:	e02e      	b.n	c0d07136 <u2f_transport_receive_fakeChannel+0xde>
        if (commandLength != service->transportLength) {
c0d070d8:	2b83      	cmp	r3, #131	; 0x83
c0d070da:	d12f      	bne.n	c0d0713c <u2f_transport_receive_fakeChannel+0xe4>
c0d070dc:	7988      	ldrb	r0, [r1, #6]
c0d070de:	794b      	ldrb	r3, [r1, #5]
c0d070e0:	021b      	lsls	r3, r3, #8
c0d070e2:	1818      	adds	r0, r3, r0
c0d070e4:	1cc0      	adds	r0, r0, #3
c0d070e6:	8b23      	ldrh	r3, [r4, #24]
c0d070e8:	b285      	uxth	r5, r0
c0d070ea:	42ab      	cmp	r3, r5
c0d070ec:	d126      	bne.n	c0d0713c <u2f_transport_receive_fakeChannel+0xe4>
c0d070ee:	1d09      	adds	r1, r1, #4
c0d070f0:	b285      	uxth	r5, r0
c0d070f2:	4b15      	ldr	r3, [pc, #84]	; (c0d07148 <u2f_transport_receive_fakeChannel+0xf0>)
c0d070f4:	2724      	movs	r7, #36	; 0x24
c0d070f6:	2000      	movs	r0, #0
        service->fakeChannelTransportPacketIndex = 0;
c0d070f8:	55e0      	strb	r0, [r4, r7]
        service->fakeChannelTransportOffset = MIN(size - 4, service->transportLength);
c0d070fa:	1f12      	subs	r2, r2, #4
c0d070fc:	42aa      	cmp	r2, r5
c0d070fe:	db00      	blt.n	c0d07102 <u2f_transport_receive_fakeChannel+0xaa>
c0d07100:	462a      	mov	r2, r5
c0d07102:	8462      	strh	r2, [r4, #34]	; 0x22
        service->fakeChannelCrc = cx_crc16_update(0, buffer + 4, service->fakeChannelTransportOffset);
c0d07104:	4013      	ands	r3, r2
c0d07106:	461a      	mov	r2, r3
c0d07108:	f7ff fc56 	bl	c0d069b8 <cx_crc16_update>
c0d0710c:	8520      	strh	r0, [r4, #40]	; 0x28
    if (service->fakeChannelTransportOffset >= service->transportLength) {
c0d0710e:	8b21      	ldrh	r1, [r4, #24]
c0d07110:	8c62      	ldrh	r2, [r4, #34]	; 0x22
c0d07112:	2501      	movs	r5, #1
c0d07114:	428a      	cmp	r2, r1
c0d07116:	d30e      	bcc.n	c0d07136 <u2f_transport_receive_fakeChannel+0xde>
        if (service->fakeChannelCrc != service->commandCrc) {
c0d07118:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
c0d0711a:	4288      	cmp	r0, r1
c0d0711c:	d10e      	bne.n	c0d0713c <u2f_transport_receive_fakeChannel+0xe4>
c0d0711e:	2006      	movs	r0, #6
        service->fakeChannelTransportState = U2F_FAKE_RECEIVED;
c0d07120:	7030      	strb	r0, [r6, #0]
c0d07122:	2700      	movs	r7, #0
        service->fakeChannelTransportOffset = 0;
c0d07124:	8467      	strh	r7, [r4, #34]	; 0x22
c0d07126:	202a      	movs	r0, #42	; 0x2a
        if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
c0d07128:	5c20      	ldrb	r0, [r4, r0]
c0d0712a:	2801      	cmp	r0, #1
c0d0712c:	d103      	bne.n	c0d07136 <u2f_transport_receive_fakeChannel+0xde>
            u2f_transport_send_usb_user_presence_required(service);
c0d0712e:	4620      	mov	r0, r4
c0d07130:	f7ff ff5e 	bl	c0d06ff0 <u2f_transport_send_usb_user_presence_required>
            service->fakeChannelTransportState = U2F_IDLE;
c0d07134:	7037      	strb	r7, [r6, #0]
}
c0d07136:	4628      	mov	r0, r5
c0d07138:	b001      	add	sp, #4
c0d0713a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0713c:	2005      	movs	r0, #5
    service->fakeChannelTransportState = U2F_INTERNAL_ERROR;
c0d0713e:	7030      	strb	r0, [r6, #0]
c0d07140:	2010      	movs	r0, #16
    THROW(EXCEPTION_IO_RESET);
c0d07142:	f7fd f91f 	bl	c0d04384 <os_longjmp>
c0d07146:	46c0      	nop			; (mov r8, r8)
c0d07148:	0000ffff 	.word	0x0000ffff

c0d0714c <u2f_transport_received>:
                          uint16_t size, u2f_transport_media_t media) {
c0d0714c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0714e:	b087      	sub	sp, #28
c0d07150:	4604      	mov	r4, r0
    service->media = media;
c0d07152:	7203      	strb	r3, [r0, #8]
c0d07154:	2020      	movs	r0, #32
    if (service->transportState == U2F_SENDING_RESPONSE) {
c0d07156:	5c20      	ldrb	r0, [r4, r0]
c0d07158:	4626      	mov	r6, r4
c0d0715a:	3620      	adds	r6, #32
c0d0715c:	2803      	cmp	r0, #3
c0d0715e:	d00a      	beq.n	c0d07176 <u2f_transport_received+0x2a>
c0d07160:	460f      	mov	r7, r1
c0d07162:	212a      	movs	r1, #42	; 0x2a
    if (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_IDLE) {
c0d07164:	5c61      	ldrb	r1, [r4, r1]
c0d07166:	2900      	cmp	r1, #0
c0d07168:	d01a      	beq.n	c0d071a0 <u2f_transport_received+0x54>
        if (!u2f_transport_receive_fakeChannel(service, buffer, size)) {
c0d0716a:	4620      	mov	r0, r4
c0d0716c:	4639      	mov	r1, r7
c0d0716e:	f7ff ff73 	bl	c0d07058 <u2f_transport_receive_fakeChannel>
c0d07172:	2800      	cmp	r0, #0
c0d07174:	d112      	bne.n	c0d0719c <u2f_transport_received+0x50>
c0d07176:	48b8      	ldr	r0, [pc, #736]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d07178:	2106      	movs	r1, #6
c0d0717a:	7201      	strb	r1, [r0, #8]
c0d0717c:	2104      	movs	r1, #4
c0d0717e:	7031      	strb	r1, [r6, #0]
c0d07180:	2140      	movs	r1, #64	; 0x40
c0d07182:	22bf      	movs	r2, #191	; 0xbf
c0d07184:	5462      	strb	r2, [r4, r1]
c0d07186:	3008      	adds	r0, #8
c0d07188:	61e0      	str	r0, [r4, #28]
c0d0718a:	2000      	movs	r0, #0
c0d0718c:	76a0      	strb	r0, [r4, #26]
c0d0718e:	2101      	movs	r1, #1
c0d07190:	8321      	strh	r1, [r4, #24]
c0d07192:	82e0      	strh	r0, [r4, #22]
c0d07194:	7a21      	ldrb	r1, [r4, #8]
c0d07196:	4620      	mov	r0, r4
c0d07198:	f7ff fe8c 	bl	c0d06eb4 <u2f_transport_sent>
}
c0d0719c:	b007      	add	sp, #28
c0d0719e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d071a0:	461d      	mov	r5, r3
c0d071a2:	4623      	mov	r3, r4
c0d071a4:	332a      	adds	r3, #42	; 0x2a
    if (service->transportState == U2F_SENDING_ERROR) {
c0d071a6:	2804      	cmp	r0, #4
c0d071a8:	d109      	bne.n	c0d071be <u2f_transport_received+0x72>
c0d071aa:	202b      	movs	r0, #43	; 0x2b
c0d071ac:	2100      	movs	r1, #0
    service->sending = false;
c0d071ae:	5421      	strb	r1, [r4, r0]
    service->transportPacketIndex = 0;
c0d071b0:	76a1      	strb	r1, [r4, #26]
    service->transportOffset = 0;
c0d071b2:	82e1      	strh	r1, [r4, #22]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d071b4:	7019      	strb	r1, [r3, #0]
    service->transportMedia = 0;
c0d071b6:	80b1      	strh	r1, [r6, #4]
c0d071b8:	6031      	str	r1, [r6, #0]
    service->transportBuffer = service->transportReceiveBuffer;
c0d071ba:	68e0      	ldr	r0, [r4, #12]
c0d071bc:	61e0      	str	r0, [r4, #28]
c0d071be:	9306      	str	r3, [sp, #24]
    uint16_t channelHeader = (media == U2F_MEDIA_USB ? 4 : 0);
c0d071c0:	1e68      	subs	r0, r5, #1
c0d071c2:	4241      	negs	r1, r0
c0d071c4:	4141      	adcs	r1, r0
    if (size < (1 + channelHeader)) {
c0d071c6:	008b      	lsls	r3, r1, #2
c0d071c8:	1c58      	adds	r0, r3, #1
c0d071ca:	4290      	cmp	r0, r2
c0d071cc:	d82c      	bhi.n	c0d07228 <u2f_transport_received+0xdc>
c0d071ce:	9003      	str	r0, [sp, #12]
    if (media == U2F_MEDIA_USB) {
c0d071d0:	2d01      	cmp	r5, #1
c0d071d2:	d108      	bne.n	c0d071e6 <u2f_transport_received+0x9a>
        os_memmove(service->channel, buffer, 4);
c0d071d4:	1d20      	adds	r0, r4, #4
c0d071d6:	9205      	str	r2, [sp, #20]
c0d071d8:	2204      	movs	r2, #4
c0d071da:	4639      	mov	r1, r7
c0d071dc:	9304      	str	r3, [sp, #16]
c0d071de:	f7fd f89c 	bl	c0d0431a <os_memmove>
c0d071e2:	9b04      	ldr	r3, [sp, #16]
c0d071e4:	9a05      	ldr	r2, [sp, #20]
    if (service->transportOffset == 0
c0d071e6:	8ae0      	ldrh	r0, [r4, #22]
        || (media == U2F_MEDIA_USB && os_memcmp(service->transportChannel, service->channel, 4) != 0) ) {
c0d071e8:	2800      	cmp	r0, #0
c0d071ea:	d00d      	beq.n	c0d07208 <u2f_transport_received+0xbc>
c0d071ec:	2d01      	cmp	r5, #1
c0d071ee:	d117      	bne.n	c0d07220 <u2f_transport_received+0xd4>
c0d071f0:	4620      	mov	r0, r4
c0d071f2:	3012      	adds	r0, #18
c0d071f4:	1d21      	adds	r1, r4, #4
c0d071f6:	9205      	str	r2, [sp, #20]
c0d071f8:	2204      	movs	r2, #4
c0d071fa:	9304      	str	r3, [sp, #16]
c0d071fc:	f7fd f8ac 	bl	c0d04358 <os_memcmp>
c0d07200:	9b04      	ldr	r3, [sp, #16]
c0d07202:	9a05      	ldr	r2, [sp, #20]
    if (service->transportOffset == 0
c0d07204:	2800      	cmp	r0, #0
c0d07206:	d00b      	beq.n	c0d07220 <u2f_transport_received+0xd4>
c0d07208:	2103      	movs	r1, #3
        if (size < (channelHeader + 3)) {
c0d0720a:	4618      	mov	r0, r3
c0d0720c:	4308      	orrs	r0, r1
c0d0720e:	4290      	cmp	r0, r2
c0d07210:	d80a      	bhi.n	c0d07228 <u2f_transport_received+0xdc>
        if ((buffer[channelHeader+0]&U2F_MASK_COMMAND) == 0) {
c0d07212:	56f8      	ldrsb	r0, [r7, r3]
c0d07214:	2800      	cmp	r0, #0
c0d07216:	db28      	blt.n	c0d0726a <u2f_transport_received+0x11e>
c0d07218:	488f      	ldr	r0, [pc, #572]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d0721a:	2104      	movs	r1, #4
c0d0721c:	7201      	strb	r1, [r0, #8]
c0d0721e:	e7ae      	b.n	c0d0717e <u2f_transport_received+0x32>
c0d07220:	2002      	movs	r0, #2
        if (size < (channelHeader + 2)) {
c0d07222:	4318      	orrs	r0, r3
c0d07224:	4290      	cmp	r0, r2
c0d07226:	d902      	bls.n	c0d0722e <u2f_transport_received+0xe2>
c0d07228:	488b      	ldr	r0, [pc, #556]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d0722a:	2185      	movs	r1, #133	; 0x85
c0d0722c:	e7a5      	b.n	c0d0717a <u2f_transport_received+0x2e>
c0d0722e:	2021      	movs	r0, #33	; 0x21
        if (media != service->transportMedia) {
c0d07230:	5c20      	ldrb	r0, [r4, r0]
c0d07232:	42a8      	cmp	r0, r5
c0d07234:	d116      	bne.n	c0d07264 <u2f_transport_received+0x118>
        if (service->transportState != U2F_HANDLE_SEGMENTED) {
c0d07236:	7830      	ldrb	r0, [r6, #0]
c0d07238:	2801      	cmp	r0, #1
c0d0723a:	d146      	bne.n	c0d072ca <u2f_transport_received+0x17e>
        if (media == U2F_MEDIA_USB) {
c0d0723c:	2d01      	cmp	r5, #1
c0d0723e:	d152      	bne.n	c0d072e6 <u2f_transport_received+0x19a>
            if (os_memcmp(buffer, service->channel, 4) != 0) {
c0d07240:	1d21      	adds	r1, r4, #4
c0d07242:	2004      	movs	r0, #4
c0d07244:	9006      	str	r0, [sp, #24]
c0d07246:	4638      	mov	r0, r7
c0d07248:	9205      	str	r2, [sp, #20]
c0d0724a:	9a06      	ldr	r2, [sp, #24]
c0d0724c:	9304      	str	r3, [sp, #16]
c0d0724e:	f7fd f883 	bl	c0d04358 <os_memcmp>
c0d07252:	9b04      	ldr	r3, [sp, #16]
c0d07254:	9a05      	ldr	r2, [sp, #20]
c0d07256:	2800      	cmp	r0, #0
c0d07258:	d045      	beq.n	c0d072e6 <u2f_transport_received+0x19a>
    G_io_usb_ep_buffer[8] = errorCode;
c0d0725a:	487f      	ldr	r0, [pc, #508]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d0725c:	2106      	movs	r1, #6
c0d0725e:	7201      	strb	r1, [r0, #8]
    service->transportState = U2F_SENDING_ERROR;
c0d07260:	9906      	ldr	r1, [sp, #24]
c0d07262:	e78c      	b.n	c0d0717e <u2f_transport_received+0x32>
    G_io_usb_ep_buffer[8] = errorCode;
c0d07264:	487c      	ldr	r0, [pc, #496]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d07266:	218d      	movs	r1, #141	; 0x8d
c0d07268:	e787      	b.n	c0d0717a <u2f_transport_received+0x2e>
c0d0726a:	9102      	str	r1, [sp, #8]
c0d0726c:	18f8      	adds	r0, r7, r3
        if (media == U2F_MEDIA_USB) {
c0d0726e:	9006      	str	r0, [sp, #24]
c0d07270:	2d01      	cmp	r5, #1
c0d07272:	d114      	bne.n	c0d0729e <u2f_transport_received+0x152>
            if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d07274:	7830      	ldrb	r0, [r6, #0]
c0d07276:	2801      	cmp	r0, #1
c0d07278:	d11a      	bne.n	c0d072b0 <u2f_transport_received+0x164>
                (os_memcmp(service->channel, service->transportChannel, 4) !=
c0d0727a:	1d20      	adds	r0, r4, #4
c0d0727c:	4621      	mov	r1, r4
c0d0727e:	3112      	adds	r1, #18
c0d07280:	9205      	str	r2, [sp, #20]
c0d07282:	2204      	movs	r2, #4
c0d07284:	9001      	str	r0, [sp, #4]
c0d07286:	9304      	str	r3, [sp, #16]
c0d07288:	f7fd f866 	bl	c0d04358 <os_memcmp>
c0d0728c:	9b04      	ldr	r3, [sp, #16]
c0d0728e:	9a05      	ldr	r2, [sp, #20]
                 0) &&
c0d07290:	2800      	cmp	r0, #0
c0d07292:	d004      	beq.n	c0d0729e <u2f_transport_received+0x152>
                (buffer[channelHeader] != U2F_CMD_INIT)) {
c0d07294:	9806      	ldr	r0, [sp, #24]
c0d07296:	7800      	ldrb	r0, [r0, #0]
            if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d07298:	2886      	cmp	r0, #134	; 0x86
c0d0729a:	d000      	beq.n	c0d0729e <u2f_transport_received+0x152>
c0d0729c:	e0c3      	b.n	c0d07426 <u2f_transport_received+0x2da>
        if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d0729e:	7830      	ldrb	r0, [r6, #0]
c0d072a0:	2801      	cmp	r0, #1
c0d072a2:	d105      	bne.n	c0d072b0 <u2f_transport_received+0x164>
            !((media == U2F_MEDIA_USB) &&
c0d072a4:	2d01      	cmp	r5, #1
c0d072a6:	d1b7      	bne.n	c0d07218 <u2f_transport_received+0xcc>
              (buffer[channelHeader] == U2F_CMD_INIT))) {
c0d072a8:	9806      	ldr	r0, [sp, #24]
c0d072aa:	7800      	ldrb	r0, [r0, #0]
        if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d072ac:	2886      	cmp	r0, #134	; 0x86
c0d072ae:	d1b3      	bne.n	c0d07218 <u2f_transport_received+0xcc>
c0d072b0:	9903      	ldr	r1, [sp, #12]
        uint16_t commandLength = U2BE(buffer, channelHeader + 1);
c0d072b2:	1878      	adds	r0, r7, r1
c0d072b4:	7840      	ldrb	r0, [r0, #1]
c0d072b6:	5c79      	ldrb	r1, [r7, r1]
c0d072b8:	0209      	lsls	r1, r1, #8
c0d072ba:	180f      	adds	r7, r1, r0
        if (commandLength > (service->transportReceiveBufferLength - 3)) {
c0d072bc:	8a20      	ldrh	r0, [r4, #16]
c0d072be:	1ec0      	subs	r0, r0, #3
c0d072c0:	4287      	cmp	r7, r0
c0d072c2:	dd35      	ble.n	c0d07330 <u2f_transport_received+0x1e4>
    G_io_usb_ep_buffer[8] = errorCode;
c0d072c4:	4864      	ldr	r0, [pc, #400]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d072c6:	9902      	ldr	r1, [sp, #8]
c0d072c8:	e757      	b.n	c0d0717a <u2f_transport_received+0x2e>
            if (media == U2F_MEDIA_USB) {
c0d072ca:	2d01      	cmp	r5, #1
c0d072cc:	d1a4      	bne.n	c0d07218 <u2f_transport_received+0xcc>
c0d072ce:	202b      	movs	r0, #43	; 0x2b
c0d072d0:	2100      	movs	r1, #0
    service->sending = false;
c0d072d2:	5421      	strb	r1, [r4, r0]
    service->transportPacketIndex = 0;
c0d072d4:	76a1      	strb	r1, [r4, #26]
    service->transportOffset = 0;
c0d072d6:	82e1      	strh	r1, [r4, #22]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d072d8:	9806      	ldr	r0, [sp, #24]
c0d072da:	7001      	strb	r1, [r0, #0]
    service->transportMedia = 0;
c0d072dc:	80b1      	strh	r1, [r6, #4]
c0d072de:	6031      	str	r1, [r6, #0]
    service->transportBuffer = service->transportReceiveBuffer;
c0d072e0:	68e0      	ldr	r0, [r4, #12]
c0d072e2:	61e0      	str	r0, [r4, #28]
c0d072e4:	e75a      	b.n	c0d0719c <u2f_transport_received+0x50>
        if (buffer[channelHeader] != service->transportPacketIndex) {
c0d072e6:	5cf8      	ldrb	r0, [r7, r3]
c0d072e8:	7ea1      	ldrb	r1, [r4, #26]
c0d072ea:	4288      	cmp	r0, r1
c0d072ec:	d194      	bne.n	c0d07218 <u2f_transport_received+0xcc>
c0d072ee:	18f9      	adds	r1, r7, r3
        xfer_len = MIN(size - (channelHeader + 1), service->transportLength - service->transportOffset);
c0d072f0:	9803      	ldr	r0, [sp, #12]
c0d072f2:	1a17      	subs	r7, r2, r0
c0d072f4:	8ae0      	ldrh	r0, [r4, #22]
c0d072f6:	8b22      	ldrh	r2, [r4, #24]
c0d072f8:	1a12      	subs	r2, r2, r0
c0d072fa:	4297      	cmp	r7, r2
c0d072fc:	db00      	blt.n	c0d07300 <u2f_transport_received+0x1b4>
c0d072fe:	4617      	mov	r7, r2
        os_memmove(service->transportBuffer + service->transportOffset, buffer + channelHeader + 1, xfer_len);
c0d07300:	b2ba      	uxth	r2, r7
c0d07302:	69e3      	ldr	r3, [r4, #28]
c0d07304:	1818      	adds	r0, r3, r0
c0d07306:	1c49      	adds	r1, r1, #1
c0d07308:	9206      	str	r2, [sp, #24]
c0d0730a:	f7fd f806 	bl	c0d0431a <os_memmove>
        if (media == U2F_MEDIA_USB) {
c0d0730e:	2d01      	cmp	r5, #1
c0d07310:	d107      	bne.n	c0d07322 <u2f_transport_received+0x1d6>
            service->commandCrc = cx_crc16_update(service->commandCrc, service->transportBuffer + service->transportOffset, xfer_len);
c0d07312:	8ae0      	ldrh	r0, [r4, #22]
c0d07314:	69e1      	ldr	r1, [r4, #28]
c0d07316:	1809      	adds	r1, r1, r0
c0d07318:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
c0d0731a:	9a06      	ldr	r2, [sp, #24]
c0d0731c:	f7ff fb4c 	bl	c0d069b8 <cx_crc16_update>
c0d07320:	84e0      	strh	r0, [r4, #38]	; 0x26
        service->transportOffset += xfer_len;
c0d07322:	8ae0      	ldrh	r0, [r4, #22]
c0d07324:	19c0      	adds	r0, r0, r7
c0d07326:	82e0      	strh	r0, [r4, #22]
        service->transportPacketIndex++;
c0d07328:	7ea0      	ldrb	r0, [r4, #26]
c0d0732a:	1c40      	adds	r0, r0, #1
c0d0732c:	76a0      	strb	r0, [r4, #26]
c0d0732e:	e054      	b.n	c0d073da <u2f_transport_received+0x28e>
        switch (buffer[channelHeader]) {
c0d07330:	9806      	ldr	r0, [sp, #24]
c0d07332:	7800      	ldrb	r0, [r0, #0]
c0d07334:	2881      	cmp	r0, #129	; 0x81
c0d07336:	d003      	beq.n	c0d07340 <u2f_transport_received+0x1f4>
c0d07338:	2886      	cmp	r0, #134	; 0x86
c0d0733a:	d01c      	beq.n	c0d07376 <u2f_transport_received+0x22a>
c0d0733c:	2883      	cmp	r0, #131	; 0x83
c0d0733e:	d15f      	bne.n	c0d07400 <u2f_transport_received+0x2b4>
c0d07340:	9304      	str	r3, [sp, #16]
c0d07342:	9205      	str	r2, [sp, #20]
            if (media == U2F_MEDIA_USB) {
c0d07344:	2d01      	cmp	r5, #1
c0d07346:	d123      	bne.n	c0d07390 <u2f_transport_received+0x244>
                if (u2f_is_channel_broadcast(service->channel) ||
c0d07348:	1d20      	adds	r0, r4, #4
    return (os_memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
c0d0734a:	4944      	ldr	r1, [pc, #272]	; (c0d0745c <u2f_transport_received+0x310>)
c0d0734c:	4479      	add	r1, pc
c0d0734e:	2204      	movs	r2, #4
c0d07350:	9003      	str	r0, [sp, #12]
c0d07352:	9202      	str	r2, [sp, #8]
c0d07354:	f7fd f800 	bl	c0d04358 <os_memcmp>
                if (u2f_is_channel_broadcast(service->channel) ||
c0d07358:	2800      	cmp	r0, #0
c0d0735a:	d007      	beq.n	c0d0736c <u2f_transport_received+0x220>
    return (os_memcmp(channel, FORBIDDEN_CHANNEL, 4) == 0);
c0d0735c:	4940      	ldr	r1, [pc, #256]	; (c0d07460 <u2f_transport_received+0x314>)
c0d0735e:	4479      	add	r1, pc
c0d07360:	2204      	movs	r2, #4
c0d07362:	9803      	ldr	r0, [sp, #12]
c0d07364:	f7fc fff8 	bl	c0d04358 <os_memcmp>
                if (u2f_is_channel_broadcast(service->channel) ||
c0d07368:	2800      	cmp	r0, #0
c0d0736a:	d111      	bne.n	c0d07390 <u2f_transport_received+0x244>
    G_io_usb_ep_buffer[8] = errorCode;
c0d0736c:	483a      	ldr	r0, [pc, #232]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d0736e:	210b      	movs	r1, #11
c0d07370:	7201      	strb	r1, [r0, #8]
    service->transportState = U2F_SENDING_ERROR;
c0d07372:	9902      	ldr	r1, [sp, #8]
c0d07374:	e703      	b.n	c0d0717e <u2f_transport_received+0x32>
            if (media != U2F_MEDIA_USB) {
c0d07376:	2d01      	cmp	r5, #1
c0d07378:	d142      	bne.n	c0d07400 <u2f_transport_received+0x2b4>
c0d0737a:	9304      	str	r3, [sp, #16]
c0d0737c:	9205      	str	r2, [sp, #20]
            if (u2f_is_channel_forbidden(service->channel)) {
c0d0737e:	1d20      	adds	r0, r4, #4
    return (os_memcmp(channel, FORBIDDEN_CHANNEL, 4) == 0);
c0d07380:	4938      	ldr	r1, [pc, #224]	; (c0d07464 <u2f_transport_received+0x318>)
c0d07382:	4479      	add	r1, pc
c0d07384:	2204      	movs	r2, #4
c0d07386:	9203      	str	r2, [sp, #12]
c0d07388:	f7fc ffe6 	bl	c0d04358 <os_memcmp>
            if (u2f_is_channel_forbidden(service->channel)) {
c0d0738c:	2800      	cmp	r0, #0
c0d0738e:	d05d      	beq.n	c0d0744c <u2f_transport_received+0x300>
            xfer_len = MIN(size - (channelHeader), U2F_COMMAND_HEADER_SIZE+commandLength);
c0d07390:	9805      	ldr	r0, [sp, #20]
c0d07392:	9904      	ldr	r1, [sp, #16]
c0d07394:	1a40      	subs	r0, r0, r1
c0d07396:	1cf9      	adds	r1, r7, #3
c0d07398:	4288      	cmp	r0, r1
c0d0739a:	db00      	blt.n	c0d0739e <u2f_transport_received+0x252>
c0d0739c:	4608      	mov	r0, r1
c0d0739e:	9104      	str	r1, [sp, #16]
c0d073a0:	9005      	str	r0, [sp, #20]
            os_memmove(service->transportBuffer, buffer + channelHeader, xfer_len);
c0d073a2:	b287      	uxth	r7, r0
c0d073a4:	69e0      	ldr	r0, [r4, #28]
c0d073a6:	9906      	ldr	r1, [sp, #24]
c0d073a8:	463a      	mov	r2, r7
c0d073aa:	f7fc ffb6 	bl	c0d0431a <os_memmove>
            if (media == U2F_MEDIA_USB) {
c0d073ae:	2d01      	cmp	r5, #1
c0d073b0:	d105      	bne.n	c0d073be <u2f_transport_received+0x272>
                service->commandCrc = cx_crc16_update(0, service->transportBuffer, xfer_len);
c0d073b2:	69e1      	ldr	r1, [r4, #28]
c0d073b4:	2000      	movs	r0, #0
c0d073b6:	463a      	mov	r2, r7
c0d073b8:	f7ff fafe 	bl	c0d069b8 <cx_crc16_update>
c0d073bc:	84e0      	strh	r0, [r4, #38]	; 0x26
c0d073be:	2021      	movs	r0, #33	; 0x21
            service->transportMedia = media;
c0d073c0:	5425      	strb	r5, [r4, r0]
            service->transportLength = U2F_COMMAND_HEADER_SIZE+commandLength;
c0d073c2:	9804      	ldr	r0, [sp, #16]
c0d073c4:	8320      	strh	r0, [r4, #24]
            service->transportOffset = xfer_len;
c0d073c6:	9805      	ldr	r0, [sp, #20]
c0d073c8:	82e0      	strh	r0, [r4, #22]
c0d073ca:	2000      	movs	r0, #0
            service->transportPacketIndex = 0;
c0d073cc:	76a0      	strb	r0, [r4, #26]
            os_memmove(service->transportChannel, service->channel, 4);
c0d073ce:	4620      	mov	r0, r4
c0d073d0:	3012      	adds	r0, #18
c0d073d2:	1d21      	adds	r1, r4, #4
c0d073d4:	2204      	movs	r2, #4
c0d073d6:	f7fc ffa0 	bl	c0d0431a <os_memmove>
c0d073da:	8ae0      	ldrh	r0, [r4, #22]
    if ((media != U2F_MEDIA_USB) &&
c0d073dc:	2d01      	cmp	r5, #1
c0d073de:	d101      	bne.n	c0d073e4 <u2f_transport_received+0x298>
    } else if (service->transportOffset >= service->transportLength) {
c0d073e0:	8b21      	ldrh	r1, [r4, #24]
c0d073e2:	e006      	b.n	c0d073f2 <u2f_transport_received+0x2a6>
         (service->transportLength + U2F_COMMAND_HEADER_SIZE))) {
c0d073e4:	8b21      	ldrh	r1, [r4, #24]
c0d073e6:	1cca      	adds	r2, r1, #3
    if ((media != U2F_MEDIA_USB) &&
c0d073e8:	4282      	cmp	r2, r0
c0d073ea:	d202      	bcs.n	c0d073f2 <u2f_transport_received+0x2a6>
    G_io_usb_ep_buffer[8] = errorCode;
c0d073ec:	481a      	ldr	r0, [pc, #104]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d073ee:	2103      	movs	r1, #3
c0d073f0:	e6c3      	b.n	c0d0717a <u2f_transport_received+0x2e>
    } else if (service->transportOffset >= service->transportLength) {
c0d073f2:	4288      	cmp	r0, r1
c0d073f4:	d211      	bcs.n	c0d0741a <u2f_transport_received+0x2ce>
c0d073f6:	2000      	movs	r0, #0
        service->seqTimeout = 0;
c0d073f8:	6360      	str	r0, [r4, #52]	; 0x34
c0d073fa:	2001      	movs	r0, #1
        service->transportState = U2F_HANDLE_SEGMENTED;
c0d073fc:	7030      	strb	r0, [r6, #0]
c0d073fe:	e6cd      	b.n	c0d0719c <u2f_transport_received+0x50>
c0d07400:	4815      	ldr	r0, [pc, #84]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d07402:	2101      	movs	r1, #1
c0d07404:	7201      	strb	r1, [r0, #8]
c0d07406:	2204      	movs	r2, #4
c0d07408:	7032      	strb	r2, [r6, #0]
c0d0740a:	2240      	movs	r2, #64	; 0x40
c0d0740c:	23bf      	movs	r3, #191	; 0xbf
c0d0740e:	54a3      	strb	r3, [r4, r2]
c0d07410:	3008      	adds	r0, #8
c0d07412:	61e0      	str	r0, [r4, #28]
c0d07414:	2000      	movs	r0, #0
c0d07416:	76a0      	strb	r0, [r4, #26]
c0d07418:	e6ba      	b.n	c0d07190 <u2f_transport_received+0x44>
c0d0741a:	2002      	movs	r0, #2
        service->transportState = U2F_PROCESSING_COMMAND;
c0d0741c:	7030      	strb	r0, [r6, #0]
        u2f_message_complete(service);
c0d0741e:	4620      	mov	r0, r4
c0d07420:	f7ff fcfe 	bl	c0d06e20 <u2f_message_complete>
c0d07424:	e6ba      	b.n	c0d0719c <u2f_transport_received+0x50>
                    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d07426:	4c0c      	ldr	r4, [pc, #48]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d07428:	2204      	movs	r2, #4
c0d0742a:	4620      	mov	r0, r4
c0d0742c:	9901      	ldr	r1, [sp, #4]
c0d0742e:	f7fc ff74 	bl	c0d0431a <os_memmove>
c0d07432:	2006      	movs	r0, #6
                G_io_usb_ep_buffer[offset++] = ERROR_CHANNEL_BUSY;
c0d07434:	71e0      	strb	r0, [r4, #7]
c0d07436:	2201      	movs	r2, #1
                G_io_usb_ep_buffer[offset++] = 1;
c0d07438:	71a2      	strb	r2, [r4, #6]
c0d0743a:	2000      	movs	r0, #0
                G_io_usb_ep_buffer[offset++] = 0;
c0d0743c:	7160      	strb	r0, [r4, #5]
c0d0743e:	20bf      	movs	r0, #191	; 0xbf
                G_io_usb_ep_buffer[offset++] = U2F_STATUS_ERROR;
c0d07440:	7120      	strb	r0, [r4, #4]
c0d07442:	2108      	movs	r1, #8
                u2f_io_send(G_io_usb_ep_buffer, offset, media);
c0d07444:	4620      	mov	r0, r4
c0d07446:	f7ff fd09 	bl	c0d06e5c <u2f_io_send>
c0d0744a:	e6a7      	b.n	c0d0719c <u2f_transport_received+0x50>
    G_io_usb_ep_buffer[8] = errorCode;
c0d0744c:	4802      	ldr	r0, [pc, #8]	; (c0d07458 <u2f_transport_received+0x30c>)
c0d0744e:	210b      	movs	r1, #11
c0d07450:	7201      	strb	r1, [r0, #8]
    service->transportState = U2F_SENDING_ERROR;
c0d07452:	9903      	ldr	r1, [sp, #12]
c0d07454:	e693      	b.n	c0d0717e <u2f_transport_received+0x32>
c0d07456:	46c0      	nop			; (mov r8, r8)
c0d07458:	200020c0 	.word	0x200020c0
c0d0745c:	00005269 	.word	0x00005269
c0d07460:	0000525b 	.word	0x0000525b
c0d07464:	00005237 	.word	0x00005237

c0d07468 <u2f_is_channel_broadcast>:
bool u2f_is_channel_broadcast(uint8_t *channel) {
c0d07468:	b580      	push	{r7, lr}
    return (os_memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
c0d0746a:	4904      	ldr	r1, [pc, #16]	; (c0d0747c <u2f_is_channel_broadcast+0x14>)
c0d0746c:	4479      	add	r1, pc
c0d0746e:	2204      	movs	r2, #4
c0d07470:	f7fc ff72 	bl	c0d04358 <os_memcmp>
c0d07474:	4241      	negs	r1, r0
c0d07476:	4148      	adcs	r0, r1
c0d07478:	bd80      	pop	{r7, pc}
c0d0747a:	46c0      	nop			; (mov r8, r8)
c0d0747c:	00005149 	.word	0x00005149

c0d07480 <u2f_message_set_autoreply_wait_user_presence>:
void u2f_message_set_autoreply_wait_user_presence(u2f_service_t* service, bool enabled) {
c0d07480:	b580      	push	{r7, lr}
c0d07482:	222a      	movs	r2, #42	; 0x2a
c0d07484:	5c83      	ldrb	r3, [r0, r2]
c0d07486:	4602      	mov	r2, r0
c0d07488:	322a      	adds	r2, #42	; 0x2a
    if (enabled) {
c0d0748a:	2900      	cmp	r1, #0
c0d0748c:	d006      	beq.n	c0d0749c <u2f_message_set_autoreply_wait_user_presence+0x1c>
        if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE) {
c0d0748e:	2b00      	cmp	r3, #0
c0d07490:	d108      	bne.n	c0d074a4 <u2f_message_set_autoreply_wait_user_presence+0x24>
c0d07492:	2101      	movs	r1, #1
            service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_ON;
c0d07494:	7011      	strb	r1, [r2, #0]
            u2f_transport_send_usb_user_presence_required(service);
c0d07496:	f7ff fdab 	bl	c0d06ff0 <u2f_transport_send_usb_user_presence_required>
}
c0d0749a:	bd80      	pop	{r7, pc}
    else if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
c0d0749c:	2b01      	cmp	r3, #1
c0d0749e:	d101      	bne.n	c0d074a4 <u2f_message_set_autoreply_wait_user_presence+0x24>
c0d074a0:	2002      	movs	r0, #2
        service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_REPLY_READY;
c0d074a2:	7010      	strb	r0, [r2, #0]
}
c0d074a4:	bd80      	pop	{r7, pc}
	...

c0d074a8 <u2f_message_reply>:
        ;
}

void u2f_message_reply(u2f_service_t *service, uint8_t cmd, uint8_t *buffer, uint16_t len) {
c0d074a8:	b570      	push	{r4, r5, r6, lr}
c0d074aa:	4604      	mov	r4, r0
c0d074ac:	202a      	movs	r0, #42	; 0x2a
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d074ae:	5c20      	ldrb	r0, [r4, r0]
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0d074b0:	2800      	cmp	r0, #0
c0d074b2:	d009      	beq.n	c0d074c8 <u2f_message_reply+0x20>
c0d074b4:	2801      	cmp	r0, #1
c0d074b6:	d029      	beq.n	c0d0750c <u2f_message_reply+0x64>
c0d074b8:	2025      	movs	r0, #37	; 0x25
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0d074ba:	5c20      	ldrb	r0, [r4, r0]
            && service->sending == false)
c0d074bc:	2806      	cmp	r0, #6
c0d074be:	d125      	bne.n	c0d0750c <u2f_message_reply+0x64>
c0d074c0:	202b      	movs	r0, #43	; 0x2b
c0d074c2:	5c20      	ldrb	r0, [r4, r0]

    // if U2F is not ready to reply, then gently avoid replying
    if (u2f_message_repliable(service)) 
c0d074c4:	2800      	cmp	r0, #0
c0d074c6:	d121      	bne.n	c0d0750c <u2f_message_reply+0x64>
c0d074c8:	2020      	movs	r0, #32
c0d074ca:	2503      	movs	r5, #3
    {
        service->transportState = U2F_SENDING_RESPONSE;
c0d074cc:	5425      	strb	r5, [r4, r0]
c0d074ce:	2040      	movs	r0, #64	; 0x40
        service->transportPacketIndex = 0;
        service->transportBuffer = buffer;
        service->transportOffset = 0;
        service->transportLength = len;
        service->sendCmd = cmd;
c0d074d0:	5421      	strb	r1, [r4, r0]
        service->transportBuffer = buffer;
c0d074d2:	61e2      	str	r2, [r4, #28]
c0d074d4:	2000      	movs	r0, #0
        service->transportPacketIndex = 0;
c0d074d6:	76a0      	strb	r0, [r4, #26]
        service->transportLength = len;
c0d074d8:	8323      	strh	r3, [r4, #24]
        service->transportOffset = 0;
c0d074da:	82e0      	strh	r0, [r4, #22]
c0d074dc:	2021      	movs	r0, #33	; 0x21
        if (service->transportMedia != U2F_MEDIA_BLE) {
c0d074de:	5c21      	ldrb	r1, [r4, r0]
c0d074e0:	2903      	cmp	r1, #3
c0d074e2:	d114      	bne.n	c0d0750e <u2f_message_reply+0x66>
            // pump the first message
            u2f_transport_sent(service, service->transportMedia);
        }
        else {
            while (G_io_app.apdu_state != APDU_IDLE) {
c0d074e4:	4d0c      	ldr	r5, [pc, #48]	; (c0d07518 <u2f_message_reply+0x70>)
c0d074e6:	7828      	ldrb	r0, [r5, #0]
c0d074e8:	2800      	cmp	r0, #0
c0d074ea:	d00f      	beq.n	c0d0750c <u2f_message_reply+0x64>
c0d074ec:	2103      	movs	r1, #3
                u2f_transport_sent(service, service->transportMedia);       
c0d074ee:	4620      	mov	r0, r4
c0d074f0:	f7ff fce0 	bl	c0d06eb4 <u2f_transport_sent>
            while (G_io_app.apdu_state != APDU_IDLE) {
c0d074f4:	7828      	ldrb	r0, [r5, #0]
c0d074f6:	2800      	cmp	r0, #0
c0d074f8:	d008      	beq.n	c0d0750c <u2f_message_reply+0x64>
c0d074fa:	4626      	mov	r6, r4
c0d074fc:	3621      	adds	r6, #33	; 0x21
                u2f_transport_sent(service, service->transportMedia);       
c0d074fe:	7831      	ldrb	r1, [r6, #0]
c0d07500:	4620      	mov	r0, r4
c0d07502:	f7ff fcd7 	bl	c0d06eb4 <u2f_transport_sent>
            while (G_io_app.apdu_state != APDU_IDLE) {
c0d07506:	7828      	ldrb	r0, [r5, #0]
c0d07508:	2800      	cmp	r0, #0
c0d0750a:	d1f8      	bne.n	c0d074fe <u2f_message_reply+0x56>
            }
        }
    }
}
c0d0750c:	bd70      	pop	{r4, r5, r6, pc}
            u2f_transport_sent(service, service->transportMedia);
c0d0750e:	4620      	mov	r0, r4
c0d07510:	f7ff fcd0 	bl	c0d06eb4 <u2f_transport_sent>
}
c0d07514:	bd70      	pop	{r4, r5, r6, pc}
c0d07516:	46c0      	nop			; (mov r8, r8)
c0d07518:	2000205c 	.word	0x2000205c

c0d0751c <io_seproxyhal_touch_address_ok>:
#include "shared_context.h"
#include "feature_getPublicKey.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_address_ok(const bagl_element_t *e) {
c0d0751c:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = set_result_get_publicKey();
c0d0751e:	f7fb fdfb 	bl	c0d03118 <set_result_get_publicKey>
c0d07522:	4604      	mov	r4, r0
    G_io_apdu_buffer[tx++] = 0x90;
c0d07524:	4808      	ldr	r0, [pc, #32]	; (c0d07548 <io_seproxyhal_touch_address_ok+0x2c>)
c0d07526:	2190      	movs	r1, #144	; 0x90
c0d07528:	5501      	strb	r1, [r0, r4]
c0d0752a:	1900      	adds	r0, r0, r4
c0d0752c:	2500      	movs	r5, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0d0752e:	7045      	strb	r5, [r0, #1]
    reset_app_context();
c0d07530:	f7fc f98c 	bl	c0d0384c <reset_app_context>
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d07534:	1ca0      	adds	r0, r4, #2
c0d07536:	b281      	uxth	r1, r0
c0d07538:	2020      	movs	r0, #32
c0d0753a:	f7fd fa73 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d0753e:	f7fc f9a7 	bl	c0d03890 <ui_idle>
    return 0;  // do not redraw the widget
c0d07542:	4628      	mov	r0, r5
c0d07544:	bdb0      	pop	{r4, r5, r7, pc}
c0d07546:	46c0      	nop			; (mov r8, r8)
c0d07548:	20001f09 	.word	0x20001f09

c0d0754c <io_seproxyhal_touch_address_cancel>:
}

unsigned int io_seproxyhal_touch_address_cancel(const bagl_element_t *e) {
c0d0754c:	b580      	push	{r7, lr}
    G_io_apdu_buffer[0] = 0x69;
c0d0754e:	4807      	ldr	r0, [pc, #28]	; (c0d0756c <io_seproxyhal_touch_address_cancel+0x20>)
c0d07550:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0d07552:	7041      	strb	r1, [r0, #1]
c0d07554:	2169      	movs	r1, #105	; 0x69
    G_io_apdu_buffer[0] = 0x69;
c0d07556:	7001      	strb	r1, [r0, #0]
    reset_app_context();
c0d07558:	f7fc f978 	bl	c0d0384c <reset_app_context>
c0d0755c:	2020      	movs	r0, #32
c0d0755e:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d07560:	f7fd fa60 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d07564:	f7fc f994 	bl	c0d03890 <ui_idle>
c0d07568:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d0756a:	bd80      	pop	{r7, pc}
c0d0756c:	20001f09 	.word	0x20001f09

c0d07570 <io_seproxyhal_touch_signMessage_ok>:
#include "shared_context.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_signMessage_ok(const bagl_element_t *e) {
c0d07570:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07572:	b0b3      	sub	sp, #204	; 0xcc
    uint8_t privateKeyData[32];
    uint8_t signature[100];
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0d07574:	f7fd fbf6 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.messageSigningContext.bip32Path,
                               tmpCtx.messageSigningContext.pathLength,
c0d07578:	4e29      	ldr	r6, [pc, #164]	; (c0d07620 <io_seproxyhal_touch_signMessage_ok+0xb0>)
c0d0757a:	7832      	ldrb	r2, [r6, #0]
c0d0757c:	2100      	movs	r1, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d0757e:	9106      	str	r1, [sp, #24]
c0d07580:	4668      	mov	r0, sp
c0d07582:	6001      	str	r1, [r0, #0]
c0d07584:	1d31      	adds	r1, r6, #4
c0d07586:	2521      	movs	r5, #33	; 0x21
c0d07588:	af2b      	add	r7, sp, #172	; 0xac
c0d0758a:	4628      	mov	r0, r5
c0d0758c:	463b      	mov	r3, r7
c0d0758e:	f7ff fa59 	bl	c0d06a44 <os_perso_derive_node_bip32>
                               privateKeyData,
                               NULL);
    io_seproxyhal_io_heartbeat();
c0d07592:	f7fd fbe7 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d07596:	2420      	movs	r4, #32
c0d07598:	ab08      	add	r3, sp, #32
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d0759a:	9304      	str	r3, [sp, #16]
c0d0759c:	4628      	mov	r0, r5
c0d0759e:	4639      	mov	r1, r7
c0d075a0:	4622      	mov	r2, r4
c0d075a2:	f7ff f9bb 	bl	c0d0691c <cx_ecfp_init_private_key>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d075a6:	4638      	mov	r0, r7
c0d075a8:	4621      	mov	r1, r4
c0d075aa:	f003 f875 	bl	c0d0a698 <explicit_bzero>
    unsigned int info = 0;
c0d075ae:	9806      	ldr	r0, [sp, #24]
c0d075b0:	9007      	str	r0, [sp, #28]
    io_seproxyhal_io_heartbeat();
c0d075b2:	f7fd fbd7 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d075b6:	a807      	add	r0, sp, #28
    signatureLength = cx_ecdsa_sign(&privateKey,
c0d075b8:	4669      	mov	r1, sp
c0d075ba:	60c8      	str	r0, [r1, #12]
c0d075bc:	2064      	movs	r0, #100	; 0x64
c0d075be:	6088      	str	r0, [r1, #8]
c0d075c0:	af12      	add	r7, sp, #72	; 0x48
c0d075c2:	604f      	str	r7, [r1, #4]
c0d075c4:	9405      	str	r4, [sp, #20]
c0d075c6:	600c      	str	r4, [r1, #0]
c0d075c8:	362c      	adds	r6, #44	; 0x2c
c0d075ca:	4916      	ldr	r1, [pc, #88]	; (c0d07624 <io_seproxyhal_touch_signMessage_ok+0xb4>)
c0d075cc:	2203      	movs	r2, #3
c0d075ce:	9c04      	ldr	r4, [sp, #16]
c0d075d0:	4620      	mov	r0, r4
c0d075d2:	4633      	mov	r3, r6
c0d075d4:	f7ff f9c2 	bl	c0d0695c <cx_ecdsa_sign>
c0d075d8:	2128      	movs	r1, #40	; 0x28
                                    tmpCtx.messageSigningContext.hash,
                                    sizeof(tmpCtx.messageSigningContext.hash),
                                    signature,
                                    sizeof(signature),
                                    &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d075da:	4620      	mov	r0, r4
c0d075dc:	f003 f85c 	bl	c0d0a698 <explicit_bzero>
    G_io_apdu_buffer[0] = 27;
    if (info & CX_ECCINFO_PARITY_ODD) {
c0d075e0:	9907      	ldr	r1, [sp, #28]
c0d075e2:	07c8      	lsls	r0, r1, #31
c0d075e4:	d001      	beq.n	c0d075ea <io_seproxyhal_touch_signMessage_ok+0x7a>
c0d075e6:	201c      	movs	r0, #28
c0d075e8:	e000      	b.n	c0d075ec <io_seproxyhal_touch_signMessage_ok+0x7c>
c0d075ea:	201b      	movs	r0, #27
        G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
c0d075ec:	0789      	lsls	r1, r1, #30
c0d075ee:	d500      	bpl.n	c0d075f2 <io_seproxyhal_touch_signMessage_ok+0x82>
c0d075f0:	1c80      	adds	r0, r0, #2
c0d075f2:	4c0d      	ldr	r4, [pc, #52]	; (c0d07628 <io_seproxyhal_touch_signMessage_ok+0xb8>)
c0d075f4:	7020      	strb	r0, [r4, #0]
        G_io_apdu_buffer[0] += 2;
    }
    format_signature_out(signature);
c0d075f6:	4638      	mov	r0, r7
c0d075f8:	f7fc f968 	bl	c0d038cc <format_signature_out>
c0d075fc:	2042      	movs	r0, #66	; 0x42
c0d075fe:	9d06      	ldr	r5, [sp, #24]
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d07600:	5425      	strb	r5, [r4, r0]
c0d07602:	2041      	movs	r0, #65	; 0x41
c0d07604:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d07606:	5421      	strb	r1, [r4, r0]
    reset_app_context();
c0d07608:	f7fc f920 	bl	c0d0384c <reset_app_context>
c0d0760c:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d0760e:	9805      	ldr	r0, [sp, #20]
c0d07610:	f7fd fa08 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d07614:	f7fc f93c 	bl	c0d03890 <ui_idle>
    return 0;  // do not redraw the widget
c0d07618:	4628      	mov	r0, r5
c0d0761a:	b033      	add	sp, #204	; 0xcc
c0d0761c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0761e:	46c0      	nop			; (mov r8, r8)
c0d07620:	20001804 	.word	0x20001804
c0d07624:	00000601 	.word	0x00000601
c0d07628:	20001f09 	.word	0x20001f09

c0d0762c <io_seproxyhal_touch_signMessage_cancel>:
}

unsigned int io_seproxyhal_touch_signMessage_cancel(const bagl_element_t *e) {
c0d0762c:	b580      	push	{r7, lr}
    reset_app_context();
c0d0762e:	f7fc f90d 	bl	c0d0384c <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0d07632:	4806      	ldr	r0, [pc, #24]	; (c0d0764c <io_seproxyhal_touch_signMessage_cancel+0x20>)
c0d07634:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0d07636:	7041      	strb	r1, [r0, #1]
c0d07638:	2169      	movs	r1, #105	; 0x69
    G_io_apdu_buffer[0] = 0x69;
c0d0763a:	7001      	strb	r1, [r0, #0]
c0d0763c:	2020      	movs	r0, #32
c0d0763e:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d07640:	f7fd f9f0 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d07644:	f7fc f924 	bl	c0d03890 <ui_idle>
c0d07648:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d0764a:	bd80      	pop	{r7, pc}
c0d0764c:	20001f09 	.word	0x20001f09

c0d07650 <io_seproxyhal_touch_signMessage712_v0_ok>:
#include "shared_context.h"
#include "ui_callbacks.h"

static const uint8_t const EIP_712_MAGIC[] = {0x19, 0x01};

unsigned int io_seproxyhal_touch_signMessage712_v0_ok(const bagl_element_t *e) {
c0d07650:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07652:	b0bb      	sub	sp, #236	; 0xec
    uint8_t hash[32];
    uint8_t signature[100];
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0d07654:	f7fd fb86 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d07658:	2701      	movs	r7, #1
c0d0765a:	0239      	lsls	r1, r7, #8
    cx_keccak_init(&global_sha3, 256);
c0d0765c:	4d3e      	ldr	r5, [pc, #248]	; (c0d07758 <io_seproxyhal_touch_signMessage712_v0_ok+0x108>)
c0d0765e:	4628      	mov	r0, r5
c0d07660:	f7ff f91a 	bl	c0d06898 <cx_keccak_init>
c0d07664:	2600      	movs	r6, #0
    cx_hash((cx_hash_t *) &global_sha3,
c0d07666:	4668      	mov	r0, sp
c0d07668:	6006      	str	r6, [r0, #0]
c0d0766a:	6046      	str	r6, [r0, #4]
c0d0766c:	4a3e      	ldr	r2, [pc, #248]	; (c0d07768 <io_seproxyhal_touch_signMessage712_v0_ok+0x118>)
c0d0766e:	447a      	add	r2, pc
c0d07670:	2302      	movs	r3, #2
c0d07672:	4628      	mov	r0, r5
c0d07674:	4631      	mov	r1, r6
c0d07676:	f7ff f8df 	bl	c0d06838 <cx_hash>
            0,
            (uint8_t *) EIP_712_MAGIC,
            sizeof(EIP_712_MAGIC),
            NULL,
            0);
    cx_hash((cx_hash_t *) &global_sha3,
c0d0767a:	4668      	mov	r0, sp
c0d0767c:	6006      	str	r6, [r0, #0]
c0d0767e:	6046      	str	r6, [r0, #4]
c0d07680:	4a36      	ldr	r2, [pc, #216]	; (c0d0775c <io_seproxyhal_touch_signMessage712_v0_ok+0x10c>)
c0d07682:	322c      	adds	r2, #44	; 0x2c
c0d07684:	2420      	movs	r4, #32
c0d07686:	4628      	mov	r0, r5
c0d07688:	4631      	mov	r1, r6
c0d0768a:	4623      	mov	r3, r4
c0d0768c:	f7ff f8d4 	bl	c0d06838 <cx_hash>
            0,
            tmpCtx.messageSigningContext712.domainHash,
            sizeof(tmpCtx.messageSigningContext712.domainHash),
            NULL,
            0);
    cx_hash((cx_hash_t *) &global_sha3,
c0d07690:	4668      	mov	r0, sp
c0d07692:	6044      	str	r4, [r0, #4]
c0d07694:	ad2b      	add	r5, sp, #172	; 0xac
c0d07696:	6005      	str	r5, [r0, #0]
c0d07698:	9504      	str	r5, [sp, #16]
c0d0769a:	4a30      	ldr	r2, [pc, #192]	; (c0d0775c <io_seproxyhal_touch_signMessage712_v0_ok+0x10c>)
c0d0769c:	324c      	adds	r2, #76	; 0x4c
c0d0769e:	482e      	ldr	r0, [pc, #184]	; (c0d07758 <io_seproxyhal_touch_signMessage712_v0_ok+0x108>)
c0d076a0:	4639      	mov	r1, r7
c0d076a2:	4623      	mov	r3, r4
c0d076a4:	f7ff f8c8 	bl	c0d06838 <cx_hash>
            CX_LAST,
            tmpCtx.messageSigningContext712.messageHash,
            sizeof(tmpCtx.messageSigningContext712.messageHash),
            hash,
            sizeof(hash));
    PRINTF("EIP712 hash to sign %.*H\n", 32, hash);
c0d076a8:	4830      	ldr	r0, [pc, #192]	; (c0d0776c <io_seproxyhal_touch_signMessage712_v0_ok+0x11c>)
c0d076aa:	4478      	add	r0, pc
c0d076ac:	4621      	mov	r1, r4
c0d076ae:	462a      	mov	r2, r5
c0d076b0:	f7fd fcc4 	bl	c0d0503c <mcu_usb_printf>
    io_seproxyhal_io_heartbeat();
c0d076b4:	f7fd fb56 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d076b8:	4928      	ldr	r1, [pc, #160]	; (c0d0775c <io_seproxyhal_touch_signMessage712_v0_ok+0x10c>)
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.messageSigningContext712.bip32Path,
                               tmpCtx.messageSigningContext712.pathLength,
c0d076ba:	780a      	ldrb	r2, [r1, #0]
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d076bc:	4668      	mov	r0, sp
c0d076be:	6006      	str	r6, [r0, #0]
c0d076c0:	1d09      	adds	r1, r1, #4
c0d076c2:	2521      	movs	r5, #33	; 0x21
c0d076c4:	af33      	add	r7, sp, #204	; 0xcc
c0d076c6:	4628      	mov	r0, r5
c0d076c8:	463b      	mov	r3, r7
c0d076ca:	f7ff f9bb 	bl	c0d06a44 <os_perso_derive_node_bip32>
                               privateKeyData,
                               NULL);
    io_seproxyhal_io_heartbeat();
c0d076ce:	f7fd fb49 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d076d2:	ab08      	add	r3, sp, #32
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d076d4:	4628      	mov	r0, r5
c0d076d6:	4639      	mov	r1, r7
c0d076d8:	4622      	mov	r2, r4
c0d076da:	461d      	mov	r5, r3
c0d076dc:	f7ff f91e 	bl	c0d0691c <cx_ecfp_init_private_key>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d076e0:	4638      	mov	r0, r7
c0d076e2:	4621      	mov	r1, r4
c0d076e4:	f002 ffd8 	bl	c0d0a698 <explicit_bzero>
c0d076e8:	9605      	str	r6, [sp, #20]
    unsigned int info = 0;
c0d076ea:	9607      	str	r6, [sp, #28]
    io_seproxyhal_io_heartbeat();
c0d076ec:	f7fd fb3a 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d076f0:	a807      	add	r0, sp, #28
    signatureLength = cx_ecdsa_sign(&privateKey,
c0d076f2:	4669      	mov	r1, sp
c0d076f4:	60c8      	str	r0, [r1, #12]
c0d076f6:	2064      	movs	r0, #100	; 0x64
c0d076f8:	6088      	str	r0, [r1, #8]
c0d076fa:	af12      	add	r7, sp, #72	; 0x48
c0d076fc:	604f      	str	r7, [r1, #4]
c0d076fe:	9406      	str	r4, [sp, #24]
c0d07700:	600c      	str	r4, [r1, #0]
c0d07702:	4917      	ldr	r1, [pc, #92]	; (c0d07760 <io_seproxyhal_touch_signMessage712_v0_ok+0x110>)
c0d07704:	2203      	movs	r2, #3
c0d07706:	462c      	mov	r4, r5
c0d07708:	4628      	mov	r0, r5
c0d0770a:	9b04      	ldr	r3, [sp, #16]
c0d0770c:	f7ff f926 	bl	c0d0695c <cx_ecdsa_sign>
c0d07710:	2128      	movs	r1, #40	; 0x28
                                    hash,
                                    sizeof(hash),
                                    signature,
                                    sizeof(signature),
                                    &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d07712:	4628      	mov	r0, r5
c0d07714:	f002 ffc0 	bl	c0d0a698 <explicit_bzero>
    G_io_apdu_buffer[0] = 27;
    if (info & CX_ECCINFO_PARITY_ODD) {
c0d07718:	9907      	ldr	r1, [sp, #28]
c0d0771a:	07c8      	lsls	r0, r1, #31
c0d0771c:	d001      	beq.n	c0d07722 <io_seproxyhal_touch_signMessage712_v0_ok+0xd2>
c0d0771e:	201c      	movs	r0, #28
c0d07720:	e000      	b.n	c0d07724 <io_seproxyhal_touch_signMessage712_v0_ok+0xd4>
c0d07722:	201b      	movs	r0, #27
        G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
c0d07724:	0789      	lsls	r1, r1, #30
c0d07726:	d500      	bpl.n	c0d0772a <io_seproxyhal_touch_signMessage712_v0_ok+0xda>
c0d07728:	1c80      	adds	r0, r0, #2
c0d0772a:	4d0e      	ldr	r5, [pc, #56]	; (c0d07764 <io_seproxyhal_touch_signMessage712_v0_ok+0x114>)
c0d0772c:	7028      	strb	r0, [r5, #0]
        G_io_apdu_buffer[0] += 2;
    }
    format_signature_out(signature);
c0d0772e:	4638      	mov	r0, r7
c0d07730:	f7fc f8cc 	bl	c0d038cc <format_signature_out>
c0d07734:	2042      	movs	r0, #66	; 0x42
c0d07736:	9c05      	ldr	r4, [sp, #20]
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d07738:	542c      	strb	r4, [r5, r0]
c0d0773a:	2041      	movs	r0, #65	; 0x41
c0d0773c:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d0773e:	5429      	strb	r1, [r5, r0]
    reset_app_context();
c0d07740:	f7fc f884 	bl	c0d0384c <reset_app_context>
c0d07744:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d07746:	9806      	ldr	r0, [sp, #24]
c0d07748:	f7fd f96c 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d0774c:	f7fc f8a0 	bl	c0d03890 <ui_idle>
    return 0;  // do not redraw the widget
c0d07750:	4620      	mov	r0, r4
c0d07752:	b03b      	add	sp, #236	; 0xec
c0d07754:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d07756:	46c0      	nop			; (mov r8, r8)
c0d07758:	20001d60 	.word	0x20001d60
c0d0775c:	20001804 	.word	0x20001804
c0d07760:	00000601 	.word	0x00000601
c0d07764:	20001f09 	.word	0x20001f09
c0d07768:	00004f4f 	.word	0x00004f4f
c0d0776c:	00004f15 	.word	0x00004f15

c0d07770 <io_seproxyhal_touch_signMessage712_v0_cancel>:
}

unsigned int io_seproxyhal_touch_signMessage712_v0_cancel(const bagl_element_t *e) {
c0d07770:	b580      	push	{r7, lr}
    reset_app_context();
c0d07772:	f7fc f86b 	bl	c0d0384c <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0d07776:	4806      	ldr	r0, [pc, #24]	; (c0d07790 <io_seproxyhal_touch_signMessage712_v0_cancel+0x20>)
c0d07778:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0d0777a:	7041      	strb	r1, [r0, #1]
c0d0777c:	2169      	movs	r1, #105	; 0x69
    G_io_apdu_buffer[0] = 0x69;
c0d0777e:	7001      	strb	r1, [r0, #0]
c0d07780:	2020      	movs	r0, #32
c0d07782:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d07784:	f7fd f94e 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d07788:	f7fc f882 	bl	c0d03890 <ui_idle>
c0d0778c:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d0778e:	bd80      	pop	{r7, pc}
c0d07790:	20001f09 	.word	0x20001f09

c0d07794 <io_seproxyhal_touch_tx_ok>:
#include "shared_context.h"
#include "utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_tx_ok(const bagl_element_t *e) {
c0d07794:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07796:	b0b3      	sub	sp, #204	; 0xcc
    uint8_t privateKeyData[32];
    uint8_t signature[100];
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    uint32_t v = getV(&tmpContent.txContent);
c0d07798:	4833      	ldr	r0, [pc, #204]	; (c0d07868 <io_seproxyhal_touch_tx_ok+0xd4>)
c0d0779a:	f002 f835 	bl	c0d09808 <getV>
c0d0779e:	9005      	str	r0, [sp, #20]
    io_seproxyhal_io_heartbeat();
c0d077a0:	f7fd fae0 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.transactionContext.bip32Path,
                               tmpCtx.transactionContext.pathLength,
c0d077a4:	4e31      	ldr	r6, [pc, #196]	; (c0d0786c <io_seproxyhal_touch_tx_ok+0xd8>)
c0d077a6:	7832      	ldrb	r2, [r6, #0]
c0d077a8:	2100      	movs	r1, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d077aa:	9106      	str	r1, [sp, #24]
c0d077ac:	4668      	mov	r0, sp
c0d077ae:	6001      	str	r1, [r0, #0]
c0d077b0:	1d31      	adds	r1, r6, #4
c0d077b2:	2721      	movs	r7, #33	; 0x21
c0d077b4:	ad2b      	add	r5, sp, #172	; 0xac
c0d077b6:	4638      	mov	r0, r7
c0d077b8:	462b      	mov	r3, r5
c0d077ba:	f7ff f943 	bl	c0d06a44 <os_perso_derive_node_bip32>
c0d077be:	2420      	movs	r4, #32
c0d077c0:	ab08      	add	r3, sp, #32
                               privateKeyData,
                               NULL);
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d077c2:	4638      	mov	r0, r7
c0d077c4:	4629      	mov	r1, r5
c0d077c6:	4622      	mov	r2, r4
c0d077c8:	461f      	mov	r7, r3
c0d077ca:	f7ff f8a7 	bl	c0d0691c <cx_ecfp_init_private_key>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d077ce:	4628      	mov	r0, r5
c0d077d0:	9d06      	ldr	r5, [sp, #24]
c0d077d2:	4621      	mov	r1, r4
c0d077d4:	f002 ff60 	bl	c0d0a698 <explicit_bzero>
    unsigned int info = 0;
c0d077d8:	9507      	str	r5, [sp, #28]
    io_seproxyhal_io_heartbeat();
c0d077da:	f7fd fac3 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d077de:	a807      	add	r0, sp, #28
    signatureLength = cx_ecdsa_sign(&privateKey,
c0d077e0:	4669      	mov	r1, sp
c0d077e2:	60c8      	str	r0, [r1, #12]
c0d077e4:	2064      	movs	r0, #100	; 0x64
c0d077e6:	6088      	str	r0, [r1, #8]
c0d077e8:	a812      	add	r0, sp, #72	; 0x48
c0d077ea:	6048      	str	r0, [r1, #4]
c0d077ec:	600c      	str	r4, [r1, #0]
c0d077ee:	362c      	adds	r6, #44	; 0x2c
c0d077f0:	491f      	ldr	r1, [pc, #124]	; (c0d07870 <io_seproxyhal_touch_tx_ok+0xdc>)
c0d077f2:	2203      	movs	r2, #3
c0d077f4:	463c      	mov	r4, r7
c0d077f6:	4638      	mov	r0, r7
c0d077f8:	4633      	mov	r3, r6
c0d077fa:	f7ff f8af 	bl	c0d0695c <cx_ecdsa_sign>
c0d077fe:	2128      	movs	r1, #40	; 0x28
                                    tmpCtx.transactionContext.hash,
                                    sizeof(tmpCtx.transactionContext.hash),
                                    signature,
                                    sizeof(signature),
                                    &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d07800:	4638      	mov	r0, r7
c0d07802:	f002 ff49 	bl	c0d0a698 <explicit_bzero>
c0d07806:	20ff      	movs	r0, #255	; 0xff
c0d07808:	3022      	adds	r0, #34	; 0x22
    // Parity is present in the sequence tag in the legacy API
    if (tmpContent.txContent.vLength == 0) {
c0d0780a:	4917      	ldr	r1, [pc, #92]	; (c0d07868 <io_seproxyhal_touch_tx_ok+0xd4>)
c0d0780c:	5c08      	ldrb	r0, [r1, r0]
c0d0780e:	2800      	cmp	r0, #0
c0d07810:	d003      	beq.n	c0d0781a <io_seproxyhal_touch_tx_ok+0x86>
        // Legacy API
        G_io_apdu_buffer[0] = 27;
    } else {
        // New API
        // Note that this is wrong for a large v, but the client can always recover
        G_io_apdu_buffer[0] = (v * 2) + 35;
c0d07812:	9805      	ldr	r0, [sp, #20]
c0d07814:	0040      	lsls	r0, r0, #1
c0d07816:	3023      	adds	r0, #35	; 0x23
c0d07818:	e000      	b.n	c0d0781c <io_seproxyhal_touch_tx_ok+0x88>
c0d0781a:	201b      	movs	r0, #27
c0d0781c:	4c15      	ldr	r4, [pc, #84]	; (c0d07874 <io_seproxyhal_touch_tx_ok+0xe0>)
c0d0781e:	7020      	strb	r0, [r4, #0]
    }
    if (info & CX_ECCINFO_PARITY_ODD) {
c0d07820:	9907      	ldr	r1, [sp, #28]
        G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
        G_io_apdu_buffer[0] += 2;
    }
    format_signature_out(signature);
c0d07822:	078a      	lsls	r2, r1, #30
c0d07824:	d006      	beq.n	c0d07834 <io_seproxyhal_touch_tx_ok+0xa0>
c0d07826:	2301      	movs	r3, #1
c0d07828:	4019      	ands	r1, r3
c0d0782a:	1840      	adds	r0, r0, r1
    if (info & CX_ECCINFO_xGTn) {
c0d0782c:	2a00      	cmp	r2, #0
c0d0782e:	d500      	bpl.n	c0d07832 <io_seproxyhal_touch_tx_ok+0x9e>
c0d07830:	1c80      	adds	r0, r0, #2
    format_signature_out(signature);
c0d07832:	7020      	strb	r0, [r4, #0]
c0d07834:	a812      	add	r0, sp, #72	; 0x48
c0d07836:	f7fc f849 	bl	c0d038cc <format_signature_out>
c0d0783a:	2042      	movs	r0, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d0783c:	5425      	strb	r5, [r4, r0]
c0d0783e:	2041      	movs	r0, #65	; 0x41
c0d07840:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d07842:	5421      	strb	r1, [r4, r0]
c0d07844:	2020      	movs	r0, #32
c0d07846:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d07848:	f7fd f8ec 	bl	c0d04a24 <io_exchange>
    if (called_from_swap) {
c0d0784c:	480a      	ldr	r0, [pc, #40]	; (c0d07878 <io_seproxyhal_touch_tx_ok+0xe4>)
c0d0784e:	7800      	ldrb	r0, [r0, #0]
c0d07850:	2800      	cmp	r0, #0
c0d07852:	d002      	beq.n	c0d0785a <io_seproxyhal_touch_tx_ok+0xc6>
c0d07854:	2000      	movs	r0, #0
        os_sched_exit(0);
c0d07856:	f7ff f95b 	bl	c0d06b10 <os_sched_exit>
    }
    reset_app_context();
c0d0785a:	f7fb fff7 	bl	c0d0384c <reset_app_context>
    // Display back the original UX
    ui_idle();
c0d0785e:	f7fc f817 	bl	c0d03890 <ui_idle>
c0d07862:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d07864:	b033      	add	sp, #204	; 0xcc
c0d07866:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d07868:	200018dc 	.word	0x200018dc
c0d0786c:	20001804 	.word	0x20001804
c0d07870:	00000601 	.word	0x00000601
c0d07874:	20001f09 	.word	0x20001f09
c0d07878:	2000189c 	.word	0x2000189c

c0d0787c <io_seproxyhal_touch_tx_cancel>:
}

unsigned int io_seproxyhal_touch_tx_cancel(const bagl_element_t *e) {
c0d0787c:	b580      	push	{r7, lr}
    reset_app_context();
c0d0787e:	f7fb ffe5 	bl	c0d0384c <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0d07882:	4806      	ldr	r0, [pc, #24]	; (c0d0789c <io_seproxyhal_touch_tx_cancel+0x20>)
c0d07884:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0d07886:	7041      	strb	r1, [r0, #1]
c0d07888:	2169      	movs	r1, #105	; 0x69
    G_io_apdu_buffer[0] = 0x69;
c0d0788a:	7001      	strb	r1, [r0, #0]
c0d0788c:	2020      	movs	r0, #32
c0d0788e:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d07890:	f7fd f8c8 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d07894:	f7fb fffc 	bl	c0d03890 <ui_idle>
c0d07898:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d0789a:	bd80      	pop	{r7, pc}
c0d0789c:	20001f09 	.word	0x20001f09

c0d078a0 <io_seproxyhal_touch_data_ok>:
}

unsigned int io_seproxyhal_touch_data_ok(const bagl_element_t *e) {
c0d078a0:	b580      	push	{r7, lr}
    parserStatus_e txResult = USTREAM_FINISHED;
    txResult = continueTx(&txContext);
c0d078a2:	4811      	ldr	r0, [pc, #68]	; (c0d078e8 <io_seproxyhal_touch_data_ok+0x48>)
c0d078a4:	f7fa fd3a 	bl	c0d0231c <continueTx>
    switch (txResult) {
c0d078a8:	2801      	cmp	r0, #1
c0d078aa:	dc04      	bgt.n	c0d078b6 <io_seproxyhal_touch_data_ok+0x16>
c0d078ac:	2800      	cmp	r0, #0
c0d078ae:	d00f      	beq.n	c0d078d0 <io_seproxyhal_touch_data_ok+0x30>
c0d078b0:	2801      	cmp	r0, #1
c0d078b2:	d017      	beq.n	c0d078e4 <io_seproxyhal_touch_data_ok+0x44>
c0d078b4:	e003      	b.n	c0d078be <io_seproxyhal_touch_data_ok+0x1e>
c0d078b6:	2802      	cmp	r0, #2
c0d078b8:	d011      	beq.n	c0d078de <io_seproxyhal_touch_data_ok+0x3e>
c0d078ba:	2803      	cmp	r0, #3
c0d078bc:	d003      	beq.n	c0d078c6 <io_seproxyhal_touch_data_ok+0x26>
            reset_app_context();
            io_seproxyhal_send_status(0x6A80);
            ui_idle();
            break;
        default:
            PRINTF("Unexpected parser status\n");
c0d078be:	480b      	ldr	r0, [pc, #44]	; (c0d078ec <io_seproxyhal_touch_data_ok+0x4c>)
c0d078c0:	4478      	add	r0, pc
c0d078c2:	f7fd fbbb 	bl	c0d0503c <mcu_usb_printf>
c0d078c6:	f7fb ffc1 	bl	c0d0384c <reset_app_context>
c0d078ca:	20d5      	movs	r0, #213	; 0xd5
c0d078cc:	01c0      	lsls	r0, r0, #7
c0d078ce:	e001      	b.n	c0d078d4 <io_seproxyhal_touch_data_ok+0x34>
c0d078d0:	2009      	movs	r0, #9
c0d078d2:	0300      	lsls	r0, r0, #12
c0d078d4:	f7fb ffee 	bl	c0d038b4 <io_seproxyhal_send_status>
c0d078d8:	f7fb ffda 	bl	c0d03890 <ui_idle>
c0d078dc:	e002      	b.n	c0d078e4 <io_seproxyhal_touch_data_ok+0x44>
c0d078de:	2000      	movs	r0, #0
            io_seproxyhal_send_status(0x6A80);
            ui_idle();
    }

    if (txResult == USTREAM_FINISHED) {
        finalizeParsing(false);
c0d078e0:	f7fb fe10 	bl	c0d03504 <finalizeParsing>
c0d078e4:	2000      	movs	r0, #0
    }

    return 0;
c0d078e6:	bd80      	pop	{r7, pc}
c0d078e8:	200018a0 	.word	0x200018a0
c0d078ec:	00003472 	.word	0x00003472

c0d078f0 <io_seproxyhal_touch_data_cancel>:
}

unsigned int io_seproxyhal_touch_data_cancel(const bagl_element_t *e) {
c0d078f0:	b580      	push	{r7, lr}
    reset_app_context();
c0d078f2:	f7fb ffab 	bl	c0d0384c <reset_app_context>
c0d078f6:	4803      	ldr	r0, [pc, #12]	; (c0d07904 <io_seproxyhal_touch_data_cancel+0x14>)
    io_seproxyhal_send_status(0x6985);
c0d078f8:	f7fb ffdc 	bl	c0d038b4 <io_seproxyhal_send_status>
    // Display back the original UX
    ui_idle();
c0d078fc:	f7fb ffc8 	bl	c0d03890 <ui_idle>
c0d07900:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d07902:	bd80      	pop	{r7, pc}
c0d07904:	00006985 	.word	0x00006985

c0d07908 <io_seproxyhal_touch_stark_pubkey_ok>:

#include "shared_context.h"
#include "ui_callbacks.h"
#include "feature_stark_getPublicKey.h"

unsigned int io_seproxyhal_touch_stark_pubkey_ok(const bagl_element_t *e) {
c0d07908:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = set_result_get_stark_publicKey();
c0d0790a:	f7fb ff91 	bl	c0d03830 <set_result_get_stark_publicKey>
c0d0790e:	4604      	mov	r4, r0
    G_io_apdu_buffer[tx++] = 0x90;
c0d07910:	4808      	ldr	r0, [pc, #32]	; (c0d07934 <io_seproxyhal_touch_stark_pubkey_ok+0x2c>)
c0d07912:	2190      	movs	r1, #144	; 0x90
c0d07914:	5501      	strb	r1, [r0, r4]
c0d07916:	1900      	adds	r0, r0, r4
c0d07918:	2500      	movs	r5, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0d0791a:	7045      	strb	r5, [r0, #1]
    reset_app_context();
c0d0791c:	f7fb ff96 	bl	c0d0384c <reset_app_context>
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d07920:	1ca0      	adds	r0, r4, #2
c0d07922:	b281      	uxth	r1, r0
c0d07924:	2020      	movs	r0, #32
c0d07926:	f7fd f87d 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d0792a:	f7fb ffb1 	bl	c0d03890 <ui_idle>
    return 0;  // do not redraw the widget
c0d0792e:	4628      	mov	r0, r5
c0d07930:	bdb0      	pop	{r4, r5, r7, pc}
c0d07932:	46c0      	nop			; (mov r8, r8)
c0d07934:	20001f09 	.word	0x20001f09

c0d07938 <io_seproxyhal_touch_stark_ok>:

#include "shared_context.h"
#include "stark_utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_stark_ok(const bagl_element_t *e) {
c0d07938:	b570      	push	{r4, r5, r6, lr}
c0d0793a:	b09c      	sub	sp, #112	; 0x70
    uint8_t privateKeyData[32];
    uint8_t signature[72];
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0d0793c:	f7fd fa12 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
                          tmpCtx.transactionContext.pathLength,
c0d07940:	4818      	ldr	r0, [pc, #96]	; (c0d079a4 <io_seproxyhal_touch_stark_ok+0x6c>)
c0d07942:	7801      	ldrb	r1, [r0, #0]
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
c0d07944:	1d00      	adds	r0, r0, #4
c0d07946:	ac14      	add	r4, sp, #80	; 0x50
c0d07948:	4622      	mov	r2, r4
c0d0794a:	f7fd ff83 	bl	c0d05854 <starkDerivePrivateKey>
                          privateKeyData);
    io_seproxyhal_io_heartbeat();
c0d0794e:	f7fd fa09 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d07952:	2080      	movs	r0, #128	; 0x80
    stark_sign(signature,
               privateKeyData,
               dataContext.starkContext.w1,
               dataContext.starkContext.w2,
               dataContext.starkContext.w3,
               (dataContext.starkContext.conditional ? dataContext.starkContext.w4 : NULL));
c0d07954:	4a14      	ldr	r2, [pc, #80]	; (c0d079a8 <io_seproxyhal_touch_stark_ok+0x70>)
c0d07956:	5c10      	ldrb	r0, [r2, r0]
c0d07958:	2800      	cmp	r0, #0
c0d0795a:	d001      	beq.n	c0d07960 <io_seproxyhal_touch_stark_ok+0x28>
c0d0795c:	4610      	mov	r0, r2
c0d0795e:	3060      	adds	r0, #96	; 0x60
    stark_sign(signature,
c0d07960:	4669      	mov	r1, sp
c0d07962:	4613      	mov	r3, r2
c0d07964:	3340      	adds	r3, #64	; 0x40
c0d07966:	600b      	str	r3, [r1, #0]
c0d07968:	6048      	str	r0, [r1, #4]
c0d0796a:	4613      	mov	r3, r2
c0d0796c:	3320      	adds	r3, #32
c0d0796e:	ad02      	add	r5, sp, #8
c0d07970:	4628      	mov	r0, r5
c0d07972:	4621      	mov	r1, r4
c0d07974:	f7fe f8b4 	bl	c0d05ae0 <stark_sign>
    G_io_apdu_buffer[0] = 0;
c0d07978:	4e0c      	ldr	r6, [pc, #48]	; (c0d079ac <io_seproxyhal_touch_stark_ok+0x74>)
c0d0797a:	2400      	movs	r4, #0
c0d0797c:	7034      	strb	r4, [r6, #0]
    format_signature_out(signature);
c0d0797e:	4628      	mov	r0, r5
c0d07980:	f7fb ffa4 	bl	c0d038cc <format_signature_out>
c0d07984:	2042      	movs	r0, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d07986:	5434      	strb	r4, [r6, r0]
c0d07988:	2041      	movs	r0, #65	; 0x41
c0d0798a:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d0798c:	5431      	strb	r1, [r6, r0]
    reset_app_context();
c0d0798e:	f7fb ff5d 	bl	c0d0384c <reset_app_context>
c0d07992:	2020      	movs	r0, #32
c0d07994:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d07996:	f7fd f845 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d0799a:	f7fb ff79 	bl	c0d03890 <ui_idle>
    return 0;  // do not redraw the widget
c0d0799e:	4620      	mov	r0, r4
c0d079a0:	b01c      	add	sp, #112	; 0x70
c0d079a2:	bd70      	pop	{r4, r5, r6, pc}
c0d079a4:	20001804 	.word	0x20001804
c0d079a8:	20001be4 	.word	0x20001be4
c0d079ac:	20001f09 	.word	0x20001f09

c0d079b0 <io_seproxyhal_touch_stark_unsafe_sign_ok>:

#include "shared_context.h"
#include "stark_utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_stark_unsafe_sign_ok(const bagl_element_t *e) {
c0d079b0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d079b2:	b0a9      	sub	sp, #164	; 0xa4
c0d079b4:	2400      	movs	r4, #0
    cx_ecfp_private_key_t privateKey;
    uint8_t privateKeyData[32];
    uint8_t signature[72];
    unsigned int info = 0;
c0d079b6:	9404      	str	r4, [sp, #16]
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0d079b8:	f7fd f9d4 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
                          tmpCtx.transactionContext.pathLength,
c0d079bc:	4819      	ldr	r0, [pc, #100]	; (c0d07a24 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x74>)
c0d079be:	7801      	ldrb	r1, [r0, #0]
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
c0d079c0:	1d00      	adds	r0, r0, #4
c0d079c2:	af17      	add	r7, sp, #92	; 0x5c
c0d079c4:	463a      	mov	r2, r7
c0d079c6:	f7fd ff45 	bl	c0d05854 <starkDerivePrivateKey>
                          privateKeyData);
    io_seproxyhal_io_heartbeat();
c0d079ca:	f7fd f9cb 	bl	c0d04d64 <io_seproxyhal_io_heartbeat>
c0d079ce:	202e      	movs	r0, #46	; 0x2e
c0d079d0:	2520      	movs	r5, #32
c0d079d2:	ae1f      	add	r6, sp, #124	; 0x7c
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d079d4:	4639      	mov	r1, r7
c0d079d6:	462a      	mov	r2, r5
c0d079d8:	4633      	mov	r3, r6
c0d079da:	f7fe ff9f 	bl	c0d0691c <cx_ecfp_init_private_key>
c0d079de:	a804      	add	r0, sp, #16
    cx_ecdsa_sign(&privateKey,
c0d079e0:	4669      	mov	r1, sp
c0d079e2:	60c8      	str	r0, [r1, #12]
c0d079e4:	2048      	movs	r0, #72	; 0x48
c0d079e6:	6088      	str	r0, [r1, #8]
c0d079e8:	af05      	add	r7, sp, #20
c0d079ea:	c1a0      	stmia	r1!, {r5, r7}
c0d079ec:	4b0e      	ldr	r3, [pc, #56]	; (c0d07a28 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x78>)
c0d079ee:	3320      	adds	r3, #32
c0d079f0:	490e      	ldr	r1, [pc, #56]	; (c0d07a2c <io_seproxyhal_touch_stark_unsafe_sign_ok+0x7c>)
c0d079f2:	2203      	movs	r2, #3
c0d079f4:	4630      	mov	r0, r6
c0d079f6:	f7fe ffb1 	bl	c0d0695c <cx_ecdsa_sign>
                  dataContext.starkContext.w2,
                  sizeof(dataContext.starkContext.w2),
                  signature,
                  sizeof(signature),
                  &info);
    G_io_apdu_buffer[0] = 0;
c0d079fa:	4e0d      	ldr	r6, [pc, #52]	; (c0d07a30 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x80>)
c0d079fc:	7034      	strb	r4, [r6, #0]
    format_signature_out(signature);
c0d079fe:	4638      	mov	r0, r7
c0d07a00:	f7fb ff64 	bl	c0d038cc <format_signature_out>
c0d07a04:	2042      	movs	r0, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d07a06:	5434      	strb	r4, [r6, r0]
c0d07a08:	2041      	movs	r0, #65	; 0x41
c0d07a0a:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d07a0c:	5431      	strb	r1, [r6, r0]
    reset_app_context();
c0d07a0e:	f7fb ff1d 	bl	c0d0384c <reset_app_context>
c0d07a12:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d07a14:	4628      	mov	r0, r5
c0d07a16:	f7fd f805 	bl	c0d04a24 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d07a1a:	f7fb ff39 	bl	c0d03890 <ui_idle>
    return 0;  // do not redraw the widget
c0d07a1e:	4620      	mov	r0, r4
c0d07a20:	b029      	add	sp, #164	; 0xa4
c0d07a22:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d07a24:	20001804 	.word	0x20001804
c0d07a28:	20001be4 	.word	0x20001be4
c0d07a2c:	00000601 	.word	0x00000601
c0d07a30:	20001f09 	.word	0x20001f09

c0d07a34 <ux_idle_flow_3_step_validateinit>:
    bn,
    {
      "Version",
      APPVERSION,
    });
UX_STEP_CB(
c0d07a34:	b580      	push	{r7, lr}
c0d07a36:	f000 f801 	bl	c0d07a3c <display_settings>
c0d07a3a:	bd80      	pop	{r7, pc}

c0d07a3c <display_settings>:
UX_FLOW(ux_settings_flow,
        &ux_settings_flow_1_step,
        &ux_settings_flow_2_step,
        &ux_settings_flow_3_step);

void display_settings() {
c0d07a3c:	b5b0      	push	{r4, r5, r7, lr}
    strcpy(strings.common.fullAddress, (N_storage.dataAllowed ? "Allowed" : "NOT Allowed"));
c0d07a3e:	4d14      	ldr	r5, [pc, #80]	; (c0d07a90 <display_settings+0x54>)
c0d07a40:	447d      	add	r5, pc
c0d07a42:	4628      	mov	r0, r5
c0d07a44:	f7fd fe78 	bl	c0d05738 <pic>
c0d07a48:	7800      	ldrb	r0, [r0, #0]
c0d07a4a:	2800      	cmp	r0, #0
c0d07a4c:	d002      	beq.n	c0d07a54 <display_settings+0x18>
c0d07a4e:	4912      	ldr	r1, [pc, #72]	; (c0d07a98 <display_settings+0x5c>)
c0d07a50:	4479      	add	r1, pc
c0d07a52:	e001      	b.n	c0d07a58 <display_settings+0x1c>
c0d07a54:	490f      	ldr	r1, [pc, #60]	; (c0d07a94 <display_settings+0x58>)
c0d07a56:	4479      	add	r1, pc
c0d07a58:	4c0c      	ldr	r4, [pc, #48]	; (c0d07a8c <display_settings+0x50>)
c0d07a5a:	4620      	mov	r0, r4
c0d07a5c:	f002 ffc4 	bl	c0d0a9e8 <strcpy>
    strcpy(strings.common.fullAddress + 20,
           (N_storage.contractDetails ? "Displayed" : "NOT Displayed"));
c0d07a60:	4628      	mov	r0, r5
c0d07a62:	f7fd fe69 	bl	c0d05738 <pic>
c0d07a66:	7840      	ldrb	r0, [r0, #1]
c0d07a68:	2800      	cmp	r0, #0
c0d07a6a:	d002      	beq.n	c0d07a72 <display_settings+0x36>
c0d07a6c:	490c      	ldr	r1, [pc, #48]	; (c0d07aa0 <display_settings+0x64>)
c0d07a6e:	4479      	add	r1, pc
c0d07a70:	e001      	b.n	c0d07a76 <display_settings+0x3a>
c0d07a72:	490a      	ldr	r1, [pc, #40]	; (c0d07a9c <display_settings+0x60>)
c0d07a74:	4479      	add	r1, pc
    strcpy(strings.common.fullAddress + 20,
c0d07a76:	3414      	adds	r4, #20
c0d07a78:	4620      	mov	r0, r4
c0d07a7a:	f002 ffb5 	bl	c0d0a9e8 <strcpy>
    ux_flow_init(0, ux_settings_flow, NULL);
c0d07a7e:	4909      	ldr	r1, [pc, #36]	; (c0d07aa4 <display_settings+0x68>)
c0d07a80:	4479      	add	r1, pc
c0d07a82:	2000      	movs	r0, #0
c0d07a84:	4602      	mov	r2, r0
c0d07a86:	f002 f8c7 	bl	c0d09c18 <ux_flow_init>
}
c0d07a8a:	bdb0      	pop	{r4, r5, r7, pc}
c0d07a8c:	20001cca 	.word	0x20001cca
c0d07a90:	00005d7c 	.word	0x00005d7c
c0d07a94:	00004bd2 	.word	0x00004bd2
c0d07a98:	00004bdc 	.word	0x00004bdc
c0d07a9c:	00004bc0 	.word	0x00004bc0
c0d07aa0:	00004bca 	.word	0x00004bca
c0d07aa4:	00004cfc 	.word	0x00004cfc

c0d07aa8 <ux_idle_flow_4_step_validateinit>:
UX_STEP_CB(
c0d07aa8:	b580      	push	{r7, lr}
c0d07aaa:	20ff      	movs	r0, #255	; 0xff
c0d07aac:	f7ff f830 	bl	c0d06b10 <os_sched_exit>
c0d07ab0:	bd80      	pop	{r7, pc}

c0d07ab2 <ux_settings_flow_1_step_validateinit>:
UX_STEP_CB(
c0d07ab2:	b580      	push	{r7, lr}
c0d07ab4:	f000 f802 	bl	c0d07abc <switch_settings_contract_data>
c0d07ab8:	bd80      	pop	{r7, pc}
	...

c0d07abc <switch_settings_contract_data>:

void switch_settings_contract_data() {
c0d07abc:	b5b0      	push	{r4, r5, r7, lr}
c0d07abe:	b082      	sub	sp, #8
    uint8_t value = (N_storage.dataAllowed ? 0 : 1);
c0d07ac0:	4c0a      	ldr	r4, [pc, #40]	; (c0d07aec <switch_settings_contract_data+0x30>)
c0d07ac2:	447c      	add	r4, pc
c0d07ac4:	4620      	mov	r0, r4
c0d07ac6:	f7fd fe37 	bl	c0d05738 <pic>
c0d07aca:	7800      	ldrb	r0, [r0, #0]
c0d07acc:	4241      	negs	r1, r0
c0d07ace:	4141      	adcs	r1, r0
c0d07ad0:	ad01      	add	r5, sp, #4
c0d07ad2:	7029      	strb	r1, [r5, #0]
    nvm_write((void*) &N_storage.dataAllowed, (void*) &value, sizeof(uint8_t));
c0d07ad4:	4620      	mov	r0, r4
c0d07ad6:	f7fd fe2f 	bl	c0d05738 <pic>
c0d07ada:	2201      	movs	r2, #1
c0d07adc:	4629      	mov	r1, r5
c0d07ade:	f7fe fe8f 	bl	c0d06800 <nvm_write>
    display_settings();
c0d07ae2:	f7ff ffab 	bl	c0d07a3c <display_settings>
}
c0d07ae6:	b002      	add	sp, #8
c0d07ae8:	bdb0      	pop	{r4, r5, r7, pc}
c0d07aea:	46c0      	nop			; (mov r8, r8)
c0d07aec:	00005cfa 	.word	0x00005cfa

c0d07af0 <ux_settings_flow_2_step_validateinit>:
UX_STEP_CB(
c0d07af0:	b580      	push	{r7, lr}
c0d07af2:	f000 f801 	bl	c0d07af8 <switch_settings_display_data>
c0d07af6:	bd80      	pop	{r7, pc}

c0d07af8 <switch_settings_display_data>:

void switch_settings_display_data() {
c0d07af8:	b5b0      	push	{r4, r5, r7, lr}
c0d07afa:	b082      	sub	sp, #8
    uint8_t value = (N_storage.contractDetails ? 0 : 1);
c0d07afc:	4c0a      	ldr	r4, [pc, #40]	; (c0d07b28 <switch_settings_display_data+0x30>)
c0d07afe:	447c      	add	r4, pc
c0d07b00:	4620      	mov	r0, r4
c0d07b02:	f7fd fe19 	bl	c0d05738 <pic>
c0d07b06:	7840      	ldrb	r0, [r0, #1]
c0d07b08:	4241      	negs	r1, r0
c0d07b0a:	4141      	adcs	r1, r0
c0d07b0c:	ad01      	add	r5, sp, #4
c0d07b0e:	7029      	strb	r1, [r5, #0]
    nvm_write((void*) &N_storage.contractDetails, (void*) &value, sizeof(uint8_t));
c0d07b10:	4620      	mov	r0, r4
c0d07b12:	f7fd fe11 	bl	c0d05738 <pic>
c0d07b16:	1c40      	adds	r0, r0, #1
c0d07b18:	2201      	movs	r2, #1
c0d07b1a:	4629      	mov	r1, r5
c0d07b1c:	f7fe fe70 	bl	c0d06800 <nvm_write>
    display_settings();
c0d07b20:	f7ff ff8c 	bl	c0d07a3c <display_settings>
}
c0d07b24:	b002      	add	sp, #8
c0d07b26:	bdb0      	pop	{r4, r5, r7, pc}
c0d07b28:	00005cbe 	.word	0x00005cbe

c0d07b2c <ux_settings_flow_3_step_validateinit>:
UX_STEP_CB(
c0d07b2c:	b580      	push	{r7, lr}
c0d07b2e:	f7fb feaf 	bl	c0d03890 <ui_idle>
c0d07b32:	bd80      	pop	{r7, pc}

c0d07b34 <ux_display_public_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Address",
      .text = strings.common.fullAddress,
    });
UX_STEP_CB(
c0d07b34:	b580      	push	{r7, lr}
c0d07b36:	2000      	movs	r0, #0
c0d07b38:	f7ff fcf0 	bl	c0d0751c <io_seproxyhal_touch_address_ok>
c0d07b3c:	bd80      	pop	{r7, pc}

c0d07b3e <ux_display_public_flow_4_step_validateinit>:
    io_seproxyhal_touch_address_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0d07b3e:	b580      	push	{r7, lr}
c0d07b40:	2000      	movs	r0, #0
c0d07b42:	f7ff fd03 	bl	c0d0754c <io_seproxyhal_touch_address_cancel>
c0d07b46:	bd80      	pop	{r7, pc}

c0d07b48 <ux_sign_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Message hash",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0d07b48:	b580      	push	{r7, lr}
c0d07b4a:	2000      	movs	r0, #0
c0d07b4c:	f7ff fd10 	bl	c0d07570 <io_seproxyhal_touch_signMessage_ok>
c0d07b50:	bd80      	pop	{r7, pc}

c0d07b52 <ux_sign_flow_4_step_validateinit>:
    {
      &C_icon_validate_14,
      "Sign",
      "message",
    });
UX_STEP_CB(
c0d07b52:	b580      	push	{r7, lr}
c0d07b54:	2000      	movs	r0, #0
c0d07b56:	f7ff fd69 	bl	c0d0762c <io_seproxyhal_touch_signMessage_cancel>
c0d07b5a:	bd80      	pop	{r7, pc}

c0d07b5c <ux_sign_712_v0_flow_2_step_init>:
    {
      &C_icon_certificate,
      "Sign",
      "typed message",
    });
UX_STEP_NOCB_INIT(
c0d07b5c:	b510      	push	{r4, lr}
c0d07b5e:	b082      	sub	sp, #8
c0d07b60:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, 70, "0x%.*H", 32, tmpCtx.messageSigningContext712.domainHash);
c0d07b62:	4808      	ldr	r0, [pc, #32]	; (c0d07b84 <ux_sign_712_v0_flow_2_step_init+0x28>)
c0d07b64:	302c      	adds	r0, #44	; 0x2c
c0d07b66:	4669      	mov	r1, sp
c0d07b68:	6008      	str	r0, [r1, #0]
c0d07b6a:	4807      	ldr	r0, [pc, #28]	; (c0d07b88 <ux_sign_712_v0_flow_2_step_init+0x2c>)
c0d07b6c:	2146      	movs	r1, #70	; 0x46
c0d07b6e:	4a07      	ldr	r2, [pc, #28]	; (c0d07b8c <ux_sign_712_v0_flow_2_step_init+0x30>)
c0d07b70:	447a      	add	r2, pc
c0d07b72:	2320      	movs	r3, #32
c0d07b74:	f7fd fc0c 	bl	c0d05390 <snprintf>
UX_STEP_NOCB_INIT(
c0d07b78:	4620      	mov	r0, r4
c0d07b7a:	f002 faab 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d07b7e:	b002      	add	sp, #8
c0d07b80:	bd10      	pop	{r4, pc}
c0d07b82:	46c0      	nop			; (mov r8, r8)
c0d07b84:	20001804 	.word	0x20001804
c0d07b88:	20001cca 	.word	0x20001cca
c0d07b8c:	000031dc 	.word	0x000031dc

c0d07b90 <ux_sign_712_v0_flow_3_step_init>:
    prepare_domain_hash_v0(),
    {
      .title = "Domain hash",
      .text = strings.tmp.tmp,
    });
UX_STEP_NOCB_INIT(
c0d07b90:	b510      	push	{r4, lr}
c0d07b92:	b082      	sub	sp, #8
c0d07b94:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, 70, "0x%.*H", 32, tmpCtx.messageSigningContext712.messageHash);
c0d07b96:	4808      	ldr	r0, [pc, #32]	; (c0d07bb8 <ux_sign_712_v0_flow_3_step_init+0x28>)
c0d07b98:	304c      	adds	r0, #76	; 0x4c
c0d07b9a:	4669      	mov	r1, sp
c0d07b9c:	6008      	str	r0, [r1, #0]
c0d07b9e:	4807      	ldr	r0, [pc, #28]	; (c0d07bbc <ux_sign_712_v0_flow_3_step_init+0x2c>)
c0d07ba0:	2146      	movs	r1, #70	; 0x46
c0d07ba2:	4a07      	ldr	r2, [pc, #28]	; (c0d07bc0 <ux_sign_712_v0_flow_3_step_init+0x30>)
c0d07ba4:	447a      	add	r2, pc
c0d07ba6:	2320      	movs	r3, #32
c0d07ba8:	f7fd fbf2 	bl	c0d05390 <snprintf>
UX_STEP_NOCB_INIT(
c0d07bac:	4620      	mov	r0, r4
c0d07bae:	f002 fa91 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d07bb2:	b002      	add	sp, #8
c0d07bb4:	bd10      	pop	{r4, pc}
c0d07bb6:	46c0      	nop			; (mov r8, r8)
c0d07bb8:	20001804 	.word	0x20001804
c0d07bbc:	20001cca 	.word	0x20001cca
c0d07bc0:	000031a8 	.word	0x000031a8

c0d07bc4 <ux_sign_712_v0_flow_4_step_validateinit>:
    prepare_message_hash_v0(),
    {
      .title = "Message hash",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0d07bc4:	b580      	push	{r7, lr}
c0d07bc6:	2000      	movs	r0, #0
c0d07bc8:	f7ff fd42 	bl	c0d07650 <io_seproxyhal_touch_signMessage712_v0_ok>
c0d07bcc:	bd80      	pop	{r7, pc}

c0d07bce <ux_sign_712_v0_flow_5_step_validateinit>:
    {
      &C_icon_validate_14,
      "Sign",
      "message",
    });
UX_STEP_CB(
c0d07bce:	b580      	push	{r7, lr}
c0d07bd0:	2000      	movs	r0, #0
c0d07bd2:	f7ff fdcd 	bl	c0d07770 <io_seproxyhal_touch_signMessage712_v0_cancel>
c0d07bd6:	bd80      	pop	{r7, pc}

c0d07bd8 <ux_confirm_selector_flow_3_step_validateinit>:
    bn,
    {
      "Selector",
      strings.tmp.tmp
    });
UX_STEP_CB(
c0d07bd8:	b580      	push	{r7, lr}
c0d07bda:	2000      	movs	r0, #0
c0d07bdc:	f7ff fe60 	bl	c0d078a0 <io_seproxyhal_touch_data_ok>
c0d07be0:	bd80      	pop	{r7, pc}

c0d07be2 <ux_confirm_selector_flow_4_step_validateinit>:
    io_seproxyhal_touch_data_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0d07be2:	b580      	push	{r7, lr}
c0d07be4:	2000      	movs	r0, #0
c0d07be6:	f7ff fe83 	bl	c0d078f0 <io_seproxyhal_touch_data_cancel>
c0d07bea:	bd80      	pop	{r7, pc}

c0d07bec <ux_confirm_parameter_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Parameter",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0d07bec:	b580      	push	{r7, lr}
c0d07bee:	2000      	movs	r0, #0
c0d07bf0:	f7ff fe56 	bl	c0d078a0 <io_seproxyhal_touch_data_ok>
c0d07bf4:	bd80      	pop	{r7, pc}

c0d07bf6 <ux_confirm_parameter_flow_4_step_validateinit>:
    io_seproxyhal_touch_data_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0d07bf6:	b580      	push	{r7, lr}
c0d07bf8:	2000      	movs	r0, #0
c0d07bfa:	f7ff fe79 	bl	c0d078f0 <io_seproxyhal_touch_data_cancel>
c0d07bfe:	bd80      	pop	{r7, pc}

c0d07c00 <ux_approval_tx_5_step_validateinit>:
    bnnn_paging,
    {
      .title = "Max Fees",
      .text = strings.common.maxFee,
    });
UX_STEP_CB(
c0d07c00:	b580      	push	{r7, lr}
c0d07c02:	2000      	movs	r0, #0
c0d07c04:	f7ff fdc6 	bl	c0d07794 <io_seproxyhal_touch_tx_ok>
c0d07c08:	bd80      	pop	{r7, pc}

c0d07c0a <ux_approval_tx_6_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0d07c0a:	b580      	push	{r7, lr}
c0d07c0c:	2000      	movs	r0, #0
c0d07c0e:	f7ff fe35 	bl	c0d0787c <io_seproxyhal_touch_tx_cancel>
c0d07c12:	bd80      	pop	{r7, pc}

c0d07c14 <ux_display_stark_public_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Stark Key",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0d07c14:	b580      	push	{r7, lr}
c0d07c16:	2000      	movs	r0, #0
c0d07c18:	f7ff fe76 	bl	c0d07908 <io_seproxyhal_touch_stark_pubkey_ok>
c0d07c1c:	bd80      	pop	{r7, pc}

c0d07c1e <ux_display_stark_public_flow_4_step_validateinit>:
    io_seproxyhal_touch_stark_pubkey_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0d07c1e:	b580      	push	{r7, lr}
c0d07c20:	2000      	movs	r0, #0
c0d07c22:	f7ff fc93 	bl	c0d0754c <io_seproxyhal_touch_address_cancel>
c0d07c26:	bd80      	pop	{r7, pc}

c0d07c28 <ux_stark_limit_order_7_step_validateinit>:
    {
      .title = "Token Account",
      .text = strings.common.fullAddress
    });

UX_STEP_CB(
c0d07c28:	b580      	push	{r7, lr}
c0d07c2a:	2000      	movs	r0, #0
c0d07c2c:	f7ff fe84 	bl	c0d07938 <io_seproxyhal_touch_stark_ok>
c0d07c30:	bd80      	pop	{r7, pc}

c0d07c32 <ux_stark_limit_order_8_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0d07c32:	b580      	push	{r7, lr}
c0d07c34:	2000      	movs	r0, #0
c0d07c36:	f7ff fe21 	bl	c0d0787c <io_seproxyhal_touch_tx_cancel>
c0d07c3a:	bd80      	pop	{r7, pc}

c0d07c3c <ux_stark_transfer_6_step_validateinit>:
    {
      .title = "Token Account",
      .text = strings.tmp.tmp2
    });

UX_STEP_CB(
c0d07c3c:	b580      	push	{r7, lr}
c0d07c3e:	2000      	movs	r0, #0
c0d07c40:	f7ff fe7a 	bl	c0d07938 <io_seproxyhal_touch_stark_ok>
c0d07c44:	bd80      	pop	{r7, pc}

c0d07c46 <ux_stark_transfer_7_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0d07c46:	b580      	push	{r7, lr}
c0d07c48:	2000      	movs	r0, #0
c0d07c4a:	f7ff fe17 	bl	c0d0787c <io_seproxyhal_touch_tx_cancel>
c0d07c4e:	bd80      	pop	{r7, pc}

c0d07c50 <ux_stark_conditional_transfer_4_step_init>:
    {
      &C_icon_crossmark,
      "Reject",
    });

UX_STEP_NOCB_INIT(
c0d07c50:	b510      	push	{r4, lr}
c0d07c52:	b082      	sub	sp, #8
c0d07c54:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp,
c0d07c56:	4808      	ldr	r0, [pc, #32]	; (c0d07c78 <ux_stark_conditional_transfer_4_step_init+0x28>)
c0d07c58:	3081      	adds	r0, #129	; 0x81
c0d07c5a:	4669      	mov	r1, sp
c0d07c5c:	6008      	str	r0, [r1, #0]
c0d07c5e:	4807      	ldr	r0, [pc, #28]	; (c0d07c7c <ux_stark_conditional_transfer_4_step_init+0x2c>)
c0d07c60:	2164      	movs	r1, #100	; 0x64
c0d07c62:	4a07      	ldr	r2, [pc, #28]	; (c0d07c80 <ux_stark_conditional_transfer_4_step_init+0x30>)
c0d07c64:	447a      	add	r2, pc
c0d07c66:	2320      	movs	r3, #32
c0d07c68:	f7fd fb92 	bl	c0d05390 <snprintf>
UX_STEP_NOCB_INIT(
c0d07c6c:	4620      	mov	r0, r4
c0d07c6e:	f002 fa31 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d07c72:	b002      	add	sp, #8
c0d07c74:	bd10      	pop	{r4, pc}
c0d07c76:	46c0      	nop			; (mov r8, r8)
c0d07c78:	20001be4 	.word	0x20001be4
c0d07c7c:	20001cca 	.word	0x20001cca
c0d07c80:	000030e8 	.word	0x000030e8

c0d07c84 <ux_stark_conditional_transfer_8_step_init>:
    {
      .title = "Master Account",
      .text = strings.tmp.tmp
    });

UX_STEP_NOCB_INIT(
c0d07c84:	b5b0      	push	{r4, r5, r7, lr}
c0d07c86:	4604      	mov	r4, r0
    strings.tmp.tmp[0] = '0';
c0d07c88:	4d09      	ldr	r5, [pc, #36]	; (c0d07cb0 <ux_stark_conditional_transfer_8_step_init+0x2c>)
c0d07c8a:	2078      	movs	r0, #120	; 0x78
    strings.tmp.tmp[1] = 'x';
c0d07c8c:	7068      	strb	r0, [r5, #1]
c0d07c8e:	2030      	movs	r0, #48	; 0x30
    strings.tmp.tmp[0] = '0';
c0d07c90:	7028      	strb	r0, [r5, #0]
                                  chainConfig);
c0d07c92:	4808      	ldr	r0, [pc, #32]	; (c0d07cb4 <ux_stark_conditional_transfer_8_step_init+0x30>)
c0d07c94:	6803      	ldr	r3, [r0, #0]
    getEthAddressStringFromBinary(dataContext.starkContext.conditionAddress,
c0d07c96:	4808      	ldr	r0, [pc, #32]	; (c0d07cb8 <ux_stark_conditional_transfer_8_step_init+0x34>)
c0d07c98:	30c1      	adds	r0, #193	; 0xc1
c0d07c9a:	1ca9      	adds	r1, r5, #2
c0d07c9c:	4a07      	ldr	r2, [pc, #28]	; (c0d07cbc <ux_stark_conditional_transfer_8_step_init+0x38>)
c0d07c9e:	f7fa fc23 	bl	c0d024e8 <getEthAddressStringFromBinary>
c0d07ca2:	202a      	movs	r0, #42	; 0x2a
c0d07ca4:	2100      	movs	r1, #0
    strings.tmp.tmp[42] = '\0';
c0d07ca6:	5429      	strb	r1, [r5, r0]
UX_STEP_NOCB_INIT(
c0d07ca8:	4620      	mov	r0, r4
c0d07caa:	f002 fa13 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d07cae:	bdb0      	pop	{r4, r5, r7, pc}
c0d07cb0:	20001cca 	.word	0x20001cca
c0d07cb4:	20001be0 	.word	0x20001be0
c0d07cb8:	20001be4 	.word	0x20001be4
c0d07cbc:	20001d60 	.word	0x20001d60

c0d07cc0 <ux_stark_conditional_transfer_9_step_init>:
    {
      .title = "Cond. Address",
      .text = strings.tmp.tmp
    });

UX_STEP_NOCB_INIT(
c0d07cc0:	b510      	push	{r4, lr}
c0d07cc2:	b082      	sub	sp, #8
c0d07cc4:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.fact);
c0d07cc6:	4808      	ldr	r0, [pc, #32]	; (c0d07ce8 <ux_stark_conditional_transfer_9_step_init+0x28>)
c0d07cc8:	30a1      	adds	r0, #161	; 0xa1
c0d07cca:	4669      	mov	r1, sp
c0d07ccc:	6008      	str	r0, [r1, #0]
c0d07cce:	4807      	ldr	r0, [pc, #28]	; (c0d07cec <ux_stark_conditional_transfer_9_step_init+0x2c>)
c0d07cd0:	2164      	movs	r1, #100	; 0x64
c0d07cd2:	4a07      	ldr	r2, [pc, #28]	; (c0d07cf0 <ux_stark_conditional_transfer_9_step_init+0x30>)
c0d07cd4:	447a      	add	r2, pc
c0d07cd6:	2320      	movs	r3, #32
c0d07cd8:	f7fd fb5a 	bl	c0d05390 <snprintf>
UX_STEP_NOCB_INIT(
c0d07cdc:	4620      	mov	r0, r4
c0d07cde:	f002 f9f9 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d07ce2:	b002      	add	sp, #8
c0d07ce4:	bd10      	pop	{r4, pc}
c0d07ce6:	46c0      	nop			; (mov r8, r8)
c0d07ce8:	20001be4 	.word	0x20001be4
c0d07cec:	20001cca 	.word	0x20001cca
c0d07cf0:	00003078 	.word	0x00003078

c0d07cf4 <ux_stark_unsafe_sign_2_step_init>:
      &C_icon_warning,
      "Unsafe",
      "Stark Sign",
    });

UX_STEP_NOCB_INIT(
c0d07cf4:	b510      	push	{r4, lr}
c0d07cf6:	b082      	sub	sp, #8
c0d07cf8:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.w1);
c0d07cfa:	4807      	ldr	r0, [pc, #28]	; (c0d07d18 <ux_stark_unsafe_sign_2_step_init+0x24>)
c0d07cfc:	4669      	mov	r1, sp
c0d07cfe:	6008      	str	r0, [r1, #0]
c0d07d00:	4806      	ldr	r0, [pc, #24]	; (c0d07d1c <ux_stark_unsafe_sign_2_step_init+0x28>)
c0d07d02:	2164      	movs	r1, #100	; 0x64
c0d07d04:	4a06      	ldr	r2, [pc, #24]	; (c0d07d20 <ux_stark_unsafe_sign_2_step_init+0x2c>)
c0d07d06:	447a      	add	r2, pc
c0d07d08:	2320      	movs	r3, #32
c0d07d0a:	f7fd fb41 	bl	c0d05390 <snprintf>
UX_STEP_NOCB_INIT(
c0d07d0e:	4620      	mov	r0, r4
c0d07d10:	f002 f9e0 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d07d14:	b002      	add	sp, #8
c0d07d16:	bd10      	pop	{r4, pc}
c0d07d18:	20001be4 	.word	0x20001be4
c0d07d1c:	20001cca 	.word	0x20001cca
c0d07d20:	00003046 	.word	0x00003046

c0d07d24 <ux_stark_unsafe_sign_3_step_init>:
  {
    .title = "From Account",
    .text = strings.tmp.tmp
  });

UX_STEP_NOCB_INIT(
c0d07d24:	b510      	push	{r4, lr}
c0d07d26:	b082      	sub	sp, #8
c0d07d28:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.w2);
c0d07d2a:	4808      	ldr	r0, [pc, #32]	; (c0d07d4c <ux_stark_unsafe_sign_3_step_init+0x28>)
c0d07d2c:	3020      	adds	r0, #32
c0d07d2e:	4669      	mov	r1, sp
c0d07d30:	6008      	str	r0, [r1, #0]
c0d07d32:	4807      	ldr	r0, [pc, #28]	; (c0d07d50 <ux_stark_unsafe_sign_3_step_init+0x2c>)
c0d07d34:	2164      	movs	r1, #100	; 0x64
c0d07d36:	4a07      	ldr	r2, [pc, #28]	; (c0d07d54 <ux_stark_unsafe_sign_3_step_init+0x30>)
c0d07d38:	447a      	add	r2, pc
c0d07d3a:	2320      	movs	r3, #32
c0d07d3c:	f7fd fb28 	bl	c0d05390 <snprintf>
UX_STEP_NOCB_INIT(
c0d07d40:	4620      	mov	r0, r4
c0d07d42:	f002 f9c7 	bl	c0d0a0d4 <ux_layout_paging_init>
c0d07d46:	b002      	add	sp, #8
c0d07d48:	bd10      	pop	{r4, pc}
c0d07d4a:	46c0      	nop			; (mov r8, r8)
c0d07d4c:	20001be4 	.word	0x20001be4
c0d07d50:	20001cca 	.word	0x20001cca
c0d07d54:	00003014 	.word	0x00003014

c0d07d58 <ux_stark_unsafe_sign_4_step_validateinit>:
    .title = "Hash",
    .text = strings.tmp.tmp
  });


UX_STEP_CB(
c0d07d58:	b580      	push	{r7, lr}
c0d07d5a:	2000      	movs	r0, #0
c0d07d5c:	f7ff fe28 	bl	c0d079b0 <io_seproxyhal_touch_stark_unsafe_sign_ok>
c0d07d60:	bd80      	pop	{r7, pc}

c0d07d62 <ux_stark_unsafe_sign_5_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0d07d62:	b580      	push	{r7, lr}
c0d07d64:	2000      	movs	r0, #0
c0d07d66:	f7ff fd89 	bl	c0d0787c <io_seproxyhal_touch_tx_cancel>
c0d07d6a:	bd80      	pop	{r7, pc}

c0d07d6c <readUint64BE>:
static const char HEXDIGITS[] = "0123456789abcdef";

static uint64_t readUint64BE(uint8_t *buffer) {
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
           (((uint64_t) buffer[4]) << 24) | (((uint64_t) buffer[5]) << 16) |
c0d07d6c:	7941      	ldrb	r1, [r0, #5]
c0d07d6e:	0409      	lsls	r1, r1, #16
c0d07d70:	7902      	ldrb	r2, [r0, #4]
c0d07d72:	0612      	lsls	r2, r2, #24
c0d07d74:	1851      	adds	r1, r2, r1
           (((uint64_t) buffer[6]) << 8) | (((uint64_t) buffer[7]));
c0d07d76:	7982      	ldrb	r2, [r0, #6]
c0d07d78:	0212      	lsls	r2, r2, #8
           (((uint64_t) buffer[4]) << 24) | (((uint64_t) buffer[5]) << 16) |
c0d07d7a:	1889      	adds	r1, r1, r2
           (((uint64_t) buffer[6]) << 8) | (((uint64_t) buffer[7]));
c0d07d7c:	79c2      	ldrb	r2, [r0, #7]
c0d07d7e:	188a      	adds	r2, r1, r2
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0d07d80:	7801      	ldrb	r1, [r0, #0]
c0d07d82:	0609      	lsls	r1, r1, #24
c0d07d84:	7843      	ldrb	r3, [r0, #1]
c0d07d86:	041b      	lsls	r3, r3, #16
c0d07d88:	1859      	adds	r1, r3, r1
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
c0d07d8a:	7883      	ldrb	r3, [r0, #2]
c0d07d8c:	021b      	lsls	r3, r3, #8
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0d07d8e:	18c9      	adds	r1, r1, r3
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
c0d07d90:	78c0      	ldrb	r0, [r0, #3]
c0d07d92:	1809      	adds	r1, r1, r0
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0d07d94:	4610      	mov	r0, r2
c0d07d96:	4770      	bx	lr

c0d07d98 <readu256BE>:
void readu128BE(uint8_t *buffer, uint128_t *target) {
    UPPER_P(target) = readUint64BE(buffer);
    LOWER_P(target) = readUint64BE(buffer + 8);
}

void readu256BE(uint8_t *buffer, uint256_t *target) {
c0d07d98:	b5b0      	push	{r4, r5, r7, lr}
c0d07d9a:	460c      	mov	r4, r1
c0d07d9c:	4605      	mov	r5, r0
    UPPER_P(target) = readUint64BE(buffer);
c0d07d9e:	f7ff ffe5 	bl	c0d07d6c <readUint64BE>
c0d07da2:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d07da4:	4628      	mov	r0, r5
c0d07da6:	3008      	adds	r0, #8
    UPPER_P(target) = readUint64BE(buffer);
c0d07da8:	3c08      	subs	r4, #8
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d07daa:	f7ff ffdf 	bl	c0d07d6c <readUint64BE>
c0d07dae:	60a0      	str	r0, [r4, #8]
c0d07db0:	60e1      	str	r1, [r4, #12]
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
c0d07db2:	4628      	mov	r0, r5
c0d07db4:	3010      	adds	r0, #16
    UPPER_P(target) = readUint64BE(buffer);
c0d07db6:	f7ff ffd9 	bl	c0d07d6c <readUint64BE>
c0d07dba:	6120      	str	r0, [r4, #16]
c0d07dbc:	6161      	str	r1, [r4, #20]
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d07dbe:	3518      	adds	r5, #24
c0d07dc0:	4628      	mov	r0, r5
c0d07dc2:	f7ff ffd3 	bl	c0d07d6c <readUint64BE>
c0d07dc6:	61a0      	str	r0, [r4, #24]
c0d07dc8:	61e1      	str	r1, [r4, #28]
}
c0d07dca:	bdb0      	pop	{r4, r5, r7, pc}

c0d07dcc <shiftl128>:
void clear256(uint256_t *target) {
    clear128(&UPPER_P(target));
    clear128(&LOWER_P(target));
}

void shiftl128(uint128_t *number, uint32_t value, uint128_t *target) {
c0d07dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07dce:	b081      	sub	sp, #4
c0d07dd0:	4614      	mov	r4, r2
    if (value >= 128) {
c0d07dd2:	2980      	cmp	r1, #128	; 0x80
c0d07dd4:	d305      	bcc.n	c0d07de2 <shiftl128+0x16>
c0d07dd6:	2000      	movs	r0, #0
c0d07dd8:	6020      	str	r0, [r4, #0]
c0d07dda:	6060      	str	r0, [r4, #4]
c0d07ddc:	60a0      	str	r0, [r4, #8]
c0d07dde:	60e0      	str	r0, [r4, #12]
c0d07de0:	e03a      	b.n	c0d07e58 <shiftl128+0x8c>
c0d07de2:	460d      	mov	r5, r1
c0d07de4:	4606      	mov	r6, r0
        clear128(target);
    } else if (value == 64) {
c0d07de6:	2900      	cmp	r1, #0
c0d07de8:	d007      	beq.n	c0d07dfa <shiftl128+0x2e>
c0d07dea:	2d40      	cmp	r5, #64	; 0x40
c0d07dec:	d10c      	bne.n	c0d07e08 <shiftl128+0x3c>
        UPPER_P(target) = LOWER_P(number);
c0d07dee:	68b0      	ldr	r0, [r6, #8]
c0d07df0:	68f1      	ldr	r1, [r6, #12]
c0d07df2:	2200      	movs	r2, #0
c0d07df4:	c407      	stmia	r4!, {r0, r1, r2}
        LOWER_P(target) = 0;
c0d07df6:	6022      	str	r2, [r4, #0]
c0d07df8:	e02e      	b.n	c0d07e58 <shiftl128+0x8c>
    UPPER_P(target) = UPPER_P(number);
c0d07dfa:	ce03      	ldmia	r6!, {r0, r1}
c0d07dfc:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d07dfe:	6830      	ldr	r0, [r6, #0]
c0d07e00:	6871      	ldr	r1, [r6, #4]
c0d07e02:	6061      	str	r1, [r4, #4]
c0d07e04:	6020      	str	r0, [r4, #0]
c0d07e06:	e027      	b.n	c0d07e58 <shiftl128+0x8c>
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
c0d07e08:	2d3f      	cmp	r5, #63	; 0x3f
c0d07e0a:	d819      	bhi.n	c0d07e40 <shiftl128+0x74>
        UPPER_P(target) = (UPPER_P(number) << value) + (LOWER_P(number) >> (64 - value));
c0d07e0c:	ce03      	ldmia	r6!, {r0, r1}
c0d07e0e:	462a      	mov	r2, r5
c0d07e10:	3e08      	subs	r6, #8
c0d07e12:	f002 fc1f 	bl	c0d0a654 <__aeabi_llsl>
c0d07e16:	4607      	mov	r7, r0
c0d07e18:	9100      	str	r1, [sp, #0]
c0d07e1a:	2040      	movs	r0, #64	; 0x40
c0d07e1c:	1b42      	subs	r2, r0, r5
c0d07e1e:	68b0      	ldr	r0, [r6, #8]
c0d07e20:	68f1      	ldr	r1, [r6, #12]
c0d07e22:	f002 fc0b 	bl	c0d0a63c <__aeabi_llsr>
c0d07e26:	19c0      	adds	r0, r0, r7
c0d07e28:	6020      	str	r0, [r4, #0]
c0d07e2a:	9800      	ldr	r0, [sp, #0]
c0d07e2c:	4141      	adcs	r1, r0
c0d07e2e:	6061      	str	r1, [r4, #4]
        LOWER_P(target) = (LOWER_P(number) << value);
c0d07e30:	68b0      	ldr	r0, [r6, #8]
c0d07e32:	68f1      	ldr	r1, [r6, #12]
c0d07e34:	462a      	mov	r2, r5
c0d07e36:	f002 fc0d 	bl	c0d0a654 <__aeabi_llsl>
c0d07e3a:	60a0      	str	r0, [r4, #8]
c0d07e3c:	60e1      	str	r1, [r4, #12]
c0d07e3e:	e00b      	b.n	c0d07e58 <shiftl128+0x8c>
    } else if ((128 > value) && (value > 64)) {
c0d07e40:	2d40      	cmp	r5, #64	; 0x40
c0d07e42:	d0c8      	beq.n	c0d07dd6 <shiftl128+0xa>
        UPPER_P(target) = LOWER_P(number) << (value - 64);
c0d07e44:	68b0      	ldr	r0, [r6, #8]
c0d07e46:	68f1      	ldr	r1, [r6, #12]
c0d07e48:	2200      	movs	r2, #0
        LOWER_P(target) = 0;
c0d07e4a:	60a2      	str	r2, [r4, #8]
c0d07e4c:	60e2      	str	r2, [r4, #12]
        UPPER_P(target) = LOWER_P(number) << (value - 64);
c0d07e4e:	3d40      	subs	r5, #64	; 0x40
c0d07e50:	462a      	mov	r2, r5
c0d07e52:	f002 fbff 	bl	c0d0a654 <__aeabi_llsl>
c0d07e56:	c403      	stmia	r4!, {r0, r1}
    } else {
        clear128(target);
    }
}
c0d07e58:	b001      	add	sp, #4
c0d07e5a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07e5c <shiftl256>:

void shiftl256(uint256_t *number, uint32_t value, uint256_t *target) {
c0d07e5c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07e5e:	b097      	sub	sp, #92	; 0x5c
c0d07e60:	4614      	mov	r4, r2
c0d07e62:	4605      	mov	r5, r0
    if (value >= 256) {
c0d07e64:	0a08      	lsrs	r0, r1, #8
c0d07e66:	d004      	beq.n	c0d07e72 <shiftl256+0x16>
c0d07e68:	2120      	movs	r1, #32
c0d07e6a:	4620      	mov	r0, r4
c0d07e6c:	f002 fbfe 	bl	c0d0a66c <__aeabi_memclr>
c0d07e70:	e079      	b.n	c0d07f66 <shiftl256+0x10a>
c0d07e72:	460e      	mov	r6, r1
        clear256(target);
    } else if (value == 128) {
c0d07e74:	2900      	cmp	r1, #0
c0d07e76:	d00e      	beq.n	c0d07e96 <shiftl256+0x3a>
c0d07e78:	2e80      	cmp	r6, #128	; 0x80
c0d07e7a:	d11b      	bne.n	c0d07eb4 <shiftl256+0x58>
    UPPER_P(target) = UPPER_P(number);
c0d07e7c:	6928      	ldr	r0, [r5, #16]
c0d07e7e:	6969      	ldr	r1, [r5, #20]
c0d07e80:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d07e82:	69a8      	ldr	r0, [r5, #24]
c0d07e84:	69e9      	ldr	r1, [r5, #28]
c0d07e86:	6061      	str	r1, [r4, #4]
c0d07e88:	6020      	str	r0, [r4, #0]
c0d07e8a:	2000      	movs	r0, #0
    UPPER_P(target) = UPPER_P(number);
c0d07e8c:	3c08      	subs	r4, #8
    LOWER_P(target) = 0;
c0d07e8e:	61e0      	str	r0, [r4, #28]
c0d07e90:	6160      	str	r0, [r4, #20]
c0d07e92:	61a0      	str	r0, [r4, #24]
c0d07e94:	e00c      	b.n	c0d07eb0 <shiftl256+0x54>
    UPPER_P(target) = UPPER_P(number);
c0d07e96:	cd03      	ldmia	r5!, {r0, r1}
c0d07e98:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d07e9a:	6828      	ldr	r0, [r5, #0]
c0d07e9c:	6869      	ldr	r1, [r5, #4]
c0d07e9e:	6061      	str	r1, [r4, #4]
c0d07ea0:	6020      	str	r0, [r4, #0]
    UPPER_P(target) = UPPER_P(number);
c0d07ea2:	68a8      	ldr	r0, [r5, #8]
c0d07ea4:	68e9      	ldr	r1, [r5, #12]
c0d07ea6:	60e1      	str	r1, [r4, #12]
c0d07ea8:	60a0      	str	r0, [r4, #8]
    LOWER_P(target) = LOWER_P(number);
c0d07eaa:	6928      	ldr	r0, [r5, #16]
c0d07eac:	6969      	ldr	r1, [r5, #20]
c0d07eae:	6161      	str	r1, [r4, #20]
c0d07eb0:	6120      	str	r0, [r4, #16]
c0d07eb2:	e058      	b.n	c0d07f66 <shiftl256+0x10a>
        copy128(&UPPER_P(target), &LOWER_P(number));
        clear128(&LOWER_P(target));
    } else if (value == 0) {
        copy256(target, number);
    } else if (value < 128) {
c0d07eb4:	2e7f      	cmp	r6, #127	; 0x7f
c0d07eb6:	d848      	bhi.n	c0d07f4a <shiftl256+0xee>
c0d07eb8:	aa12      	add	r2, sp, #72	; 0x48
        uint128_t tmp1;
        uint128_t tmp2;
        uint256_t result;
        shiftl128(&UPPER_P(number), value, &tmp1);
c0d07eba:	4628      	mov	r0, r5
c0d07ebc:	4631      	mov	r1, r6
c0d07ebe:	f7ff ff85 	bl	c0d07dcc <shiftl128>
c0d07ec2:	2080      	movs	r0, #128	; 0x80
        shiftr128(&LOWER_P(number), (128 - value), &tmp2);
c0d07ec4:	1b81      	subs	r1, r0, r6
c0d07ec6:	3510      	adds	r5, #16
c0d07ec8:	aa0e      	add	r2, sp, #56	; 0x38
c0d07eca:	4628      	mov	r0, r5
c0d07ecc:	f000 f84d 	bl	c0d07f6a <shiftr128>
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d07ed0:	9914      	ldr	r1, [sp, #80]	; 0x50
c0d07ed2:	9103      	str	r1, [sp, #12]
c0d07ed4:	9810      	ldr	r0, [sp, #64]	; 0x40
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d07ed6:	9004      	str	r0, [sp, #16]
c0d07ed8:	1840      	adds	r0, r0, r1
c0d07eda:	9008      	str	r0, [sp, #32]
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d07edc:	9815      	ldr	r0, [sp, #84]	; 0x54
c0d07ede:	9a11      	ldr	r2, [sp, #68]	; 0x44
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d07ee0:	9202      	str	r2, [sp, #8]
c0d07ee2:	4142      	adcs	r2, r0
c0d07ee4:	9209      	str	r2, [sp, #36]	; 0x24
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0d07ee6:	9913      	ldr	r1, [sp, #76]	; 0x4c
c0d07ee8:	9105      	str	r1, [sp, #20]
c0d07eea:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d07eec:	9f12      	ldr	r7, [sp, #72]	; 0x48
c0d07eee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
c0d07ef0:	19d9      	adds	r1, r3, r7
c0d07ef2:	9b05      	ldr	r3, [sp, #20]
c0d07ef4:	415a      	adcs	r2, r3
c0d07ef6:	2300      	movs	r3, #0
c0d07ef8:	9101      	str	r1, [sp, #4]
c0d07efa:	1c49      	adds	r1, r1, #1
c0d07efc:	9105      	str	r1, [sp, #20]
c0d07efe:	9200      	str	r2, [sp, #0]
c0d07f00:	4617      	mov	r7, r2
c0d07f02:	415f      	adcs	r7, r3
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d07f04:	43c0      	mvns	r0, r0
c0d07f06:	9903      	ldr	r1, [sp, #12]
c0d07f08:	43c9      	mvns	r1, r1
c0d07f0a:	9a04      	ldr	r2, [sp, #16]
c0d07f0c:	1a89      	subs	r1, r1, r2
c0d07f0e:	9902      	ldr	r1, [sp, #8]
c0d07f10:	4188      	sbcs	r0, r1
c0d07f12:	d200      	bcs.n	c0d07f16 <shiftl256+0xba>
c0d07f14:	2301      	movs	r3, #1
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0d07f16:	2b00      	cmp	r3, #0
c0d07f18:	9805      	ldr	r0, [sp, #20]
c0d07f1a:	d100      	bne.n	c0d07f1e <shiftl256+0xc2>
c0d07f1c:	9f00      	ldr	r7, [sp, #0]
c0d07f1e:	9707      	str	r7, [sp, #28]
c0d07f20:	2b00      	cmp	r3, #0
c0d07f22:	d100      	bne.n	c0d07f26 <shiftl256+0xca>
c0d07f24:	9801      	ldr	r0, [sp, #4]
c0d07f26:	9006      	str	r0, [sp, #24]
c0d07f28:	aa06      	add	r2, sp, #24
        shiftl128(&LOWER_P(number), value, &LOWER(result));
c0d07f2a:	3210      	adds	r2, #16
c0d07f2c:	4628      	mov	r0, r5
c0d07f2e:	4631      	mov	r1, r6
c0d07f30:	f7ff ff4c 	bl	c0d07dcc <shiftl128>
    UPPER_P(target) = UPPER_P(number);
c0d07f34:	9806      	ldr	r0, [sp, #24]
c0d07f36:	9004      	str	r0, [sp, #16]
c0d07f38:	af07      	add	r7, sp, #28
c0d07f3a:	cfee      	ldmia	r7, {r1, r2, r3, r5, r6, r7}
    LOWER_P(target) = LOWER_P(number);
c0d07f3c:	980d      	ldr	r0, [sp, #52]	; 0x34
    UPPER_P(target) = UPPER_P(number);
c0d07f3e:	9005      	str	r0, [sp, #20]
c0d07f40:	9804      	ldr	r0, [sp, #16]
c0d07f42:	c4ef      	stmia	r4!, {r0, r1, r2, r3, r5, r6, r7}
    LOWER_P(target) = LOWER_P(number);
c0d07f44:	9805      	ldr	r0, [sp, #20]
c0d07f46:	6020      	str	r0, [r4, #0]
c0d07f48:	e00d      	b.n	c0d07f66 <shiftl256+0x10a>
    } else if ((256 > value) && (value > 128)) {
c0d07f4a:	2e80      	cmp	r6, #128	; 0x80
c0d07f4c:	d08c      	beq.n	c0d07e68 <shiftl256+0xc>
        shiftl128(&LOWER_P(number), (value - 128), &UPPER_P(target));
c0d07f4e:	3510      	adds	r5, #16
c0d07f50:	3e80      	subs	r6, #128	; 0x80
c0d07f52:	4628      	mov	r0, r5
c0d07f54:	4631      	mov	r1, r6
c0d07f56:	4622      	mov	r2, r4
c0d07f58:	f7ff ff38 	bl	c0d07dcc <shiftl128>
c0d07f5c:	2000      	movs	r0, #0
    LOWER_P(target) = 0;
c0d07f5e:	6120      	str	r0, [r4, #16]
c0d07f60:	6160      	str	r0, [r4, #20]
c0d07f62:	61a0      	str	r0, [r4, #24]
c0d07f64:	61e0      	str	r0, [r4, #28]
}
c0d07f66:	b017      	add	sp, #92	; 0x5c
c0d07f68:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07f6a <shiftr128>:
void shiftr128(uint128_t *number, uint32_t value, uint128_t *target) {
c0d07f6a:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07f6c:	b083      	sub	sp, #12
c0d07f6e:	4614      	mov	r4, r2
    if (value >= 128) {
c0d07f70:	2980      	cmp	r1, #128	; 0x80
c0d07f72:	d305      	bcc.n	c0d07f80 <shiftr128+0x16>
c0d07f74:	2000      	movs	r0, #0
c0d07f76:	6020      	str	r0, [r4, #0]
c0d07f78:	6060      	str	r0, [r4, #4]
c0d07f7a:	60a0      	str	r0, [r4, #8]
c0d07f7c:	60e0      	str	r0, [r4, #12]
c0d07f7e:	e03d      	b.n	c0d07ffc <shiftr128+0x92>
c0d07f80:	460d      	mov	r5, r1
c0d07f82:	4606      	mov	r6, r0
    } else if (value == 64) {
c0d07f84:	2900      	cmp	r1, #0
c0d07f86:	d006      	beq.n	c0d07f96 <shiftr128+0x2c>
c0d07f88:	2d40      	cmp	r5, #64	; 0x40
c0d07f8a:	d10c      	bne.n	c0d07fa6 <shiftr128+0x3c>
c0d07f8c:	2000      	movs	r0, #0
        UPPER_P(target) = 0;
c0d07f8e:	6060      	str	r0, [r4, #4]
c0d07f90:	6020      	str	r0, [r4, #0]
        LOWER_P(target) = UPPER_P(number);
c0d07f92:	ce03      	ldmia	r6!, {r0, r1}
c0d07f94:	e004      	b.n	c0d07fa0 <shiftr128+0x36>
    UPPER_P(target) = UPPER_P(number);
c0d07f96:	ce03      	ldmia	r6!, {r0, r1}
c0d07f98:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d07f9a:	6830      	ldr	r0, [r6, #0]
c0d07f9c:	6871      	ldr	r1, [r6, #4]
    UPPER_P(target) = UPPER_P(number);
c0d07f9e:	3c08      	subs	r4, #8
c0d07fa0:	60e1      	str	r1, [r4, #12]
c0d07fa2:	60a0      	str	r0, [r4, #8]
c0d07fa4:	e02a      	b.n	c0d07ffc <shiftr128+0x92>
    } else if (value < 64) {
c0d07fa6:	2d3f      	cmp	r5, #63	; 0x3f
c0d07fa8:	d81c      	bhi.n	c0d07fe4 <shiftr128+0x7a>
        UPPER(result) = UPPER_P(number) >> value;
c0d07faa:	6837      	ldr	r7, [r6, #0]
c0d07fac:	6871      	ldr	r1, [r6, #4]
c0d07fae:	9102      	str	r1, [sp, #8]
c0d07fb0:	4638      	mov	r0, r7
c0d07fb2:	462a      	mov	r2, r5
c0d07fb4:	f002 fb42 	bl	c0d0a63c <__aeabi_llsr>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d07fb8:	68b2      	ldr	r2, [r6, #8]
c0d07fba:	68f3      	ldr	r3, [r6, #12]
    UPPER_P(target) = UPPER_P(number);
c0d07fbc:	c403      	stmia	r4!, {r0, r1}
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d07fbe:	4610      	mov	r0, r2
c0d07fc0:	4619      	mov	r1, r3
c0d07fc2:	462a      	mov	r2, r5
    UPPER_P(target) = UPPER_P(number);
c0d07fc4:	3c08      	subs	r4, #8
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d07fc6:	f002 fb39 	bl	c0d0a63c <__aeabi_llsr>
c0d07fca:	4606      	mov	r6, r0
c0d07fcc:	9101      	str	r1, [sp, #4]
c0d07fce:	2040      	movs	r0, #64	; 0x40
c0d07fd0:	1b42      	subs	r2, r0, r5
c0d07fd2:	4638      	mov	r0, r7
c0d07fd4:	9902      	ldr	r1, [sp, #8]
c0d07fd6:	f002 fb3d 	bl	c0d0a654 <__aeabi_llsl>
c0d07fda:	1830      	adds	r0, r6, r0
    LOWER_P(target) = LOWER_P(number);
c0d07fdc:	60a0      	str	r0, [r4, #8]
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d07fde:	9801      	ldr	r0, [sp, #4]
c0d07fe0:	4141      	adcs	r1, r0
c0d07fe2:	e00a      	b.n	c0d07ffa <shiftr128+0x90>
    } else if ((128 > value) && (value > 64)) {
c0d07fe4:	2d40      	cmp	r5, #64	; 0x40
c0d07fe6:	d0c5      	beq.n	c0d07f74 <shiftr128+0xa>
        LOWER_P(target) = UPPER_P(number) >> (value - 64);
c0d07fe8:	ce03      	ldmia	r6!, {r0, r1}
c0d07fea:	2200      	movs	r2, #0
        UPPER_P(target) = 0;
c0d07fec:	6022      	str	r2, [r4, #0]
c0d07fee:	6062      	str	r2, [r4, #4]
        LOWER_P(target) = UPPER_P(number) >> (value - 64);
c0d07ff0:	3d40      	subs	r5, #64	; 0x40
c0d07ff2:	462a      	mov	r2, r5
c0d07ff4:	f002 fb22 	bl	c0d0a63c <__aeabi_llsr>
c0d07ff8:	60a0      	str	r0, [r4, #8]
c0d07ffa:	60e1      	str	r1, [r4, #12]
}
c0d07ffc:	b003      	add	sp, #12
c0d07ffe:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d08000 <shiftr256>:
void shiftr256(uint256_t *number, uint32_t value, uint256_t *target) {
c0d08000:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08002:	b095      	sub	sp, #84	; 0x54
c0d08004:	4614      	mov	r4, r2
c0d08006:	4605      	mov	r5, r0
    if (value >= 256) {
c0d08008:	0a08      	lsrs	r0, r1, #8
c0d0800a:	d004      	beq.n	c0d08016 <shiftr256+0x16>
c0d0800c:	2120      	movs	r1, #32
c0d0800e:	4620      	mov	r0, r4
c0d08010:	f002 fb2c 	bl	c0d0a66c <__aeabi_memclr>
c0d08014:	e072      	b.n	c0d080fc <shiftr256+0xfc>
c0d08016:	460e      	mov	r6, r1
    } else if (value == 128) {
c0d08018:	2900      	cmp	r1, #0
c0d0801a:	d00e      	beq.n	c0d0803a <shiftr256+0x3a>
c0d0801c:	2e80      	cmp	r6, #128	; 0x80
c0d0801e:	d11b      	bne.n	c0d08058 <shiftr256+0x58>
    UPPER_P(target) = UPPER_P(number);
c0d08020:	cd03      	ldmia	r5!, {r0, r1}
c0d08022:	6161      	str	r1, [r4, #20]
c0d08024:	6120      	str	r0, [r4, #16]
    LOWER_P(target) = LOWER_P(number);
c0d08026:	6828      	ldr	r0, [r5, #0]
c0d08028:	6869      	ldr	r1, [r5, #4]
c0d0802a:	61e1      	str	r1, [r4, #28]
c0d0802c:	61a0      	str	r0, [r4, #24]
c0d0802e:	2000      	movs	r0, #0
    LOWER_P(target) = 0;
c0d08030:	60e0      	str	r0, [r4, #12]
c0d08032:	6060      	str	r0, [r4, #4]
c0d08034:	60a0      	str	r0, [r4, #8]
c0d08036:	6020      	str	r0, [r4, #0]
c0d08038:	e060      	b.n	c0d080fc <shiftr256+0xfc>
    UPPER_P(target) = UPPER_P(number);
c0d0803a:	cd03      	ldmia	r5!, {r0, r1}
c0d0803c:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d0803e:	6828      	ldr	r0, [r5, #0]
c0d08040:	6869      	ldr	r1, [r5, #4]
c0d08042:	6061      	str	r1, [r4, #4]
c0d08044:	6020      	str	r0, [r4, #0]
    UPPER_P(target) = UPPER_P(number);
c0d08046:	68a8      	ldr	r0, [r5, #8]
c0d08048:	68e9      	ldr	r1, [r5, #12]
c0d0804a:	60e1      	str	r1, [r4, #12]
c0d0804c:	60a0      	str	r0, [r4, #8]
    LOWER_P(target) = LOWER_P(number);
c0d0804e:	6928      	ldr	r0, [r5, #16]
c0d08050:	6969      	ldr	r1, [r5, #20]
c0d08052:	6161      	str	r1, [r4, #20]
c0d08054:	6120      	str	r0, [r4, #16]
c0d08056:	e051      	b.n	c0d080fc <shiftr256+0xfc>
    } else if (value < 128) {
c0d08058:	2e7f      	cmp	r6, #127	; 0x7f
c0d0805a:	d841      	bhi.n	c0d080e0 <shiftr256+0xe0>
c0d0805c:	aa04      	add	r2, sp, #16
        shiftr128(&UPPER_P(number), value, &UPPER(result));
c0d0805e:	4628      	mov	r0, r5
c0d08060:	4631      	mov	r1, r6
c0d08062:	f7ff ff82 	bl	c0d07f6a <shiftr128>
        shiftr128(&LOWER_P(number), value, &tmp1);
c0d08066:	4628      	mov	r0, r5
c0d08068:	3010      	adds	r0, #16
c0d0806a:	aa10      	add	r2, sp, #64	; 0x40
c0d0806c:	4631      	mov	r1, r6
c0d0806e:	f7ff ff7c 	bl	c0d07f6a <shiftr128>
c0d08072:	2080      	movs	r0, #128	; 0x80
        shiftl128(&UPPER_P(number), (128 - value), &tmp2);
c0d08074:	1b81      	subs	r1, r0, r6
c0d08076:	aa0c      	add	r2, sp, #48	; 0x30
c0d08078:	4628      	mov	r0, r5
c0d0807a:	f7ff fea7 	bl	c0d07dcc <shiftl128>
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d0807e:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d08080:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d08082:	1829      	adds	r1, r5, r0
c0d08084:	9103      	str	r1, [sp, #12]
c0d08086:	910a      	str	r1, [sp, #40]	; 0x28
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d08088:	9b13      	ldr	r3, [sp, #76]	; 0x4c
c0d0808a:	990f      	ldr	r1, [sp, #60]	; 0x3c
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d0808c:	460a      	mov	r2, r1
c0d0808e:	415a      	adcs	r2, r3
c0d08090:	9202      	str	r2, [sp, #8]
c0d08092:	920b      	str	r2, [sp, #44]	; 0x2c
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0d08094:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d08096:	9201      	str	r2, [sp, #4]
c0d08098:	9e0d      	ldr	r6, [sp, #52]	; 0x34
c0d0809a:	9f10      	ldr	r7, [sp, #64]	; 0x40
c0d0809c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0d0809e:	19d2      	adds	r2, r2, r7
c0d080a0:	9f01      	ldr	r7, [sp, #4]
c0d080a2:	417e      	adcs	r6, r7
c0d080a4:	2700      	movs	r7, #0
c0d080a6:	9200      	str	r2, [sp, #0]
c0d080a8:	1c52      	adds	r2, r2, #1
c0d080aa:	9201      	str	r2, [sp, #4]
c0d080ac:	4632      	mov	r2, r6
c0d080ae:	417a      	adcs	r2, r7
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d080b0:	43db      	mvns	r3, r3
c0d080b2:	43c0      	mvns	r0, r0
c0d080b4:	1b40      	subs	r0, r0, r5
c0d080b6:	418b      	sbcs	r3, r1
c0d080b8:	d200      	bcs.n	c0d080bc <shiftr256+0xbc>
c0d080ba:	2701      	movs	r7, #1
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0d080bc:	2f00      	cmp	r7, #0
c0d080be:	d100      	bne.n	c0d080c2 <shiftr256+0xc2>
c0d080c0:	4632      	mov	r2, r6
c0d080c2:	9209      	str	r2, [sp, #36]	; 0x24
c0d080c4:	2f00      	cmp	r7, #0
c0d080c6:	9e01      	ldr	r6, [sp, #4]
c0d080c8:	d100      	bne.n	c0d080cc <shiftr256+0xcc>
c0d080ca:	9e00      	ldr	r6, [sp, #0]
c0d080cc:	9608      	str	r6, [sp, #32]
    UPPER_P(target) = UPPER_P(number);
c0d080ce:	ad04      	add	r5, sp, #16
c0d080d0:	cd2b      	ldmia	r5, {r0, r1, r3, r5}
c0d080d2:	c46b      	stmia	r4!, {r0, r1, r3, r5, r6}
c0d080d4:	6022      	str	r2, [r4, #0]
    LOWER_P(target) = LOWER_P(number);
c0d080d6:	9803      	ldr	r0, [sp, #12]
c0d080d8:	6060      	str	r0, [r4, #4]
c0d080da:	9802      	ldr	r0, [sp, #8]
c0d080dc:	60a0      	str	r0, [r4, #8]
c0d080de:	e00d      	b.n	c0d080fc <shiftr256+0xfc>
    } else if ((256 > value) && (value > 128)) {
c0d080e0:	2e80      	cmp	r6, #128	; 0x80
c0d080e2:	d093      	beq.n	c0d0800c <shiftr256+0xc>
        shiftr128(&UPPER_P(number), (value - 128), &LOWER_P(target));
c0d080e4:	3e80      	subs	r6, #128	; 0x80
c0d080e6:	4622      	mov	r2, r4
c0d080e8:	3210      	adds	r2, #16
c0d080ea:	4628      	mov	r0, r5
c0d080ec:	4631      	mov	r1, r6
c0d080ee:	f7ff ff3c 	bl	c0d07f6a <shiftr128>
c0d080f2:	2000      	movs	r0, #0
    LOWER_P(target) = 0;
c0d080f4:	6020      	str	r0, [r4, #0]
c0d080f6:	6060      	str	r0, [r4, #4]
c0d080f8:	60a0      	str	r0, [r4, #8]
c0d080fa:	60e0      	str	r0, [r4, #12]
}
c0d080fc:	b015      	add	sp, #84	; 0x54
c0d080fe:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d08100 <bits256>:
uint32_t bits256(uint256_t *number) {
c0d08100:	b570      	push	{r4, r5, r6, lr}
c0d08102:	6804      	ldr	r4, [r0, #0]
c0d08104:	1d03      	adds	r3, r0, #4
c0d08106:	cb0e      	ldmia	r3, {r1, r2, r3}
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d08108:	461e      	mov	r6, r3
c0d0810a:	430e      	orrs	r6, r1
c0d0810c:	4615      	mov	r5, r2
c0d0810e:	4325      	orrs	r5, r4
c0d08110:	4335      	orrs	r5, r6
c0d08112:	2d00      	cmp	r5, #0
c0d08114:	d016      	beq.n	c0d08144 <bits256+0x44>
c0d08116:	2080      	movs	r0, #128	; 0x80
c0d08118:	2d00      	cmp	r5, #0
c0d0811a:	d032      	beq.n	c0d08182 <bits256+0x82>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d0811c:	0852      	lsrs	r2, r2, #1
c0d0811e:	07dd      	lsls	r5, r3, #31
c0d08120:	1952      	adds	r2, r2, r5
        UPPER(result) = UPPER_P(number) >> value;
c0d08122:	0865      	lsrs	r5, r4, #1
c0d08124:	07ce      	lsls	r6, r1, #31
c0d08126:	19ad      	adds	r5, r5, r6
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d08128:	462e      	mov	r6, r5
c0d0812a:	4316      	orrs	r6, r2
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d0812c:	07e4      	lsls	r4, r4, #31
c0d0812e:	085b      	lsrs	r3, r3, #1
c0d08130:	18e3      	adds	r3, r4, r3
        UPPER(result) = UPPER_P(number) >> value;
c0d08132:	0849      	lsrs	r1, r1, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d08134:	460c      	mov	r4, r1
c0d08136:	431c      	orrs	r4, r3
c0d08138:	4334      	orrs	r4, r6
            result++;
c0d0813a:	1c40      	adds	r0, r0, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d0813c:	2c00      	cmp	r4, #0
c0d0813e:	462c      	mov	r4, r5
c0d08140:	d1ec      	bne.n	c0d0811c <bits256+0x1c>
c0d08142:	e01e      	b.n	c0d08182 <bits256+0x82>
    UPPER_P(target) = UPPER_P(number);
c0d08144:	6904      	ldr	r4, [r0, #16]
c0d08146:	4603      	mov	r3, r0
c0d08148:	3314      	adds	r3, #20
c0d0814a:	cb0e      	ldmia	r3, {r1, r2, r3}
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d0814c:	4608      	mov	r0, r1
c0d0814e:	4318      	orrs	r0, r3
c0d08150:	4625      	mov	r5, r4
c0d08152:	4315      	orrs	r5, r2
c0d08154:	4305      	orrs	r5, r0
c0d08156:	2000      	movs	r0, #0
c0d08158:	2d00      	cmp	r5, #0
c0d0815a:	d012      	beq.n	c0d08182 <bits256+0x82>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d0815c:	0852      	lsrs	r2, r2, #1
c0d0815e:	07dd      	lsls	r5, r3, #31
c0d08160:	1952      	adds	r2, r2, r5
        UPPER(result) = UPPER_P(number) >> value;
c0d08162:	0865      	lsrs	r5, r4, #1
c0d08164:	07ce      	lsls	r6, r1, #31
c0d08166:	19ad      	adds	r5, r5, r6
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d08168:	462e      	mov	r6, r5
c0d0816a:	4316      	orrs	r6, r2
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d0816c:	07e4      	lsls	r4, r4, #31
c0d0816e:	085b      	lsrs	r3, r3, #1
c0d08170:	18e3      	adds	r3, r4, r3
        UPPER(result) = UPPER_P(number) >> value;
c0d08172:	0849      	lsrs	r1, r1, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d08174:	460c      	mov	r4, r1
c0d08176:	431c      	orrs	r4, r3
c0d08178:	4334      	orrs	r4, r6
            result++;
c0d0817a:	1c40      	adds	r0, r0, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d0817c:	2c00      	cmp	r4, #0
c0d0817e:	462c      	mov	r4, r5
c0d08180:	d1ec      	bne.n	c0d0815c <bits256+0x5c>
    return result;
c0d08182:	bd70      	pop	{r4, r5, r6, pc}

c0d08184 <gt256>:
bool gt256(uint256_t *number1, uint256_t *number2) {
c0d08184:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0d08186:	680b      	ldr	r3, [r1, #0]
c0d08188:	684a      	ldr	r2, [r1, #4]
c0d0818a:	6805      	ldr	r5, [r0, #0]
c0d0818c:	6844      	ldr	r4, [r0, #4]
c0d0818e:	4626      	mov	r6, r4
c0d08190:	4056      	eors	r6, r2
c0d08192:	462f      	mov	r7, r5
c0d08194:	405f      	eors	r7, r3
c0d08196:	4337      	orrs	r7, r6
c0d08198:	2f00      	cmp	r7, #0
c0d0819a:	d11e      	bne.n	c0d081da <gt256+0x56>
c0d0819c:	688b      	ldr	r3, [r1, #8]
c0d0819e:	68ca      	ldr	r2, [r1, #12]
c0d081a0:	6885      	ldr	r5, [r0, #8]
c0d081a2:	68c4      	ldr	r4, [r0, #12]
c0d081a4:	4626      	mov	r6, r4
c0d081a6:	4056      	eors	r6, r2
c0d081a8:	462f      	mov	r7, r5
c0d081aa:	405f      	eors	r7, r3
c0d081ac:	4337      	orrs	r7, r6
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
c0d081ae:	2f00      	cmp	r7, #0
c0d081b0:	d113      	bne.n	c0d081da <gt256+0x56>
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d081b2:	690b      	ldr	r3, [r1, #16]
c0d081b4:	694a      	ldr	r2, [r1, #20]
c0d081b6:	6905      	ldr	r5, [r0, #16]
c0d081b8:	6944      	ldr	r4, [r0, #20]
c0d081ba:	4626      	mov	r6, r4
c0d081bc:	4056      	eors	r6, r2
c0d081be:	462f      	mov	r7, r5
c0d081c0:	405f      	eors	r7, r3
c0d081c2:	4337      	orrs	r7, r6
c0d081c4:	2f00      	cmp	r7, #0
c0d081c6:	d108      	bne.n	c0d081da <gt256+0x56>
        return (LOWER_P(number1) > LOWER_P(number2));
c0d081c8:	6982      	ldr	r2, [r0, #24]
c0d081ca:	69c0      	ldr	r0, [r0, #28]
c0d081cc:	698b      	ldr	r3, [r1, #24]
c0d081ce:	69c9      	ldr	r1, [r1, #28]
c0d081d0:	1a9a      	subs	r2, r3, r2
c0d081d2:	4181      	sbcs	r1, r0
c0d081d4:	d204      	bcs.n	c0d081e0 <gt256+0x5c>
c0d081d6:	2001      	movs	r0, #1
}
c0d081d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d081da:	1b58      	subs	r0, r3, r5
c0d081dc:	41a2      	sbcs	r2, r4
c0d081de:	d3fa      	bcc.n	c0d081d6 <gt256+0x52>
c0d081e0:	2000      	movs	r0, #0
c0d081e2:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d081e4 <gte256>:
bool gte256(uint256_t *number1, uint256_t *number2) {
c0d081e4:	b570      	push	{r4, r5, r6, lr}
c0d081e6:	460d      	mov	r5, r1
c0d081e8:	4604      	mov	r4, r0
    return gt256(number1, number2) || equal256(number1, number2);
c0d081ea:	f7ff ffcb 	bl	c0d08184 <gt256>
c0d081ee:	2800      	cmp	r0, #0
c0d081f0:	d001      	beq.n	c0d081f6 <gte256+0x12>
c0d081f2:	2001      	movs	r0, #1
c0d081f4:	bd70      	pop	{r4, r5, r6, pc}
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0d081f6:	cd03      	ldmia	r5!, {r0, r1}
c0d081f8:	cc0c      	ldmia	r4!, {r2, r3}
c0d081fa:	404b      	eors	r3, r1
c0d081fc:	4042      	eors	r2, r0
c0d081fe:	431a      	orrs	r2, r3
c0d08200:	2000      	movs	r0, #0
c0d08202:	3c08      	subs	r4, #8
c0d08204:	3d08      	subs	r5, #8
c0d08206:	2a00      	cmp	r2, #0
c0d08208:	d11a      	bne.n	c0d08240 <gte256+0x5c>
c0d0820a:	68a9      	ldr	r1, [r5, #8]
c0d0820c:	68ea      	ldr	r2, [r5, #12]
c0d0820e:	68a3      	ldr	r3, [r4, #8]
c0d08210:	68e6      	ldr	r6, [r4, #12]
c0d08212:	4056      	eors	r6, r2
c0d08214:	404b      	eors	r3, r1
c0d08216:	4333      	orrs	r3, r6
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
c0d08218:	2b00      	cmp	r3, #0
c0d0821a:	d111      	bne.n	c0d08240 <gte256+0x5c>
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0d0821c:	6929      	ldr	r1, [r5, #16]
c0d0821e:	696a      	ldr	r2, [r5, #20]
c0d08220:	6923      	ldr	r3, [r4, #16]
c0d08222:	6966      	ldr	r6, [r4, #20]
c0d08224:	4056      	eors	r6, r2
c0d08226:	404b      	eors	r3, r1
c0d08228:	4333      	orrs	r3, r6
c0d0822a:	2b00      	cmp	r3, #0
c0d0822c:	d108      	bne.n	c0d08240 <gte256+0x5c>
c0d0822e:	69a8      	ldr	r0, [r5, #24]
c0d08230:	69e9      	ldr	r1, [r5, #28]
c0d08232:	69a2      	ldr	r2, [r4, #24]
c0d08234:	69e3      	ldr	r3, [r4, #28]
c0d08236:	404b      	eors	r3, r1
c0d08238:	4042      	eors	r2, r0
c0d0823a:	431a      	orrs	r2, r3
c0d0823c:	4250      	negs	r0, r2
c0d0823e:	4150      	adcs	r0, r2
    return gt256(number1, number2) || equal256(number1, number2);
c0d08240:	bd70      	pop	{r4, r5, r6, pc}

c0d08242 <minus256>:
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
}

void minus256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0d08242:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08244:	b090      	sub	sp, #64	; 0x40
c0d08246:	920e      	str	r2, [sp, #56]	; 0x38
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d08248:	684c      	ldr	r4, [r1, #4]
c0d0824a:	6843      	ldr	r3, [r0, #4]
c0d0824c:	680a      	ldr	r2, [r1, #0]
c0d0824e:	6805      	ldr	r5, [r0, #0]
c0d08250:	1aaa      	subs	r2, r5, r2
c0d08252:	41a3      	sbcs	r3, r4
c0d08254:	2400      	movs	r4, #0
c0d08256:	920f      	str	r2, [sp, #60]	; 0x3c
c0d08258:	1e52      	subs	r2, r2, #1
c0d0825a:	920c      	str	r2, [sp, #48]	; 0x30
c0d0825c:	461a      	mov	r2, r3
c0d0825e:	940a      	str	r4, [sp, #40]	; 0x28
c0d08260:	41a2      	sbcs	r2, r4
c0d08262:	920d      	str	r2, [sp, #52]	; 0x34
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d08264:	68cc      	ldr	r4, [r1, #12]
c0d08266:	68c6      	ldr	r6, [r0, #12]
c0d08268:	688f      	ldr	r7, [r1, #8]
c0d0826a:	6882      	ldr	r2, [r0, #8]
c0d0826c:	2501      	movs	r5, #1
c0d0826e:	1bd2      	subs	r2, r2, r7
c0d08270:	41a6      	sbcs	r6, r4
c0d08272:	462c      	mov	r4, r5
c0d08274:	d300      	bcc.n	c0d08278 <minus256+0x36>
c0d08276:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d08278:	2c00      	cmp	r4, #0
c0d0827a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0d0827c:	d100      	bne.n	c0d08280 <minus256+0x3e>
c0d0827e:	461a      	mov	r2, r3
c0d08280:	9509      	str	r5, [sp, #36]	; 0x24
c0d08282:	9e0e      	ldr	r6, [sp, #56]	; 0x38
c0d08284:	920d      	str	r2, [sp, #52]	; 0x34
c0d08286:	6072      	str	r2, [r6, #4]
c0d08288:	2c00      	cmp	r4, #0
c0d0828a:	d101      	bne.n	c0d08290 <minus256+0x4e>
c0d0828c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d0828e:	920c      	str	r2, [sp, #48]	; 0x30
c0d08290:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0d08292:	6032      	str	r2, [r6, #0]
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d08294:	68ca      	ldr	r2, [r1, #12]
c0d08296:	68c7      	ldr	r7, [r0, #12]
c0d08298:	688b      	ldr	r3, [r1, #8]
c0d0829a:	6884      	ldr	r4, [r0, #8]
c0d0829c:	1ae3      	subs	r3, r4, r3
c0d0829e:	9306      	str	r3, [sp, #24]
c0d082a0:	60b3      	str	r3, [r6, #8]
c0d082a2:	4197      	sbcs	r7, r2
c0d082a4:	9707      	str	r7, [sp, #28]
c0d082a6:	60f7      	str	r7, [r6, #12]
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d082a8:	694c      	ldr	r4, [r1, #20]
c0d082aa:	6942      	ldr	r2, [r0, #20]
c0d082ac:	690b      	ldr	r3, [r1, #16]
c0d082ae:	6905      	ldr	r5, [r0, #16]
c0d082b0:	9508      	str	r5, [sp, #32]
c0d082b2:	1aef      	subs	r7, r5, r3
c0d082b4:	9200      	str	r2, [sp, #0]
c0d082b6:	41a2      	sbcs	r2, r4
c0d082b8:	970f      	str	r7, [sp, #60]	; 0x3c
c0d082ba:	1e7b      	subs	r3, r7, #1
c0d082bc:	930b      	str	r3, [sp, #44]	; 0x2c
c0d082be:	9201      	str	r2, [sp, #4]
c0d082c0:	4617      	mov	r7, r2
c0d082c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
c0d082c4:	419f      	sbcs	r7, r3
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d082c6:	69ca      	ldr	r2, [r1, #28]
c0d082c8:	69c5      	ldr	r5, [r0, #28]
c0d082ca:	698c      	ldr	r4, [r1, #24]
c0d082cc:	6986      	ldr	r6, [r0, #24]
c0d082ce:	9403      	str	r4, [sp, #12]
c0d082d0:	9602      	str	r6, [sp, #8]
c0d082d2:	1b34      	subs	r4, r6, r4
c0d082d4:	9504      	str	r5, [sp, #16]
c0d082d6:	9205      	str	r2, [sp, #20]
c0d082d8:	4195      	sbcs	r5, r2
c0d082da:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0d082dc:	d300      	bcc.n	c0d082e0 <minus256+0x9e>
c0d082de:	461a      	mov	r2, r3
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d082e0:	2a00      	cmp	r2, #0
c0d082e2:	d101      	bne.n	c0d082e8 <minus256+0xa6>
c0d082e4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0d082e6:	930b      	str	r3, [sp, #44]	; 0x2c
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d082e8:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
c0d082ea:	9b08      	ldr	r3, [sp, #32]
c0d082ec:	405c      	eors	r4, r3
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d082ee:	2a00      	cmp	r2, #0
c0d082f0:	9a02      	ldr	r2, [sp, #8]
c0d082f2:	9b01      	ldr	r3, [sp, #4]
c0d082f4:	9e00      	ldr	r6, [sp, #0]
c0d082f6:	d100      	bne.n	c0d082fa <minus256+0xb8>
c0d082f8:	461f      	mov	r7, r3
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d082fa:	463d      	mov	r5, r7
c0d082fc:	4075      	eors	r5, r6
c0d082fe:	432c      	orrs	r4, r5
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d08300:	460d      	mov	r5, r1
c0d08302:	3518      	adds	r5, #24
c0d08304:	950a      	str	r5, [sp, #40]	; 0x28
c0d08306:	4605      	mov	r5, r0
c0d08308:	3518      	adds	r5, #24
c0d0830a:	9509      	str	r5, [sp, #36]	; 0x24
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d0830c:	2c00      	cmp	r4, #0
c0d0830e:	d109      	bne.n	c0d08324 <minus256+0xe2>
c0d08310:	9c03      	ldr	r4, [sp, #12]
c0d08312:	4615      	mov	r5, r2
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d08314:	1b12      	subs	r2, r2, r4
c0d08316:	9e04      	ldr	r6, [sp, #16]
c0d08318:	4632      	mov	r2, r6
c0d0831a:	9f05      	ldr	r7, [sp, #20]
c0d0831c:	41ba      	sbcs	r2, r7
c0d0831e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    uint128_t tmp;
    minus128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    minus128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
    if (gt128(&tmp, &LOWER_P(number1))) {
c0d08320:	d30a      	bcc.n	c0d08338 <minus256+0xf6>
c0d08322:	e02e      	b.n	c0d08382 <minus256+0x140>
c0d08324:	4615      	mov	r5, r2
    return (UPPER_P(number1) > UPPER_P(number2));
c0d08326:	9a08      	ldr	r2, [sp, #32]
c0d08328:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
c0d0832a:	1b12      	subs	r2, r2, r4
c0d0832c:	41be      	sbcs	r6, r7
c0d0832e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d08330:	9f05      	ldr	r7, [sp, #20]
c0d08332:	9e04      	ldr	r6, [sp, #16]
c0d08334:	9c03      	ldr	r4, [sp, #12]
    if (gt128(&tmp, &LOWER_P(number1))) {
c0d08336:	d224      	bcs.n	c0d08382 <minus256+0x140>
c0d08338:	2500      	movs	r5, #0
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d0833a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0d0833c:	1e53      	subs	r3, r2, #1
c0d0833e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0d08340:	4616      	mov	r6, r2
c0d08342:	41ae      	sbcs	r6, r5
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d08344:	9c06      	ldr	r4, [sp, #24]
c0d08346:	9f07      	ldr	r7, [sp, #28]
c0d08348:	433c      	orrs	r4, r7
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d0834a:	2c00      	cmp	r4, #0
c0d0834c:	d000      	beq.n	c0d08350 <minus256+0x10e>
c0d0834e:	4616      	mov	r6, r2
c0d08350:	3110      	adds	r1, #16
c0d08352:	3010      	adds	r0, #16
c0d08354:	9f0e      	ldr	r7, [sp, #56]	; 0x38
c0d08356:	463a      	mov	r2, r7
c0d08358:	3208      	adds	r2, #8
c0d0835a:	607e      	str	r6, [r7, #4]
c0d0835c:	2c00      	cmp	r4, #0
c0d0835e:	d000      	beq.n	c0d08362 <minus256+0x120>
c0d08360:	9b0c      	ldr	r3, [sp, #48]	; 0x30
c0d08362:	603b      	str	r3, [r7, #0]
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d08364:	9b06      	ldr	r3, [sp, #24]
c0d08366:	1e5b      	subs	r3, r3, #1
c0d08368:	9c07      	ldr	r4, [sp, #28]
c0d0836a:	41ac      	sbcs	r4, r5
c0d0836c:	c218      	stmia	r2!, {r3, r4}
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d0836e:	680a      	ldr	r2, [r1, #0]
c0d08370:	6849      	ldr	r1, [r1, #4]
c0d08372:	6804      	ldr	r4, [r0, #0]
c0d08374:	6843      	ldr	r3, [r0, #4]
c0d08376:	1aa2      	subs	r2, r4, r2
c0d08378:	418b      	sbcs	r3, r1
c0d0837a:	980a      	ldr	r0, [sp, #40]	; 0x28
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d0837c:	c890      	ldmia	r0!, {r4, r7}
c0d0837e:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d08380:	c860      	ldmia	r0!, {r5, r6}
c0d08382:	2100      	movs	r1, #0
c0d08384:	920f      	str	r2, [sp, #60]	; 0x3c
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d08386:	1e50      	subs	r0, r2, #1
c0d08388:	461a      	mov	r2, r3
c0d0838a:	418a      	sbcs	r2, r1
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d0838c:	1b2c      	subs	r4, r5, r4
c0d0838e:	41be      	sbcs	r6, r7
c0d08390:	9c0e      	ldr	r4, [sp, #56]	; 0x38
c0d08392:	d200      	bcs.n	c0d08396 <minus256+0x154>
c0d08394:	2101      	movs	r1, #1
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d08396:	2900      	cmp	r1, #0
c0d08398:	d100      	bne.n	c0d0839c <minus256+0x15a>
c0d0839a:	461a      	mov	r2, r3
c0d0839c:	6162      	str	r2, [r4, #20]
c0d0839e:	2900      	cmp	r1, #0
c0d083a0:	d100      	bne.n	c0d083a4 <minus256+0x162>
c0d083a2:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0d083a4:	6120      	str	r0, [r4, #16]
c0d083a6:	990a      	ldr	r1, [sp, #40]	; 0x28
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d083a8:	c903      	ldmia	r1, {r0, r1}
c0d083aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0d083ac:	cb0c      	ldmia	r3, {r2, r3}
c0d083ae:	1a10      	subs	r0, r2, r0
c0d083b0:	61a0      	str	r0, [r4, #24]
c0d083b2:	418b      	sbcs	r3, r1
c0d083b4:	61e3      	str	r3, [r4, #28]
        UPPER(one) = 0;
        LOWER(one) = 1;
        minus128(&UPPER_P(target), &one, &UPPER_P(target));
    }
    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}
c0d083b6:	b010      	add	sp, #64	; 0x40
c0d083b8:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d083ba <write_u64_be>:
    buffer[2] = ((value >> 40) & 0xff);
    buffer[3] = ((value >> 32) & 0xff);
    buffer[4] = ((value >> 24) & 0xff);
    buffer[5] = ((value >> 16) & 0xff);
    buffer[6] = ((value >> 8) & 0xff);
    buffer[7] = (value & 0xff);
c0d083ba:	71c2      	strb	r2, [r0, #7]
    buffer[3] = ((value >> 32) & 0xff);
c0d083bc:	70c3      	strb	r3, [r0, #3]
    buffer[6] = ((value >> 8) & 0xff);
c0d083be:	0a11      	lsrs	r1, r2, #8
c0d083c0:	7181      	strb	r1, [r0, #6]
    buffer[5] = ((value >> 16) & 0xff);
c0d083c2:	0c11      	lsrs	r1, r2, #16
c0d083c4:	7141      	strb	r1, [r0, #5]
    buffer[4] = ((value >> 24) & 0xff);
c0d083c6:	0e11      	lsrs	r1, r2, #24
c0d083c8:	7101      	strb	r1, [r0, #4]
    buffer[2] = ((value >> 40) & 0xff);
c0d083ca:	0a19      	lsrs	r1, r3, #8
c0d083cc:	7081      	strb	r1, [r0, #2]
    buffer[1] = ((value >> 48) & 0xff);
c0d083ce:	0c19      	lsrs	r1, r3, #16
c0d083d0:	7041      	strb	r1, [r0, #1]
    buffer[0] = ((value >> 56) & 0xff);
c0d083d2:	0e19      	lsrs	r1, r3, #24
c0d083d4:	7001      	strb	r1, [r0, #0]
}
c0d083d6:	4770      	bx	lr

c0d083d8 <mul256>:
    *out_ptr++ = in[2];
    *out_ptr++ = in[1];
    *out_ptr = in[0];
}

void mul256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0d083d8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d083da:	b0a5      	sub	sp, #148	; 0x94
c0d083dc:	9201      	str	r2, [sp, #4]
c0d083de:	9103      	str	r1, [sp, #12]
c0d083e0:	9002      	str	r0, [sp, #8]
c0d083e2:	a805      	add	r0, sp, #20
c0d083e4:	2140      	movs	r1, #64	; 0x40
c0d083e6:	9100      	str	r1, [sp, #0]
    uint8_t num1[32], num2[32], result[64];
    memset(&result, 0, sizeof(result));
c0d083e8:	f002 f940 	bl	c0d0a66c <__aeabi_memclr>
c0d083ec:	2600      	movs	r6, #0
c0d083ee:	ac15      	add	r4, sp, #84	; 0x54
c0d083f0:	ad1d      	add	r5, sp, #116	; 0x74
c0d083f2:	9404      	str	r4, [sp, #16]
    for (uint8_t i = 0; i < 4; i++) {
        write_u64_be(num1 + i * sizeof(uint64_t), number1->elements[i / 2].elements[i % 2]);
c0d083f4:	00f4      	lsls	r4, r6, #3
c0d083f6:	2008      	movs	r0, #8
c0d083f8:	4627      	mov	r7, r4
c0d083fa:	4007      	ands	r7, r0
c0d083fc:	4384      	bics	r4, r0
c0d083fe:	9802      	ldr	r0, [sp, #8]
c0d08400:	1900      	adds	r0, r0, r4
c0d08402:	59c2      	ldr	r2, [r0, r7]
c0d08404:	19c0      	adds	r0, r0, r7
c0d08406:	6843      	ldr	r3, [r0, #4]
c0d08408:	4628      	mov	r0, r5
c0d0840a:	f7ff ffd6 	bl	c0d083ba <write_u64_be>
        write_u64_be(num2 + i * sizeof(uint64_t), number2->elements[i / 2].elements[i % 2]);
c0d0840e:	9803      	ldr	r0, [sp, #12]
c0d08410:	1900      	adds	r0, r0, r4
c0d08412:	9c04      	ldr	r4, [sp, #16]
c0d08414:	59c2      	ldr	r2, [r0, r7]
c0d08416:	19c0      	adds	r0, r0, r7
c0d08418:	6843      	ldr	r3, [r0, #4]
c0d0841a:	4620      	mov	r0, r4
c0d0841c:	f7ff ffcd 	bl	c0d083ba <write_u64_be>
    for (uint8_t i = 0; i < 4; i++) {
c0d08420:	3508      	adds	r5, #8
c0d08422:	3408      	adds	r4, #8
c0d08424:	1c76      	adds	r6, r6, #1
c0d08426:	2e04      	cmp	r6, #4
c0d08428:	d1e3      	bne.n	c0d083f2 <mul256+0x1a>
c0d0842a:	a805      	add	r0, sp, #20
c0d0842c:	a91d      	add	r1, sp, #116	; 0x74
c0d0842e:	aa15      	add	r2, sp, #84	; 0x54
c0d08430:	2320      	movs	r3, #32
    }
    cx_math_mult(result, num1, num2, sizeof(num1));
c0d08432:	f7fe fadf 	bl	c0d069f4 <cx_math_mult>
c0d08436:	201f      	movs	r0, #31
c0d08438:	43c0      	mvns	r0, r0
c0d0843a:	2100      	movs	r1, #0
c0d0843c:	9e01      	ldr	r6, [sp, #4]
c0d0843e:	9f00      	ldr	r7, [sp, #0]
c0d08440:	aa05      	add	r2, sp, #20
    for (uint8_t i = 0; i < 4; i++) {
        read_u64_be(result + 32 + i * sizeof(uint64_t), &target->elements[i / 2].elements[i % 2]);
c0d08442:	1812      	adds	r2, r2, r0
c0d08444:	2347      	movs	r3, #71	; 0x47
    *out_ptr++ = in[7];
c0d08446:	5cd3      	ldrb	r3, [r2, r3]
        read_u64_be(result + 32 + i * sizeof(uint64_t), &target->elements[i / 2].elements[i % 2]);
c0d08448:	084c      	lsrs	r4, r1, #1
c0d0844a:	0124      	lsls	r4, r4, #4
c0d0844c:	1934      	adds	r4, r6, r4
c0d0844e:	2501      	movs	r5, #1
c0d08450:	400d      	ands	r5, r1
c0d08452:	00ed      	lsls	r5, r5, #3
    *out_ptr++ = in[7];
c0d08454:	5563      	strb	r3, [r4, r5]
        read_u64_be(result + 32 + i * sizeof(uint64_t), &target->elements[i / 2].elements[i % 2]);
c0d08456:	1963      	adds	r3, r4, r5
c0d08458:	2446      	movs	r4, #70	; 0x46
    *out_ptr++ = in[6];
c0d0845a:	5d14      	ldrb	r4, [r2, r4]
c0d0845c:	705c      	strb	r4, [r3, #1]
c0d0845e:	2445      	movs	r4, #69	; 0x45
    *out_ptr++ = in[5];
c0d08460:	5d14      	ldrb	r4, [r2, r4]
c0d08462:	709c      	strb	r4, [r3, #2]
c0d08464:	2444      	movs	r4, #68	; 0x44
    *out_ptr++ = in[4];
c0d08466:	5d14      	ldrb	r4, [r2, r4]
c0d08468:	70dc      	strb	r4, [r3, #3]
c0d0846a:	2443      	movs	r4, #67	; 0x43
    *out_ptr++ = in[3];
c0d0846c:	5d14      	ldrb	r4, [r2, r4]
c0d0846e:	711c      	strb	r4, [r3, #4]
c0d08470:	2442      	movs	r4, #66	; 0x42
    *out_ptr++ = in[2];
c0d08472:	5d14      	ldrb	r4, [r2, r4]
c0d08474:	715c      	strb	r4, [r3, #5]
c0d08476:	2441      	movs	r4, #65	; 0x41
    *out_ptr++ = in[1];
c0d08478:	5d14      	ldrb	r4, [r2, r4]
c0d0847a:	719c      	strb	r4, [r3, #6]
    *out_ptr = in[0];
c0d0847c:	5dd2      	ldrb	r2, [r2, r7]
c0d0847e:	71da      	strb	r2, [r3, #7]
    for (uint8_t i = 0; i < 4; i++) {
c0d08480:	3008      	adds	r0, #8
c0d08482:	1c49      	adds	r1, r1, #1
c0d08484:	2800      	cmp	r0, #0
c0d08486:	d1db      	bne.n	c0d08440 <mul256+0x68>
    }
}
c0d08488:	b025      	add	sp, #148	; 0x94
c0d0848a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d0848c <divmod256>:
        copy128(retDiv, &resDiv);
        copy128(retMod, &resMod);
    }
}

void divmod256(uint256_t *l, uint256_t *r, uint256_t *retDiv, uint256_t *retMod) {
c0d0848c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0848e:	b0b5      	sub	sp, #212	; 0xd4
c0d08490:	9306      	str	r3, [sp, #24]
c0d08492:	9205      	str	r2, [sp, #20]
c0d08494:	460c      	mov	r4, r1
c0d08496:	9113      	str	r1, [sp, #76]	; 0x4c
c0d08498:	4607      	mov	r7, r0
c0d0849a:	a814      	add	r0, sp, #80	; 0x50
c0d0849c:	2118      	movs	r1, #24
    uint256_t copyd, adder, resDiv, resMod;
    uint256_t one;
    clear256(&one);
    UPPER(LOWER(one)) = 0;
c0d0849e:	f002 f8e5 	bl	c0d0a66c <__aeabi_memclr>
c0d084a2:	2000      	movs	r0, #0
c0d084a4:	9012      	str	r0, [sp, #72]	; 0x48
    LOWER(LOWER(one)) = 1;
c0d084a6:	901b      	str	r0, [sp, #108]	; 0x6c
c0d084a8:	2001      	movs	r0, #1
c0d084aa:	901a      	str	r0, [sp, #104]	; 0x68
    uint32_t diffBits = bits256(l) - bits256(r);
c0d084ac:	4638      	mov	r0, r7
c0d084ae:	f7ff fe27 	bl	c0d08100 <bits256>
c0d084b2:	9011      	str	r0, [sp, #68]	; 0x44
c0d084b4:	4620      	mov	r0, r4
c0d084b6:	f7ff fe23 	bl	c0d08100 <bits256>
c0d084ba:	9010      	str	r0, [sp, #64]	; 0x40
    UPPER_P(target) = UPPER_P(number);
c0d084bc:	683c      	ldr	r4, [r7, #0]
c0d084be:	6879      	ldr	r1, [r7, #4]
    LOWER_P(target) = LOWER_P(number);
c0d084c0:	68b8      	ldr	r0, [r7, #8]
c0d084c2:	900a      	str	r0, [sp, #40]	; 0x28
c0d084c4:	68fb      	ldr	r3, [r7, #12]
    UPPER_P(target) = UPPER_P(number);
c0d084c6:	693d      	ldr	r5, [r7, #16]
c0d084c8:	6978      	ldr	r0, [r7, #20]
    LOWER_P(target) = LOWER_P(number);
c0d084ca:	69be      	ldr	r6, [r7, #24]
c0d084cc:	69fa      	ldr	r2, [r7, #28]
c0d084ce:	9209      	str	r2, [sp, #36]	; 0x24
c0d084d0:	9108      	str	r1, [sp, #32]
    UPPER_P(target) = UPPER_P(number);
c0d084d2:	911d      	str	r1, [sp, #116]	; 0x74
c0d084d4:	9407      	str	r4, [sp, #28]
c0d084d6:	941c      	str	r4, [sp, #112]	; 0x70
c0d084d8:	9304      	str	r3, [sp, #16]
    LOWER_P(target) = LOWER_P(number);
c0d084da:	931f      	str	r3, [sp, #124]	; 0x7c
c0d084dc:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d084de:	911e      	str	r1, [sp, #120]	; 0x78
c0d084e0:	9002      	str	r0, [sp, #8]
    UPPER_P(target) = UPPER_P(number);
c0d084e2:	9021      	str	r0, [sp, #132]	; 0x84
c0d084e4:	9503      	str	r5, [sp, #12]
c0d084e6:	9520      	str	r5, [sp, #128]	; 0x80
c0d084e8:	9809      	ldr	r0, [sp, #36]	; 0x24
    LOWER_P(target) = LOWER_P(number);
c0d084ea:	9023      	str	r0, [sp, #140]	; 0x8c
c0d084ec:	9601      	str	r6, [sp, #4]
c0d084ee:	9622      	str	r6, [sp, #136]	; 0x88
    clear256(&resDiv);
    copy256(&resMod, l);
    if (gt256(r, l)) {
c0d084f0:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d084f2:	4639      	mov	r1, r7
c0d084f4:	f7ff fe46 	bl	c0d08184 <gt256>
c0d084f8:	a91c      	add	r1, sp, #112	; 0x70
c0d084fa:	aa24      	add	r2, sp, #144	; 0x90
c0d084fc:	2800      	cmp	r0, #0
c0d084fe:	d019      	beq.n	c0d08534 <divmod256+0xa8>
c0d08500:	4638      	mov	r0, r7
c0d08502:	3018      	adds	r0, #24
c0d08504:	4639      	mov	r1, r7
c0d08506:	3110      	adds	r1, #16
c0d08508:	3708      	adds	r7, #8
    UPPER_P(target) = UPPER_P(number);
c0d0850a:	9a07      	ldr	r2, [sp, #28]
c0d0850c:	9c06      	ldr	r4, [sp, #24]
c0d0850e:	6022      	str	r2, [r4, #0]
c0d08510:	9a08      	ldr	r2, [sp, #32]
c0d08512:	6062      	str	r2, [r4, #4]
    LOWER_P(target) = LOWER_P(number);
c0d08514:	cf0c      	ldmia	r7!, {r2, r3}
c0d08516:	60e3      	str	r3, [r4, #12]
c0d08518:	60a2      	str	r2, [r4, #8]
    UPPER_P(target) = UPPER_P(number);
c0d0851a:	680a      	ldr	r2, [r1, #0]
c0d0851c:	6849      	ldr	r1, [r1, #4]
c0d0851e:	6161      	str	r1, [r4, #20]
c0d08520:	6122      	str	r2, [r4, #16]
    LOWER_P(target) = LOWER_P(number);
c0d08522:	6801      	ldr	r1, [r0, #0]
c0d08524:	6840      	ldr	r0, [r0, #4]
c0d08526:	61e0      	str	r0, [r4, #28]
c0d08528:	61a1      	str	r1, [r4, #24]
c0d0852a:	2120      	movs	r1, #32
    LOWER_P(target) = 0;
c0d0852c:	9805      	ldr	r0, [sp, #20]
c0d0852e:	f002 f89d 	bl	c0d0a66c <__aeabi_memclr>
c0d08532:	e0dc      	b.n	c0d086ee <divmod256+0x262>
c0d08534:	920b      	str	r2, [sp, #44]	; 0x2c
c0d08536:	9100      	str	r1, [sp, #0]
c0d08538:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d0853a:	9910      	ldr	r1, [sp, #64]	; 0x40
c0d0853c:	1a45      	subs	r5, r0, r1
c0d0853e:	aa2c      	add	r2, sp, #176	; 0xb0
c0d08540:	9f13      	ldr	r7, [sp, #76]	; 0x4c
        copy256(retMod, l);
        clear256(retDiv);
    } else {
        shiftl256(r, diffBits, &copyd);
c0d08542:	4638      	mov	r0, r7
c0d08544:	4629      	mov	r1, r5
c0d08546:	f7ff fc89 	bl	c0d07e5c <shiftl256>
c0d0854a:	a814      	add	r0, sp, #80	; 0x50
c0d0854c:	aa24      	add	r2, sp, #144	; 0x90
        shiftl256(&one, diffBits, &adder);
c0d0854e:	4629      	mov	r1, r5
c0d08550:	f7ff fc84 	bl	c0d07e5c <shiftl256>
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0d08554:	982d      	ldr	r0, [sp, #180]	; 0xb4
c0d08556:	4602      	mov	r2, r0
c0d08558:	9d08      	ldr	r5, [sp, #32]
c0d0855a:	406a      	eors	r2, r5
c0d0855c:	992c      	ldr	r1, [sp, #176]	; 0xb0
c0d0855e:	460b      	mov	r3, r1
c0d08560:	9c07      	ldr	r4, [sp, #28]
c0d08562:	4063      	eors	r3, r4
c0d08564:	4313      	orrs	r3, r2
c0d08566:	2b00      	cmp	r3, #0
c0d08568:	d11e      	bne.n	c0d085a8 <divmod256+0x11c>
c0d0856a:	982e      	ldr	r0, [sp, #184]	; 0xb8
c0d0856c:	4602      	mov	r2, r0
c0d0856e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
c0d08570:	4072      	eors	r2, r6
c0d08572:	992f      	ldr	r1, [sp, #188]	; 0xbc
c0d08574:	460b      	mov	r3, r1
c0d08576:	9f04      	ldr	r7, [sp, #16]
c0d08578:	407b      	eors	r3, r7
c0d0857a:	4313      	orrs	r3, r2
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
c0d0857c:	2b00      	cmp	r3, #0
c0d0857e:	d000      	beq.n	c0d08582 <divmod256+0xf6>
c0d08580:	e0b7      	b.n	c0d086f2 <divmod256+0x266>
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d08582:	9830      	ldr	r0, [sp, #192]	; 0xc0
c0d08584:	4602      	mov	r2, r0
c0d08586:	9e03      	ldr	r6, [sp, #12]
c0d08588:	4072      	eors	r2, r6
c0d0858a:	9931      	ldr	r1, [sp, #196]	; 0xc4
c0d0858c:	460b      	mov	r3, r1
c0d0858e:	9f02      	ldr	r7, [sp, #8]
c0d08590:	407b      	eors	r3, r7
c0d08592:	4313      	orrs	r3, r2
c0d08594:	2b00      	cmp	r3, #0
c0d08596:	d000      	beq.n	c0d0859a <divmod256+0x10e>
c0d08598:	e0af      	b.n	c0d086fa <divmod256+0x26e>
        return (LOWER_P(number1) > LOWER_P(number2));
c0d0859a:	9833      	ldr	r0, [sp, #204]	; 0xcc
c0d0859c:	9932      	ldr	r1, [sp, #200]	; 0xc8
c0d0859e:	9a01      	ldr	r2, [sp, #4]
c0d085a0:	1a51      	subs	r1, r2, r1
c0d085a2:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d085a4:	4181      	sbcs	r1, r0
c0d085a6:	e0aa      	b.n	c0d086fe <divmod256+0x272>
    return (UPPER_P(number1) > UPPER_P(number2));
c0d085a8:	1a61      	subs	r1, r4, r1
c0d085aa:	4629      	mov	r1, r5
c0d085ac:	4181      	sbcs	r1, r0
        if (gt256(&copyd, &resMod)) {
c0d085ae:	d20a      	bcs.n	c0d085c6 <divmod256+0x13a>
c0d085b0:	2401      	movs	r4, #1
c0d085b2:	a82c      	add	r0, sp, #176	; 0xb0
            shiftr256(&copyd, 1, &copyd);
c0d085b4:	4621      	mov	r1, r4
c0d085b6:	4602      	mov	r2, r0
c0d085b8:	f7ff fd22 	bl	c0d08000 <shiftr256>
c0d085bc:	a824      	add	r0, sp, #144	; 0x90
            shiftr256(&adder, 1, &adder);
c0d085be:	4621      	mov	r1, r4
c0d085c0:	4602      	mov	r2, r0
c0d085c2:	f7ff fd1d 	bl	c0d08000 <shiftr256>
c0d085c6:	a81c      	add	r0, sp, #112	; 0x70
        }
        while (gte256(&resMod, r)) {
c0d085c8:	4639      	mov	r1, r7
c0d085ca:	f7ff fe0b 	bl	c0d081e4 <gte256>
c0d085ce:	2800      	cmp	r0, #0
c0d085d0:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d085d2:	4605      	mov	r5, r0
c0d085d4:	4606      	mov	r6, r0
c0d085d6:	4604      	mov	r4, r0
c0d085d8:	9010      	str	r0, [sp, #64]	; 0x40
c0d085da:	900f      	str	r0, [sp, #60]	; 0x3c
c0d085dc:	4607      	mov	r7, r0
c0d085de:	9011      	str	r0, [sp, #68]	; 0x44
c0d085e0:	9905      	ldr	r1, [sp, #20]
c0d085e2:	9a06      	ldr	r2, [sp, #24]
c0d085e4:	d06a      	beq.n	c0d086bc <divmod256+0x230>
c0d085e6:	9800      	ldr	r0, [sp, #0]
c0d085e8:	4601      	mov	r1, r0
c0d085ea:	3118      	adds	r1, #24
c0d085ec:	9109      	str	r1, [sp, #36]	; 0x24
c0d085ee:	4601      	mov	r1, r0
c0d085f0:	3110      	adds	r1, #16
c0d085f2:	910a      	str	r1, [sp, #40]	; 0x28
c0d085f4:	3008      	adds	r0, #8
c0d085f6:	9000      	str	r0, [sp, #0]
c0d085f8:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d085fa:	4605      	mov	r5, r0
c0d085fc:	3508      	adds	r5, #8
c0d085fe:	4606      	mov	r6, r0
c0d08600:	3610      	adds	r6, #16
c0d08602:	3018      	adds	r0, #24
c0d08604:	900b      	str	r0, [sp, #44]	; 0x2c
c0d08606:	2700      	movs	r7, #0
c0d08608:	9711      	str	r7, [sp, #68]	; 0x44
c0d0860a:	9710      	str	r7, [sp, #64]	; 0x40
c0d0860c:	970f      	str	r7, [sp, #60]	; 0x3c
c0d0860e:	970e      	str	r7, [sp, #56]	; 0x38
c0d08610:	970d      	str	r7, [sp, #52]	; 0x34
c0d08612:	9712      	str	r7, [sp, #72]	; 0x48
c0d08614:	970c      	str	r7, [sp, #48]	; 0x30
c0d08616:	a81c      	add	r0, sp, #112	; 0x70
c0d08618:	a92c      	add	r1, sp, #176	; 0xb0
            if (gte256(&resMod, &copyd)) {
c0d0861a:	f7ff fde3 	bl	c0d081e4 <gte256>
c0d0861e:	2800      	cmp	r0, #0
c0d08620:	d022      	beq.n	c0d08668 <divmod256+0x1dc>
c0d08622:	a92c      	add	r1, sp, #176	; 0xb0
c0d08624:	a81c      	add	r0, sp, #112	; 0x70
                minus256(&resMod, &copyd, &resMod);
c0d08626:	4602      	mov	r2, r0
c0d08628:	f7ff fe0b 	bl	c0d08242 <minus256>
c0d0862c:	990b      	ldr	r1, [sp, #44]	; 0x2c
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d0862e:	c903      	ldmia	r1, {r0, r1}
c0d08630:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d08632:	430a      	orrs	r2, r1
c0d08634:	9211      	str	r2, [sp, #68]	; 0x44
c0d08636:	4307      	orrs	r7, r0
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d08638:	ce03      	ldmia	r6!, {r0, r1}
c0d0863a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d0863c:	430a      	orrs	r2, r1
c0d0863e:	920f      	str	r2, [sp, #60]	; 0x3c
c0d08640:	9910      	ldr	r1, [sp, #64]	; 0x40
c0d08642:	4301      	orrs	r1, r0
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d08644:	9110      	str	r1, [sp, #64]	; 0x40
c0d08646:	cd03      	ldmia	r5!, {r0, r1}
c0d08648:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0d0864a:	430a      	orrs	r2, r1
c0d0864c:	920d      	str	r2, [sp, #52]	; 0x34
c0d0864e:	990e      	ldr	r1, [sp, #56]	; 0x38
c0d08650:	4301      	orrs	r1, r0
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d08652:	910e      	str	r1, [sp, #56]	; 0x38
c0d08654:	9825      	ldr	r0, [sp, #148]	; 0x94
c0d08656:	990c      	ldr	r1, [sp, #48]	; 0x30
c0d08658:	4301      	orrs	r1, r0
c0d0865a:	910c      	str	r1, [sp, #48]	; 0x30
c0d0865c:	9824      	ldr	r0, [sp, #144]	; 0x90
c0d0865e:	9912      	ldr	r1, [sp, #72]	; 0x48
c0d08660:	4301      	orrs	r1, r0
c0d08662:	9112      	str	r1, [sp, #72]	; 0x48
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d08664:	3d08      	subs	r5, #8
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d08666:	3e08      	subs	r6, #8
c0d08668:	2401      	movs	r4, #1
c0d0866a:	a82c      	add	r0, sp, #176	; 0xb0
                or256(&resDiv, &adder, &resDiv);
            }
            shiftr256(&copyd, 1, &copyd);
c0d0866c:	4621      	mov	r1, r4
c0d0866e:	4602      	mov	r2, r0
c0d08670:	f7ff fcc6 	bl	c0d08000 <shiftr256>
c0d08674:	a824      	add	r0, sp, #144	; 0x90
            shiftr256(&adder, 1, &adder);
c0d08676:	4621      	mov	r1, r4
c0d08678:	4602      	mov	r2, r0
c0d0867a:	f7ff fcc1 	bl	c0d08000 <shiftr256>
c0d0867e:	a81c      	add	r0, sp, #112	; 0x70
        while (gte256(&resMod, r)) {
c0d08680:	9913      	ldr	r1, [sp, #76]	; 0x4c
c0d08682:	f7ff fdaf 	bl	c0d081e4 <gte256>
c0d08686:	2800      	cmp	r0, #0
c0d08688:	d1c5      	bne.n	c0d08616 <divmod256+0x18a>
c0d0868a:	9809      	ldr	r0, [sp, #36]	; 0x24
    LOWER_P(target) = LOWER_P(number);
c0d0868c:	6801      	ldr	r1, [r0, #0]
c0d0868e:	9101      	str	r1, [sp, #4]
c0d08690:	6840      	ldr	r0, [r0, #4]
c0d08692:	9009      	str	r0, [sp, #36]	; 0x24
c0d08694:	990a      	ldr	r1, [sp, #40]	; 0x28
    UPPER_P(target) = UPPER_P(number);
c0d08696:	6808      	ldr	r0, [r1, #0]
c0d08698:	9003      	str	r0, [sp, #12]
c0d0869a:	6848      	ldr	r0, [r1, #4]
c0d0869c:	9002      	str	r0, [sp, #8]
c0d0869e:	9800      	ldr	r0, [sp, #0]
    LOWER_P(target) = LOWER_P(number);
c0d086a0:	6801      	ldr	r1, [r0, #0]
c0d086a2:	910a      	str	r1, [sp, #40]	; 0x28
c0d086a4:	6840      	ldr	r0, [r0, #4]
    UPPER_P(target) = UPPER_P(number);
c0d086a6:	9004      	str	r0, [sp, #16]
c0d086a8:	981d      	ldr	r0, [sp, #116]	; 0x74
c0d086aa:	9008      	str	r0, [sp, #32]
c0d086ac:	981c      	ldr	r0, [sp, #112]	; 0x70
c0d086ae:	9007      	str	r0, [sp, #28]
c0d086b0:	9a06      	ldr	r2, [sp, #24]
c0d086b2:	9905      	ldr	r1, [sp, #20]
c0d086b4:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d086b6:	9e0e      	ldr	r6, [sp, #56]	; 0x38
c0d086b8:	9c0d      	ldr	r4, [sp, #52]	; 0x34
c0d086ba:	9d0c      	ldr	r5, [sp, #48]	; 0x30
c0d086bc:	c161      	stmia	r1!, {r0, r5, r6}
    LOWER_P(target) = LOWER_P(number);
c0d086be:	600c      	str	r4, [r1, #0]
    UPPER_P(target) = UPPER_P(number);
c0d086c0:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d086c2:	6048      	str	r0, [r1, #4]
c0d086c4:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0d086c6:	6088      	str	r0, [r1, #8]
    LOWER_P(target) = LOWER_P(number);
c0d086c8:	60cf      	str	r7, [r1, #12]
c0d086ca:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d086cc:	6108      	str	r0, [r1, #16]
    UPPER_P(target) = UPPER_P(number);
c0d086ce:	9807      	ldr	r0, [sp, #28]
c0d086d0:	6010      	str	r0, [r2, #0]
c0d086d2:	9808      	ldr	r0, [sp, #32]
c0d086d4:	6050      	str	r0, [r2, #4]
    LOWER_P(target) = LOWER_P(number);
c0d086d6:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d086d8:	6090      	str	r0, [r2, #8]
c0d086da:	9804      	ldr	r0, [sp, #16]
c0d086dc:	60d0      	str	r0, [r2, #12]
    UPPER_P(target) = UPPER_P(number);
c0d086de:	9803      	ldr	r0, [sp, #12]
c0d086e0:	6110      	str	r0, [r2, #16]
c0d086e2:	9802      	ldr	r0, [sp, #8]
c0d086e4:	6150      	str	r0, [r2, #20]
    LOWER_P(target) = LOWER_P(number);
c0d086e6:	9801      	ldr	r0, [sp, #4]
c0d086e8:	6190      	str	r0, [r2, #24]
c0d086ea:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d086ec:	61d0      	str	r0, [r2, #28]
        }
        copy256(retDiv, &resDiv);
        copy256(retMod, &resMod);
    }
}
c0d086ee:	b035      	add	sp, #212	; 0xd4
c0d086f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return (LOWER_P(number1) > LOWER_P(number2));
c0d086f2:	1a30      	subs	r0, r6, r0
c0d086f4:	4638      	mov	r0, r7
c0d086f6:	4188      	sbcs	r0, r1
c0d086f8:	e001      	b.n	c0d086fe <divmod256+0x272>
    return (UPPER_P(number1) > UPPER_P(number2));
c0d086fa:	1a30      	subs	r0, r6, r0
c0d086fc:	418f      	sbcs	r7, r1
c0d086fe:	9f13      	ldr	r7, [sp, #76]	; 0x4c
c0d08700:	d200      	bcs.n	c0d08704 <divmod256+0x278>
c0d08702:	e755      	b.n	c0d085b0 <divmod256+0x124>
        if (gt256(&copyd, &resMod)) {
c0d08704:	e75f      	b.n	c0d085c6 <divmod256+0x13a>
	...

c0d08708 <tostring256>:
    out[offset] = '\0';
    reverseString(out, offset);
    return true;
}

bool tostring256(uint256_t *number, uint32_t baseParam, char *out, uint32_t outLength) {
c0d08708:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0870a:	b0a1      	sub	sp, #132	; 0x84
c0d0870c:	9301      	str	r3, [sp, #4]
c0d0870e:	9207      	str	r2, [sp, #28]
c0d08710:	9106      	str	r1, [sp, #24]
    UPPER_P(target) = UPPER_P(number);
c0d08712:	c8fe      	ldmia	r0!, {r1, r2, r3, r4, r5, r6, r7}
    LOWER_P(target) = LOWER_P(number);
c0d08714:	6800      	ldr	r0, [r0, #0]
c0d08716:	901f      	str	r0, [sp, #124]	; 0x7c
    UPPER_P(target) = UPPER_P(number);
c0d08718:	a818      	add	r0, sp, #96	; 0x60
c0d0871a:	c0fe      	stmia	r0!, {r1, r2, r3, r4, r5, r6, r7}
c0d0871c:	a810      	add	r0, sp, #64	; 0x40
c0d0871e:	2120      	movs	r1, #32
    LOWER_P(target) = 0;
c0d08720:	f001 ffa4 	bl	c0d0a66c <__aeabi_memclr>
c0d08724:	a808      	add	r0, sp, #32
c0d08726:	2118      	movs	r1, #24
    uint256_t rMod;
    uint256_t base;
    copy256(&rDiv, number);
    clear256(&rMod);
    clear256(&base);
    UPPER(LOWER(base)) = 0;
c0d08728:	f001 ffa0 	bl	c0d0a66c <__aeabi_memclr>
c0d0872c:	2000      	movs	r0, #0
    LOWER(LOWER(base)) = baseParam;
c0d0872e:	900f      	str	r0, [sp, #60]	; 0x3c
c0d08730:	aa18      	add	r2, sp, #96	; 0x60
c0d08732:	9906      	ldr	r1, [sp, #24]
c0d08734:	910e      	str	r1, [sp, #56]	; 0x38
    uint32_t offset = 0;
    if ((baseParam < 2) || (baseParam > 16)) {
c0d08736:	1e89      	subs	r1, r1, #2
c0d08738:	290e      	cmp	r1, #14
c0d0873a:	d84e      	bhi.n	c0d087da <tostring256+0xd2>
c0d0873c:	9000      	str	r0, [sp, #0]
c0d0873e:	4610      	mov	r0, r2
c0d08740:	3018      	adds	r0, #24
c0d08742:	9004      	str	r0, [sp, #16]
c0d08744:	4610      	mov	r0, r2
c0d08746:	3010      	adds	r0, #16
c0d08748:	9003      	str	r0, [sp, #12]
c0d0874a:	3208      	adds	r2, #8
c0d0874c:	9205      	str	r2, [sp, #20]
c0d0874e:	a810      	add	r0, sp, #64	; 0x40
c0d08750:	3018      	adds	r0, #24
c0d08752:	9002      	str	r0, [sp, #8]
c0d08754:	9801      	ldr	r0, [sp, #4]
c0d08756:	1e40      	subs	r0, r0, #1
c0d08758:	9006      	str	r0, [sp, #24]
c0d0875a:	2001      	movs	r0, #1
c0d0875c:	9001      	str	r0, [sp, #4]
c0d0875e:	43c7      	mvns	r7, r0
c0d08760:	1c7c      	adds	r4, r7, #1
        return false;
    }
    do {
        if (offset > (outLength - 1)) {
c0d08762:	1cb8      	adds	r0, r7, #2
c0d08764:	9906      	ldr	r1, [sp, #24]
c0d08766:	4288      	cmp	r0, r1
c0d08768:	d836      	bhi.n	c0d087d8 <tostring256+0xd0>
c0d0876a:	a908      	add	r1, sp, #32
c0d0876c:	a818      	add	r0, sp, #96	; 0x60
c0d0876e:	ab10      	add	r3, sp, #64	; 0x40
            return false;
        }
        divmod256(&rDiv, &base, &rDiv, &rMod);
c0d08770:	4602      	mov	r2, r0
c0d08772:	f7ff fe8b 	bl	c0d0848c <divmod256>
        out[offset++] = HEXDIGITS[(uint8_t) LOWER(LOWER(rMod))];
c0d08776:	9807      	ldr	r0, [sp, #28]
c0d08778:	19c1      	adds	r1, r0, r7
c0d0877a:	9802      	ldr	r0, [sp, #8]
c0d0877c:	7800      	ldrb	r0, [r0, #0]
c0d0877e:	4a18      	ldr	r2, [pc, #96]	; (c0d087e0 <tostring256+0xd8>)
c0d08780:	447a      	add	r2, pc
c0d08782:	5c10      	ldrb	r0, [r2, r0]
c0d08784:	7088      	strb	r0, [r1, #2]
c0d08786:	9904      	ldr	r1, [sp, #16]
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d08788:	c90c      	ldmia	r1!, {r2, r3}
c0d0878a:	9d03      	ldr	r5, [sp, #12]
c0d0878c:	cd22      	ldmia	r5, {r1, r5}
c0d0878e:	431d      	orrs	r5, r3
c0d08790:	9e05      	ldr	r6, [sp, #20]
c0d08792:	ce48      	ldmia	r6, {r3, r6}
c0d08794:	432e      	orrs	r6, r5
c0d08796:	9d19      	ldr	r5, [sp, #100]	; 0x64
c0d08798:	4335      	orrs	r5, r6
c0d0879a:	4311      	orrs	r1, r2
c0d0879c:	4319      	orrs	r1, r3
c0d0879e:	9a18      	ldr	r2, [sp, #96]	; 0x60
c0d087a0:	430a      	orrs	r2, r1
c0d087a2:	432a      	orrs	r2, r5
c0d087a4:	1c7f      	adds	r7, r7, #1
c0d087a6:	1c64      	adds	r4, r4, #1
c0d087a8:	2a00      	cmp	r2, #0
c0d087aa:	d1da      	bne.n	c0d08762 <tostring256+0x5a>
c0d087ac:	9b07      	ldr	r3, [sp, #28]
    } while (!zero256(&rDiv));
    out[offset] = '\0';
c0d087ae:	19d9      	adds	r1, r3, r7
c0d087b0:	2200      	movs	r2, #0
c0d087b2:	708a      	strb	r2, [r1, #2]
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d087b4:	2c00      	cmp	r4, #0
c0d087b6:	d00d      	beq.n	c0d087d4 <tostring256+0xcc>
        c = str[i];
c0d087b8:	7819      	ldrb	r1, [r3, #0]
        str[i] = str[j];
c0d087ba:	7018      	strb	r0, [r3, #0]
        str[j] = c;
c0d087bc:	5519      	strb	r1, [r3, r4]
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d087be:	2f02      	cmp	r7, #2
c0d087c0:	d308      	bcc.n	c0d087d4 <tostring256+0xcc>
c0d087c2:	2001      	movs	r0, #1
        c = str[i];
c0d087c4:	5c19      	ldrb	r1, [r3, r0]
        str[i] = str[j];
c0d087c6:	5dda      	ldrb	r2, [r3, r7]
c0d087c8:	541a      	strb	r2, [r3, r0]
        str[j] = c;
c0d087ca:	55d9      	strb	r1, [r3, r7]
c0d087cc:	1e7f      	subs	r7, r7, #1
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d087ce:	1c40      	adds	r0, r0, #1
c0d087d0:	42b8      	cmp	r0, r7
c0d087d2:	d3f7      	bcc.n	c0d087c4 <tostring256+0xbc>
c0d087d4:	9801      	ldr	r0, [sp, #4]
c0d087d6:	e000      	b.n	c0d087da <tostring256+0xd2>
c0d087d8:	9800      	ldr	r0, [sp, #0]
    reverseString(out, offset);
    return true;
}
c0d087da:	b021      	add	sp, #132	; 0x84
c0d087dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d087de:	46c0      	nop			; (mov r8, r8)
c0d087e0:	00002e6b 	.word	0x00002e6b

c0d087e4 <USBD_LL_Init>:
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  UNUSED(pdev);
  ep_in_stall = 0;
  ep_out_stall = 0;
c0d087e4:	4902      	ldr	r1, [pc, #8]	; (c0d087f0 <USBD_LL_Init+0xc>)
c0d087e6:	2000      	movs	r0, #0
c0d087e8:	6008      	str	r0, [r1, #0]
  ep_in_stall = 0;
c0d087ea:	4902      	ldr	r1, [pc, #8]	; (c0d087f4 <USBD_LL_Init+0x10>)
c0d087ec:	6008      	str	r0, [r1, #0]
  return USBD_OK;
c0d087ee:	4770      	bx	lr
c0d087f0:	20002118 	.word	0x20002118
c0d087f4:	20002114 	.word	0x20002114

c0d087f8 <USBD_LL_DeInit>:
  * @brief  De-Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_DeInit (USBD_HandleTypeDef *pdev)
{
c0d087f8:	b510      	push	{r4, lr}
  UNUSED(pdev);
  // usb off
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d087fa:	4807      	ldr	r0, [pc, #28]	; (c0d08818 <USBD_LL_DeInit+0x20>)
c0d087fc:	2102      	movs	r1, #2
  G_io_seproxyhal_spi_buffer[1] = 0;
  G_io_seproxyhal_spi_buffer[2] = 1;
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT;
c0d087fe:	70c1      	strb	r1, [r0, #3]
c0d08800:	2101      	movs	r1, #1
  G_io_seproxyhal_spi_buffer[2] = 1;
c0d08802:	7081      	strb	r1, [r0, #2]
c0d08804:	2400      	movs	r4, #0
  G_io_seproxyhal_spi_buffer[1] = 0;
c0d08806:	7044      	strb	r4, [r0, #1]
c0d08808:	214f      	movs	r1, #79	; 0x4f
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d0880a:	7001      	strb	r1, [r0, #0]
c0d0880c:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 4);
c0d0880e:	f7fe f98b 	bl	c0d06b28 <io_seph_send>

  return USBD_OK; 
c0d08812:	4620      	mov	r0, r4
c0d08814:	bd10      	pop	{r4, pc}
c0d08816:	46c0      	nop			; (mov r8, r8)
c0d08818:	20001b00 	.word	0x20001b00

c0d0881c <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
c0d0881c:	b570      	push	{r4, r5, r6, lr}
c0d0881e:	b082      	sub	sp, #8
c0d08820:	466d      	mov	r5, sp
c0d08822:	2400      	movs	r4, #0
  // reset address
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 2;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
  buffer[4] = 0;
c0d08824:	712c      	strb	r4, [r5, #4]
c0d08826:	2003      	movs	r0, #3
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
c0d08828:	70e8      	strb	r0, [r5, #3]
c0d0882a:	2002      	movs	r0, #2
  buffer[2] = 2;
c0d0882c:	70a8      	strb	r0, [r5, #2]
  buffer[1] = 0;
c0d0882e:	706c      	strb	r4, [r5, #1]
c0d08830:	264f      	movs	r6, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d08832:	702e      	strb	r6, [r5, #0]
c0d08834:	2105      	movs	r1, #5
  io_seproxyhal_spi_send(buffer, 5);
c0d08836:	4628      	mov	r0, r5
c0d08838:	f7fe f976 	bl	c0d06b28 <io_seph_send>
c0d0883c:	2001      	movs	r0, #1
  
  // start usb operation
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 1;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_CONNECT;
c0d0883e:	70e8      	strb	r0, [r5, #3]
  buffer[2] = 1;
c0d08840:	70a8      	strb	r0, [r5, #2]
  buffer[1] = 0;
c0d08842:	706c      	strb	r4, [r5, #1]
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d08844:	702e      	strb	r6, [r5, #0]
c0d08846:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(buffer, 4);
c0d08848:	4628      	mov	r0, r5
c0d0884a:	f7fe f96d 	bl	c0d06b28 <io_seph_send>
  return USBD_OK; 
c0d0884e:	4620      	mov	r0, r4
c0d08850:	b002      	add	sp, #8
c0d08852:	bd70      	pop	{r4, r5, r6, pc}

c0d08854 <USBD_LL_Stop>:
  * @brief  Stops the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev)
{
c0d08854:	b510      	push	{r4, lr}
c0d08856:	b082      	sub	sp, #8
c0d08858:	a801      	add	r0, sp, #4
c0d0885a:	2102      	movs	r1, #2
  UNUSED(pdev);
  uint8_t buffer[4];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 1;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT;
c0d0885c:	70c1      	strb	r1, [r0, #3]
c0d0885e:	2101      	movs	r1, #1
  buffer[2] = 1;
c0d08860:	7081      	strb	r1, [r0, #2]
c0d08862:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d08864:	7044      	strb	r4, [r0, #1]
c0d08866:	214f      	movs	r1, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d08868:	7001      	strb	r1, [r0, #0]
c0d0886a:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(buffer, 4);
c0d0886c:	f7fe f95c 	bl	c0d06b28 <io_seph_send>
  return USBD_OK; 
c0d08870:	4620      	mov	r0, r4
c0d08872:	b002      	add	sp, #8
c0d08874:	bd10      	pop	{r4, pc}
	...

c0d08878 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
c0d08878:	b570      	push	{r4, r5, r6, lr}
c0d0887a:	b082      	sub	sp, #8
  uint8_t buffer[8];
  UNUSED(pdev);

  ep_in_stall = 0;
  ep_out_stall = 0;
c0d0887c:	4814      	ldr	r0, [pc, #80]	; (c0d088d0 <USBD_LL_OpenEP+0x58>)
c0d0887e:	2400      	movs	r4, #0
c0d08880:	6004      	str	r4, [r0, #0]
  ep_in_stall = 0;
c0d08882:	4814      	ldr	r0, [pc, #80]	; (c0d088d4 <USBD_LL_OpenEP+0x5c>)
c0d08884:	6004      	str	r4, [r0, #0]
c0d08886:	466d      	mov	r5, sp
  buffer[1] = 0;
  buffer[2] = 5;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
  buffer[4] = 1;
  buffer[5] = ep_addr;
  buffer[6] = 0;
c0d08888:	71ac      	strb	r4, [r5, #6]
  buffer[5] = ep_addr;
c0d0888a:	7169      	strb	r1, [r5, #5]
c0d0888c:	2001      	movs	r0, #1
  buffer[4] = 1;
c0d0888e:	7128      	strb	r0, [r5, #4]
c0d08890:	2104      	movs	r1, #4
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
c0d08892:	70e9      	strb	r1, [r5, #3]
c0d08894:	2605      	movs	r6, #5
  buffer[2] = 5;
c0d08896:	70ae      	strb	r6, [r5, #2]
  buffer[1] = 0;
c0d08898:	706c      	strb	r4, [r5, #1]
c0d0889a:	244f      	movs	r4, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d0889c:	702c      	strb	r4, [r5, #0]
  switch(ep_type) {
c0d0889e:	2a01      	cmp	r2, #1
c0d088a0:	dc05      	bgt.n	c0d088ae <USBD_LL_OpenEP+0x36>
c0d088a2:	2a00      	cmp	r2, #0
c0d088a4:	d00a      	beq.n	c0d088bc <USBD_LL_OpenEP+0x44>
c0d088a6:	2a01      	cmp	r2, #1
c0d088a8:	d10a      	bne.n	c0d088c0 <USBD_LL_OpenEP+0x48>
c0d088aa:	4608      	mov	r0, r1
c0d088ac:	e006      	b.n	c0d088bc <USBD_LL_OpenEP+0x44>
c0d088ae:	2a02      	cmp	r2, #2
c0d088b0:	d003      	beq.n	c0d088ba <USBD_LL_OpenEP+0x42>
c0d088b2:	2a03      	cmp	r2, #3
c0d088b4:	d104      	bne.n	c0d088c0 <USBD_LL_OpenEP+0x48>
c0d088b6:	2002      	movs	r0, #2
c0d088b8:	e000      	b.n	c0d088bc <USBD_LL_OpenEP+0x44>
c0d088ba:	2003      	movs	r0, #3
c0d088bc:	4669      	mov	r1, sp
c0d088be:	7188      	strb	r0, [r1, #6]
c0d088c0:	4668      	mov	r0, sp
      break;
    case USBD_EP_TYPE_INTR:
      buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT;
      break;
  }
  buffer[7] = ep_mps;
c0d088c2:	71c3      	strb	r3, [r0, #7]
c0d088c4:	2108      	movs	r1, #8
  io_seproxyhal_spi_send(buffer, 8);
c0d088c6:	f7fe f92f 	bl	c0d06b28 <io_seph_send>
c0d088ca:	2000      	movs	r0, #0
  return USBD_OK; 
c0d088cc:	b002      	add	sp, #8
c0d088ce:	bd70      	pop	{r4, r5, r6, pc}
c0d088d0:	20002118 	.word	0x20002118
c0d088d4:	20002114 	.word	0x20002114

c0d088d8 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
c0d088d8:	b510      	push	{r4, lr}
c0d088da:	b082      	sub	sp, #8
c0d088dc:	4668      	mov	r0, sp
c0d088de:	2400      	movs	r4, #0
  buffer[2] = 5;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
  buffer[4] = 1;
  buffer[5] = ep_addr;
  buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED;
  buffer[7] = 0;
c0d088e0:	71c4      	strb	r4, [r0, #7]
  buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED;
c0d088e2:	7184      	strb	r4, [r0, #6]
  buffer[5] = ep_addr;
c0d088e4:	7141      	strb	r1, [r0, #5]
c0d088e6:	2101      	movs	r1, #1
  buffer[4] = 1;
c0d088e8:	7101      	strb	r1, [r0, #4]
c0d088ea:	2104      	movs	r1, #4
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
c0d088ec:	70c1      	strb	r1, [r0, #3]
c0d088ee:	2105      	movs	r1, #5
  buffer[2] = 5;
c0d088f0:	7081      	strb	r1, [r0, #2]
  buffer[1] = 0;
c0d088f2:	7044      	strb	r4, [r0, #1]
c0d088f4:	214f      	movs	r1, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d088f6:	7001      	strb	r1, [r0, #0]
c0d088f8:	2108      	movs	r1, #8
  io_seproxyhal_spi_send(buffer, 8);
c0d088fa:	f7fe f915 	bl	c0d06b28 <io_seph_send>
  return USBD_OK; 
c0d088fe:	4620      	mov	r0, r4
c0d08900:	b002      	add	sp, #8
c0d08902:	bd10      	pop	{r4, pc}

c0d08904 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{ 
c0d08904:	b5b0      	push	{r4, r5, r7, lr}
c0d08906:	b082      	sub	sp, #8
c0d08908:	460d      	mov	r5, r1
c0d0890a:	4668      	mov	r0, sp
c0d0890c:	2400      	movs	r4, #0
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = 0;
  buffer[2] = 3;
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL;
  buffer[5] = 0;
c0d0890e:	7144      	strb	r4, [r0, #5]
c0d08910:	2140      	movs	r1, #64	; 0x40
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL;
c0d08912:	7101      	strb	r1, [r0, #4]
  buffer[3] = ep_addr;
c0d08914:	70c5      	strb	r5, [r0, #3]
c0d08916:	2103      	movs	r1, #3
  buffer[2] = 3;
c0d08918:	7081      	strb	r1, [r0, #2]
  buffer[1] = 0;
c0d0891a:	7044      	strb	r4, [r0, #1]
c0d0891c:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d0891e:	7001      	strb	r1, [r0, #0]
c0d08920:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0d08922:	f7fe f901 	bl	c0d06b28 <io_seph_send>
  if (ep_addr & 0x80) {
c0d08926:	0628      	lsls	r0, r5, #24
c0d08928:	d501      	bpl.n	c0d0892e <USBD_LL_StallEP+0x2a>
c0d0892a:	4807      	ldr	r0, [pc, #28]	; (c0d08948 <USBD_LL_StallEP+0x44>)
c0d0892c:	e000      	b.n	c0d08930 <USBD_LL_StallEP+0x2c>
c0d0892e:	4805      	ldr	r0, [pc, #20]	; (c0d08944 <USBD_LL_StallEP+0x40>)
c0d08930:	6801      	ldr	r1, [r0, #0]
c0d08932:	227f      	movs	r2, #127	; 0x7f
c0d08934:	4015      	ands	r5, r2
c0d08936:	2201      	movs	r2, #1
c0d08938:	40aa      	lsls	r2, r5
c0d0893a:	430a      	orrs	r2, r1
c0d0893c:	6002      	str	r2, [r0, #0]
    ep_in_stall |= (1<<(ep_addr&0x7F));
  }
  else {
    ep_out_stall |= (1<<(ep_addr&0x7F)); 
  }
  return USBD_OK; 
c0d0893e:	4620      	mov	r0, r4
c0d08940:	b002      	add	sp, #8
c0d08942:	bdb0      	pop	{r4, r5, r7, pc}
c0d08944:	20002118 	.word	0x20002118
c0d08948:	20002114 	.word	0x20002114

c0d0894c <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
c0d0894c:	b5b0      	push	{r4, r5, r7, lr}
c0d0894e:	b082      	sub	sp, #8
c0d08950:	460d      	mov	r5, r1
c0d08952:	4668      	mov	r0, sp
c0d08954:	2400      	movs	r4, #0
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = 0;
  buffer[2] = 3;
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL;
  buffer[5] = 0;
c0d08956:	7144      	strb	r4, [r0, #5]
c0d08958:	2180      	movs	r1, #128	; 0x80
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL;
c0d0895a:	7101      	strb	r1, [r0, #4]
  buffer[3] = ep_addr;
c0d0895c:	70c5      	strb	r5, [r0, #3]
c0d0895e:	2103      	movs	r1, #3
  buffer[2] = 3;
c0d08960:	7081      	strb	r1, [r0, #2]
  buffer[1] = 0;
c0d08962:	7044      	strb	r4, [r0, #1]
c0d08964:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d08966:	7001      	strb	r1, [r0, #0]
c0d08968:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0d0896a:	f7fe f8dd 	bl	c0d06b28 <io_seph_send>
  if (ep_addr & 0x80) {
c0d0896e:	0628      	lsls	r0, r5, #24
c0d08970:	d501      	bpl.n	c0d08976 <USBD_LL_ClearStallEP+0x2a>
c0d08972:	4807      	ldr	r0, [pc, #28]	; (c0d08990 <USBD_LL_ClearStallEP+0x44>)
c0d08974:	e000      	b.n	c0d08978 <USBD_LL_ClearStallEP+0x2c>
c0d08976:	4805      	ldr	r0, [pc, #20]	; (c0d0898c <USBD_LL_ClearStallEP+0x40>)
c0d08978:	6801      	ldr	r1, [r0, #0]
c0d0897a:	227f      	movs	r2, #127	; 0x7f
c0d0897c:	4015      	ands	r5, r2
c0d0897e:	2201      	movs	r2, #1
c0d08980:	40aa      	lsls	r2, r5
c0d08982:	4391      	bics	r1, r2
c0d08984:	6001      	str	r1, [r0, #0]
    ep_in_stall &= ~(1<<(ep_addr&0x7F));
  }
  else {
    ep_out_stall &= ~(1<<(ep_addr&0x7F)); 
  }
  return USBD_OK; 
c0d08986:	4620      	mov	r0, r4
c0d08988:	b002      	add	sp, #8
c0d0898a:	bdb0      	pop	{r4, r5, r7, pc}
c0d0898c:	20002118 	.word	0x20002118
c0d08990:	20002114 	.word	0x20002114

c0d08994 <USBD_LL_IsStallEP>:
c0d08994:	0608      	lsls	r0, r1, #24
c0d08996:	d501      	bpl.n	c0d0899c <USBD_LL_IsStallEP+0x8>
c0d08998:	4805      	ldr	r0, [pc, #20]	; (c0d089b0 <USBD_LL_IsStallEP+0x1c>)
c0d0899a:	e000      	b.n	c0d0899e <USBD_LL_IsStallEP+0xa>
c0d0899c:	4803      	ldr	r0, [pc, #12]	; (c0d089ac <USBD_LL_IsStallEP+0x18>)
c0d0899e:	7802      	ldrb	r2, [r0, #0]
c0d089a0:	207f      	movs	r0, #127	; 0x7f
c0d089a2:	4001      	ands	r1, r0
c0d089a4:	2001      	movs	r0, #1
c0d089a6:	4088      	lsls	r0, r1
c0d089a8:	4010      	ands	r0, r2
  }
  else
  {
    return ep_out_stall & (1<<(ep_addr&0x7F));
  }
}
c0d089aa:	4770      	bx	lr
c0d089ac:	20002118 	.word	0x20002118
c0d089b0:	20002114 	.word	0x20002114

c0d089b4 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
c0d089b4:	b510      	push	{r4, lr}
c0d089b6:	b082      	sub	sp, #8
c0d089b8:	4668      	mov	r0, sp
  uint8_t buffer[5];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 2;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
  buffer[4] = dev_addr;
c0d089ba:	7101      	strb	r1, [r0, #4]
c0d089bc:	2103      	movs	r1, #3
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
c0d089be:	70c1      	strb	r1, [r0, #3]
c0d089c0:	2102      	movs	r1, #2
  buffer[2] = 2;
c0d089c2:	7081      	strb	r1, [r0, #2]
c0d089c4:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d089c6:	7044      	strb	r4, [r0, #1]
c0d089c8:	214f      	movs	r1, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d089ca:	7001      	strb	r1, [r0, #0]
c0d089cc:	2105      	movs	r1, #5
  io_seproxyhal_spi_send(buffer, 5);
c0d089ce:	f7fe f8ab 	bl	c0d06b28 <io_seph_send>
  return USBD_OK; 
c0d089d2:	4620      	mov	r0, r4
c0d089d4:	b002      	add	sp, #8
c0d089d6:	bd10      	pop	{r4, pc}

c0d089d8 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
c0d089d8:	b5b0      	push	{r4, r5, r7, lr}
c0d089da:	b082      	sub	sp, #8
c0d089dc:	461c      	mov	r4, r3
c0d089de:	4615      	mov	r5, r2
c0d089e0:	4668      	mov	r0, sp
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = (3+size)>>8;
  buffer[2] = (3+size);
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
  buffer[5] = size;
c0d089e2:	7143      	strb	r3, [r0, #5]
c0d089e4:	2220      	movs	r2, #32
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
c0d089e6:	7102      	strb	r2, [r0, #4]
  buffer[3] = ep_addr;
c0d089e8:	70c1      	strb	r1, [r0, #3]
c0d089ea:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d089ec:	7001      	strb	r1, [r0, #0]
  buffer[1] = (3+size)>>8;
c0d089ee:	1cd9      	adds	r1, r3, #3
  buffer[2] = (3+size);
c0d089f0:	7081      	strb	r1, [r0, #2]
  buffer[1] = (3+size)>>8;
c0d089f2:	0a09      	lsrs	r1, r1, #8
c0d089f4:	7041      	strb	r1, [r0, #1]
c0d089f6:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0d089f8:	f7fe f896 	bl	c0d06b28 <io_seph_send>
  io_seproxyhal_spi_send(pbuf, size);
c0d089fc:	4628      	mov	r0, r5
c0d089fe:	4621      	mov	r1, r4
c0d08a00:	f7fe f892 	bl	c0d06b28 <io_seph_send>
c0d08a04:	2000      	movs	r0, #0
  return USBD_OK;   
c0d08a06:	b002      	add	sp, #8
c0d08a08:	bdb0      	pop	{r4, r5, r7, pc}

c0d08a0a <USBD_LL_PrepareReceive>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,
                                           uint16_t  size)
{
c0d08a0a:	b510      	push	{r4, lr}
c0d08a0c:	b082      	sub	sp, #8
c0d08a0e:	4668      	mov	r0, sp
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = (3/*+size*/)>>8;
  buffer[2] = (3/*+size*/);
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT;
  buffer[5] = size; // expected size, not transmitted here !
c0d08a10:	7142      	strb	r2, [r0, #5]
c0d08a12:	2230      	movs	r2, #48	; 0x30
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT;
c0d08a14:	7102      	strb	r2, [r0, #4]
  buffer[3] = ep_addr;
c0d08a16:	70c1      	strb	r1, [r0, #3]
c0d08a18:	2103      	movs	r1, #3
  buffer[2] = (3/*+size*/);
c0d08a1a:	7081      	strb	r1, [r0, #2]
c0d08a1c:	2400      	movs	r4, #0
  buffer[1] = (3/*+size*/)>>8;
c0d08a1e:	7044      	strb	r4, [r0, #1]
c0d08a20:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d08a22:	7001      	strb	r1, [r0, #0]
c0d08a24:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0d08a26:	f7fe f87f 	bl	c0d06b28 <io_seph_send>
  return USBD_OK;   
c0d08a2a:	4620      	mov	r0, r4
c0d08a2c:	b002      	add	sp, #8
c0d08a2e:	bd10      	pop	{r4, pc}

c0d08a30 <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
c0d08a30:	b570      	push	{r4, r5, r6, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
c0d08a32:	2800      	cmp	r0, #0
c0d08a34:	d012      	beq.n	c0d08a5c <USBD_Init+0x2c>
c0d08a36:	4615      	mov	r5, r2
c0d08a38:	460e      	mov	r6, r1
c0d08a3a:	4604      	mov	r4, r0
c0d08a3c:	21d4      	movs	r1, #212	; 0xd4
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }

  memset(pdev, 0, sizeof(USBD_HandleTypeDef));
c0d08a3e:	f001 fe15 	bl	c0d0a66c <__aeabi_memclr>
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
c0d08a42:	2e00      	cmp	r6, #0
c0d08a44:	d001      	beq.n	c0d08a4a <USBD_Init+0x1a>
c0d08a46:	20b0      	movs	r0, #176	; 0xb0
  {
    pdev->pDesc = pdesc;
c0d08a48:	5026      	str	r6, [r4, r0]
c0d08a4a:	209c      	movs	r0, #156	; 0x9c
c0d08a4c:	2101      	movs	r1, #1
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
c0d08a4e:	5421      	strb	r1, [r4, r0]
  pdev->id = id;
c0d08a50:	7025      	strb	r5, [r4, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
c0d08a52:	4620      	mov	r0, r4
c0d08a54:	f7ff fec6 	bl	c0d087e4 <USBD_LL_Init>
c0d08a58:	2000      	movs	r0, #0
  
  return USBD_OK; 
}
c0d08a5a:	bd70      	pop	{r4, r5, r6, pc}
c0d08a5c:	2002      	movs	r0, #2
c0d08a5e:	bd70      	pop	{r4, r5, r6, pc}

c0d08a60 <USBD_DeInit>:
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
c0d08a60:	b5b0      	push	{r4, r5, r7, lr}
c0d08a62:	4604      	mov	r4, r0
c0d08a64:	209c      	movs	r0, #156	; 0x9c
c0d08a66:	2101      	movs	r1, #1
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
c0d08a68:	5421      	strb	r1, [r4, r0]
c0d08a6a:	25b4      	movs	r5, #180	; 0xb4
  
  /* Free Class Resources */
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(pdev->interfacesClass[intf].pClass != NULL) {
c0d08a6c:	5960      	ldr	r0, [r4, r5]
c0d08a6e:	2800      	cmp	r0, #0
c0d08a70:	d006      	beq.n	c0d08a80 <USBD_DeInit+0x20>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config);  
c0d08a72:	6840      	ldr	r0, [r0, #4]
c0d08a74:	f7fc fe60 	bl	c0d05738 <pic>
c0d08a78:	4602      	mov	r2, r0
c0d08a7a:	7921      	ldrb	r1, [r4, #4]
c0d08a7c:	4620      	mov	r0, r4
c0d08a7e:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08a80:	3508      	adds	r5, #8
c0d08a82:	2dcc      	cmp	r5, #204	; 0xcc
c0d08a84:	d1f2      	bne.n	c0d08a6c <USBD_DeInit+0xc>
    }
  }
  
    /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
c0d08a86:	4620      	mov	r0, r4
c0d08a88:	f7ff fee4 	bl	c0d08854 <USBD_LL_Stop>
  
  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
c0d08a8c:	4620      	mov	r0, r4
c0d08a8e:	f7ff feb3 	bl	c0d087f8 <USBD_LL_DeInit>
c0d08a92:	2000      	movs	r0, #0
  
  return USBD_OK;
c0d08a94:	bdb0      	pop	{r4, r5, r7, pc}

c0d08a96 <USBD_RegisterClassForInterface>:
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClassForInterface(uint8_t interfaceidx, USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
c0d08a96:	2a00      	cmp	r2, #0
c0d08a98:	d008      	beq.n	c0d08aac <USBD_RegisterClassForInterface+0x16>
c0d08a9a:	4603      	mov	r3, r0
c0d08a9c:	2000      	movs	r0, #0
  {
    if (interfaceidx < USBD_MAX_NUM_INTERFACES) {
c0d08a9e:	2b02      	cmp	r3, #2
c0d08aa0:	d803      	bhi.n	c0d08aaa <USBD_RegisterClassForInterface+0x14>
      /* link the class to the USB Device handle */
      pdev->interfacesClass[interfaceidx].pClass = pclass;
c0d08aa2:	00db      	lsls	r3, r3, #3
c0d08aa4:	18c9      	adds	r1, r1, r3
c0d08aa6:	23b4      	movs	r3, #180	; 0xb4
c0d08aa8:	50ca      	str	r2, [r1, r3]
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
  }
  
  return status;
c0d08aaa:	4770      	bx	lr
c0d08aac:	2002      	movs	r0, #2
c0d08aae:	4770      	bx	lr

c0d08ab0 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
c0d08ab0:	b580      	push	{r7, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
c0d08ab2:	f7ff feb3 	bl	c0d0881c <USBD_LL_Start>
c0d08ab6:	2000      	movs	r0, #0
  
  return USBD_OK;  
c0d08ab8:	bd80      	pop	{r7, pc}

c0d08aba <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
c0d08aba:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08abc:	b081      	sub	sp, #4
c0d08abe:	460c      	mov	r4, r1
c0d08ac0:	4605      	mov	r5, r0
c0d08ac2:	2600      	movs	r6, #0
c0d08ac4:	27b4      	movs	r7, #180	; 0xb4
  /* Set configuration  and Start the Class*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(usbd_is_valid_intf(pdev, intf)) {
c0d08ac6:	4628      	mov	r0, r5
c0d08ac8:	4631      	mov	r1, r6
c0d08aca:	f000 f965 	bl	c0d08d98 <usbd_is_valid_intf>
c0d08ace:	2800      	cmp	r0, #0
c0d08ad0:	d007      	beq.n	c0d08ae2 <USBD_SetClassConfig+0x28>
      ((Init_t)PIC(pdev->interfacesClass[intf].pClass->Init))(pdev, cfgidx);
c0d08ad2:	59e8      	ldr	r0, [r5, r7]
c0d08ad4:	6800      	ldr	r0, [r0, #0]
c0d08ad6:	f7fc fe2f 	bl	c0d05738 <pic>
c0d08ada:	4602      	mov	r2, r0
c0d08adc:	4628      	mov	r0, r5
c0d08ade:	4621      	mov	r1, r4
c0d08ae0:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08ae2:	3708      	adds	r7, #8
c0d08ae4:	1c76      	adds	r6, r6, #1
c0d08ae6:	2e03      	cmp	r6, #3
c0d08ae8:	d1ed      	bne.n	c0d08ac6 <USBD_SetClassConfig+0xc>
c0d08aea:	2000      	movs	r0, #0
    }
  }

  return USBD_OK; 
c0d08aec:	b001      	add	sp, #4
c0d08aee:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d08af0 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
c0d08af0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08af2:	b081      	sub	sp, #4
c0d08af4:	460c      	mov	r4, r1
c0d08af6:	4605      	mov	r5, r0
c0d08af8:	2600      	movs	r6, #0
c0d08afa:	27b4      	movs	r7, #180	; 0xb4
  /* Clear configuration  and De-initialize the Class process*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(usbd_is_valid_intf(pdev, intf)) {
c0d08afc:	4628      	mov	r0, r5
c0d08afe:	4631      	mov	r1, r6
c0d08b00:	f000 f94a 	bl	c0d08d98 <usbd_is_valid_intf>
c0d08b04:	2800      	cmp	r0, #0
c0d08b06:	d007      	beq.n	c0d08b18 <USBD_ClrClassConfig+0x28>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, cfgidx);  
c0d08b08:	59e8      	ldr	r0, [r5, r7]
c0d08b0a:	6840      	ldr	r0, [r0, #4]
c0d08b0c:	f7fc fe14 	bl	c0d05738 <pic>
c0d08b10:	4602      	mov	r2, r0
c0d08b12:	4628      	mov	r0, r5
c0d08b14:	4621      	mov	r1, r4
c0d08b16:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08b18:	3708      	adds	r7, #8
c0d08b1a:	1c76      	adds	r6, r6, #1
c0d08b1c:	2e03      	cmp	r6, #3
c0d08b1e:	d1ed      	bne.n	c0d08afc <USBD_ClrClassConfig+0xc>
c0d08b20:	2000      	movs	r0, #0
    }
  }
  return USBD_OK;
c0d08b22:	b001      	add	sp, #4
c0d08b24:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d08b26 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
c0d08b26:	b5b0      	push	{r4, r5, r7, lr}
c0d08b28:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
c0d08b2a:	4605      	mov	r5, r0
c0d08b2c:	35a8      	adds	r5, #168	; 0xa8
c0d08b2e:	4628      	mov	r0, r5
c0d08b30:	f000 fb74 	bl	c0d0921c <USBD_ParseSetupRequest>
c0d08b34:	2094      	movs	r0, #148	; 0x94
c0d08b36:	2101      	movs	r1, #1
  
  pdev->ep0_state = USBD_EP0_SETUP;
c0d08b38:	5021      	str	r1, [r4, r0]
c0d08b3a:	20ae      	movs	r0, #174	; 0xae
  pdev->ep0_data_len = pdev->request.wLength;
c0d08b3c:	5a20      	ldrh	r0, [r4, r0]
c0d08b3e:	2198      	movs	r1, #152	; 0x98
c0d08b40:	5060      	str	r0, [r4, r1]
c0d08b42:	20a8      	movs	r0, #168	; 0xa8
  
  switch (pdev->request.bmRequest & 0x1F) 
c0d08b44:	5c21      	ldrb	r1, [r4, r0]
c0d08b46:	201f      	movs	r0, #31
c0d08b48:	4008      	ands	r0, r1
c0d08b4a:	2802      	cmp	r0, #2
c0d08b4c:	d008      	beq.n	c0d08b60 <USBD_LL_SetupStage+0x3a>
c0d08b4e:	2801      	cmp	r0, #1
c0d08b50:	d00b      	beq.n	c0d08b6a <USBD_LL_SetupStage+0x44>
c0d08b52:	2800      	cmp	r0, #0
c0d08b54:	d10e      	bne.n	c0d08b74 <USBD_LL_SetupStage+0x4e>
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
c0d08b56:	4620      	mov	r0, r4
c0d08b58:	4629      	mov	r1, r5
c0d08b5a:	f000 f929 	bl	c0d08db0 <USBD_StdDevReq>
c0d08b5e:	e00e      	b.n	c0d08b7e <USBD_LL_SetupStage+0x58>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
c0d08b60:	4620      	mov	r0, r4
c0d08b62:	4629      	mov	r1, r5
c0d08b64:	f000 fad8 	bl	c0d09118 <USBD_StdEPReq>
c0d08b68:	e009      	b.n	c0d08b7e <USBD_LL_SetupStage+0x58>
    USBD_StdItfReq(pdev, &pdev->request);
c0d08b6a:	4620      	mov	r0, r4
c0d08b6c:	4629      	mov	r1, r5
c0d08b6e:	f000 faaf 	bl	c0d090d0 <USBD_StdItfReq>
c0d08b72:	e004      	b.n	c0d08b7e <USBD_LL_SetupStage+0x58>
c0d08b74:	2080      	movs	r0, #128	; 0x80
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
c0d08b76:	4001      	ands	r1, r0
c0d08b78:	4620      	mov	r0, r4
c0d08b7a:	f7ff fec3 	bl	c0d08904 <USBD_LL_StallEP>
c0d08b7e:	2000      	movs	r0, #0
    break;
  }  
  return USBD_OK;  
c0d08b80:	bdb0      	pop	{r4, r5, r7, pc}

c0d08b82 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
c0d08b82:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08b84:	b083      	sub	sp, #12
c0d08b86:	9202      	str	r2, [sp, #8]
c0d08b88:	4604      	mov	r4, r0
c0d08b8a:	9101      	str	r1, [sp, #4]
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
c0d08b8c:	2900      	cmp	r1, #0
c0d08b8e:	d01c      	beq.n	c0d08bca <USBD_LL_DataOutStage+0x48>
c0d08b90:	4625      	mov	r5, r4
c0d08b92:	359c      	adds	r5, #156	; 0x9c
c0d08b94:	2700      	movs	r7, #0
c0d08b96:	26b4      	movs	r6, #180	; 0xb4
  }
  else {

    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->DataOut != NULL)&&
c0d08b98:	4620      	mov	r0, r4
c0d08b9a:	4639      	mov	r1, r7
c0d08b9c:	f000 f8fc 	bl	c0d08d98 <usbd_is_valid_intf>
c0d08ba0:	2800      	cmp	r0, #0
c0d08ba2:	d00d      	beq.n	c0d08bc0 <USBD_LL_DataOutStage+0x3e>
c0d08ba4:	59a0      	ldr	r0, [r4, r6]
c0d08ba6:	6980      	ldr	r0, [r0, #24]
c0d08ba8:	2800      	cmp	r0, #0
c0d08baa:	d009      	beq.n	c0d08bc0 <USBD_LL_DataOutStage+0x3e>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d08bac:	7829      	ldrb	r1, [r5, #0]
      if( usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->DataOut != NULL)&&
c0d08bae:	2903      	cmp	r1, #3
c0d08bb0:	d106      	bne.n	c0d08bc0 <USBD_LL_DataOutStage+0x3e>
      {
        ((DataOut_t)PIC(pdev->interfacesClass[intf].pClass->DataOut))(pdev, epnum, pdata); 
c0d08bb2:	f7fc fdc1 	bl	c0d05738 <pic>
c0d08bb6:	4603      	mov	r3, r0
c0d08bb8:	4620      	mov	r0, r4
c0d08bba:	9901      	ldr	r1, [sp, #4]
c0d08bbc:	9a02      	ldr	r2, [sp, #8]
c0d08bbe:	4798      	blx	r3
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08bc0:	3608      	adds	r6, #8
c0d08bc2:	1c7f      	adds	r7, r7, #1
c0d08bc4:	2f03      	cmp	r7, #3
c0d08bc6:	d1e7      	bne.n	c0d08b98 <USBD_LL_DataOutStage+0x16>
c0d08bc8:	e02f      	b.n	c0d08c2a <USBD_LL_DataOutStage+0xa8>
c0d08bca:	2094      	movs	r0, #148	; 0x94
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
c0d08bcc:	5820      	ldr	r0, [r4, r0]
c0d08bce:	2803      	cmp	r0, #3
c0d08bd0:	d12b      	bne.n	c0d08c2a <USBD_LL_DataOutStage+0xa8>
      if(pep->rem_length > pep->maxpacket)
c0d08bd2:	6de1      	ldr	r1, [r4, #92]	; 0x5c
c0d08bd4:	6e20      	ldr	r0, [r4, #96]	; 0x60
c0d08bd6:	4281      	cmp	r1, r0
c0d08bd8:	d90a      	bls.n	c0d08bf0 <USBD_LL_DataOutStage+0x6e>
        pep->rem_length -=  pep->maxpacket;
c0d08bda:	1a09      	subs	r1, r1, r0
c0d08bdc:	65e1      	str	r1, [r4, #92]	; 0x5c
                            MIN(pep->rem_length ,pep->maxpacket));
c0d08bde:	4281      	cmp	r1, r0
c0d08be0:	d300      	bcc.n	c0d08be4 <USBD_LL_DataOutStage+0x62>
c0d08be2:	4601      	mov	r1, r0
        USBD_CtlContinueRx (pdev, 
c0d08be4:	b28a      	uxth	r2, r1
c0d08be6:	4620      	mov	r0, r4
c0d08be8:	9902      	ldr	r1, [sp, #8]
c0d08bea:	f000 fdc0 	bl	c0d0976e <USBD_CtlContinueRx>
c0d08bee:	e01c      	b.n	c0d08c2a <USBD_LL_DataOutStage+0xa8>
c0d08bf0:	4626      	mov	r6, r4
c0d08bf2:	369c      	adds	r6, #156	; 0x9c
c0d08bf4:	2500      	movs	r5, #0
c0d08bf6:	27b4      	movs	r7, #180	; 0xb4
          if(usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->EP0_RxReady != NULL)&&
c0d08bf8:	4620      	mov	r0, r4
c0d08bfa:	4629      	mov	r1, r5
c0d08bfc:	f000 f8cc 	bl	c0d08d98 <usbd_is_valid_intf>
c0d08c00:	2800      	cmp	r0, #0
c0d08c02:	d00b      	beq.n	c0d08c1c <USBD_LL_DataOutStage+0x9a>
c0d08c04:	59e0      	ldr	r0, [r4, r7]
c0d08c06:	6900      	ldr	r0, [r0, #16]
c0d08c08:	2800      	cmp	r0, #0
c0d08c0a:	d007      	beq.n	c0d08c1c <USBD_LL_DataOutStage+0x9a>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d08c0c:	7831      	ldrb	r1, [r6, #0]
          if(usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->EP0_RxReady != NULL)&&
c0d08c0e:	2903      	cmp	r1, #3
c0d08c10:	d104      	bne.n	c0d08c1c <USBD_LL_DataOutStage+0x9a>
            ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_RxReady))(pdev); 
c0d08c12:	f7fc fd91 	bl	c0d05738 <pic>
c0d08c16:	4601      	mov	r1, r0
c0d08c18:	4620      	mov	r0, r4
c0d08c1a:	4788      	blx	r1
        for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08c1c:	3708      	adds	r7, #8
c0d08c1e:	1c6d      	adds	r5, r5, #1
c0d08c20:	2d03      	cmp	r5, #3
c0d08c22:	d1e9      	bne.n	c0d08bf8 <USBD_LL_DataOutStage+0x76>
        USBD_CtlSendStatus(pdev);
c0d08c24:	4620      	mov	r0, r4
c0d08c26:	f000 fda9 	bl	c0d0977c <USBD_CtlSendStatus>
c0d08c2a:	2000      	movs	r0, #0
      }
    }
  }  
  return USBD_OK;
c0d08c2c:	b003      	add	sp, #12
c0d08c2e:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d08c30 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
c0d08c30:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08c32:	b081      	sub	sp, #4
c0d08c34:	4604      	mov	r4, r0
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
c0d08c36:	3098      	adds	r0, #152	; 0x98
c0d08c38:	9000      	str	r0, [sp, #0]
  USBD_EndpointTypeDef    *pep;
  UNUSED(pdata);
    
  if(epnum == 0) 
c0d08c3a:	2900      	cmp	r1, #0
c0d08c3c:	d01b      	beq.n	c0d08c76 <USBD_LL_DataInStage+0x46>
c0d08c3e:	460d      	mov	r5, r1
c0d08c40:	2600      	movs	r6, #0
c0d08c42:	27b4      	movs	r7, #180	; 0xb4
    }
  }
  else {
    uint8_t intf;
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->DataIn != NULL)&&
c0d08c44:	4620      	mov	r0, r4
c0d08c46:	4631      	mov	r1, r6
c0d08c48:	f000 f8a6 	bl	c0d08d98 <usbd_is_valid_intf>
c0d08c4c:	2800      	cmp	r0, #0
c0d08c4e:	d00d      	beq.n	c0d08c6c <USBD_LL_DataInStage+0x3c>
c0d08c50:	59e0      	ldr	r0, [r4, r7]
c0d08c52:	6940      	ldr	r0, [r0, #20]
c0d08c54:	2800      	cmp	r0, #0
c0d08c56:	d009      	beq.n	c0d08c6c <USBD_LL_DataInStage+0x3c>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d08c58:	9900      	ldr	r1, [sp, #0]
c0d08c5a:	7909      	ldrb	r1, [r1, #4]
      if( usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->DataIn != NULL)&&
c0d08c5c:	2903      	cmp	r1, #3
c0d08c5e:	d105      	bne.n	c0d08c6c <USBD_LL_DataInStage+0x3c>
      {
        ((DataIn_t)PIC(pdev->interfacesClass[intf].pClass->DataIn))(pdev, epnum); 
c0d08c60:	f7fc fd6a 	bl	c0d05738 <pic>
c0d08c64:	4602      	mov	r2, r0
c0d08c66:	4620      	mov	r0, r4
c0d08c68:	4629      	mov	r1, r5
c0d08c6a:	4790      	blx	r2
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08c6c:	3708      	adds	r7, #8
c0d08c6e:	1c76      	adds	r6, r6, #1
c0d08c70:	2e03      	cmp	r6, #3
c0d08c72:	d1e7      	bne.n	c0d08c44 <USBD_LL_DataInStage+0x14>
c0d08c74:	e04b      	b.n	c0d08d0e <USBD_LL_DataInStage+0xde>
c0d08c76:	2094      	movs	r0, #148	; 0x94
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
c0d08c78:	5820      	ldr	r0, [r4, r0]
c0d08c7a:	2802      	cmp	r0, #2
c0d08c7c:	d140      	bne.n	c0d08d00 <USBD_LL_DataInStage+0xd0>
      if(pep->rem_length > pep->maxpacket)
c0d08c7e:	69e0      	ldr	r0, [r4, #28]
c0d08c80:	6a25      	ldr	r5, [r4, #32]
c0d08c82:	42a8      	cmp	r0, r5
c0d08c84:	d90a      	bls.n	c0d08c9c <USBD_LL_DataInStage+0x6c>
c0d08c86:	22d0      	movs	r2, #208	; 0xd0
        pdev->pData += pep->maxpacket;
c0d08c88:	58a1      	ldr	r1, [r4, r2]
c0d08c8a:	1949      	adds	r1, r1, r5
c0d08c8c:	50a1      	str	r1, [r4, r2]
        pep->rem_length -=  pep->maxpacket;
c0d08c8e:	1b40      	subs	r0, r0, r5
c0d08c90:	61e0      	str	r0, [r4, #28]
        USBD_CtlContinueSendData (pdev, 
c0d08c92:	b282      	uxth	r2, r0
c0d08c94:	4620      	mov	r0, r4
c0d08c96:	f000 fd5c 	bl	c0d09752 <USBD_CtlContinueSendData>
c0d08c9a:	e031      	b.n	c0d08d00 <USBD_LL_DataInStage+0xd0>
        if((pep->total_length % pep->maxpacket == 0) &&
c0d08c9c:	69a6      	ldr	r6, [r4, #24]
c0d08c9e:	4630      	mov	r0, r6
c0d08ca0:	4629      	mov	r1, r5
c0d08ca2:	f001 fcc5 	bl	c0d0a630 <__aeabi_uidivmod>
c0d08ca6:	42ae      	cmp	r6, r5
c0d08ca8:	d30e      	bcc.n	c0d08cc8 <USBD_LL_DataInStage+0x98>
c0d08caa:	2900      	cmp	r1, #0
c0d08cac:	d10c      	bne.n	c0d08cc8 <USBD_LL_DataInStage+0x98>
             (pep->total_length < pdev->ep0_data_len ))
c0d08cae:	9800      	ldr	r0, [sp, #0]
c0d08cb0:	6800      	ldr	r0, [r0, #0]
        if((pep->total_length % pep->maxpacket == 0) &&
c0d08cb2:	4286      	cmp	r6, r0
c0d08cb4:	d208      	bcs.n	c0d08cc8 <USBD_LL_DataInStage+0x98>
c0d08cb6:	2500      	movs	r5, #0
          USBD_CtlContinueSendData(pdev , NULL, 0);
c0d08cb8:	4620      	mov	r0, r4
c0d08cba:	4629      	mov	r1, r5
c0d08cbc:	462a      	mov	r2, r5
c0d08cbe:	f000 fd48 	bl	c0d09752 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
c0d08cc2:	9800      	ldr	r0, [sp, #0]
c0d08cc4:	6005      	str	r5, [r0, #0]
c0d08cc6:	e01b      	b.n	c0d08d00 <USBD_LL_DataInStage+0xd0>
c0d08cc8:	2500      	movs	r5, #0
c0d08cca:	26b4      	movs	r6, #180	; 0xb4
            if(usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->EP0_TxSent != NULL)&&
c0d08ccc:	4620      	mov	r0, r4
c0d08cce:	4629      	mov	r1, r5
c0d08cd0:	f000 f862 	bl	c0d08d98 <usbd_is_valid_intf>
c0d08cd4:	2800      	cmp	r0, #0
c0d08cd6:	d00c      	beq.n	c0d08cf2 <USBD_LL_DataInStage+0xc2>
c0d08cd8:	59a0      	ldr	r0, [r4, r6]
c0d08cda:	68c0      	ldr	r0, [r0, #12]
c0d08cdc:	2800      	cmp	r0, #0
c0d08cde:	d008      	beq.n	c0d08cf2 <USBD_LL_DataInStage+0xc2>
               (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d08ce0:	9900      	ldr	r1, [sp, #0]
c0d08ce2:	7909      	ldrb	r1, [r1, #4]
            if(usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->EP0_TxSent != NULL)&&
c0d08ce4:	2903      	cmp	r1, #3
c0d08ce6:	d104      	bne.n	c0d08cf2 <USBD_LL_DataInStage+0xc2>
              ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_TxSent))(pdev); 
c0d08ce8:	f7fc fd26 	bl	c0d05738 <pic>
c0d08cec:	4601      	mov	r1, r0
c0d08cee:	4620      	mov	r0, r4
c0d08cf0:	4788      	blx	r1
          for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08cf2:	3608      	adds	r6, #8
c0d08cf4:	1c6d      	adds	r5, r5, #1
c0d08cf6:	2d03      	cmp	r5, #3
c0d08cf8:	d1e8      	bne.n	c0d08ccc <USBD_LL_DataInStage+0x9c>
          USBD_CtlReceiveStatus(pdev);
c0d08cfa:	4620      	mov	r0, r4
c0d08cfc:	f000 fd4a 	bl	c0d09794 <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode == 1)
c0d08d00:	9800      	ldr	r0, [sp, #0]
c0d08d02:	7a00      	ldrb	r0, [r0, #8]
c0d08d04:	2801      	cmp	r0, #1
c0d08d06:	d102      	bne.n	c0d08d0e <USBD_LL_DataInStage+0xde>
c0d08d08:	2000      	movs	r0, #0
      pdev->dev_test_mode = 0;
c0d08d0a:	9900      	ldr	r1, [sp, #0]
c0d08d0c:	7208      	strb	r0, [r1, #8]
c0d08d0e:	2000      	movs	r0, #0
      }
    }
  }
  return USBD_OK;
c0d08d10:	b001      	add	sp, #4
c0d08d12:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d08d14 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
c0d08d14:	b570      	push	{r4, r5, r6, lr}
c0d08d16:	4604      	mov	r4, r0
c0d08d18:	209c      	movs	r0, #156	; 0x9c
c0d08d1a:	2101      	movs	r1, #1
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
c0d08d1c:	5421      	strb	r1, [r4, r0]
c0d08d1e:	2040      	movs	r0, #64	; 0x40
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
c0d08d20:	6220      	str	r0, [r4, #32]
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
c0d08d22:	6620      	str	r0, [r4, #96]	; 0x60
c0d08d24:	2500      	movs	r5, #0
c0d08d26:	26b4      	movs	r6, #180	; 0xb4
 
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if( usbd_is_valid_intf(pdev, intf))
c0d08d28:	4620      	mov	r0, r4
c0d08d2a:	4629      	mov	r1, r5
c0d08d2c:	f000 f834 	bl	c0d08d98 <usbd_is_valid_intf>
c0d08d30:	2800      	cmp	r0, #0
c0d08d32:	d007      	beq.n	c0d08d44 <USBD_LL_Reset+0x30>
    {
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config); 
c0d08d34:	59a0      	ldr	r0, [r4, r6]
c0d08d36:	6840      	ldr	r0, [r0, #4]
c0d08d38:	f7fc fcfe 	bl	c0d05738 <pic>
c0d08d3c:	4602      	mov	r2, r0
c0d08d3e:	7921      	ldrb	r1, [r4, #4]
c0d08d40:	4620      	mov	r0, r4
c0d08d42:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08d44:	3608      	adds	r6, #8
c0d08d46:	1c6d      	adds	r5, r5, #1
c0d08d48:	2d03      	cmp	r5, #3
c0d08d4a:	d1ed      	bne.n	c0d08d28 <USBD_LL_Reset+0x14>
c0d08d4c:	2000      	movs	r0, #0
    }
  }
  
  return USBD_OK;
c0d08d4e:	bd70      	pop	{r4, r5, r6, pc}

c0d08d50 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
c0d08d50:	7401      	strb	r1, [r0, #16]
c0d08d52:	2000      	movs	r0, #0
  return USBD_OK;
c0d08d54:	4770      	bx	lr

c0d08d56 <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
c0d08d56:	2000      	movs	r0, #0
  UNUSED(pdev);
  // Ignored, gently
  //pdev->dev_old_state =  pdev->dev_state;
  //pdev->dev_state  = USBD_STATE_SUSPENDED;
  return USBD_OK;
c0d08d58:	4770      	bx	lr

c0d08d5a <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
c0d08d5a:	2000      	movs	r0, #0
  UNUSED(pdev);
  // Ignored, gently
  //pdev->dev_state = pdev->dev_old_state;  
  return USBD_OK;
c0d08d5c:	4770      	bx	lr

c0d08d5e <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
c0d08d5e:	b570      	push	{r4, r5, r6, lr}
c0d08d60:	4604      	mov	r4, r0
c0d08d62:	209c      	movs	r0, #156	; 0x9c
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
c0d08d64:	5c20      	ldrb	r0, [r4, r0]
c0d08d66:	2803      	cmp	r0, #3
c0d08d68:	d114      	bne.n	c0d08d94 <USBD_LL_SOF+0x36>
c0d08d6a:	2500      	movs	r5, #0
c0d08d6c:	26b4      	movs	r6, #180	; 0xb4
  {
    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) && pdev->interfacesClass[intf].pClass->SOF != NULL)
c0d08d6e:	4620      	mov	r0, r4
c0d08d70:	4629      	mov	r1, r5
c0d08d72:	f000 f811 	bl	c0d08d98 <usbd_is_valid_intf>
c0d08d76:	2800      	cmp	r0, #0
c0d08d78:	d008      	beq.n	c0d08d8c <USBD_LL_SOF+0x2e>
c0d08d7a:	59a0      	ldr	r0, [r4, r6]
c0d08d7c:	69c0      	ldr	r0, [r0, #28]
c0d08d7e:	2800      	cmp	r0, #0
c0d08d80:	d004      	beq.n	c0d08d8c <USBD_LL_SOF+0x2e>
      {
        ((SOF_t)PIC(pdev->interfacesClass[intf].pClass->SOF))(pdev); 
c0d08d82:	f7fc fcd9 	bl	c0d05738 <pic>
c0d08d86:	4601      	mov	r1, r0
c0d08d88:	4620      	mov	r0, r4
c0d08d8a:	4788      	blx	r1
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d08d8c:	3608      	adds	r6, #8
c0d08d8e:	1c6d      	adds	r5, r5, #1
c0d08d90:	2d03      	cmp	r5, #3
c0d08d92:	d1ec      	bne.n	c0d08d6e <USBD_LL_SOF+0x10>
c0d08d94:	2000      	movs	r0, #0
      }
    }
  }
  return USBD_OK;
c0d08d96:	bd70      	pop	{r4, r5, r6, pc}

c0d08d98 <usbd_is_valid_intf>:
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d08d98:	2902      	cmp	r1, #2
c0d08d9a:	d807      	bhi.n	c0d08dac <usbd_is_valid_intf+0x14>
c0d08d9c:	00c9      	lsls	r1, r1, #3
c0d08d9e:	1840      	adds	r0, r0, r1
c0d08da0:	21b4      	movs	r1, #180	; 0xb4
c0d08da2:	5840      	ldr	r0, [r0, r1]
c0d08da4:	2800      	cmp	r0, #0
c0d08da6:	d000      	beq.n	c0d08daa <usbd_is_valid_intf+0x12>
c0d08da8:	2001      	movs	r0, #1
c0d08daa:	4770      	bx	lr
c0d08dac:	2000      	movs	r0, #0
c0d08dae:	4770      	bx	lr

c0d08db0 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
c0d08db0:	b580      	push	{r7, lr}
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
c0d08db2:	784a      	ldrb	r2, [r1, #1]
c0d08db4:	2a04      	cmp	r2, #4
c0d08db6:	dd08      	ble.n	c0d08dca <USBD_StdDevReq+0x1a>
c0d08db8:	2a07      	cmp	r2, #7
c0d08dba:	dc0f      	bgt.n	c0d08ddc <USBD_StdDevReq+0x2c>
c0d08dbc:	2a05      	cmp	r2, #5
c0d08dbe:	d014      	beq.n	c0d08dea <USBD_StdDevReq+0x3a>
c0d08dc0:	2a06      	cmp	r2, #6
c0d08dc2:	d11b      	bne.n	c0d08dfc <USBD_StdDevReq+0x4c>
  {
  case USB_REQ_GET_DESCRIPTOR: 
    
    USBD_GetDescriptor (pdev, req) ;
c0d08dc4:	f000 f821 	bl	c0d08e0a <USBD_GetDescriptor>
c0d08dc8:	e01d      	b.n	c0d08e06 <USBD_StdDevReq+0x56>
  switch (req->bRequest) 
c0d08dca:	2a00      	cmp	r2, #0
c0d08dcc:	d010      	beq.n	c0d08df0 <USBD_StdDevReq+0x40>
c0d08dce:	2a01      	cmp	r2, #1
c0d08dd0:	d017      	beq.n	c0d08e02 <USBD_StdDevReq+0x52>
c0d08dd2:	2a03      	cmp	r2, #3
c0d08dd4:	d112      	bne.n	c0d08dfc <USBD_StdDevReq+0x4c>
    USBD_GetStatus (pdev , req);
    break;
    
    
  case USB_REQ_SET_FEATURE:   
    USBD_SetFeature (pdev , req);    
c0d08dd6:	f000 f936 	bl	c0d09046 <USBD_SetFeature>
c0d08dda:	e014      	b.n	c0d08e06 <USBD_StdDevReq+0x56>
  switch (req->bRequest) 
c0d08ddc:	2a08      	cmp	r2, #8
c0d08dde:	d00a      	beq.n	c0d08df6 <USBD_StdDevReq+0x46>
c0d08de0:	2a09      	cmp	r2, #9
c0d08de2:	d10b      	bne.n	c0d08dfc <USBD_StdDevReq+0x4c>
    USBD_SetConfig (pdev , req);
c0d08de4:	f000 f8bd 	bl	c0d08f62 <USBD_SetConfig>
c0d08de8:	e00d      	b.n	c0d08e06 <USBD_StdDevReq+0x56>
    USBD_SetAddress(pdev, req);
c0d08dea:	f000 f894 	bl	c0d08f16 <USBD_SetAddress>
c0d08dee:	e00a      	b.n	c0d08e06 <USBD_StdDevReq+0x56>
    USBD_GetStatus (pdev , req);
c0d08df0:	f000 f906 	bl	c0d09000 <USBD_GetStatus>
c0d08df4:	e007      	b.n	c0d08e06 <USBD_StdDevReq+0x56>
    USBD_GetConfig (pdev , req);
c0d08df6:	f000 f8ec 	bl	c0d08fd2 <USBD_GetConfig>
c0d08dfa:	e004      	b.n	c0d08e06 <USBD_StdDevReq+0x56>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
c0d08dfc:	f000 fbe2 	bl	c0d095c4 <USBD_CtlError>
c0d08e00:	e001      	b.n	c0d08e06 <USBD_StdDevReq+0x56>
    USBD_ClrFeature (pdev , req);
c0d08e02:	f000 f93d 	bl	c0d09080 <USBD_ClrFeature>
c0d08e06:	2000      	movs	r0, #0
    break;
  }
  
  return ret;
c0d08e08:	bd80      	pop	{r7, pc}

c0d08e0a <USBD_GetDescriptor>:
* @param  req: usb request
* @retval status
*/
void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
                               USBD_SetupReqTypedef *req)
{
c0d08e0a:	b5b0      	push	{r4, r5, r7, lr}
c0d08e0c:	b082      	sub	sp, #8
c0d08e0e:	460d      	mov	r5, r1
c0d08e10:	4604      	mov	r4, r0
c0d08e12:	a801      	add	r0, sp, #4
c0d08e14:	2100      	movs	r1, #0
  uint16_t len = 0;
c0d08e16:	8001      	strh	r1, [r0, #0]
  uint8_t *pbuf = NULL;
  
    
  switch (req->wValue >> 8)
c0d08e18:	886a      	ldrh	r2, [r5, #2]
c0d08e1a:	0a10      	lsrs	r0, r2, #8
c0d08e1c:	2805      	cmp	r0, #5
c0d08e1e:	dc12      	bgt.n	c0d08e46 <USBD_GetDescriptor+0x3c>
c0d08e20:	2801      	cmp	r0, #1
c0d08e22:	d01c      	beq.n	c0d08e5e <USBD_GetDescriptor+0x54>
c0d08e24:	2802      	cmp	r0, #2
c0d08e26:	d024      	beq.n	c0d08e72 <USBD_GetDescriptor+0x68>
c0d08e28:	2803      	cmp	r0, #3
c0d08e2a:	d137      	bne.n	c0d08e9c <USBD_GetDescriptor+0x92>
      }
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
c0d08e2c:	b2d0      	uxtb	r0, r2
c0d08e2e:	2802      	cmp	r0, #2
c0d08e30:	dc39      	bgt.n	c0d08ea6 <USBD_GetDescriptor+0x9c>
c0d08e32:	2800      	cmp	r0, #0
c0d08e34:	d05f      	beq.n	c0d08ef6 <USBD_GetDescriptor+0xec>
c0d08e36:	2801      	cmp	r0, #1
c0d08e38:	d065      	beq.n	c0d08f06 <USBD_GetDescriptor+0xfc>
c0d08e3a:	2802      	cmp	r0, #2
c0d08e3c:	d12e      	bne.n	c0d08e9c <USBD_GetDescriptor+0x92>
c0d08e3e:	20b0      	movs	r0, #176	; 0xb0
    case USBD_IDX_MFC_STR:
      pbuf = ((GetManufacturerStrDescriptor_t)PIC(pdev->pDesc->GetManufacturerStrDescriptor))(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = ((GetProductStrDescriptor_t)PIC(pdev->pDesc->GetProductStrDescriptor))(pdev->dev_speed, &len);
c0d08e40:	5820      	ldr	r0, [r4, r0]
c0d08e42:	68c0      	ldr	r0, [r0, #12]
c0d08e44:	e00e      	b.n	c0d08e64 <USBD_GetDescriptor+0x5a>
  switch (req->wValue >> 8)
c0d08e46:	2806      	cmp	r0, #6
c0d08e48:	d01c      	beq.n	c0d08e84 <USBD_GetDescriptor+0x7a>
c0d08e4a:	2807      	cmp	r0, #7
c0d08e4c:	d023      	beq.n	c0d08e96 <USBD_GetDescriptor+0x8c>
c0d08e4e:	280f      	cmp	r0, #15
c0d08e50:	d124      	bne.n	c0d08e9c <USBD_GetDescriptor+0x92>
c0d08e52:	20b0      	movs	r0, #176	; 0xb0
    if(pdev->pDesc->GetBOSDescriptor != NULL) {
c0d08e54:	5820      	ldr	r0, [r4, r0]
c0d08e56:	69c0      	ldr	r0, [r0, #28]
c0d08e58:	2800      	cmp	r0, #0
c0d08e5a:	d103      	bne.n	c0d08e64 <USBD_GetDescriptor+0x5a>
c0d08e5c:	e01e      	b.n	c0d08e9c <USBD_GetDescriptor+0x92>
c0d08e5e:	20b0      	movs	r0, #176	; 0xb0
    pbuf = ((GetDeviceDescriptor_t)PIC(pdev->pDesc->GetDeviceDescriptor))(pdev->dev_speed, &len);
c0d08e60:	5820      	ldr	r0, [r4, r0]
c0d08e62:	6800      	ldr	r0, [r0, #0]
c0d08e64:	f7fc fc68 	bl	c0d05738 <pic>
c0d08e68:	4602      	mov	r2, r0
c0d08e6a:	7c20      	ldrb	r0, [r4, #16]
c0d08e6c:	a901      	add	r1, sp, #4
c0d08e6e:	4790      	blx	r2
c0d08e70:	e02f      	b.n	c0d08ed2 <USBD_GetDescriptor+0xc8>
c0d08e72:	20b4      	movs	r0, #180	; 0xb4
    if(pdev->interfacesClass[0].pClass != NULL) {
c0d08e74:	5820      	ldr	r0, [r4, r0]
c0d08e76:	2800      	cmp	r0, #0
c0d08e78:	d02c      	beq.n	c0d08ed4 <USBD_GetDescriptor+0xca>
      if(pdev->dev_speed == USBD_SPEED_HIGH )   
c0d08e7a:	7c21      	ldrb	r1, [r4, #16]
c0d08e7c:	2900      	cmp	r1, #0
c0d08e7e:	d022      	beq.n	c0d08ec6 <USBD_GetDescriptor+0xbc>
        pbuf   = (uint8_t *)((GetFSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetFSConfigDescriptor))(&len);
c0d08e80:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
c0d08e82:	e021      	b.n	c0d08ec8 <USBD_GetDescriptor+0xbe>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL )   
c0d08e84:	7c20      	ldrb	r0, [r4, #16]
c0d08e86:	2800      	cmp	r0, #0
c0d08e88:	d108      	bne.n	c0d08e9c <USBD_GetDescriptor+0x92>
c0d08e8a:	20b4      	movs	r0, #180	; 0xb4
c0d08e8c:	5820      	ldr	r0, [r4, r0]
c0d08e8e:	2800      	cmp	r0, #0
c0d08e90:	d004      	beq.n	c0d08e9c <USBD_GetDescriptor+0x92>
    {
      pbuf   = (uint8_t *)((GetDeviceQualifierDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetDeviceQualifierDescriptor))(&len);
c0d08e92:	6b40      	ldr	r0, [r0, #52]	; 0x34
c0d08e94:	e018      	b.n	c0d08ec8 <USBD_GetDescriptor+0xbe>
    {
      goto default_error;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL)   
c0d08e96:	7c20      	ldrb	r0, [r4, #16]
c0d08e98:	2800      	cmp	r0, #0
c0d08e9a:	d00e      	beq.n	c0d08eba <USBD_GetDescriptor+0xb0>
      goto default_error;
    }

  default: 
  default_error:
     USBD_CtlError(pdev , req);
c0d08e9c:	4620      	mov	r0, r4
c0d08e9e:	4629      	mov	r1, r5
c0d08ea0:	f000 fb90 	bl	c0d095c4 <USBD_CtlError>
c0d08ea4:	e025      	b.n	c0d08ef2 <USBD_GetDescriptor+0xe8>
    switch ((uint8_t)(req->wValue))
c0d08ea6:	2803      	cmp	r0, #3
c0d08ea8:	d029      	beq.n	c0d08efe <USBD_GetDescriptor+0xf4>
c0d08eaa:	2804      	cmp	r0, #4
c0d08eac:	d02f      	beq.n	c0d08f0e <USBD_GetDescriptor+0x104>
c0d08eae:	2805      	cmp	r0, #5
c0d08eb0:	d1f4      	bne.n	c0d08e9c <USBD_GetDescriptor+0x92>
c0d08eb2:	20b0      	movs	r0, #176	; 0xb0
      pbuf = ((GetInterfaceStrDescriptor_t)PIC(pdev->pDesc->GetInterfaceStrDescriptor))(pdev->dev_speed, &len);
c0d08eb4:	5820      	ldr	r0, [r4, r0]
c0d08eb6:	6980      	ldr	r0, [r0, #24]
c0d08eb8:	e7d4      	b.n	c0d08e64 <USBD_GetDescriptor+0x5a>
c0d08eba:	20b4      	movs	r0, #180	; 0xb4
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL)   
c0d08ebc:	5820      	ldr	r0, [r4, r0]
c0d08ebe:	2800      	cmp	r0, #0
c0d08ec0:	d0ec      	beq.n	c0d08e9c <USBD_GetDescriptor+0x92>
      pbuf   = (uint8_t *)((GetOtherSpeedConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetOtherSpeedConfigDescriptor))(&len);
c0d08ec2:	6b00      	ldr	r0, [r0, #48]	; 0x30
c0d08ec4:	e000      	b.n	c0d08ec8 <USBD_GetDescriptor+0xbe>
        pbuf   = (uint8_t *)((GetHSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetHSConfigDescriptor))(&len);
c0d08ec6:	6a80      	ldr	r0, [r0, #40]	; 0x28
c0d08ec8:	f7fc fc36 	bl	c0d05738 <pic>
c0d08ecc:	4601      	mov	r1, r0
c0d08ece:	a801      	add	r0, sp, #4
c0d08ed0:	4788      	blx	r1
c0d08ed2:	4601      	mov	r1, r0
c0d08ed4:	a801      	add	r0, sp, #4
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
c0d08ed6:	8802      	ldrh	r2, [r0, #0]
c0d08ed8:	2a00      	cmp	r2, #0
c0d08eda:	d00a      	beq.n	c0d08ef2 <USBD_GetDescriptor+0xe8>
c0d08edc:	88e8      	ldrh	r0, [r5, #6]
c0d08ede:	2800      	cmp	r0, #0
c0d08ee0:	d007      	beq.n	c0d08ef2 <USBD_GetDescriptor+0xe8>
  {
    
    len = MIN(len , req->wLength);
c0d08ee2:	4282      	cmp	r2, r0
c0d08ee4:	d300      	bcc.n	c0d08ee8 <USBD_GetDescriptor+0xde>
c0d08ee6:	4602      	mov	r2, r0
c0d08ee8:	a801      	add	r0, sp, #4
c0d08eea:	8002      	strh	r2, [r0, #0]
    
    // prepare abort if host does not read the whole data
    //USBD_CtlReceiveStatus(pdev);

    // start transfer
    USBD_CtlSendData (pdev, 
c0d08eec:	4620      	mov	r0, r4
c0d08eee:	f000 fc1b 	bl	c0d09728 <USBD_CtlSendData>
                      pbuf,
                      len);
  }
  
}
c0d08ef2:	b002      	add	sp, #8
c0d08ef4:	bdb0      	pop	{r4, r5, r7, pc}
c0d08ef6:	20b0      	movs	r0, #176	; 0xb0
     pbuf = ((GetLangIDStrDescriptor_t)PIC(pdev->pDesc->GetLangIDStrDescriptor))(pdev->dev_speed, &len);        
c0d08ef8:	5820      	ldr	r0, [r4, r0]
c0d08efa:	6840      	ldr	r0, [r0, #4]
c0d08efc:	e7b2      	b.n	c0d08e64 <USBD_GetDescriptor+0x5a>
c0d08efe:	20b0      	movs	r0, #176	; 0xb0
      pbuf = ((GetSerialStrDescriptor_t)PIC(pdev->pDesc->GetSerialStrDescriptor))(pdev->dev_speed, &len);
c0d08f00:	5820      	ldr	r0, [r4, r0]
c0d08f02:	6900      	ldr	r0, [r0, #16]
c0d08f04:	e7ae      	b.n	c0d08e64 <USBD_GetDescriptor+0x5a>
c0d08f06:	20b0      	movs	r0, #176	; 0xb0
      pbuf = ((GetManufacturerStrDescriptor_t)PIC(pdev->pDesc->GetManufacturerStrDescriptor))(pdev->dev_speed, &len);
c0d08f08:	5820      	ldr	r0, [r4, r0]
c0d08f0a:	6880      	ldr	r0, [r0, #8]
c0d08f0c:	e7aa      	b.n	c0d08e64 <USBD_GetDescriptor+0x5a>
c0d08f0e:	20b0      	movs	r0, #176	; 0xb0
      pbuf = ((GetConfigurationStrDescriptor_t)PIC(pdev->pDesc->GetConfigurationStrDescriptor))(pdev->dev_speed, &len);
c0d08f10:	5820      	ldr	r0, [r4, r0]
c0d08f12:	6940      	ldr	r0, [r0, #20]
c0d08f14:	e7a6      	b.n	c0d08e64 <USBD_GetDescriptor+0x5a>

c0d08f16 <USBD_SetAddress>:
* @param  req: usb request
* @retval status
*/
void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d08f16:	b570      	push	{r4, r5, r6, lr}
c0d08f18:	4604      	mov	r4, r0
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
c0d08f1a:	8888      	ldrh	r0, [r1, #4]
c0d08f1c:	2800      	cmp	r0, #0
c0d08f1e:	d106      	bne.n	c0d08f2e <USBD_SetAddress+0x18>
c0d08f20:	88c8      	ldrh	r0, [r1, #6]
c0d08f22:	2800      	cmp	r0, #0
c0d08f24:	d103      	bne.n	c0d08f2e <USBD_SetAddress+0x18>
c0d08f26:	209c      	movs	r0, #156	; 0x9c
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
c0d08f28:	5c20      	ldrb	r0, [r4, r0]
c0d08f2a:	2803      	cmp	r0, #3
c0d08f2c:	d103      	bne.n	c0d08f36 <USBD_SetAddress+0x20>
c0d08f2e:	4620      	mov	r0, r4
c0d08f30:	f000 fb48 	bl	c0d095c4 <USBD_CtlError>
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
  } 
}
c0d08f34:	bd70      	pop	{r4, r5, r6, pc}
c0d08f36:	8848      	ldrh	r0, [r1, #2]
c0d08f38:	257f      	movs	r5, #127	; 0x7f
c0d08f3a:	4005      	ands	r5, r0
c0d08f3c:	4626      	mov	r6, r4
c0d08f3e:	369c      	adds	r6, #156	; 0x9c
c0d08f40:	209e      	movs	r0, #158	; 0x9e
      pdev->dev_address = dev_addr;
c0d08f42:	5425      	strb	r5, [r4, r0]
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
c0d08f44:	4620      	mov	r0, r4
c0d08f46:	4629      	mov	r1, r5
c0d08f48:	f7ff fd34 	bl	c0d089b4 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
c0d08f4c:	4620      	mov	r0, r4
c0d08f4e:	f000 fc15 	bl	c0d0977c <USBD_CtlSendStatus>
      if (dev_addr != 0) 
c0d08f52:	2d00      	cmp	r5, #0
c0d08f54:	d002      	beq.n	c0d08f5c <USBD_SetAddress+0x46>
c0d08f56:	2002      	movs	r0, #2
        pdev->dev_state  = USBD_STATE_ADDRESSED;
c0d08f58:	7030      	strb	r0, [r6, #0]
}
c0d08f5a:	bd70      	pop	{r4, r5, r6, pc}
c0d08f5c:	2001      	movs	r0, #1
        pdev->dev_state  = USBD_STATE_DEFAULT; 
c0d08f5e:	7030      	strb	r0, [r6, #0]
}
c0d08f60:	bd70      	pop	{r4, r5, r6, pc}

c0d08f62 <USBD_SetConfig>:
* @param  req: usb request
* @retval status
*/
void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d08f62:	b570      	push	{r4, r5, r6, lr}
c0d08f64:	460d      	mov	r5, r1
c0d08f66:	4604      	mov	r4, r0
  
  uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
c0d08f68:	788e      	ldrb	r6, [r1, #2]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
c0d08f6a:	2e02      	cmp	r6, #2
c0d08f6c:	d21d      	bcs.n	c0d08faa <USBD_SetConfig+0x48>
c0d08f6e:	209c      	movs	r0, #156	; 0x9c
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
c0d08f70:	5c21      	ldrb	r1, [r4, r0]
c0d08f72:	4620      	mov	r0, r4
c0d08f74:	309c      	adds	r0, #156	; 0x9c
c0d08f76:	2903      	cmp	r1, #3
c0d08f78:	d007      	beq.n	c0d08f8a <USBD_SetConfig+0x28>
c0d08f7a:	2902      	cmp	r1, #2
c0d08f7c:	d115      	bne.n	c0d08faa <USBD_SetConfig+0x48>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
c0d08f7e:	2e00      	cmp	r6, #0
c0d08f80:	d023      	beq.n	c0d08fca <USBD_SetConfig+0x68>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
c0d08f82:	6066      	str	r6, [r4, #4]
c0d08f84:	2103      	movs	r1, #3
        pdev->dev_state = USBD_STATE_CONFIGURED;
c0d08f86:	7001      	strb	r1, [r0, #0]
c0d08f88:	e009      	b.n	c0d08f9e <USBD_SetConfig+0x3c>
      }
      USBD_CtlSendStatus(pdev);
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
c0d08f8a:	2e00      	cmp	r6, #0
c0d08f8c:	d012      	beq.n	c0d08fb4 <USBD_SetConfig+0x52>
        pdev->dev_state = USBD_STATE_ADDRESSED;
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
      } 
      else  if (cfgidx != pdev->dev_config) 
c0d08f8e:	6860      	ldr	r0, [r4, #4]
c0d08f90:	42b0      	cmp	r0, r6
c0d08f92:	d01a      	beq.n	c0d08fca <USBD_SetConfig+0x68>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
c0d08f94:	b2c1      	uxtb	r1, r0
c0d08f96:	4620      	mov	r0, r4
c0d08f98:	f7ff fdaa 	bl	c0d08af0 <USBD_ClrClassConfig>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
c0d08f9c:	6066      	str	r6, [r4, #4]
c0d08f9e:	4620      	mov	r0, r4
c0d08fa0:	4631      	mov	r1, r6
c0d08fa2:	f7ff fd8a 	bl	c0d08aba <USBD_SetClassConfig>
c0d08fa6:	2802      	cmp	r0, #2
c0d08fa8:	d10f      	bne.n	c0d08fca <USBD_SetConfig+0x68>
c0d08faa:	4620      	mov	r0, r4
c0d08fac:	4629      	mov	r1, r5
c0d08fae:	f000 fb09 	bl	c0d095c4 <USBD_CtlError>
    default:					
       USBD_CtlError(pdev , req);                     
      break;
    }
  }
}
c0d08fb2:	bd70      	pop	{r4, r5, r6, pc}
c0d08fb4:	2102      	movs	r1, #2
        pdev->dev_state = USBD_STATE_ADDRESSED;
c0d08fb6:	7001      	strb	r1, [r0, #0]
c0d08fb8:	2000      	movs	r0, #0
        pdev->dev_config = cfgidx;          
c0d08fba:	6060      	str	r0, [r4, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
c0d08fbc:	4620      	mov	r0, r4
c0d08fbe:	4631      	mov	r1, r6
c0d08fc0:	f7ff fd96 	bl	c0d08af0 <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
c0d08fc4:	4620      	mov	r0, r4
c0d08fc6:	f000 fbd9 	bl	c0d0977c <USBD_CtlSendStatus>
c0d08fca:	4620      	mov	r0, r4
c0d08fcc:	f000 fbd6 	bl	c0d0977c <USBD_CtlSendStatus>
}
c0d08fd0:	bd70      	pop	{r4, r5, r6, pc}

c0d08fd2 <USBD_GetConfig>:
* @param  req: usb request
* @retval status
*/
void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d08fd2:	b580      	push	{r7, lr}

  if (req->wLength != 1) 
c0d08fd4:	88ca      	ldrh	r2, [r1, #6]
c0d08fd6:	2a01      	cmp	r2, #1
c0d08fd8:	d10a      	bne.n	c0d08ff0 <USBD_GetConfig+0x1e>
c0d08fda:	229c      	movs	r2, #156	; 0x9c
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
c0d08fdc:	5c82      	ldrb	r2, [r0, r2]
c0d08fde:	2a03      	cmp	r2, #3
c0d08fe0:	d009      	beq.n	c0d08ff6 <USBD_GetConfig+0x24>
c0d08fe2:	2a02      	cmp	r2, #2
c0d08fe4:	d104      	bne.n	c0d08ff0 <USBD_GetConfig+0x1e>
c0d08fe6:	2100      	movs	r1, #0
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
c0d08fe8:	6081      	str	r1, [r0, #8]
c0d08fea:	4601      	mov	r1, r0
c0d08fec:	3108      	adds	r1, #8
c0d08fee:	e003      	b.n	c0d08ff8 <USBD_GetConfig+0x26>
c0d08ff0:	f000 fae8 	bl	c0d095c4 <USBD_CtlError>
    default:
       USBD_CtlError(pdev , req);
      break;
    }
  }
}
c0d08ff4:	bd80      	pop	{r7, pc}
                        (uint8_t *)&pdev->dev_config,
c0d08ff6:	1d01      	adds	r1, r0, #4
c0d08ff8:	2201      	movs	r2, #1
c0d08ffa:	f000 fb95 	bl	c0d09728 <USBD_CtlSendData>
}
c0d08ffe:	bd80      	pop	{r7, pc}

c0d09000 <USBD_GetStatus>:
* @param  req: usb request
* @retval status
*/
void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d09000:	b5b0      	push	{r4, r5, r7, lr}
c0d09002:	4604      	mov	r4, r0
c0d09004:	209c      	movs	r0, #156	; 0x9c
  
    
  switch (pdev->dev_state) 
c0d09006:	5c20      	ldrb	r0, [r4, r0]
c0d09008:	22fe      	movs	r2, #254	; 0xfe
c0d0900a:	4002      	ands	r2, r0
c0d0900c:	2a02      	cmp	r2, #2
c0d0900e:	d10e      	bne.n	c0d0902e <USBD_GetStatus+0x2e>
c0d09010:	2001      	movs	r0, #1
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
c0d09012:	60e0      	str	r0, [r4, #12]
c0d09014:	20a4      	movs	r0, #164	; 0xa4
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0d09016:	5820      	ldr	r0, [r4, r0]
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
c0d09018:	4625      	mov	r5, r4
c0d0901a:	350c      	adds	r5, #12
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0d0901c:	2800      	cmp	r0, #0
c0d0901e:	d00a      	beq.n	c0d09036 <USBD_GetStatus+0x36>
c0d09020:	4620      	mov	r0, r4
c0d09022:	f000 fbb7 	bl	c0d09794 <USBD_CtlReceiveStatus>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
c0d09026:	68e1      	ldr	r1, [r4, #12]
c0d09028:	2002      	movs	r0, #2
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0d0902a:	4308      	orrs	r0, r1
c0d0902c:	e004      	b.n	c0d09038 <USBD_GetStatus+0x38>
                      (uint8_t *)& pdev->dev_config_status,
                      2);
    break;
    
  default :
    USBD_CtlError(pdev , req);                        
c0d0902e:	4620      	mov	r0, r4
c0d09030:	f000 fac8 	bl	c0d095c4 <USBD_CtlError>
    break;
  }
}
c0d09034:	bdb0      	pop	{r4, r5, r7, pc}
c0d09036:	2003      	movs	r0, #3
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
c0d09038:	60e0      	str	r0, [r4, #12]
c0d0903a:	2202      	movs	r2, #2
    USBD_CtlSendData (pdev, 
c0d0903c:	4620      	mov	r0, r4
c0d0903e:	4629      	mov	r1, r5
c0d09040:	f000 fb72 	bl	c0d09728 <USBD_CtlSendData>
}
c0d09044:	bdb0      	pop	{r4, r5, r7, pc}

c0d09046 <USBD_SetFeature>:
* @param  req: usb request
* @retval status
*/
void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d09046:	b5b0      	push	{r4, r5, r7, lr}
c0d09048:	4604      	mov	r4, r0

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
c0d0904a:	8848      	ldrh	r0, [r1, #2]
c0d0904c:	2801      	cmp	r0, #1
c0d0904e:	d116      	bne.n	c0d0907e <USBD_SetFeature+0x38>
c0d09050:	460d      	mov	r5, r1
c0d09052:	20a4      	movs	r0, #164	; 0xa4
c0d09054:	2101      	movs	r1, #1
  {
    pdev->dev_remote_wakeup = 1;  
c0d09056:	5021      	str	r1, [r4, r0]
    if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d09058:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d0905a:	2802      	cmp	r0, #2
c0d0905c:	d80c      	bhi.n	c0d09078 <USBD_SetFeature+0x32>
c0d0905e:	00c0      	lsls	r0, r0, #3
c0d09060:	1820      	adds	r0, r4, r0
c0d09062:	21b4      	movs	r1, #180	; 0xb4
c0d09064:	5840      	ldr	r0, [r0, r1]
    if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d09066:	2800      	cmp	r0, #0
c0d09068:	d006      	beq.n	c0d09078 <USBD_SetFeature+0x32>
      ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);   
c0d0906a:	6880      	ldr	r0, [r0, #8]
c0d0906c:	f7fc fb64 	bl	c0d05738 <pic>
c0d09070:	4602      	mov	r2, r0
c0d09072:	4620      	mov	r0, r4
c0d09074:	4629      	mov	r1, r5
c0d09076:	4790      	blx	r2
    }
    USBD_CtlSendStatus(pdev);
c0d09078:	4620      	mov	r0, r4
c0d0907a:	f000 fb7f 	bl	c0d0977c <USBD_CtlSendStatus>
  }

}
c0d0907e:	bdb0      	pop	{r4, r5, r7, pc}

c0d09080 <USBD_ClrFeature>:
* @param  req: usb request
* @retval status
*/
void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d09080:	b5b0      	push	{r4, r5, r7, lr}
c0d09082:	460d      	mov	r5, r1
c0d09084:	4604      	mov	r4, r0
c0d09086:	209c      	movs	r0, #156	; 0x9c
  switch (pdev->dev_state)
c0d09088:	5c20      	ldrb	r0, [r4, r0]
c0d0908a:	21fe      	movs	r1, #254	; 0xfe
c0d0908c:	4001      	ands	r1, r0
c0d0908e:	2902      	cmp	r1, #2
c0d09090:	d119      	bne.n	c0d090c6 <USBD_ClrFeature+0x46>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
c0d09092:	8868      	ldrh	r0, [r5, #2]
c0d09094:	2801      	cmp	r0, #1
c0d09096:	d11a      	bne.n	c0d090ce <USBD_ClrFeature+0x4e>
c0d09098:	20a4      	movs	r0, #164	; 0xa4
c0d0909a:	2100      	movs	r1, #0
    {
      pdev->dev_remote_wakeup = 0; 
c0d0909c:	5021      	str	r1, [r4, r0]
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d0909e:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d090a0:	2802      	cmp	r0, #2
c0d090a2:	d80c      	bhi.n	c0d090be <USBD_ClrFeature+0x3e>
c0d090a4:	00c0      	lsls	r0, r0, #3
c0d090a6:	1820      	adds	r0, r4, r0
c0d090a8:	21b4      	movs	r1, #180	; 0xb4
c0d090aa:	5840      	ldr	r0, [r0, r1]
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d090ac:	2800      	cmp	r0, #0
c0d090ae:	d006      	beq.n	c0d090be <USBD_ClrFeature+0x3e>
        ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);   
c0d090b0:	6880      	ldr	r0, [r0, #8]
c0d090b2:	f7fc fb41 	bl	c0d05738 <pic>
c0d090b6:	4602      	mov	r2, r0
c0d090b8:	4620      	mov	r0, r4
c0d090ba:	4629      	mov	r1, r5
c0d090bc:	4790      	blx	r2
      }
      USBD_CtlSendStatus(pdev);
c0d090be:	4620      	mov	r0, r4
c0d090c0:	f000 fb5c 	bl	c0d0977c <USBD_CtlSendStatus>
    
  default :
     USBD_CtlError(pdev , req);
    break;
  }
}
c0d090c4:	bdb0      	pop	{r4, r5, r7, pc}
     USBD_CtlError(pdev , req);
c0d090c6:	4620      	mov	r0, r4
c0d090c8:	4629      	mov	r1, r5
c0d090ca:	f000 fa7b 	bl	c0d095c4 <USBD_CtlError>
}
c0d090ce:	bdb0      	pop	{r4, r5, r7, pc}

c0d090d0 <USBD_StdItfReq>:
{
c0d090d0:	b5b0      	push	{r4, r5, r7, lr}
c0d090d2:	460d      	mov	r5, r1
c0d090d4:	4604      	mov	r4, r0
c0d090d6:	209c      	movs	r0, #156	; 0x9c
  switch (pdev->dev_state) 
c0d090d8:	5c20      	ldrb	r0, [r4, r0]
c0d090da:	2803      	cmp	r0, #3
c0d090dc:	d116      	bne.n	c0d0910c <USBD_StdItfReq+0x3c>
    if (usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) 
c0d090de:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d090e0:	2802      	cmp	r0, #2
c0d090e2:	d813      	bhi.n	c0d0910c <USBD_StdItfReq+0x3c>
c0d090e4:	00c0      	lsls	r0, r0, #3
c0d090e6:	1820      	adds	r0, r4, r0
c0d090e8:	21b4      	movs	r1, #180	; 0xb4
c0d090ea:	5840      	ldr	r0, [r0, r1]
    if (usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) 
c0d090ec:	2800      	cmp	r0, #0
c0d090ee:	d00d      	beq.n	c0d0910c <USBD_StdItfReq+0x3c>
      ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);
c0d090f0:	6880      	ldr	r0, [r0, #8]
c0d090f2:	f7fc fb21 	bl	c0d05738 <pic>
c0d090f6:	4602      	mov	r2, r0
c0d090f8:	4620      	mov	r0, r4
c0d090fa:	4629      	mov	r1, r5
c0d090fc:	4790      	blx	r2
      if((req->wLength == 0)&& (ret == USBD_OK))
c0d090fe:	88e8      	ldrh	r0, [r5, #6]
c0d09100:	2800      	cmp	r0, #0
c0d09102:	d107      	bne.n	c0d09114 <USBD_StdItfReq+0x44>
         USBD_CtlSendStatus(pdev);
c0d09104:	4620      	mov	r0, r4
c0d09106:	f000 fb39 	bl	c0d0977c <USBD_CtlSendStatus>
c0d0910a:	e003      	b.n	c0d09114 <USBD_StdItfReq+0x44>
c0d0910c:	4620      	mov	r0, r4
c0d0910e:	4629      	mov	r1, r5
c0d09110:	f000 fa58 	bl	c0d095c4 <USBD_CtlError>
c0d09114:	2000      	movs	r0, #0
  return USBD_OK;
c0d09116:	bdb0      	pop	{r4, r5, r7, pc}

c0d09118 <USBD_StdEPReq>:
{
c0d09118:	b5b0      	push	{r4, r5, r7, lr}
c0d0911a:	460d      	mov	r5, r1
c0d0911c:	4604      	mov	r4, r0
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d0911e:	7808      	ldrb	r0, [r1, #0]
c0d09120:	2260      	movs	r2, #96	; 0x60
c0d09122:	4002      	ands	r2, r0
  ep_addr  = LOBYTE(req->wIndex);   
c0d09124:	7909      	ldrb	r1, [r1, #4]
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d09126:	2a20      	cmp	r2, #32
c0d09128:	d10f      	bne.n	c0d0914a <USBD_StdEPReq+0x32>
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d0912a:	2902      	cmp	r1, #2
c0d0912c:	d80d      	bhi.n	c0d0914a <USBD_StdEPReq+0x32>
c0d0912e:	00c8      	lsls	r0, r1, #3
c0d09130:	1820      	adds	r0, r4, r0
c0d09132:	22b4      	movs	r2, #180	; 0xb4
c0d09134:	5880      	ldr	r0, [r0, r2]
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d09136:	2800      	cmp	r0, #0
c0d09138:	d007      	beq.n	c0d0914a <USBD_StdEPReq+0x32>
    ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);
c0d0913a:	6880      	ldr	r0, [r0, #8]
c0d0913c:	f7fc fafc 	bl	c0d05738 <pic>
c0d09140:	4602      	mov	r2, r0
c0d09142:	4620      	mov	r0, r4
c0d09144:	4629      	mov	r1, r5
c0d09146:	4790      	blx	r2
c0d09148:	e066      	b.n	c0d09218 <USBD_StdEPReq+0x100>
  switch (req->bRequest) 
c0d0914a:	7868      	ldrb	r0, [r5, #1]
c0d0914c:	2800      	cmp	r0, #0
c0d0914e:	d016      	beq.n	c0d0917e <USBD_StdEPReq+0x66>
c0d09150:	2801      	cmp	r0, #1
c0d09152:	d01d      	beq.n	c0d09190 <USBD_StdEPReq+0x78>
c0d09154:	2803      	cmp	r0, #3
c0d09156:	d15f      	bne.n	c0d09218 <USBD_StdEPReq+0x100>
c0d09158:	209c      	movs	r0, #156	; 0x9c
    switch (pdev->dev_state) 
c0d0915a:	5c20      	ldrb	r0, [r4, r0]
c0d0915c:	2803      	cmp	r0, #3
c0d0915e:	d11b      	bne.n	c0d09198 <USBD_StdEPReq+0x80>
      if (req->wValue == USB_FEATURE_EP_HALT)
c0d09160:	8868      	ldrh	r0, [r5, #2]
c0d09162:	2800      	cmp	r0, #0
c0d09164:	d107      	bne.n	c0d09176 <USBD_StdEPReq+0x5e>
c0d09166:	2080      	movs	r0, #128	; 0x80
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
c0d09168:	4308      	orrs	r0, r1
c0d0916a:	2880      	cmp	r0, #128	; 0x80
c0d0916c:	d003      	beq.n	c0d09176 <USBD_StdEPReq+0x5e>
          USBD_LL_StallEP(pdev , ep_addr);
c0d0916e:	4620      	mov	r0, r4
c0d09170:	f7ff fbc8 	bl	c0d08904 <USBD_LL_StallEP>
        }
c0d09174:	7929      	ldrb	r1, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d09176:	2902      	cmp	r1, #2
c0d09178:	d83d      	bhi.n	c0d091f6 <USBD_StdEPReq+0xde>
c0d0917a:	00c8      	lsls	r0, r1, #3
c0d0917c:	e02f      	b.n	c0d091de <USBD_StdEPReq+0xc6>
c0d0917e:	209c      	movs	r0, #156	; 0x9c
    switch (pdev->dev_state) 
c0d09180:	5c20      	ldrb	r0, [r4, r0]
c0d09182:	2803      	cmp	r0, #3
c0d09184:	d017      	beq.n	c0d091b6 <USBD_StdEPReq+0x9e>
c0d09186:	2802      	cmp	r0, #2
c0d09188:	d110      	bne.n	c0d091ac <USBD_StdEPReq+0x94>
      if ((ep_addr & 0x7F) != 0x00) 
c0d0918a:	0648      	lsls	r0, r1, #25
c0d0918c:	d10a      	bne.n	c0d091a4 <USBD_StdEPReq+0x8c>
c0d0918e:	e043      	b.n	c0d09218 <USBD_StdEPReq+0x100>
c0d09190:	209c      	movs	r0, #156	; 0x9c
    switch (pdev->dev_state) 
c0d09192:	5c20      	ldrb	r0, [r4, r0]
c0d09194:	2803      	cmp	r0, #3
c0d09196:	d016      	beq.n	c0d091c6 <USBD_StdEPReq+0xae>
c0d09198:	2802      	cmp	r0, #2
c0d0919a:	d107      	bne.n	c0d091ac <USBD_StdEPReq+0x94>
c0d0919c:	2080      	movs	r0, #128	; 0x80
c0d0919e:	4308      	orrs	r0, r1
c0d091a0:	2880      	cmp	r0, #128	; 0x80
c0d091a2:	d039      	beq.n	c0d09218 <USBD_StdEPReq+0x100>
c0d091a4:	4620      	mov	r0, r4
c0d091a6:	f7ff fbad 	bl	c0d08904 <USBD_LL_StallEP>
c0d091aa:	e035      	b.n	c0d09218 <USBD_StdEPReq+0x100>
c0d091ac:	4620      	mov	r0, r4
c0d091ae:	4629      	mov	r1, r5
c0d091b0:	f000 fa08 	bl	c0d095c4 <USBD_CtlError>
c0d091b4:	e030      	b.n	c0d09218 <USBD_StdEPReq+0x100>
c0d091b6:	207f      	movs	r0, #127	; 0x7f
c0d091b8:	4008      	ands	r0, r1
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
c0d091ba:	0100      	lsls	r0, r0, #4
c0d091bc:	1825      	adds	r5, r4, r0
c0d091be:	0608      	lsls	r0, r1, #24
c0d091c0:	d51d      	bpl.n	c0d091fe <USBD_StdEPReq+0xe6>
c0d091c2:	3514      	adds	r5, #20
c0d091c4:	e01c      	b.n	c0d09200 <USBD_StdEPReq+0xe8>
      if (req->wValue == USB_FEATURE_EP_HALT)
c0d091c6:	8868      	ldrh	r0, [r5, #2]
c0d091c8:	2800      	cmp	r0, #0
c0d091ca:	d125      	bne.n	c0d09218 <USBD_StdEPReq+0x100>
        if ((ep_addr & 0x7F) != 0x00) 
c0d091cc:	0648      	lsls	r0, r1, #25
c0d091ce:	d012      	beq.n	c0d091f6 <USBD_StdEPReq+0xde>
          USBD_LL_ClearStallEP(pdev , ep_addr);
c0d091d0:	4620      	mov	r0, r4
c0d091d2:	f7ff fbbb 	bl	c0d0894c <USBD_LL_ClearStallEP>
          if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d091d6:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d091d8:	2802      	cmp	r0, #2
c0d091da:	d80c      	bhi.n	c0d091f6 <USBD_StdEPReq+0xde>
c0d091dc:	00c0      	lsls	r0, r0, #3
c0d091de:	1820      	adds	r0, r4, r0
c0d091e0:	21b4      	movs	r1, #180	; 0xb4
c0d091e2:	5840      	ldr	r0, [r0, r1]
c0d091e4:	2800      	cmp	r0, #0
c0d091e6:	d006      	beq.n	c0d091f6 <USBD_StdEPReq+0xde>
c0d091e8:	6880      	ldr	r0, [r0, #8]
c0d091ea:	f7fc faa5 	bl	c0d05738 <pic>
c0d091ee:	4602      	mov	r2, r0
c0d091f0:	4620      	mov	r0, r4
c0d091f2:	4629      	mov	r1, r5
c0d091f4:	4790      	blx	r2
c0d091f6:	4620      	mov	r0, r4
c0d091f8:	f000 fac0 	bl	c0d0977c <USBD_CtlSendStatus>
c0d091fc:	e00c      	b.n	c0d09218 <USBD_StdEPReq+0x100>
c0d091fe:	3554      	adds	r5, #84	; 0x54
      if(USBD_LL_IsStallEP(pdev, ep_addr))
c0d09200:	4620      	mov	r0, r4
c0d09202:	f7ff fbc7 	bl	c0d08994 <USBD_LL_IsStallEP>
c0d09206:	2800      	cmp	r0, #0
c0d09208:	d000      	beq.n	c0d0920c <USBD_StdEPReq+0xf4>
c0d0920a:	2001      	movs	r0, #1
c0d0920c:	6028      	str	r0, [r5, #0]
c0d0920e:	2202      	movs	r2, #2
      USBD_CtlSendData (pdev,
c0d09210:	4620      	mov	r0, r4
c0d09212:	4629      	mov	r1, r5
c0d09214:	f000 fa88 	bl	c0d09728 <USBD_CtlSendData>
c0d09218:	2000      	movs	r0, #0
}
c0d0921a:	bdb0      	pop	{r4, r5, r7, pc}

c0d0921c <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
c0d0921c:	780a      	ldrb	r2, [r1, #0]
c0d0921e:	7002      	strb	r2, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
c0d09220:	784a      	ldrb	r2, [r1, #1]
c0d09222:	7042      	strb	r2, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
c0d09224:	788a      	ldrb	r2, [r1, #2]
c0d09226:	78cb      	ldrb	r3, [r1, #3]
c0d09228:	021b      	lsls	r3, r3, #8
c0d0922a:	189a      	adds	r2, r3, r2
c0d0922c:	8042      	strh	r2, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
c0d0922e:	790a      	ldrb	r2, [r1, #4]
c0d09230:	794b      	ldrb	r3, [r1, #5]
c0d09232:	021b      	lsls	r3, r3, #8
c0d09234:	189a      	adds	r2, r3, r2
c0d09236:	8082      	strh	r2, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
c0d09238:	798a      	ldrb	r2, [r1, #6]
c0d0923a:	79c9      	ldrb	r1, [r1, #7]
c0d0923c:	0209      	lsls	r1, r1, #8
c0d0923e:	1889      	adds	r1, r1, r2
c0d09240:	80c1      	strh	r1, [r0, #6]

}
c0d09242:	4770      	bx	lr

c0d09244 <USBD_CtlStall>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/
void USBD_CtlStall( USBD_HandleTypeDef *pdev)
{
c0d09244:	b510      	push	{r4, lr}
c0d09246:	4604      	mov	r4, r0
c0d09248:	2180      	movs	r1, #128	; 0x80
  USBD_LL_StallEP(pdev , 0x80);
c0d0924a:	f7ff fb5b 	bl	c0d08904 <USBD_LL_StallEP>
c0d0924e:	2100      	movs	r1, #0
  USBD_LL_StallEP(pdev , 0);
c0d09250:	4620      	mov	r0, r4
c0d09252:	f7ff fb57 	bl	c0d08904 <USBD_LL_StallEP>
}
c0d09256:	bd10      	pop	{r4, pc}

c0d09258 <USBD_HID_Setup>:
  * @param  req: usb requests
  * @retval status
  */
uint8_t  USBD_HID_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
c0d09258:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0925a:	b083      	sub	sp, #12
c0d0925c:	460e      	mov	r6, r1
c0d0925e:	4605      	mov	r5, r0
c0d09260:	a802      	add	r0, sp, #8
c0d09262:	2400      	movs	r4, #0
  uint16_t len = 0;
c0d09264:	8004      	strh	r4, [r0, #0]
c0d09266:	a801      	add	r0, sp, #4
  uint8_t  *pbuf = NULL;

  uint8_t val = 0;
c0d09268:	7004      	strb	r4, [r0, #0]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
c0d0926a:	7809      	ldrb	r1, [r1, #0]
c0d0926c:	2060      	movs	r0, #96	; 0x60
c0d0926e:	4008      	ands	r0, r1
c0d09270:	2800      	cmp	r0, #0
c0d09272:	d010      	beq.n	c0d09296 <USBD_HID_Setup+0x3e>
c0d09274:	2820      	cmp	r0, #32
c0d09276:	d137      	bne.n	c0d092e8 <USBD_HID_Setup+0x90>
  {
  case USB_REQ_TYPE_CLASS :  
    switch (req->bRequest)
c0d09278:	7870      	ldrb	r0, [r6, #1]
c0d0927a:	4601      	mov	r1, r0
c0d0927c:	390a      	subs	r1, #10
c0d0927e:	2902      	cmp	r1, #2
c0d09280:	d332      	bcc.n	c0d092e8 <USBD_HID_Setup+0x90>
c0d09282:	2802      	cmp	r0, #2
c0d09284:	d01b      	beq.n	c0d092be <USBD_HID_Setup+0x66>
c0d09286:	2803      	cmp	r0, #3
c0d09288:	d019      	beq.n	c0d092be <USBD_HID_Setup+0x66>
                        (uint8_t *)&val,
                        1);      
      break;      
      
    default:
      USBD_CtlError (pdev, req);
c0d0928a:	4628      	mov	r0, r5
c0d0928c:	4631      	mov	r1, r6
c0d0928e:	f000 f999 	bl	c0d095c4 <USBD_CtlError>
c0d09292:	2402      	movs	r4, #2
c0d09294:	e028      	b.n	c0d092e8 <USBD_HID_Setup+0x90>
      return USBD_FAIL; 
    }
    break;
    
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
c0d09296:	7870      	ldrb	r0, [r6, #1]
c0d09298:	280b      	cmp	r0, #11
c0d0929a:	d013      	beq.n	c0d092c4 <USBD_HID_Setup+0x6c>
c0d0929c:	280a      	cmp	r0, #10
c0d0929e:	d00e      	beq.n	c0d092be <USBD_HID_Setup+0x66>
c0d092a0:	2806      	cmp	r0, #6
c0d092a2:	d121      	bne.n	c0d092e8 <USBD_HID_Setup+0x90>
    {
    case USB_REQ_GET_DESCRIPTOR: 
      // 0x22
      if( req->wValue >> 8 == HID_REPORT_DESC)
c0d092a4:	78f0      	ldrb	r0, [r6, #3]
c0d092a6:	2400      	movs	r4, #0
c0d092a8:	2821      	cmp	r0, #33	; 0x21
c0d092aa:	d00f      	beq.n	c0d092cc <USBD_HID_Setup+0x74>
c0d092ac:	2822      	cmp	r0, #34	; 0x22
      
      //USBD_CtlReceiveStatus(pdev);
      
      USBD_CtlSendData (pdev, 
                        pbuf,
                        len);
c0d092ae:	4622      	mov	r2, r4
c0d092b0:	4621      	mov	r1, r4
      if( req->wValue >> 8 == HID_REPORT_DESC)
c0d092b2:	d116      	bne.n	c0d092e2 <USBD_HID_Setup+0x8a>
c0d092b4:	af02      	add	r7, sp, #8
        pbuf =  USBD_HID_GetReportDescriptor_impl(&len);
c0d092b6:	4638      	mov	r0, r7
c0d092b8:	f000 f858 	bl	c0d0936c <USBD_HID_GetReportDescriptor_impl>
c0d092bc:	e00a      	b.n	c0d092d4 <USBD_HID_Setup+0x7c>
c0d092be:	a901      	add	r1, sp, #4
c0d092c0:	2201      	movs	r2, #1
c0d092c2:	e00e      	b.n	c0d092e2 <USBD_HID_Setup+0x8a>
      break;

    case USB_REQ_SET_INTERFACE :
      //hhid->AltSetting = (uint8_t)(req->wValue);
      USBD_CtlSendStatus(pdev);
c0d092c4:	4628      	mov	r0, r5
c0d092c6:	f000 fa59 	bl	c0d0977c <USBD_CtlSendStatus>
c0d092ca:	e00d      	b.n	c0d092e8 <USBD_HID_Setup+0x90>
c0d092cc:	af02      	add	r7, sp, #8
        pbuf = USBD_HID_GetHidDescriptor_impl(&len);
c0d092ce:	4638      	mov	r0, r7
c0d092d0:	f000 f832 	bl	c0d09338 <USBD_HID_GetHidDescriptor_impl>
c0d092d4:	4601      	mov	r1, r0
c0d092d6:	883a      	ldrh	r2, [r7, #0]
c0d092d8:	88f0      	ldrh	r0, [r6, #6]
c0d092da:	4282      	cmp	r2, r0
c0d092dc:	d300      	bcc.n	c0d092e0 <USBD_HID_Setup+0x88>
c0d092de:	4602      	mov	r2, r0
c0d092e0:	803a      	strh	r2, [r7, #0]
c0d092e2:	4628      	mov	r0, r5
c0d092e4:	f000 fa20 	bl	c0d09728 <USBD_CtlSendData>
      
    }
  }

  return USBD_OK;
}
c0d092e8:	4620      	mov	r0, r4
c0d092ea:	b003      	add	sp, #12
c0d092ec:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d092ee <USBD_HID_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_HID_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d092ee:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d092f0:	b081      	sub	sp, #4
c0d092f2:	4604      	mov	r4, r0
c0d092f4:	2182      	movs	r1, #130	; 0x82
c0d092f6:	2603      	movs	r6, #3
c0d092f8:	2540      	movs	r5, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d092fa:	4632      	mov	r2, r6
c0d092fc:	462b      	mov	r3, r5
c0d092fe:	f7ff fabb 	bl	c0d08878 <USBD_LL_OpenEP>
c0d09302:	2702      	movs	r7, #2
                 HID_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 HID_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d09304:	4620      	mov	r0, r4
c0d09306:	4639      	mov	r1, r7
c0d09308:	4632      	mov	r2, r6
c0d0930a:	462b      	mov	r3, r5
c0d0930c:	f7ff fab4 	bl	c0d08878 <USBD_LL_OpenEP>
                 HID_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 HID_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR, HID_EPOUT_SIZE);
c0d09310:	4620      	mov	r0, r4
c0d09312:	4639      	mov	r1, r7
c0d09314:	462a      	mov	r2, r5
c0d09316:	f7ff fb78 	bl	c0d08a0a <USBD_LL_PrepareReceive>
c0d0931a:	2000      	movs	r0, #0
  USBD_LL_Transmit (pdev, 
                    HID_EPIN_ADDR,                                      
                    NULL,
                    0);
  */
  return USBD_OK;
c0d0931c:	b001      	add	sp, #4
c0d0931e:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d09320 <USBD_HID_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_HID_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
c0d09320:	b510      	push	{r4, lr}
c0d09322:	4604      	mov	r4, r0
c0d09324:	2182      	movs	r1, #130	; 0x82
  UNUSED(cfgidx);
  /* Close HID EP IN */
  USBD_LL_CloseEP(pdev,
c0d09326:	f7ff fad7 	bl	c0d088d8 <USBD_LL_CloseEP>
c0d0932a:	2102      	movs	r1, #2
                  HID_EPIN_ADDR);
  
  /* Close HID EP OUT */
  USBD_LL_CloseEP(pdev,
c0d0932c:	4620      	mov	r0, r4
c0d0932e:	f7ff fad3 	bl	c0d088d8 <USBD_LL_CloseEP>
c0d09332:	2000      	movs	r0, #0
                  HID_EPOUT_ADDR);
  
  return USBD_OK;
c0d09334:	bd10      	pop	{r4, pc}
	...

c0d09338 <USBD_HID_GetHidDescriptor_impl>:
{
  *length = sizeof (USBD_CfgDesc);
  return (uint8_t*)USBD_CfgDesc;
}

uint8_t* USBD_HID_GetHidDescriptor_impl(uint16_t* len) {
c0d09338:	21ac      	movs	r1, #172	; 0xac
  switch (USBD_Device.request.wIndex&0xFF) {
c0d0933a:	4a09      	ldr	r2, [pc, #36]	; (c0d09360 <USBD_HID_GetHidDescriptor_impl+0x28>)
c0d0933c:	5c51      	ldrb	r1, [r2, r1]
c0d0933e:	2209      	movs	r2, #9
c0d09340:	2901      	cmp	r1, #1
c0d09342:	d004      	beq.n	c0d0934e <USBD_HID_GetHidDescriptor_impl+0x16>
c0d09344:	2900      	cmp	r1, #0
c0d09346:	d105      	bne.n	c0d09354 <USBD_HID_GetHidDescriptor_impl+0x1c>
c0d09348:	4907      	ldr	r1, [pc, #28]	; (c0d09368 <USBD_HID_GetHidDescriptor_impl+0x30>)
c0d0934a:	4479      	add	r1, pc
c0d0934c:	e004      	b.n	c0d09358 <USBD_HID_GetHidDescriptor_impl+0x20>
c0d0934e:	4905      	ldr	r1, [pc, #20]	; (c0d09364 <USBD_HID_GetHidDescriptor_impl+0x2c>)
c0d09350:	4479      	add	r1, pc
c0d09352:	e001      	b.n	c0d09358 <USBD_HID_GetHidDescriptor_impl+0x20>
c0d09354:	2200      	movs	r2, #0
c0d09356:	4611      	mov	r1, r2
c0d09358:	8002      	strh	r2, [r0, #0]
      return (uint8_t*)USBD_HID_Desc_kbd; 
#endif // HAVE_USB_HIDKBD
  }
  *len = 0;
  return 0;
}
c0d0935a:	4608      	mov	r0, r1
c0d0935c:	4770      	bx	lr
c0d0935e:	46c0      	nop			; (mov r8, r8)
c0d09360:	2000211c 	.word	0x2000211c
c0d09364:	00003e90 	.word	0x00003e90
c0d09368:	00003ea2 	.word	0x00003ea2

c0d0936c <USBD_HID_GetReportDescriptor_impl>:

uint8_t* USBD_HID_GetReportDescriptor_impl(uint16_t* len) {
c0d0936c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0936e:	b081      	sub	sp, #4
c0d09370:	4602      	mov	r2, r0
c0d09372:	20ac      	movs	r0, #172	; 0xac
  switch (USBD_Device.request.wIndex&0xFF) {
c0d09374:	4913      	ldr	r1, [pc, #76]	; (c0d093c4 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d09376:	5c08      	ldrb	r0, [r1, r0]
c0d09378:	2422      	movs	r4, #34	; 0x22
c0d0937a:	2800      	cmp	r0, #0
c0d0937c:	d01a      	beq.n	c0d093b4 <USBD_HID_GetReportDescriptor_impl+0x48>
c0d0937e:	2801      	cmp	r0, #1
c0d09380:	d11b      	bne.n	c0d093ba <USBD_HID_GetReportDescriptor_impl+0x4e>
#ifdef HAVE_IO_U2F
  case U2F_INTF:

    // very dirty work due to lack of callback when USB_HID_Init is called
    USBD_LL_OpenEP(&USBD_Device,
c0d09382:	4810      	ldr	r0, [pc, #64]	; (c0d093c4 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d09384:	2181      	movs	r1, #129	; 0x81
c0d09386:	2703      	movs	r7, #3
c0d09388:	2640      	movs	r6, #64	; 0x40
c0d0938a:	9200      	str	r2, [sp, #0]
c0d0938c:	463a      	mov	r2, r7
c0d0938e:	4633      	mov	r3, r6
c0d09390:	f7ff fa72 	bl	c0d08878 <USBD_LL_OpenEP>
c0d09394:	2501      	movs	r5, #1
                   U2F_EPIN_ADDR,
                   USBD_EP_TYPE_INTR,
                   U2F_EPIN_SIZE);
    
    USBD_LL_OpenEP(&USBD_Device,
c0d09396:	480b      	ldr	r0, [pc, #44]	; (c0d093c4 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d09398:	4629      	mov	r1, r5
c0d0939a:	463a      	mov	r2, r7
c0d0939c:	4633      	mov	r3, r6
c0d0939e:	f7ff fa6b 	bl	c0d08878 <USBD_LL_OpenEP>
                   U2F_EPOUT_ADDR,
                   USBD_EP_TYPE_INTR,
                   U2F_EPOUT_SIZE);

    /* Prepare Out endpoint to receive 1st packet */ 
    USBD_LL_PrepareReceive(&USBD_Device, U2F_EPOUT_ADDR, U2F_EPOUT_SIZE);
c0d093a2:	4808      	ldr	r0, [pc, #32]	; (c0d093c4 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d093a4:	4629      	mov	r1, r5
c0d093a6:	4632      	mov	r2, r6
c0d093a8:	f7ff fb2f 	bl	c0d08a0a <USBD_LL_PrepareReceive>
c0d093ac:	9a00      	ldr	r2, [sp, #0]
c0d093ae:	4807      	ldr	r0, [pc, #28]	; (c0d093cc <USBD_HID_GetReportDescriptor_impl+0x60>)
c0d093b0:	4478      	add	r0, pc
c0d093b2:	e004      	b.n	c0d093be <USBD_HID_GetReportDescriptor_impl+0x52>
c0d093b4:	4804      	ldr	r0, [pc, #16]	; (c0d093c8 <USBD_HID_GetReportDescriptor_impl+0x5c>)
c0d093b6:	4478      	add	r0, pc
c0d093b8:	e001      	b.n	c0d093be <USBD_HID_GetReportDescriptor_impl+0x52>
c0d093ba:	2400      	movs	r4, #0
c0d093bc:	4620      	mov	r0, r4
c0d093be:	8014      	strh	r4, [r2, #0]
    return (uint8_t*)HID_ReportDesc_kbd;
#endif // HAVE_USB_HIDKBD
  }
  *len = 0;
  return 0;
}
c0d093c0:	b001      	add	sp, #4
c0d093c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d093c4:	2000211c 	.word	0x2000211c
c0d093c8:	00003e61 	.word	0x00003e61
c0d093cc:	00003e45 	.word	0x00003e45

c0d093d0 <USBD_U2F_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_U2F_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d093d0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d093d2:	b081      	sub	sp, #4
c0d093d4:	4604      	mov	r4, r0
c0d093d6:	2181      	movs	r1, #129	; 0x81
c0d093d8:	2603      	movs	r6, #3
c0d093da:	2540      	movs	r5, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d093dc:	4632      	mov	r2, r6
c0d093de:	462b      	mov	r3, r5
c0d093e0:	f7ff fa4a 	bl	c0d08878 <USBD_LL_OpenEP>
c0d093e4:	2701      	movs	r7, #1
                 U2F_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 U2F_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d093e6:	4620      	mov	r0, r4
c0d093e8:	4639      	mov	r1, r7
c0d093ea:	4632      	mov	r2, r6
c0d093ec:	462b      	mov	r3, r5
c0d093ee:	f7ff fa43 	bl	c0d08878 <USBD_LL_OpenEP>
                 U2F_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 U2F_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, U2F_EPOUT_ADDR, U2F_EPOUT_SIZE);
c0d093f2:	4620      	mov	r0, r4
c0d093f4:	4639      	mov	r1, r7
c0d093f6:	462a      	mov	r2, r5
c0d093f8:	f7ff fb07 	bl	c0d08a0a <USBD_LL_PrepareReceive>
c0d093fc:	2000      	movs	r0, #0

  return USBD_OK;
c0d093fe:	b001      	add	sp, #4
c0d09400:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d09404 <USBD_U2F_DataIn_impl>:
}

uint8_t  USBD_U2F_DataIn_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d09404:	b580      	push	{r7, lr}
  UNUSED(pdev);
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d09406:	2901      	cmp	r1, #1
c0d09408:	d103      	bne.n	c0d09412 <USBD_U2F_DataIn_impl+0xe>
  // FIDO endpoint
  case (U2F_EPIN_ADDR&0x7F):
    // advance the u2f sending machine state
    u2f_transport_sent(&G_io_u2f, U2F_MEDIA_USB);
c0d0940a:	4803      	ldr	r0, [pc, #12]	; (c0d09418 <USBD_U2F_DataIn_impl+0x14>)
c0d0940c:	2101      	movs	r1, #1
c0d0940e:	f7fd fd51 	bl	c0d06eb4 <u2f_transport_sent>
c0d09412:	2000      	movs	r0, #0
    break;
  } 
  return USBD_OK;
c0d09414:	bd80      	pop	{r7, pc}
c0d09416:	46c0      	nop			; (mov r8, r8)
c0d09418:	2000207c 	.word	0x2000207c

c0d0941c <USBD_U2F_DataOut_impl>:
}

uint8_t  USBD_U2F_DataOut_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d0941c:	b5b0      	push	{r4, r5, r7, lr}
  switch (epnum) {
c0d0941e:	2901      	cmp	r1, #1
c0d09420:	d10e      	bne.n	c0d09440 <USBD_U2F_DataOut_impl+0x24>
c0d09422:	4614      	mov	r4, r2
c0d09424:	2501      	movs	r5, #1
c0d09426:	2240      	movs	r2, #64	; 0x40
  // FIDO endpoint
  case (U2F_EPOUT_ADDR&0x7F):
      USBD_LL_PrepareReceive(pdev, U2F_EPOUT_ADDR , U2F_EPOUT_SIZE);
c0d09428:	4629      	mov	r1, r5
c0d0942a:	f7ff faee 	bl	c0d08a0a <USBD_LL_PrepareReceive>
      u2f_transport_received(&G_io_u2f, buffer, io_seproxyhal_get_ep_rx_size(U2F_EPOUT_ADDR), U2F_MEDIA_USB);
c0d0942e:	4628      	mov	r0, r5
c0d09430:	f7fb f912 	bl	c0d04658 <io_seproxyhal_get_ep_rx_size>
c0d09434:	4602      	mov	r2, r0
c0d09436:	4803      	ldr	r0, [pc, #12]	; (c0d09444 <USBD_U2F_DataOut_impl+0x28>)
c0d09438:	4621      	mov	r1, r4
c0d0943a:	462b      	mov	r3, r5
c0d0943c:	f7fd fe86 	bl	c0d0714c <u2f_transport_received>
c0d09440:	2000      	movs	r0, #0
    break;
  }

  return USBD_OK;
c0d09442:	bdb0      	pop	{r4, r5, r7, pc}
c0d09444:	2000207c 	.word	0x2000207c

c0d09448 <USBD_HID_DataIn_impl>:
}
#endif // HAVE_IO_U2F

uint8_t  USBD_HID_DataIn_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d09448:	b580      	push	{r7, lr}
  UNUSED(pdev);
  switch (epnum) {
c0d0944a:	2902      	cmp	r1, #2
c0d0944c:	d103      	bne.n	c0d09456 <USBD_HID_DataIn_impl+0xe>
    // HID gen endpoint
    case (HID_EPIN_ADDR&0x7F):
      io_usb_hid_sent(io_usb_send_apdu_data);
c0d0944e:	4803      	ldr	r0, [pc, #12]	; (c0d0945c <USBD_HID_DataIn_impl+0x14>)
c0d09450:	4478      	add	r0, pc
c0d09452:	f7fb fd4b 	bl	c0d04eec <io_usb_hid_sent>
c0d09456:	2000      	movs	r0, #0
      break;
  }

  return USBD_OK;
c0d09458:	bd80      	pop	{r7, pc}
c0d0945a:	46c0      	nop			; (mov r8, r8)
c0d0945c:	ffffb2d1 	.word	0xffffb2d1

c0d09460 <USBD_HID_DataOut_impl>:
}

uint8_t  USBD_HID_DataOut_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d09460:	b5b0      	push	{r4, r5, r7, lr}
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d09462:	2902      	cmp	r1, #2
c0d09464:	d11a      	bne.n	c0d0949c <USBD_HID_DataOut_impl+0x3c>
c0d09466:	4614      	mov	r4, r2
c0d09468:	2102      	movs	r1, #2
c0d0946a:	2240      	movs	r2, #64	; 0x40

  // HID gen endpoint
  case (HID_EPOUT_ADDR&0x7F):
    // prepare receiving the next chunk (masked time)
    USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR , HID_EPOUT_SIZE);
c0d0946c:	f7ff facd 	bl	c0d08a0a <USBD_LL_PrepareReceive>

#ifndef HAVE_USB_HIDKBD
    // avoid troubles when an apdu has not been replied yet
    if (G_io_app.apdu_media == IO_APDU_MEDIA_NONE) {      
c0d09470:	4d0b      	ldr	r5, [pc, #44]	; (c0d094a0 <USBD_HID_DataOut_impl+0x40>)
c0d09472:	79a8      	ldrb	r0, [r5, #6]
c0d09474:	2800      	cmp	r0, #0
c0d09476:	d111      	bne.n	c0d0949c <USBD_HID_DataOut_impl+0x3c>
c0d09478:	2002      	movs	r0, #2
      // add to the hid transport
      switch(io_usb_hid_receive(io_usb_send_apdu_data, buffer, io_seproxyhal_get_ep_rx_size(HID_EPOUT_ADDR))) {
c0d0947a:	f7fb f8ed 	bl	c0d04658 <io_seproxyhal_get_ep_rx_size>
c0d0947e:	4602      	mov	r2, r0
c0d09480:	4809      	ldr	r0, [pc, #36]	; (c0d094a8 <USBD_HID_DataOut_impl+0x48>)
c0d09482:	4478      	add	r0, pc
c0d09484:	4621      	mov	r1, r4
c0d09486:	f7fb fc83 	bl	c0d04d90 <io_usb_hid_receive>
c0d0948a:	2802      	cmp	r0, #2
c0d0948c:	d106      	bne.n	c0d0949c <USBD_HID_DataOut_impl+0x3c>
c0d0948e:	2007      	movs	r0, #7
        default:
          break;

        case IO_USB_APDU_RECEIVED:
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_HID; // for application code
          G_io_app.apdu_state = APDU_USB_HID; // for next call to io_exchange
c0d09490:	7028      	strb	r0, [r5, #0]
c0d09492:	2001      	movs	r0, #1
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_HID; // for application code
c0d09494:	71a8      	strb	r0, [r5, #6]
          G_io_app.apdu_length = G_io_usb_hid_total_length;
c0d09496:	4803      	ldr	r0, [pc, #12]	; (c0d094a4 <USBD_HID_DataOut_impl+0x44>)
c0d09498:	6800      	ldr	r0, [r0, #0]
c0d0949a:	8068      	strh	r0, [r5, #2]
c0d0949c:	2000      	movs	r0, #0
    }
#endif // HAVE_USB_HIDKBD
    break;
  }

  return USBD_OK;
c0d0949e:	bdb0      	pop	{r4, r5, r7, pc}
c0d094a0:	2000205c 	.word	0x2000205c
c0d094a4:	20002104 	.word	0x20002104
c0d094a8:	ffffb29f 	.word	0xffffb29f

c0d094ac <USBD_WEBUSB_Init>:

#ifdef HAVE_WEBUSB

uint8_t  USBD_WEBUSB_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d094ac:	b570      	push	{r4, r5, r6, lr}
c0d094ae:	4604      	mov	r4, r0
c0d094b0:	2183      	movs	r1, #131	; 0x83
c0d094b2:	2503      	movs	r5, #3
c0d094b4:	2640      	movs	r6, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d094b6:	462a      	mov	r2, r5
c0d094b8:	4633      	mov	r3, r6
c0d094ba:	f7ff f9dd 	bl	c0d08878 <USBD_LL_OpenEP>
                 WEBUSB_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 WEBUSB_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d094be:	4620      	mov	r0, r4
c0d094c0:	4629      	mov	r1, r5
c0d094c2:	462a      	mov	r2, r5
c0d094c4:	4633      	mov	r3, r6
c0d094c6:	f7ff f9d7 	bl	c0d08878 <USBD_LL_OpenEP>
                 WEBUSB_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 WEBUSB_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, WEBUSB_EPOUT_ADDR, WEBUSB_EPOUT_SIZE);
c0d094ca:	4620      	mov	r0, r4
c0d094cc:	4629      	mov	r1, r5
c0d094ce:	4632      	mov	r2, r6
c0d094d0:	f7ff fa9b 	bl	c0d08a0a <USBD_LL_PrepareReceive>
c0d094d4:	2000      	movs	r0, #0

  return USBD_OK;
c0d094d6:	bd70      	pop	{r4, r5, r6, pc}

c0d094d8 <USBD_WEBUSB_DeInit>:
}

uint8_t  USBD_WEBUSB_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx) {
c0d094d8:	2000      	movs	r0, #0
  UNUSED(pdev);
  UNUSED(cfgidx);
  return USBD_OK;
c0d094da:	4770      	bx	lr

c0d094dc <USBD_WEBUSB_Setup>:
}

uint8_t  USBD_WEBUSB_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
c0d094dc:	2000      	movs	r0, #0
  UNUSED(pdev);
  UNUSED(req);
  return USBD_OK;
c0d094de:	4770      	bx	lr

c0d094e0 <USBD_WEBUSB_DataIn>:
}

uint8_t  USBD_WEBUSB_DataIn (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d094e0:	b580      	push	{r7, lr}
  UNUSED(pdev);
  switch (epnum) {
c0d094e2:	2903      	cmp	r1, #3
c0d094e4:	d103      	bne.n	c0d094ee <USBD_WEBUSB_DataIn+0xe>
    // HID gen endpoint
    case (WEBUSB_EPIN_ADDR&0x7F):
      io_usb_hid_sent(io_usb_send_apdu_data_ep0x83);
c0d094e6:	4803      	ldr	r0, [pc, #12]	; (c0d094f4 <USBD_WEBUSB_DataIn+0x14>)
c0d094e8:	4478      	add	r0, pc
c0d094ea:	f7fb fcff 	bl	c0d04eec <io_usb_hid_sent>
c0d094ee:	2000      	movs	r0, #0
      break;
  }
  return USBD_OK;
c0d094f0:	bd80      	pop	{r7, pc}
c0d094f2:	46c0      	nop			; (mov r8, r8)
c0d094f4:	ffffb249 	.word	0xffffb249

c0d094f8 <USBD_WEBUSB_DataOut>:
}

uint8_t USBD_WEBUSB_DataOut (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d094f8:	b5b0      	push	{r4, r5, r7, lr}
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d094fa:	2903      	cmp	r1, #3
c0d094fc:	d11a      	bne.n	c0d09534 <USBD_WEBUSB_DataOut+0x3c>
c0d094fe:	4614      	mov	r4, r2
c0d09500:	2103      	movs	r1, #3
c0d09502:	2240      	movs	r2, #64	; 0x40

  // HID gen endpoint
  case (WEBUSB_EPOUT_ADDR&0x7F):
    // prepare receiving the next chunk (masked time)
    USBD_LL_PrepareReceive(pdev, WEBUSB_EPOUT_ADDR, WEBUSB_EPOUT_SIZE);
c0d09504:	f7ff fa81 	bl	c0d08a0a <USBD_LL_PrepareReceive>

    // avoid troubles when an apdu has not been replied yet
    if (G_io_app.apdu_media == IO_APDU_MEDIA_NONE) {      
c0d09508:	4d0b      	ldr	r5, [pc, #44]	; (c0d09538 <USBD_WEBUSB_DataOut+0x40>)
c0d0950a:	79a8      	ldrb	r0, [r5, #6]
c0d0950c:	2800      	cmp	r0, #0
c0d0950e:	d111      	bne.n	c0d09534 <USBD_WEBUSB_DataOut+0x3c>
c0d09510:	2003      	movs	r0, #3
      // add to the hid transport
      switch(io_usb_hid_receive(io_usb_send_apdu_data_ep0x83, buffer, io_seproxyhal_get_ep_rx_size(WEBUSB_EPOUT_ADDR))) {
c0d09512:	f7fb f8a1 	bl	c0d04658 <io_seproxyhal_get_ep_rx_size>
c0d09516:	4602      	mov	r2, r0
c0d09518:	4809      	ldr	r0, [pc, #36]	; (c0d09540 <USBD_WEBUSB_DataOut+0x48>)
c0d0951a:	4478      	add	r0, pc
c0d0951c:	4621      	mov	r1, r4
c0d0951e:	f7fb fc37 	bl	c0d04d90 <io_usb_hid_receive>
c0d09522:	2802      	cmp	r0, #2
c0d09524:	d106      	bne.n	c0d09534 <USBD_WEBUSB_DataOut+0x3c>
c0d09526:	200b      	movs	r0, #11
        default:
          break;

        case IO_USB_APDU_RECEIVED:
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_WEBUSB; // for application code
          G_io_app.apdu_state = APDU_USB_WEBUSB; // for next call to io_exchange
c0d09528:	7028      	strb	r0, [r5, #0]
c0d0952a:	2005      	movs	r0, #5
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_WEBUSB; // for application code
c0d0952c:	71a8      	strb	r0, [r5, #6]
          G_io_app.apdu_length = G_io_usb_hid_total_length;
c0d0952e:	4803      	ldr	r0, [pc, #12]	; (c0d0953c <USBD_WEBUSB_DataOut+0x44>)
c0d09530:	6800      	ldr	r0, [r0, #0]
c0d09532:	8068      	strh	r0, [r5, #2]
c0d09534:	2000      	movs	r0, #0
      }
    }
    break;
  }

  return USBD_OK;
c0d09536:	bdb0      	pop	{r4, r5, r7, pc}
c0d09538:	2000205c 	.word	0x2000205c
c0d0953c:	20002104 	.word	0x20002104
c0d09540:	ffffb217 	.word	0xffffb217

c0d09544 <USBD_DeviceDescriptor>:
{
c0d09544:	2012      	movs	r0, #18
  *length = sizeof(USBD_DeviceDesc);
c0d09546:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_DeviceDesc;
c0d09548:	4801      	ldr	r0, [pc, #4]	; (c0d09550 <USBD_DeviceDescriptor+0xc>)
c0d0954a:	4478      	add	r0, pc
c0d0954c:	4770      	bx	lr
c0d0954e:	46c0      	nop			; (mov r8, r8)
c0d09550:	00003f4a 	.word	0x00003f4a

c0d09554 <USBD_LangIDStrDescriptor>:
{
c0d09554:	2004      	movs	r0, #4
  *length = sizeof(USBD_LangIDDesc);  
c0d09556:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_LangIDDesc;
c0d09558:	4801      	ldr	r0, [pc, #4]	; (c0d09560 <USBD_LangIDStrDescriptor+0xc>)
c0d0955a:	4478      	add	r0, pc
c0d0955c:	4770      	bx	lr
c0d0955e:	46c0      	nop			; (mov r8, r8)
c0d09560:	00003f4c 	.word	0x00003f4c

c0d09564 <USBD_ManufacturerStrDescriptor>:
{
c0d09564:	200e      	movs	r0, #14
  *length = sizeof(USBD_MANUFACTURER_STRING);
c0d09566:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_MANUFACTURER_STRING;
c0d09568:	4801      	ldr	r0, [pc, #4]	; (c0d09570 <USBD_ManufacturerStrDescriptor+0xc>)
c0d0956a:	4478      	add	r0, pc
c0d0956c:	4770      	bx	lr
c0d0956e:	46c0      	nop			; (mov r8, r8)
c0d09570:	00003f40 	.word	0x00003f40

c0d09574 <USBD_ProductStrDescriptor>:
{
c0d09574:	200e      	movs	r0, #14
  *length = sizeof(USBD_PRODUCT_FS_STRING);
c0d09576:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_PRODUCT_FS_STRING;
c0d09578:	4801      	ldr	r0, [pc, #4]	; (c0d09580 <USBD_ProductStrDescriptor+0xc>)
c0d0957a:	4478      	add	r0, pc
c0d0957c:	4770      	bx	lr
c0d0957e:	46c0      	nop			; (mov r8, r8)
c0d09580:	00003f3e 	.word	0x00003f3e

c0d09584 <USBD_SerialStrDescriptor>:
{
c0d09584:	200a      	movs	r0, #10
  *length = sizeof(USB_SERIAL_STRING);
c0d09586:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USB_SERIAL_STRING;
c0d09588:	4801      	ldr	r0, [pc, #4]	; (c0d09590 <USBD_SerialStrDescriptor+0xc>)
c0d0958a:	4478      	add	r0, pc
c0d0958c:	4770      	bx	lr
c0d0958e:	46c0      	nop			; (mov r8, r8)
c0d09590:	00003f3c 	.word	0x00003f3c

c0d09594 <USBD_ConfigStrDescriptor>:
{
c0d09594:	200e      	movs	r0, #14
  *length = sizeof(USBD_CONFIGURATION_FS_STRING);
c0d09596:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_CONFIGURATION_FS_STRING;
c0d09598:	4801      	ldr	r0, [pc, #4]	; (c0d095a0 <USBD_ConfigStrDescriptor+0xc>)
c0d0959a:	4478      	add	r0, pc
c0d0959c:	4770      	bx	lr
c0d0959e:	46c0      	nop			; (mov r8, r8)
c0d095a0:	00003f1e 	.word	0x00003f1e

c0d095a4 <USBD_InterfaceStrDescriptor>:
{
c0d095a4:	200e      	movs	r0, #14
  *length = sizeof(USBD_INTERFACE_FS_STRING);
c0d095a6:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_INTERFACE_FS_STRING;
c0d095a8:	4801      	ldr	r0, [pc, #4]	; (c0d095b0 <USBD_InterfaceStrDescriptor+0xc>)
c0d095aa:	4478      	add	r0, pc
c0d095ac:	4770      	bx	lr
c0d095ae:	46c0      	nop			; (mov r8, r8)
c0d095b0:	00003f0e 	.word	0x00003f0e

c0d095b4 <USBD_BOSDescriptor>:
};

#endif // HAVE_WEBUSB

static uint8_t *USBD_BOSDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
c0d095b4:	2039      	movs	r0, #57	; 0x39
  UNUSED(speed);
#ifdef HAVE_WEBUSB
  *length = sizeof(C_usb_bos);
c0d095b6:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)C_usb_bos;
c0d095b8:	4801      	ldr	r0, [pc, #4]	; (c0d095c0 <USBD_BOSDescriptor+0xc>)
c0d095ba:	4478      	add	r0, pc
c0d095bc:	4770      	bx	lr
c0d095be:	46c0      	nop			; (mov r8, r8)
c0d095c0:	00003c7f 	.word	0x00003c7f

c0d095c4 <USBD_CtlError>:
  '4', 0x00, '6', 0x00, '7', 0x00, '6', 0x00, '5', 0x00, '7', 0x00,
  '2', 0x00, '}', 0x00, 0x00, 0x00, 0x00, 0x00 // propertyData, double unicode nul terminated
};

// upon unsupported request, check for webusb request
void USBD_CtlError( USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef *req) {
c0d095c4:	b580      	push	{r7, lr}
    USBD_CtlSendData (pdev, (unsigned char*)C_webusb_url_descriptor, MIN(req->wLength, sizeof(C_webusb_url_descriptor)));
  }
  else 
#endif // WEBUSB_URL_SIZE_B
    // SETUP (LE): 0x80 0x06 0x03 0x77 0x00 0x00 0xXX 0xXX
    if ((req->bmRequest & 0x80) 
c0d095c6:	780a      	ldrb	r2, [r1, #0]
c0d095c8:	b252      	sxtb	r2, r2
    && req->bRequest == USB_REQ_GET_DESCRIPTOR 
c0d095ca:	2a00      	cmp	r2, #0
c0d095cc:	db02      	blt.n	c0d095d4 <USBD_CtlError+0x10>
      && req->bRequest == WINUSB_VENDOR_CODE
      && req->wIndex == MS_OS_20_DESCRIPTOR_INDEX) {
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_request_descriptor, MIN(req->wLength, sizeof(C_winusb_request_descriptor)));
  }
  else {
    USBD_CtlStall(pdev);
c0d095ce:	f7ff fe39 	bl	c0d09244 <USBD_CtlStall>
  }
}
c0d095d2:	bd80      	pop	{r7, pc}
    && req->bRequest == USB_REQ_GET_DESCRIPTOR 
c0d095d4:	784a      	ldrb	r2, [r1, #1]
    && (req->wValue>>8) == USB_DESC_TYPE_STRING 
c0d095d6:	2a77      	cmp	r2, #119	; 0x77
c0d095d8:	d00e      	beq.n	c0d095f8 <USBD_CtlError+0x34>
c0d095da:	2a06      	cmp	r2, #6
c0d095dc:	d1f7      	bne.n	c0d095ce <USBD_CtlError+0xa>
c0d095de:	884a      	ldrh	r2, [r1, #2]
c0d095e0:	4b17      	ldr	r3, [pc, #92]	; (c0d09640 <USBD_CtlError+0x7c>)
    && (req->wValue & 0xFF) == 0xEE) {
c0d095e2:	429a      	cmp	r2, r3
c0d095e4:	d1f3      	bne.n	c0d095ce <USBD_CtlError+0xa>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_string_descriptor, MIN(req->wLength, sizeof(C_winusb_string_descriptor)));
c0d095e6:	88ca      	ldrh	r2, [r1, #6]
c0d095e8:	2a12      	cmp	r2, #18
c0d095ea:	d300      	bcc.n	c0d095ee <USBD_CtlError+0x2a>
c0d095ec:	2212      	movs	r2, #18
c0d095ee:	4915      	ldr	r1, [pc, #84]	; (c0d09644 <USBD_CtlError+0x80>)
c0d095f0:	4479      	add	r1, pc
c0d095f2:	f000 f899 	bl	c0d09728 <USBD_CtlSendData>
}
c0d095f6:	bd80      	pop	{r7, pc}
    && req->wIndex == WINUSB_GET_COMPATIBLE_ID_FEATURE) {
c0d095f8:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80) 
c0d095fa:	2a04      	cmp	r2, #4
c0d095fc:	d108      	bne.n	c0d09610 <USBD_CtlError+0x4c>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_wcid, MIN(req->wLength, sizeof(C_winusb_wcid)));
c0d095fe:	88ca      	ldrh	r2, [r1, #6]
c0d09600:	2a28      	cmp	r2, #40	; 0x28
c0d09602:	d300      	bcc.n	c0d09606 <USBD_CtlError+0x42>
c0d09604:	2228      	movs	r2, #40	; 0x28
c0d09606:	4910      	ldr	r1, [pc, #64]	; (c0d09648 <USBD_CtlError+0x84>)
c0d09608:	4479      	add	r1, pc
c0d0960a:	f000 f88d 	bl	c0d09728 <USBD_CtlSendData>
}
c0d0960e:	bd80      	pop	{r7, pc}
    && req->wIndex == WINUSB_GET_EXTENDED_PROPERTIES_OS_FEATURE 
c0d09610:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80) 
c0d09612:	2a05      	cmp	r2, #5
c0d09614:	d108      	bne.n	c0d09628 <USBD_CtlError+0x64>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_guid, MIN(req->wLength, sizeof(C_winusb_guid)));
c0d09616:	88ca      	ldrh	r2, [r1, #6]
c0d09618:	2a92      	cmp	r2, #146	; 0x92
c0d0961a:	d300      	bcc.n	c0d0961e <USBD_CtlError+0x5a>
c0d0961c:	2292      	movs	r2, #146	; 0x92
c0d0961e:	490b      	ldr	r1, [pc, #44]	; (c0d0964c <USBD_CtlError+0x88>)
c0d09620:	4479      	add	r1, pc
c0d09622:	f000 f881 	bl	c0d09728 <USBD_CtlSendData>
}
c0d09626:	bd80      	pop	{r7, pc}
      && req->wIndex == MS_OS_20_DESCRIPTOR_INDEX) {
c0d09628:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80)
c0d0962a:	2a07      	cmp	r2, #7
c0d0962c:	d1cf      	bne.n	c0d095ce <USBD_CtlError+0xa>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_request_descriptor, MIN(req->wLength, sizeof(C_winusb_request_descriptor)));
c0d0962e:	88ca      	ldrh	r2, [r1, #6]
c0d09630:	2ab2      	cmp	r2, #178	; 0xb2
c0d09632:	d300      	bcc.n	c0d09636 <USBD_CtlError+0x72>
c0d09634:	22b2      	movs	r2, #178	; 0xb2
c0d09636:	4906      	ldr	r1, [pc, #24]	; (c0d09650 <USBD_CtlError+0x8c>)
c0d09638:	4479      	add	r1, pc
c0d0963a:	f000 f875 	bl	c0d09728 <USBD_CtlSendData>
}
c0d0963e:	bd80      	pop	{r7, pc}
c0d09640:	000003ee 	.word	0x000003ee
c0d09644:	00003ca4 	.word	0x00003ca4
c0d09648:	00003ec8 	.word	0x00003ec8
c0d0964c:	00003c86 	.word	0x00003c86
c0d09650:	00003d00 	.word	0x00003d00

c0d09654 <USB_power>:
  // nothing to do ?
  return 0;
}
#endif // HAVE_USB_CLASS_CCID

void USB_power(unsigned char enabled) {
c0d09654:	b570      	push	{r4, r5, r6, lr}
c0d09656:	4604      	mov	r4, r0
  os_memset(&USBD_Device, 0, sizeof(USBD_Device));
c0d09658:	4823      	ldr	r0, [pc, #140]	; (c0d096e8 <USB_power+0x94>)
c0d0965a:	2500      	movs	r5, #0
c0d0965c:	22d4      	movs	r2, #212	; 0xd4
c0d0965e:	4629      	mov	r1, r5
c0d09660:	f7fa fe71 	bl	c0d04346 <os_memset>

  // init timeouts and other global fields
  os_memset(G_io_app.usb_ep_xfer_len, 0, sizeof(G_io_app.usb_ep_xfer_len));
c0d09664:	4e21      	ldr	r6, [pc, #132]	; (c0d096ec <USB_power+0x98>)
c0d09666:	4630      	mov	r0, r6
c0d09668:	300c      	adds	r0, #12
c0d0966a:	2204      	movs	r2, #4
c0d0966c:	4629      	mov	r1, r5
c0d0966e:	f7fa fe6a 	bl	c0d04346 <os_memset>
  os_memset(G_io_app.usb_ep_timeouts, 0, sizeof(G_io_app.usb_ep_timeouts));
c0d09672:	3610      	adds	r6, #16
c0d09674:	2208      	movs	r2, #8
c0d09676:	4630      	mov	r0, r6
c0d09678:	4629      	mov	r1, r5
c0d0967a:	f7fa fe64 	bl	c0d04346 <os_memset>

  if (enabled) {
c0d0967e:	2c00      	cmp	r4, #0
c0d09680:	d02d      	beq.n	c0d096de <USB_power+0x8a>
    os_memset(&USBD_Device, 0, sizeof(USBD_Device));
c0d09682:	4c19      	ldr	r4, [pc, #100]	; (c0d096e8 <USB_power+0x94>)
c0d09684:	2500      	movs	r5, #0
c0d09686:	22d4      	movs	r2, #212	; 0xd4
c0d09688:	4620      	mov	r0, r4
c0d0968a:	4629      	mov	r1, r5
c0d0968c:	f7fa fe5b 	bl	c0d04346 <os_memset>
    /* Init Device Library */
    USBD_Init(&USBD_Device, (USBD_DescriptorsTypeDef*)&HID_Desc, 0);
c0d09690:	4919      	ldr	r1, [pc, #100]	; (c0d096f8 <USB_power+0xa4>)
c0d09692:	4479      	add	r1, pc
c0d09694:	4620      	mov	r0, r4
c0d09696:	462a      	mov	r2, r5
c0d09698:	f7ff f9ca 	bl	c0d08a30 <USBD_Init>
    
    /* Register the HID class */
    USBD_RegisterClassForInterface(HID_INTF,  &USBD_Device, (USBD_ClassTypeDef*)&USBD_HID);
c0d0969c:	4a17      	ldr	r2, [pc, #92]	; (c0d096fc <USB_power+0xa8>)
c0d0969e:	447a      	add	r2, pc
c0d096a0:	4628      	mov	r0, r5
c0d096a2:	4621      	mov	r1, r4
c0d096a4:	f7ff f9f7 	bl	c0d08a96 <USBD_RegisterClassForInterface>
c0d096a8:	2001      	movs	r0, #1
#ifdef HAVE_IO_U2F
    USBD_RegisterClassForInterface(U2F_INTF,  &USBD_Device, (USBD_ClassTypeDef*)&USBD_U2F);
c0d096aa:	4a15      	ldr	r2, [pc, #84]	; (c0d09700 <USB_power+0xac>)
c0d096ac:	447a      	add	r2, pc
c0d096ae:	4621      	mov	r1, r4
c0d096b0:	f7ff f9f1 	bl	c0d08a96 <USBD_RegisterClassForInterface>
c0d096b4:	22ff      	movs	r2, #255	; 0xff
c0d096b6:	3252      	adds	r2, #82	; 0x52
    // initialize the U2F tunnel transport
    u2f_transport_init(&G_io_u2f, G_io_apdu_buffer, IO_APDU_BUFFER_SIZE);
c0d096b8:	480d      	ldr	r0, [pc, #52]	; (c0d096f0 <USB_power+0x9c>)
c0d096ba:	490e      	ldr	r1, [pc, #56]	; (c0d096f4 <USB_power+0xa0>)
c0d096bc:	f7fd fbf0 	bl	c0d06ea0 <u2f_transport_init>
c0d096c0:	2002      	movs	r0, #2
#ifdef HAVE_USB_CLASS_CCID
    USBD_RegisterClassForInterface(CCID_INTF, &USBD_Device, (USBD_ClassTypeDef*)&USBD_CCID);
#endif // HAVE_USB_CLASS_CCID

#ifdef HAVE_WEBUSB
    USBD_RegisterClassForInterface(WEBUSB_INTF, &USBD_Device, (USBD_ClassTypeDef*)&USBD_WEBUSB);
c0d096c2:	4a10      	ldr	r2, [pc, #64]	; (c0d09704 <USB_power+0xb0>)
c0d096c4:	447a      	add	r2, pc
c0d096c6:	4621      	mov	r1, r4
c0d096c8:	f7ff f9e5 	bl	c0d08a96 <USBD_RegisterClassForInterface>
c0d096cc:	2103      	movs	r1, #3
c0d096ce:	2240      	movs	r2, #64	; 0x40
    USBD_LL_PrepareReceive(&USBD_Device, WEBUSB_EPOUT_ADDR , WEBUSB_EPOUT_SIZE);
c0d096d0:	4620      	mov	r0, r4
c0d096d2:	f7ff f99a 	bl	c0d08a0a <USBD_LL_PrepareReceive>
#endif // HAVE_WEBUSB

    /* Start Device Process */
    USBD_Start(&USBD_Device);
c0d096d6:	4620      	mov	r0, r4
c0d096d8:	f7ff f9ea 	bl	c0d08ab0 <USBD_Start>
  }
  else {
    USBD_DeInit(&USBD_Device);
  }
}
c0d096dc:	bd70      	pop	{r4, r5, r6, pc}
    USBD_DeInit(&USBD_Device);
c0d096de:	4802      	ldr	r0, [pc, #8]	; (c0d096e8 <USB_power+0x94>)
c0d096e0:	f7ff f9be 	bl	c0d08a60 <USBD_DeInit>
}
c0d096e4:	bd70      	pop	{r4, r5, r6, pc}
c0d096e6:	46c0      	nop			; (mov r8, r8)
c0d096e8:	2000211c 	.word	0x2000211c
c0d096ec:	2000205c 	.word	0x2000205c
c0d096f0:	2000207c 	.word	0x2000207c
c0d096f4:	20001f09 	.word	0x20001f09
c0d096f8:	00003be2 	.word	0x00003be2
c0d096fc:	00003d4e 	.word	0x00003d4e
c0d09700:	00003d78 	.word	0x00003d78
c0d09704:	00003d98 	.word	0x00003d98

c0d09708 <USBD_GetCfgDesc_impl>:
{
c0d09708:	2160      	movs	r1, #96	; 0x60
  *length = sizeof (USBD_CfgDesc);
c0d0970a:	8001      	strh	r1, [r0, #0]
  return (uint8_t*)USBD_CfgDesc;
c0d0970c:	4801      	ldr	r0, [pc, #4]	; (c0d09714 <USBD_GetCfgDesc_impl+0xc>)
c0d0970e:	4478      	add	r0, pc
c0d09710:	4770      	bx	lr
c0d09712:	46c0      	nop			; (mov r8, r8)
c0d09714:	00003dea 	.word	0x00003dea

c0d09718 <USBD_GetDeviceQualifierDesc_impl>:
{
c0d09718:	210a      	movs	r1, #10
  *length = sizeof (USBD_DeviceQualifierDesc);
c0d0971a:	8001      	strh	r1, [r0, #0]
  return (uint8_t*)USBD_DeviceQualifierDesc;
c0d0971c:	4801      	ldr	r0, [pc, #4]	; (c0d09724 <USBD_GetDeviceQualifierDesc_impl+0xc>)
c0d0971e:	4478      	add	r0, pc
c0d09720:	4770      	bx	lr
c0d09722:	46c0      	nop			; (mov r8, r8)
c0d09724:	00003e3a 	.word	0x00003e3a

c0d09728 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
c0d09728:	b5b0      	push	{r4, r5, r7, lr}
c0d0972a:	460c      	mov	r4, r1
c0d0972c:	21d0      	movs	r1, #208	; 0xd0
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
  // store the continuation data if needed
  pdev->pData = pbuf;
c0d0972e:	5044      	str	r4, [r0, r1]
c0d09730:	2194      	movs	r1, #148	; 0x94
c0d09732:	2302      	movs	r3, #2
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
c0d09734:	5043      	str	r3, [r0, r1]
  pdev->ep_in[0].total_length = len;
c0d09736:	6182      	str	r2, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
c0d09738:	61c2      	str	r2, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, MIN(len, pdev->ep_in[0].maxpacket));  
c0d0973a:	6a01      	ldr	r1, [r0, #32]
c0d0973c:	4291      	cmp	r1, r2
c0d0973e:	d800      	bhi.n	c0d09742 <USBD_CtlSendData+0x1a>
c0d09740:	460a      	mov	r2, r1
c0d09742:	b293      	uxth	r3, r2
c0d09744:	2500      	movs	r5, #0
c0d09746:	4629      	mov	r1, r5
c0d09748:	4622      	mov	r2, r4
c0d0974a:	f7ff f945 	bl	c0d089d8 <USBD_LL_Transmit>
  
  return USBD_OK;
c0d0974e:	4628      	mov	r0, r5
c0d09750:	bdb0      	pop	{r4, r5, r7, pc}

c0d09752 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
c0d09752:	b5b0      	push	{r4, r5, r7, lr}
c0d09754:	460c      	mov	r4, r1
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, MIN(len, pdev->ep_in[0].maxpacket));   
c0d09756:	6a01      	ldr	r1, [r0, #32]
c0d09758:	4291      	cmp	r1, r2
c0d0975a:	d800      	bhi.n	c0d0975e <USBD_CtlContinueSendData+0xc>
c0d0975c:	460a      	mov	r2, r1
c0d0975e:	b293      	uxth	r3, r2
c0d09760:	2500      	movs	r5, #0
c0d09762:	4629      	mov	r1, r5
c0d09764:	4622      	mov	r2, r4
c0d09766:	f7ff f937 	bl	c0d089d8 <USBD_LL_Transmit>
  return USBD_OK;
c0d0976a:	4628      	mov	r0, r5
c0d0976c:	bdb0      	pop	{r4, r5, r7, pc}

c0d0976e <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
c0d0976e:	b510      	push	{r4, lr}
c0d09770:	2400      	movs	r4, #0
  UNUSED(pbuf);
  USBD_LL_PrepareReceive (pdev,
c0d09772:	4621      	mov	r1, r4
c0d09774:	f7ff f949 	bl	c0d08a0a <USBD_LL_PrepareReceive>
                          0,                                            
                          len);
  return USBD_OK;
c0d09778:	4620      	mov	r0, r4
c0d0977a:	bd10      	pop	{r4, pc}

c0d0977c <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
c0d0977c:	b510      	push	{r4, lr}
c0d0977e:	2194      	movs	r1, #148	; 0x94
c0d09780:	2204      	movs	r2, #4

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
c0d09782:	5042      	str	r2, [r0, r1]
c0d09784:	2400      	movs	r4, #0
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
c0d09786:	4621      	mov	r1, r4
c0d09788:	4622      	mov	r2, r4
c0d0978a:	4623      	mov	r3, r4
c0d0978c:	f7ff f924 	bl	c0d089d8 <USBD_LL_Transmit>
  
  return USBD_OK;
c0d09790:	4620      	mov	r0, r4
c0d09792:	bd10      	pop	{r4, pc}

c0d09794 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
c0d09794:	b510      	push	{r4, lr}
c0d09796:	2194      	movs	r1, #148	; 0x94
c0d09798:	2205      	movs	r2, #5
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
c0d0979a:	5042      	str	r2, [r0, r1]
c0d0979c:	2400      	movs	r4, #0
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
c0d0979e:	4621      	mov	r1, r4
c0d097a0:	4622      	mov	r2, r4
c0d097a2:	f7ff f932 	bl	c0d08a0a <USBD_LL_PrepareReceive>
                    0,
                    0);  

  return USBD_OK;
c0d097a6:	4620      	mov	r0, r4
c0d097a8:	bd10      	pop	{r4, pc}
	...

c0d097ac <array_hexstr>:
#include "tokens.h"

static const unsigned char hex_digits[] =
    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

void array_hexstr(char *strbuf, const void *bin, unsigned int len) {
c0d097ac:	b5b0      	push	{r4, r5, r7, lr}
    while (len--) {
c0d097ae:	2a00      	cmp	r2, #0
c0d097b0:	d00e      	beq.n	c0d097d0 <array_hexstr+0x24>
c0d097b2:	4b09      	ldr	r3, [pc, #36]	; (c0d097d8 <array_hexstr+0x2c>)
c0d097b4:	447b      	add	r3, pc
        *strbuf++ = hex_digits[((*((char *) bin)) >> 4) & 0xF];
c0d097b6:	780c      	ldrb	r4, [r1, #0]
c0d097b8:	0924      	lsrs	r4, r4, #4
c0d097ba:	5d1c      	ldrb	r4, [r3, r4]
c0d097bc:	7004      	strb	r4, [r0, #0]
        *strbuf++ = hex_digits[(*((char *) bin)) & 0xF];
c0d097be:	780c      	ldrb	r4, [r1, #0]
c0d097c0:	250f      	movs	r5, #15
c0d097c2:	4025      	ands	r5, r4
c0d097c4:	5d5c      	ldrb	r4, [r3, r5]
c0d097c6:	7044      	strb	r4, [r0, #1]
c0d097c8:	1c80      	adds	r0, r0, #2
        bin = (const void *) ((unsigned int) bin + 1);
c0d097ca:	1c49      	adds	r1, r1, #1
    while (len--) {
c0d097cc:	1e52      	subs	r2, r2, #1
c0d097ce:	d1f2      	bne.n	c0d097b6 <array_hexstr+0xa>
c0d097d0:	2100      	movs	r1, #0
    }
    *strbuf = 0;  // EOS
c0d097d2:	7001      	strb	r1, [r0, #0]
}
c0d097d4:	bdb0      	pop	{r4, r5, r7, pc}
c0d097d6:	46c0      	nop			; (mov r8, r8)
c0d097d8:	000026e3 	.word	0x000026e3

c0d097dc <convertUint256BE>:

void convertUint256BE(uint8_t *data, uint32_t length, uint256_t *target) {
c0d097dc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d097de:	b089      	sub	sp, #36	; 0x24
c0d097e0:	4614      	mov	r4, r2
c0d097e2:	460d      	mov	r5, r1
c0d097e4:	4606      	mov	r6, r0
c0d097e6:	af01      	add	r7, sp, #4
c0d097e8:	2120      	movs	r1, #32
    uint8_t tmp[32];
    memset(tmp, 0, 32);
c0d097ea:	4638      	mov	r0, r7
c0d097ec:	f000 ff3e 	bl	c0d0a66c <__aeabi_memclr>
    memmove(tmp + 32 - length, data, length);
c0d097f0:	1b78      	subs	r0, r7, r5
c0d097f2:	3020      	adds	r0, #32
c0d097f4:	4631      	mov	r1, r6
c0d097f6:	462a      	mov	r2, r5
c0d097f8:	f000 ff3e 	bl	c0d0a678 <__aeabi_memcpy>
    readu256BE(tmp, target);
c0d097fc:	4638      	mov	r0, r7
c0d097fe:	4621      	mov	r1, r4
c0d09800:	f7fe faca 	bl	c0d07d98 <readu256BE>
}
c0d09804:	b009      	add	sp, #36	; 0x24
c0d09806:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d09808 <getV>:
        }
    }
    return -1;
}

uint32_t getV(txContent_t *txContent) {
c0d09808:	b580      	push	{r7, lr}
c0d0980a:	21ff      	movs	r1, #255	; 0xff
c0d0980c:	460a      	mov	r2, r1
c0d0980e:	3222      	adds	r2, #34	; 0x22
    uint32_t v = 0;
    if (txContent->vLength == 1) {
c0d09810:	5c82      	ldrb	r2, [r0, r2]
c0d09812:	2a01      	cmp	r2, #1
c0d09814:	dd10      	ble.n	c0d09838 <getV+0x30>
c0d09816:	2a02      	cmp	r2, #2
c0d09818:	d012      	beq.n	c0d09840 <getV+0x38>
c0d0981a:	2a03      	cmp	r2, #3
c0d0981c:	d118      	bne.n	c0d09850 <getV+0x48>
c0d0981e:	460a      	mov	r2, r1
c0d09820:	321e      	adds	r2, #30
        v = txContent->v[0];
    } else if (txContent->vLength == 2) {
        v = (txContent->v[0] << 8) | txContent->v[1];
    } else if (txContent->vLength == 3) {
        v = (txContent->v[0] << 16) | (txContent->v[1] << 8) | txContent->v[2];
c0d09822:	5c82      	ldrb	r2, [r0, r2]
c0d09824:	0412      	lsls	r2, r2, #16
c0d09826:	238f      	movs	r3, #143	; 0x8f
c0d09828:	005b      	lsls	r3, r3, #1
c0d0982a:	5cc3      	ldrb	r3, [r0, r3]
c0d0982c:	021b      	lsls	r3, r3, #8
c0d0982e:	189a      	adds	r2, r3, r2
c0d09830:	3120      	adds	r1, #32
c0d09832:	5c40      	ldrb	r0, [r0, r1]
c0d09834:	1810      	adds	r0, r2, r0
            txContent->v[3];
    } else if (txContent->vLength != 0) {
        PRINTF("Unexpected v format\n");
        THROW(EXCEPTION);
    }
    return v;
c0d09836:	bd80      	pop	{r7, pc}
    if (txContent->vLength == 1) {
c0d09838:	2a00      	cmp	r2, #0
c0d0983a:	d11d      	bne.n	c0d09878 <getV+0x70>
c0d0983c:	2000      	movs	r0, #0
    return v;
c0d0983e:	bd80      	pop	{r7, pc}
c0d09840:	228f      	movs	r2, #143	; 0x8f
c0d09842:	0052      	lsls	r2, r2, #1
        v = (txContent->v[0] << 8) | txContent->v[1];
c0d09844:	5c82      	ldrb	r2, [r0, r2]
c0d09846:	311e      	adds	r1, #30
c0d09848:	5c40      	ldrb	r0, [r0, r1]
c0d0984a:	0200      	lsls	r0, r0, #8
c0d0984c:	1880      	adds	r0, r0, r2
    return v;
c0d0984e:	bd80      	pop	{r7, pc}
    if (txContent->vLength == 1) {
c0d09850:	2a04      	cmp	r2, #4
c0d09852:	d116      	bne.n	c0d09882 <getV+0x7a>
c0d09854:	460a      	mov	r2, r1
c0d09856:	321e      	adds	r2, #30
        v = (txContent->v[0] << 24) | (txContent->v[1] << 16) | (txContent->v[2] << 8) |
c0d09858:	5c82      	ldrb	r2, [r0, r2]
c0d0985a:	0612      	lsls	r2, r2, #24
c0d0985c:	238f      	movs	r3, #143	; 0x8f
c0d0985e:	005b      	lsls	r3, r3, #1
c0d09860:	5cc3      	ldrb	r3, [r0, r3]
c0d09862:	041b      	lsls	r3, r3, #16
c0d09864:	189a      	adds	r2, r3, r2
c0d09866:	3120      	adds	r1, #32
c0d09868:	5c41      	ldrb	r1, [r0, r1]
c0d0986a:	0209      	lsls	r1, r1, #8
c0d0986c:	1851      	adds	r1, r2, r1
c0d0986e:	2209      	movs	r2, #9
c0d09870:	0152      	lsls	r2, r2, #5
            txContent->v[3];
c0d09872:	5c80      	ldrb	r0, [r0, r2]
        v = (txContent->v[0] << 24) | (txContent->v[1] << 16) | (txContent->v[2] << 8) |
c0d09874:	1808      	adds	r0, r1, r0
    return v;
c0d09876:	bd80      	pop	{r7, pc}
    if (txContent->vLength == 1) {
c0d09878:	2a01      	cmp	r2, #1
c0d0987a:	d102      	bne.n	c0d09882 <getV+0x7a>
c0d0987c:	311e      	adds	r1, #30
        v = txContent->v[0];
c0d0987e:	5c40      	ldrb	r0, [r0, r1]
    return v;
c0d09880:	bd80      	pop	{r7, pc}
        PRINTF("Unexpected v format\n");
c0d09882:	4803      	ldr	r0, [pc, #12]	; (c0d09890 <getV+0x88>)
c0d09884:	4478      	add	r0, pc
c0d09886:	f7fb fbd9 	bl	c0d0503c <mcu_usb_printf>
c0d0988a:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0d0988c:	f7fa fd7a 	bl	c0d04384 <os_longjmp>
c0d09890:	00003cde 	.word	0x00003cde

c0d09894 <amountToString>:
void amountToString(uint8_t *amount,
                    uint8_t amount_size,
                    uint8_t decimals,
                    char *ticker,
                    char *out_buffer,
                    uint8_t out_buffer_size) {
c0d09894:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09896:	b0a7      	sub	sp, #156	; 0x9c
c0d09898:	461d      	mov	r5, r3
c0d0989a:	9204      	str	r2, [sp, #16]
c0d0989c:	460e      	mov	r6, r1
c0d0989e:	4607      	mov	r7, r0
c0d098a0:	ac05      	add	r4, sp, #20
c0d098a2:	2120      	movs	r1, #32
    memset(tmp, 0, 32);
c0d098a4:	4620      	mov	r0, r4
c0d098a6:	f000 fee1 	bl	c0d0a66c <__aeabi_memclr>
    memmove(tmp + 32 - length, data, length);
c0d098aa:	1ba0      	subs	r0, r4, r6
c0d098ac:	3020      	adds	r0, #32
c0d098ae:	4639      	mov	r1, r7
c0d098b0:	4632      	mov	r2, r6
c0d098b2:	f000 fee1 	bl	c0d0a678 <__aeabi_memcpy>
c0d098b6:	af1e      	add	r7, sp, #120	; 0x78
    readu256BE(tmp, target);
c0d098b8:	4620      	mov	r0, r4
c0d098ba:	4639      	mov	r1, r7
c0d098bc:	f7fe fa6c 	bl	c0d07d98 <readu256BE>
c0d098c0:	210a      	movs	r1, #10
c0d098c2:	ae05      	add	r6, sp, #20
c0d098c4:	2464      	movs	r4, #100	; 0x64
    uint256_t amount_256;
    char tmp_buffer[100];
    convertUint256BE(amount, amount_size, &amount_256);
    tostring256(&amount_256, 10, tmp_buffer, 100);
c0d098c6:	4638      	mov	r0, r7
c0d098c8:	4632      	mov	r2, r6
c0d098ca:	4623      	mov	r3, r4
c0d098cc:	f7fe ff1c 	bl	c0d08708 <tostring256>

    uint8_t amount_len = strnlen(tmp_buffer, sizeof(tmp_buffer));
c0d098d0:	4630      	mov	r0, r6
c0d098d2:	4621      	mov	r1, r4
c0d098d4:	f001 f92e 	bl	c0d0ab34 <strnlen>
c0d098d8:	9002      	str	r0, [sp, #8]
c0d098da:	210c      	movs	r1, #12
c0d098dc:	9503      	str	r5, [sp, #12]
    uint8_t ticker_len = strnlen(ticker, MAX_TICKER_LEN);
c0d098de:	4628      	mov	r0, r5
c0d098e0:	f001 f928 	bl	c0d0ab34 <strnlen>

    memcpy(out_buffer, ticker, MIN(out_buffer_size, ticker_len));
c0d098e4:	b2c7      	uxtb	r7, r0
c0d098e6:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
c0d098e8:	42af      	cmp	r7, r5
c0d098ea:	462a      	mov	r2, r5
c0d098ec:	d800      	bhi.n	c0d098f0 <amountToString+0x5c>
c0d098ee:	463a      	mov	r2, r7
c0d098f0:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
c0d098f2:	4620      	mov	r0, r4
c0d098f4:	9903      	ldr	r1, [sp, #12]
c0d098f6:	f000 febf 	bl	c0d0a678 <__aeabi_memcpy>

    adjustDecimals(tmp_buffer,
c0d098fa:	4668      	mov	r0, sp
c0d098fc:	9904      	ldr	r1, [sp, #16]
c0d098fe:	6001      	str	r1, [r0, #0]
                   amount_len,
                   out_buffer + ticker_len,
c0d09900:	19e2      	adds	r2, r4, r7
                   out_buffer_size - ticker_len - 1,
c0d09902:	43f8      	mvns	r0, r7
c0d09904:	1943      	adds	r3, r0, r5
                   amount_len,
c0d09906:	9802      	ldr	r0, [sp, #8]
c0d09908:	b2c1      	uxtb	r1, r0
    adjustDecimals(tmp_buffer,
c0d0990a:	4630      	mov	r0, r6
c0d0990c:	f7f8 ff3e 	bl	c0d0278c <adjustDecimals>
c0d09910:	1960      	adds	r0, r4, r5
c0d09912:	2100      	movs	r1, #0
c0d09914:	43ca      	mvns	r2, r1
                   decimals);
    out_buffer[out_buffer_size - 1] = '\0';
c0d09916:	5481      	strb	r1, [r0, r2]
}
c0d09918:	b027      	add	sp, #156	; 0x9c
c0d0991a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d0991c <parse_swap_config>:

bool parse_swap_config(uint8_t *config, uint8_t config_len, char *ticker, uint8_t *decimals) {
c0d0991c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0991e:	b081      	sub	sp, #4
c0d09920:	4605      	mov	r5, r0
c0d09922:	2000      	movs	r0, #0
    uint8_t ticker_len, offset = 0;
    if (config_len == 0) {
c0d09924:	2900      	cmp	r1, #0
c0d09926:	d01b      	beq.n	c0d09960 <parse_swap_config+0x44>
c0d09928:	460e      	mov	r6, r1
        return false;
    }
    ticker_len = config[offset++];
c0d0992a:	782c      	ldrb	r4, [r5, #0]
    if (ticker_len == 0 || ticker_len > MAX_TICKER_LEN - 2 || config_len - offset < ticker_len) {
c0d0992c:	428c      	cmp	r4, r1
c0d0992e:	d217      	bcs.n	c0d09960 <parse_swap_config+0x44>
c0d09930:	1e61      	subs	r1, r4, #1
c0d09932:	b2c9      	uxtb	r1, r1
c0d09934:	2909      	cmp	r1, #9
c0d09936:	d813      	bhi.n	c0d09960 <parse_swap_config+0x44>
c0d09938:	4617      	mov	r7, r2
        return false;
    }
    memcpy(ticker, config + offset, ticker_len);
c0d0993a:	1c69      	adds	r1, r5, #1
c0d0993c:	4610      	mov	r0, r2
c0d0993e:	4622      	mov	r2, r4
c0d09940:	9300      	str	r3, [sp, #0]
c0d09942:	f000 fe99 	bl	c0d0a678 <__aeabi_memcpy>
c0d09946:	9a00      	ldr	r2, [sp, #0]
c0d09948:	2020      	movs	r0, #32
    offset += ticker_len;
    ticker[ticker_len] = ' ';
c0d0994a:	5538      	strb	r0, [r7, r4]
    memcpy(ticker, config + offset, ticker_len);
c0d0994c:	1939      	adds	r1, r7, r4
c0d0994e:	2000      	movs	r0, #0
    ticker[ticker_len + 1] = '\0';
c0d09950:	7048      	strb	r0, [r1, #1]

    if (config_len - offset < 1) {
c0d09952:	1c61      	adds	r1, r4, #1
c0d09954:	b2c9      	uxtb	r1, r1
c0d09956:	42b1      	cmp	r1, r6
c0d09958:	d202      	bcs.n	c0d09960 <parse_swap_config+0x44>
        return false;
    }
    *decimals = config[offset];
c0d0995a:	5c68      	ldrb	r0, [r5, r1]
c0d0995c:	7010      	strb	r0, [r2, #0]
c0d0995e:	2001      	movs	r0, #1
    return true;
}
c0d09960:	b001      	add	sp, #4
c0d09962:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d09964 <ux_flow_is_first>:
	}
	return 1;
}

// to hide the left tick or not
unsigned int ux_flow_is_first(void) {
c0d09964:	b5b0      	push	{r4, r5, r7, lr}
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d09966:	4912      	ldr	r1, [pc, #72]	; (c0d099b0 <ux_flow_is_first+0x4c>)
c0d09968:	780a      	ldrb	r2, [r1, #0]
c0d0996a:	2001      	movs	r0, #1
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d0996c:	2a01      	cmp	r2, #1
c0d0996e:	d81d      	bhi.n	c0d099ac <ux_flow_is_first+0x48>
c0d09970:	1e52      	subs	r2, r2, #1
c0d09972:	230c      	movs	r3, #12
c0d09974:	4353      	muls	r3, r2
c0d09976:	18cb      	adds	r3, r1, r3
c0d09978:	8b1a      	ldrh	r2, [r3, #24]
	// no previous ?
	if (!ux_flow_check_valid()
		|| G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d0997a:	2a00      	cmp	r2, #0
c0d0997c:	d016      	beq.n	c0d099ac <ux_flow_is_first+0x48>
c0d0997e:	6919      	ldr	r1, [r3, #16]
		|| (G_ux.flow_stack[G_ux.stack_count-1].index == 0 
c0d09980:	2900      	cmp	r1, #0
c0d09982:	d013      	beq.n	c0d099ac <ux_flow_is_first+0x48>
c0d09984:	8a9b      	ldrh	r3, [r3, #20]
			  && G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].length-1] != FLOW_LOOP)) {
c0d09986:	2b00      	cmp	r3, #0
c0d09988:	d106      	bne.n	c0d09998 <ux_flow_is_first+0x34>
c0d0998a:	0094      	lsls	r4, r2, #2
c0d0998c:	190c      	adds	r4, r1, r4
c0d0998e:	2503      	movs	r5, #3
c0d09990:	43ed      	mvns	r5, r5
c0d09992:	5964      	ldr	r4, [r4, r5]
	if (!ux_flow_check_valid()
c0d09994:	1ce4      	adds	r4, r4, #3
c0d09996:	d109      	bne.n	c0d099ac <ux_flow_is_first+0x48>
		return 1;
	}

	// previous is a flow barrier ?
	if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
		&& G_ux.flow_stack[G_ux.stack_count-1].index < G_ux.flow_stack[G_ux.stack_count-1].length
c0d09998:	4293      	cmp	r3, r2
c0d0999a:	d206      	bcs.n	c0d099aa <ux_flow_is_first+0x46>
		&& G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index-1] == FLOW_BARRIER) {
c0d0999c:	009a      	lsls	r2, r3, #2
c0d0999e:	1889      	adds	r1, r1, r2
c0d099a0:	2203      	movs	r2, #3
c0d099a2:	43d2      	mvns	r2, r2
c0d099a4:	5889      	ldr	r1, [r1, r2]
	if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d099a6:	1c89      	adds	r1, r1, #2
c0d099a8:	d000      	beq.n	c0d099ac <ux_flow_is_first+0x48>
c0d099aa:	2000      	movs	r0, #0
		return 1;
	}

	// not the first, for sure
	return 0;
}
c0d099ac:	bdb0      	pop	{r4, r5, r7, pc}
c0d099ae:	46c0      	nop			; (mov r8, r8)
c0d099b0:	20001a00 	.word	0x20001a00

c0d099b4 <ux_flow_is_last>:

unsigned int ux_flow_is_last(void){
c0d099b4:	b510      	push	{r4, lr}
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d099b6:	490e      	ldr	r1, [pc, #56]	; (c0d099f0 <ux_flow_is_last+0x3c>)
c0d099b8:	780a      	ldrb	r2, [r1, #0]
c0d099ba:	2001      	movs	r0, #1
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d099bc:	2a01      	cmp	r2, #1
c0d099be:	d816      	bhi.n	c0d099ee <ux_flow_is_last+0x3a>
c0d099c0:	1e52      	subs	r2, r2, #1
c0d099c2:	230c      	movs	r3, #12
c0d099c4:	4353      	muls	r3, r2
c0d099c6:	18cb      	adds	r3, r1, r3
c0d099c8:	8b1a      	ldrh	r2, [r3, #24]
	// last ?
	if (!ux_flow_check_valid()
		|| G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d099ca:	2a00      	cmp	r2, #0
c0d099cc:	d00f      	beq.n	c0d099ee <ux_flow_is_last+0x3a>
c0d099ce:	6919      	ldr	r1, [r3, #16]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0
c0d099d0:	2900      	cmp	r1, #0
c0d099d2:	d00c      	beq.n	c0d099ee <ux_flow_is_last+0x3a>
		|| G_ux.flow_stack[G_ux.stack_count-1].index >= G_ux.flow_stack[G_ux.stack_count-1].length -1) {
c0d099d4:	8a9b      	ldrh	r3, [r3, #20]
c0d099d6:	1e54      	subs	r4, r2, #1
	if (!ux_flow_check_valid()
c0d099d8:	429c      	cmp	r4, r3
c0d099da:	dd08      	ble.n	c0d099ee <ux_flow_is_last+0x3a>
		return 1;
	}

	// followed by a flow barrier ?
	if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
		&& G_ux.flow_stack[G_ux.stack_count-1].index < G_ux.flow_stack[G_ux.stack_count-1].length - 2
c0d099dc:	1e92      	subs	r2, r2, #2
c0d099de:	429a      	cmp	r2, r3
c0d099e0:	dd04      	ble.n	c0d099ec <ux_flow_is_last+0x38>
		&& G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d099e2:	009a      	lsls	r2, r3, #2
c0d099e4:	1889      	adds	r1, r1, r2
c0d099e6:	6849      	ldr	r1, [r1, #4]
	if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d099e8:	1c89      	adds	r1, r1, #2
c0d099ea:	d000      	beq.n	c0d099ee <ux_flow_is_last+0x3a>
c0d099ec:	2000      	movs	r0, #0
		return 1;
	}

	// is not last
	return 0;
}
c0d099ee:	bd10      	pop	{r4, pc}
c0d099f0:	20001a00 	.word	0x20001a00

c0d099f4 <ux_flow_direction>:

ux_flow_direction_t ux_flow_direction(void) {
	if (G_ux.stack_count) {
c0d099f4:	4809      	ldr	r0, [pc, #36]	; (c0d09a1c <ux_flow_direction+0x28>)
c0d099f6:	7801      	ldrb	r1, [r0, #0]
c0d099f8:	2900      	cmp	r1, #0
c0d099fa:	d00c      	beq.n	c0d09a16 <ux_flow_direction+0x22>
c0d099fc:	220c      	movs	r2, #12
		if (G_ux.flow_stack[G_ux.stack_count-1].index > G_ux.flow_stack[G_ux.stack_count-1].prev_index) {
c0d099fe:	434a      	muls	r2, r1
c0d09a00:	1881      	adds	r1, r0, r2
c0d09a02:	8948      	ldrh	r0, [r1, #10]
c0d09a04:	8909      	ldrh	r1, [r1, #8]
c0d09a06:	4281      	cmp	r1, r0
c0d09a08:	d901      	bls.n	c0d09a0e <ux_flow_direction+0x1a>
c0d09a0a:	2001      	movs	r0, #1
c0d09a0c:	e004      	b.n	c0d09a18 <ux_flow_direction+0x24>
		return FLOW_DIRECTION_FORWARD;
		}
		else if (G_ux.flow_stack[G_ux.stack_count-1].index < G_ux.flow_stack[G_ux.stack_count-1].prev_index) {
c0d09a0e:	4281      	cmp	r1, r0
c0d09a10:	d201      	bcs.n	c0d09a16 <ux_flow_direction+0x22>
c0d09a12:	20ff      	movs	r0, #255	; 0xff
c0d09a14:	e000      	b.n	c0d09a18 <ux_flow_direction+0x24>
c0d09a16:	2000      	movs	r0, #0
			return FLOW_DIRECTION_BACKWARD;
		}
	}
  return FLOW_DIRECTION_START;
}
c0d09a18:	b240      	sxtb	r0, r0
c0d09a1a:	4770      	bx	lr
c0d09a1c:	20001a00 	.word	0x20001a00

c0d09a20 <ux_flow_next_internal>:
			           STEPSPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->validate_flow), 
			           (const ux_flow_step_t*) PIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->params));
	}
}

static void ux_flow_next_internal(unsigned int display_step) {
c0d09a20:	b570      	push	{r4, r5, r6, lr}
c0d09a22:	4601      	mov	r1, r0
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d09a24:	4a15      	ldr	r2, [pc, #84]	; (c0d09a7c <ux_flow_next_internal+0x5c>)
c0d09a26:	7810      	ldrb	r0, [r2, #0]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d09a28:	2801      	cmp	r0, #1
c0d09a2a:	d826      	bhi.n	c0d09a7a <ux_flow_next_internal+0x5a>
c0d09a2c:	1e40      	subs	r0, r0, #1
c0d09a2e:	230c      	movs	r3, #12
c0d09a30:	4343      	muls	r3, r0
c0d09a32:	18d2      	adds	r2, r2, r3
c0d09a34:	8b16      	ldrh	r6, [r2, #24]
	// last reached already (need validation, not next)
	if (!ux_flow_check_valid()
		|| G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d09a36:	2e00      	cmp	r6, #0
c0d09a38:	d01f      	beq.n	c0d09a7a <ux_flow_next_internal+0x5a>
c0d09a3a:	6914      	ldr	r4, [r2, #16]
		|| G_ux.flow_stack[G_ux.stack_count-1].length <= 1
c0d09a3c:	2c00      	cmp	r4, #0
c0d09a3e:	d01c      	beq.n	c0d09a7a <ux_flow_next_internal+0x5a>
		|| G_ux.flow_stack[G_ux.stack_count-1].index >= G_ux.flow_stack[G_ux.stack_count-1].length -1) {
c0d09a40:	2e02      	cmp	r6, #2
c0d09a42:	d31a      	bcc.n	c0d09a7a <ux_flow_next_internal+0x5a>
c0d09a44:	8a93      	ldrh	r3, [r2, #20]
c0d09a46:	1e75      	subs	r5, r6, #1
	if (!ux_flow_check_valid()
c0d09a48:	429d      	cmp	r5, r3
c0d09a4a:	dd16      	ble.n	c0d09a7a <ux_flow_next_internal+0x5a>
c0d09a4c:	4615      	mov	r5, r2
c0d09a4e:	3514      	adds	r5, #20
		return;
	}

	// followed by a flow barrier ? => need validation instead of next
	if (G_ux.flow_stack[G_ux.stack_count-1].index <= G_ux.flow_stack[G_ux.stack_count-1].length - 2) {
c0d09a50:	1eb6      	subs	r6, r6, #2
c0d09a52:	429e      	cmp	r6, r3
c0d09a54:	db0a      	blt.n	c0d09a6c <ux_flow_next_internal+0x4c>
		if (G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d09a56:	009e      	lsls	r6, r3, #2
c0d09a58:	19a4      	adds	r4, r4, r6
c0d09a5a:	6864      	ldr	r4, [r4, #4]
c0d09a5c:	1ca6      	adds	r6, r4, #2
c0d09a5e:	d00c      	beq.n	c0d09a7a <ux_flow_next_internal+0x5a>
c0d09a60:	1ce4      	adds	r4, r4, #3
c0d09a62:	d103      	bne.n	c0d09a6c <ux_flow_next_internal+0x4c>
c0d09a64:	2100      	movs	r1, #0
		}

		// followed by a flow barrier ? => need validation instead of next
		if (G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_LOOP) {
			// display first step, fake direction as forward
			G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index = 0;
c0d09a66:	8029      	strh	r1, [r5, #0]
c0d09a68:	82d1      	strh	r1, [r2, #22]
c0d09a6a:	e004      	b.n	c0d09a76 <ux_flow_next_internal+0x56>
			return;
		}
	}

	// advance flow pointer and display it (skip META STEPS)
	G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index;
c0d09a6c:	82d3      	strh	r3, [r2, #22]
	G_ux.flow_stack[G_ux.stack_count-1].index++;
c0d09a6e:	1c5a      	adds	r2, r3, #1
c0d09a70:	802a      	strh	r2, [r5, #0]
	if (display_step) {
c0d09a72:	2900      	cmp	r1, #0
c0d09a74:	d001      	beq.n	c0d09a7a <ux_flow_next_internal+0x5a>
c0d09a76:	f000 f83b 	bl	c0d09af0 <ux_flow_engine_init_step>
		ux_flow_engine_init_step(G_ux.stack_count-1);
	}
}
c0d09a7a:	bd70      	pop	{r4, r5, r6, pc}
c0d09a7c:	20001a00 	.word	0x20001a00

c0d09a80 <ux_flow_next>:

void ux_flow_next_no_display(void) {
	ux_flow_next_internal(0);
}

void ux_flow_next(void) {
c0d09a80:	b580      	push	{r7, lr}
c0d09a82:	2001      	movs	r0, #1
	ux_flow_next_internal(1);
c0d09a84:	f7ff ffcc 	bl	c0d09a20 <ux_flow_next_internal>
}
c0d09a88:	bd80      	pop	{r7, pc}
	...

c0d09a8c <ux_flow_prev>:

void ux_flow_prev(void) {
c0d09a8c:	b5b0      	push	{r4, r5, r7, lr}
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d09a8e:	4917      	ldr	r1, [pc, #92]	; (c0d09aec <ux_flow_prev+0x60>)
c0d09a90:	7808      	ldrb	r0, [r1, #0]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d09a92:	2801      	cmp	r0, #1
c0d09a94:	d828      	bhi.n	c0d09ae8 <ux_flow_prev+0x5c>
c0d09a96:	1e40      	subs	r0, r0, #1
c0d09a98:	220c      	movs	r2, #12
c0d09a9a:	4342      	muls	r2, r0
c0d09a9c:	1889      	adds	r1, r1, r2
c0d09a9e:	8b0a      	ldrh	r2, [r1, #24]
	// first reached already
	if (!ux_flow_check_valid()
		|| G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d09aa0:	2a00      	cmp	r2, #0
c0d09aa2:	d021      	beq.n	c0d09ae8 <ux_flow_prev+0x5c>
c0d09aa4:	690c      	ldr	r4, [r1, #16]
		|| G_ux.flow_stack[G_ux.stack_count-1].length <= 1
c0d09aa6:	2c00      	cmp	r4, #0
c0d09aa8:	d01e      	beq.n	c0d09ae8 <ux_flow_prev+0x5c>
		|| (G_ux.flow_stack[G_ux.stack_count-1].index == 0 
c0d09aaa:	2a02      	cmp	r2, #2
c0d09aac:	d31c      	bcc.n	c0d09ae8 <ux_flow_prev+0x5c>
c0d09aae:	8a8d      	ldrh	r5, [r1, #20]
c0d09ab0:	460b      	mov	r3, r1
c0d09ab2:	3314      	adds	r3, #20
			  && G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].length-1] != FLOW_LOOP)) {
c0d09ab4:	2d00      	cmp	r5, #0
c0d09ab6:	d00a      	beq.n	c0d09ace <ux_flow_prev+0x42>
		ux_flow_engine_init_step(G_ux.stack_count-1);
		return;
	}

	// previous item is a flow barrier ?
	if (G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index-1] == FLOW_BARRIER) {
c0d09ab8:	00aa      	lsls	r2, r5, #2
c0d09aba:	18a2      	adds	r2, r4, r2
c0d09abc:	2403      	movs	r4, #3
c0d09abe:	43e4      	mvns	r4, r4
c0d09ac0:	5912      	ldr	r2, [r2, r4]
c0d09ac2:	1c92      	adds	r2, r2, #2
c0d09ac4:	d010      	beq.n	c0d09ae8 <ux_flow_prev+0x5c>
		return;
	}

	// advance flow pointer and display it (skip META STEPS)
	G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index;
c0d09ac6:	82cd      	strh	r5, [r1, #22]
	G_ux.flow_stack[G_ux.stack_count-1].index--;
c0d09ac8:	1e69      	subs	r1, r5, #1
c0d09aca:	8019      	strh	r1, [r3, #0]
c0d09acc:	e00a      	b.n	c0d09ae4 <ux_flow_prev+0x58>
			  && G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].length-1] != FLOW_LOOP)) {
c0d09ace:	0095      	lsls	r5, r2, #2
c0d09ad0:	1964      	adds	r4, r4, r5
c0d09ad2:	2503      	movs	r5, #3
c0d09ad4:	43ed      	mvns	r5, r5
c0d09ad6:	5964      	ldr	r4, [r4, r5]
	if (!ux_flow_check_valid()
c0d09ad8:	1ce4      	adds	r4, r4, #3
c0d09ada:	d105      	bne.n	c0d09ae8 <ux_flow_prev+0x5c>
		G_ux.flow_stack[G_ux.stack_count-1].index = G_ux.flow_stack[G_ux.stack_count-1].length-2;
c0d09adc:	1e94      	subs	r4, r2, #2
c0d09ade:	801c      	strh	r4, [r3, #0]
		G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index+1;
c0d09ae0:	1e52      	subs	r2, r2, #1
c0d09ae2:	82ca      	strh	r2, [r1, #22]
c0d09ae4:	f000 f804 	bl	c0d09af0 <ux_flow_engine_init_step>

	ux_flow_engine_init_step(G_ux.stack_count-1);
}
c0d09ae8:	bdb0      	pop	{r4, r5, r7, pc}
c0d09aea:	46c0      	nop			; (mov r8, r8)
c0d09aec:	20001a00 	.word	0x20001a00

c0d09af0 <ux_flow_engine_init_step>:
static void ux_flow_engine_init_step(unsigned int stack_slot) {
c0d09af0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09af2:	b081      	sub	sp, #4
c0d09af4:	4604      	mov	r4, r0
c0d09af6:	200c      	movs	r0, #12
	if (G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] == FLOW_END_STEP) {
c0d09af8:	4360      	muls	r0, r4
c0d09afa:	491a      	ldr	r1, [pc, #104]	; (c0d09b64 <ux_flow_engine_init_step+0x74>)
c0d09afc:	180e      	adds	r6, r1, r0
c0d09afe:	6930      	ldr	r0, [r6, #16]
c0d09b00:	8ab1      	ldrh	r1, [r6, #20]
c0d09b02:	0089      	lsls	r1, r1, #2
c0d09b04:	5840      	ldr	r0, [r0, r1]
c0d09b06:	2103      	movs	r1, #3
c0d09b08:	43c9      	mvns	r1, r1
c0d09b0a:	4288      	cmp	r0, r1
c0d09b0c:	d827      	bhi.n	c0d09b5e <ux_flow_engine_init_step+0x6e>
c0d09b0e:	4637      	mov	r7, r6
c0d09b10:	3714      	adds	r7, #20
c0d09b12:	3610      	adds	r6, #16
	if (STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->init) {
c0d09b14:	f7fb fe10 	bl	c0d05738 <pic>
c0d09b18:	6831      	ldr	r1, [r6, #0]
c0d09b1a:	883a      	ldrh	r2, [r7, #0]
c0d09b1c:	0092      	lsls	r2, r2, #2
c0d09b1e:	5889      	ldr	r1, [r1, r2]
c0d09b20:	6805      	ldr	r5, [r0, #0]
c0d09b22:	4608      	mov	r0, r1
c0d09b24:	f7fb fe08 	bl	c0d05738 <pic>
c0d09b28:	2d00      	cmp	r5, #0
c0d09b2a:	d006      	beq.n	c0d09b3a <ux_flow_engine_init_step+0x4a>
		INITPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->init)(stack_slot);
c0d09b2c:	6800      	ldr	r0, [r0, #0]
c0d09b2e:	f7fb fe03 	bl	c0d05738 <pic>
c0d09b32:	4601      	mov	r1, r0
c0d09b34:	4620      	mov	r0, r4
c0d09b36:	4788      	blx	r1
c0d09b38:	e011      	b.n	c0d09b5e <ux_flow_engine_init_step+0x6e>
			           STEPSPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->validate_flow), 
c0d09b3a:	6880      	ldr	r0, [r0, #8]
c0d09b3c:	f7fb fdfc 	bl	c0d05738 <pic>
c0d09b40:	4605      	mov	r5, r0
			           (const ux_flow_step_t*) PIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->params));
c0d09b42:	6830      	ldr	r0, [r6, #0]
c0d09b44:	8839      	ldrh	r1, [r7, #0]
c0d09b46:	0089      	lsls	r1, r1, #2
c0d09b48:	5840      	ldr	r0, [r0, r1]
c0d09b4a:	f7fb fdf5 	bl	c0d05738 <pic>
c0d09b4e:	6840      	ldr	r0, [r0, #4]
c0d09b50:	f7fb fdf2 	bl	c0d05738 <pic>
c0d09b54:	4602      	mov	r2, r0
		ux_flow_init(stack_slot,
c0d09b56:	4620      	mov	r0, r4
c0d09b58:	4629      	mov	r1, r5
c0d09b5a:	f000 f85d 	bl	c0d09c18 <ux_flow_init>
}
c0d09b5e:	b001      	add	sp, #4
c0d09b60:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d09b62:	46c0      	nop			; (mov r8, r8)
c0d09b64:	20001a00 	.word	0x20001a00

c0d09b68 <ux_flow_validate>:

void ux_flow_validate(void) {
c0d09b68:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09b6a:	b081      	sub	sp, #4
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d09b6c:	4d29      	ldr	r5, [pc, #164]	; (c0d09c14 <ux_flow_validate+0xac>)
c0d09b6e:	7828      	ldrb	r0, [r5, #0]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d09b70:	2801      	cmp	r0, #1
c0d09b72:	d825      	bhi.n	c0d09bc0 <ux_flow_validate+0x58>
c0d09b74:	1e40      	subs	r0, r0, #1
c0d09b76:	260c      	movs	r6, #12
c0d09b78:	4370      	muls	r0, r6
c0d09b7a:	182a      	adds	r2, r5, r0
c0d09b7c:	8b10      	ldrh	r0, [r2, #24]
	// no flow ?
	if (!ux_flow_check_valid()
	  || G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d09b7e:	2800      	cmp	r0, #0
c0d09b80:	d01e      	beq.n	c0d09bc0 <ux_flow_validate+0x58>
c0d09b82:	6911      	ldr	r1, [r2, #16]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0
c0d09b84:	2900      	cmp	r1, #0
c0d09b86:	d01b      	beq.n	c0d09bc0 <ux_flow_validate+0x58>
		|| G_ux.flow_stack[G_ux.stack_count-1].index >= G_ux.flow_stack[G_ux.stack_count-1].length) {
c0d09b88:	8a92      	ldrh	r2, [r2, #20]
	if (!ux_flow_check_valid()
c0d09b8a:	4282      	cmp	r2, r0
c0d09b8c:	d218      	bcs.n	c0d09bc0 <ux_flow_validate+0x58>
		return;
	}

	// no validation flow ?
	if (STEPPIC(G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index])->validate_flow != NULL) {
c0d09b8e:	0090      	lsls	r0, r2, #2
c0d09b90:	5808      	ldr	r0, [r1, r0]
c0d09b92:	f7fb fdd1 	bl	c0d05738 <pic>
c0d09b96:	6880      	ldr	r0, [r0, #8]
c0d09b98:	7829      	ldrb	r1, [r5, #0]
c0d09b9a:	1e4c      	subs	r4, r1, #1
	}
	else {
		// if next is a barrier, then proceed to the item after the barrier
		// if NOT followed by a barrier, then validation is only performed through 
		// a validate_flow specified in the step, else ignored
		if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d09b9c:	4366      	muls	r6, r4
	if (STEPPIC(G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index])->validate_flow != NULL) {
c0d09b9e:	2800      	cmp	r0, #0
c0d09ba0:	d010      	beq.n	c0d09bc4 <ux_flow_validate+0x5c>
		ux_flow_init(G_ux.stack_count-1, STEPSPIC(STEPPIC(G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index])->validate_flow), NULL);
c0d09ba2:	19a8      	adds	r0, r5, r6
c0d09ba4:	6901      	ldr	r1, [r0, #16]
c0d09ba6:	8a80      	ldrh	r0, [r0, #20]
c0d09ba8:	0080      	lsls	r0, r0, #2
c0d09baa:	5808      	ldr	r0, [r1, r0]
c0d09bac:	f7fb fdc4 	bl	c0d05738 <pic>
c0d09bb0:	6880      	ldr	r0, [r0, #8]
c0d09bb2:	f7fb fdc1 	bl	c0d05738 <pic>
c0d09bb6:	4601      	mov	r1, r0
c0d09bb8:	2200      	movs	r2, #0
c0d09bba:	4620      	mov	r0, r4
c0d09bbc:	f000 f82c 	bl	c0d09c18 <ux_flow_init>
				// execute reached step
				ux_flow_engine_init_step(G_ux.stack_count-1);
			}
		}
	}
}
c0d09bc0:	b001      	add	sp, #4
c0d09bc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d09bc4:	19a8      	adds	r0, r5, r6
c0d09bc6:	8b02      	ldrh	r2, [r0, #24]
			&& G_ux.flow_stack[G_ux.stack_count-1].index <= G_ux.flow_stack[G_ux.stack_count-1].length - 2) {
c0d09bc8:	2a00      	cmp	r2, #0
c0d09bca:	d0f9      	beq.n	c0d09bc0 <ux_flow_validate+0x58>
c0d09bcc:	8a81      	ldrh	r1, [r0, #20]
c0d09bce:	1e93      	subs	r3, r2, #2
		if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d09bd0:	428b      	cmp	r3, r1
c0d09bd2:	dbf5      	blt.n	c0d09bc0 <ux_flow_validate+0x58>
c0d09bd4:	4602      	mov	r2, r0
c0d09bd6:	3214      	adds	r2, #20
			if (G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d09bd8:	6905      	ldr	r5, [r0, #16]
c0d09bda:	008e      	lsls	r6, r1, #2
c0d09bdc:	19ae      	adds	r6, r5, r6
c0d09bde:	6876      	ldr	r6, [r6, #4]
c0d09be0:	1cf7      	adds	r7, r6, #3
c0d09be2:	d010      	beq.n	c0d09c06 <ux_flow_validate+0x9e>
c0d09be4:	1cb6      	adds	r6, r6, #2
c0d09be6:	d1eb      	bne.n	c0d09bc0 <ux_flow_validate+0x58>
c0d09be8:	460e      	mov	r6, r1
					&& G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d09bea:	00b6      	lsls	r6, r6, #2
c0d09bec:	19ae      	adds	r6, r5, r6
c0d09bee:	6876      	ldr	r6, [r6, #4]
				while (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d09bf0:	1cb6      	adds	r6, r6, #2
c0d09bf2:	d104      	bne.n	c0d09bfe <ux_flow_validate+0x96>
					G_ux.flow_stack[G_ux.stack_count-1].index++;
c0d09bf4:	1c49      	adds	r1, r1, #1
c0d09bf6:	8011      	strh	r1, [r2, #0]
					&& G_ux.flow_stack[G_ux.stack_count-1].index <= G_ux.flow_stack[G_ux.stack_count-1].length - 2
c0d09bf8:	b28e      	uxth	r6, r1
					&& G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d09bfa:	42b3      	cmp	r3, r6
c0d09bfc:	daf5      	bge.n	c0d09bea <ux_flow_validate+0x82>
				G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index;
c0d09bfe:	82c1      	strh	r1, [r0, #22]
				G_ux.flow_stack[G_ux.stack_count-1].index++;
c0d09c00:	1c48      	adds	r0, r1, #1
c0d09c02:	8010      	strh	r0, [r2, #0]
c0d09c04:	e002      	b.n	c0d09c0c <ux_flow_validate+0xa4>
c0d09c06:	2100      	movs	r1, #0
				G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index = 0;
c0d09c08:	8011      	strh	r1, [r2, #0]
c0d09c0a:	82c1      	strh	r1, [r0, #22]
c0d09c0c:	4620      	mov	r0, r4
c0d09c0e:	f7ff ff6f 	bl	c0d09af0 <ux_flow_engine_init_step>
c0d09c12:	e7d5      	b.n	c0d09bc0 <ux_flow_validate+0x58>
c0d09c14:	20001a00 	.word	0x20001a00

c0d09c18 <ux_flow_init>:
 * Last step is marked with a FLOW_END_STEP value
 */
#define FLOW_END_STEP ((void*)0xFFFFFFFFUL)
#define FLOW_BARRIER  ((void*)0xFFFFFFFEUL)
#define FLOW_START    ((void*)0xFFFFFFFDUL)
void ux_flow_init(unsigned int stack_slot, const ux_flow_step_t* const * steps, const ux_flow_step_t* const start_step) {
c0d09c18:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09c1a:	b083      	sub	sp, #12
c0d09c1c:	4615      	mov	r5, r2
c0d09c1e:	460e      	mov	r6, r1
c0d09c20:	4604      	mov	r4, r0
c0d09c22:	220c      	movs	r2, #12
	G_ux.flow_stack[stack_slot].length = G_ux.flow_stack[stack_slot].prev_index = G_ux.flow_stack[stack_slot].index = 0;
c0d09c24:	4610      	mov	r0, r2
c0d09c26:	4360      	muls	r0, r4
c0d09c28:	4b21      	ldr	r3, [pc, #132]	; (c0d09cb0 <ux_flow_init+0x98>)
c0d09c2a:	181f      	adds	r7, r3, r0
c0d09c2c:	2100      	movs	r1, #0
	G_ux.flow_stack[stack_slot].steps = NULL;
c0d09c2e:	8339      	strh	r1, [r7, #24]
c0d09c30:	6139      	str	r1, [r7, #16]
c0d09c32:	6179      	str	r1, [r7, #20]
	
	// reset paging to avoid troubles if first step is a paginated step
	os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d09c34:	1d18      	adds	r0, r3, #4
c0d09c36:	f7fa fb86 	bl	c0d04346 <os_memset>

	if (steps) {
c0d09c3a:	2e00      	cmp	r6, #0
c0d09c3c:	d035      	beq.n	c0d09caa <ux_flow_init+0x92>
c0d09c3e:	9501      	str	r5, [sp, #4]
c0d09c40:	9402      	str	r4, [sp, #8]
c0d09c42:	463c      	mov	r4, r7
c0d09c44:	3410      	adds	r4, #16
c0d09c46:	463d      	mov	r5, r7
c0d09c48:	3518      	adds	r5, #24
		G_ux.flow_stack[stack_slot].steps = STEPSPIC(steps);
c0d09c4a:	4630      	mov	r0, r6
c0d09c4c:	f7fb fd74 	bl	c0d05738 <pic>
c0d09c50:	6020      	str	r0, [r4, #0]
		while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].length] != FLOW_END_STEP) {
c0d09c52:	8829      	ldrh	r1, [r5, #0]
c0d09c54:	008a      	lsls	r2, r1, #2
c0d09c56:	5882      	ldr	r2, [r0, r2]
c0d09c58:	1c52      	adds	r2, r2, #1
c0d09c5a:	d006      	beq.n	c0d09c6a <ux_flow_init+0x52>
			G_ux.flow_stack[stack_slot].length++;
c0d09c5c:	1c49      	adds	r1, r1, #1
		while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].length] != FLOW_END_STEP) {
c0d09c5e:	b28a      	uxth	r2, r1
c0d09c60:	0092      	lsls	r2, r2, #2
c0d09c62:	5882      	ldr	r2, [r0, r2]
c0d09c64:	1c52      	adds	r2, r2, #1
c0d09c66:	d1f9      	bne.n	c0d09c5c <ux_flow_init+0x44>
c0d09c68:	8029      	strh	r1, [r5, #0]
c0d09c6a:	9801      	ldr	r0, [sp, #4]
		}
		if (start_step != NULL) {
c0d09c6c:	2800      	cmp	r0, #0
c0d09c6e:	d019      	beq.n	c0d09ca4 <ux_flow_init+0x8c>
c0d09c70:	463e      	mov	r6, r7
c0d09c72:	3614      	adds	r6, #20
			const ux_flow_step_t* const start_step2  = STEPPIC(start_step);
c0d09c74:	f7fb fd60 	bl	c0d05738 <pic>
c0d09c78:	4605      	mov	r5, r0
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0d09c7a:	6820      	ldr	r0, [r4, #0]
c0d09c7c:	8831      	ldrh	r1, [r6, #0]
c0d09c7e:	0089      	lsls	r1, r1, #2
c0d09c80:	5840      	ldr	r0, [r0, r1]
				 && STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index]) != start_step2) {
c0d09c82:	1c41      	adds	r1, r0, #1
c0d09c84:	d00e      	beq.n	c0d09ca4 <ux_flow_init+0x8c>
c0d09c86:	3716      	adds	r7, #22
c0d09c88:	f7fb fd56 	bl	c0d05738 <pic>
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0d09c8c:	42a8      	cmp	r0, r5
c0d09c8e:	d009      	beq.n	c0d09ca4 <ux_flow_init+0x8c>
				G_ux.flow_stack[stack_slot].prev_index = G_ux.flow_stack[stack_slot].index;
c0d09c90:	8830      	ldrh	r0, [r6, #0]
c0d09c92:	8038      	strh	r0, [r7, #0]
				G_ux.flow_stack[stack_slot].index++;
c0d09c94:	1c40      	adds	r0, r0, #1
c0d09c96:	8030      	strh	r0, [r6, #0]
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0d09c98:	b280      	uxth	r0, r0
c0d09c9a:	0080      	lsls	r0, r0, #2
c0d09c9c:	6821      	ldr	r1, [r4, #0]
c0d09c9e:	5808      	ldr	r0, [r1, r0]
				 && STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index]) != start_step2) {
c0d09ca0:	1c41      	adds	r1, r0, #1
c0d09ca2:	d1f1      	bne.n	c0d09c88 <ux_flow_init+0x70>
			}
		}

		// init step
		ux_flow_engine_init_step(stack_slot);
c0d09ca4:	9802      	ldr	r0, [sp, #8]
c0d09ca6:	f7ff ff23 	bl	c0d09af0 <ux_flow_engine_init_step>
	}
}
c0d09caa:	b003      	add	sp, #12
c0d09cac:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d09cae:	46c0      	nop			; (mov r8, r8)
c0d09cb0:	20001a00 	.word	0x20001a00

c0d09cb4 <ux_flow_button_callback>:

void ux_flow_uninit(unsigned int stack_slot) {
	memset(&G_ux.flow_stack[stack_slot], 0, sizeof(G_ux.flow_stack[stack_slot]));
}

unsigned int ux_flow_button_callback(unsigned int button_mask, unsigned int button_mask_counter) {
c0d09cb4:	b580      	push	{r7, lr}
c0d09cb6:	490a      	ldr	r1, [pc, #40]	; (c0d09ce0 <ux_flow_button_callback+0x2c>)
  UNUSED(button_mask_counter);
  switch(button_mask) {
c0d09cb8:	4288      	cmp	r0, r1
c0d09cba:	d008      	beq.n	c0d09cce <ux_flow_button_callback+0x1a>
c0d09cbc:	4909      	ldr	r1, [pc, #36]	; (c0d09ce4 <ux_flow_button_callback+0x30>)
c0d09cbe:	4288      	cmp	r0, r1
c0d09cc0:	d008      	beq.n	c0d09cd4 <ux_flow_button_callback+0x20>
c0d09cc2:	4909      	ldr	r1, [pc, #36]	; (c0d09ce8 <ux_flow_button_callback+0x34>)
c0d09cc4:	4288      	cmp	r0, r1
c0d09cc6:	d108      	bne.n	c0d09cda <ux_flow_button_callback+0x26>
    case BUTTON_EVT_RELEASED|BUTTON_LEFT:
      ux_flow_prev();
c0d09cc8:	f7ff fee0 	bl	c0d09a8c <ux_flow_prev>
c0d09ccc:	e005      	b.n	c0d09cda <ux_flow_button_callback+0x26>
      break;
    case BUTTON_EVT_RELEASED|BUTTON_RIGHT:
      ux_flow_next();
      break;
    case BUTTON_EVT_RELEASED|BUTTON_LEFT|BUTTON_RIGHT:
      ux_flow_validate();
c0d09cce:	f7ff ff4b 	bl	c0d09b68 <ux_flow_validate>
c0d09cd2:	e002      	b.n	c0d09cda <ux_flow_button_callback+0x26>
c0d09cd4:	2001      	movs	r0, #1
	ux_flow_next_internal(1);
c0d09cd6:	f7ff fea3 	bl	c0d09a20 <ux_flow_next_internal>
c0d09cda:	2000      	movs	r0, #0
      break;
  }
  return 0;
c0d09cdc:	bd80      	pop	{r7, pc}
c0d09cde:	46c0      	nop			; (mov r8, r8)
c0d09ce0:	80000003 	.word	0x80000003
c0d09ce4:	80000002 	.word	0x80000002
c0d09ce8:	80000001 	.word	0x80000001

c0d09cec <ux_stack_get_step_params>:
}

void* ux_stack_get_step_params(unsigned int stack_slot) {
c0d09cec:	b510      	push	{r4, lr}
c0d09cee:	4601      	mov	r1, r0
c0d09cf0:	2000      	movs	r0, #0
	if (stack_slot >= UX_STACK_SLOT_COUNT) {
c0d09cf2:	2900      	cmp	r1, #0
c0d09cf4:	d10f      	bne.n	c0d09d16 <ux_stack_get_step_params+0x2a>
		return NULL;
	}

	if (G_ux.flow_stack[stack_slot].length == 0) {
c0d09cf6:	4c08      	ldr	r4, [pc, #32]	; (c0d09d18 <ux_stack_get_step_params+0x2c>)
c0d09cf8:	8b21      	ldrh	r1, [r4, #24]
		return NULL;
	}

	if (G_ux.flow_stack[stack_slot].index >= G_ux.flow_stack[stack_slot].length) {
c0d09cfa:	8aa2      	ldrh	r2, [r4, #20]
	if (G_ux.flow_stack[stack_slot].length == 0) {
c0d09cfc:	428a      	cmp	r2, r1
c0d09cfe:	d20a      	bcs.n	c0d09d16 <ux_stack_get_step_params+0x2a>
		return NULL;
	}

	return (void*)PIC(STEPPIC(STEPSPIC(G_ux.flow_stack[stack_slot].steps)[G_ux.flow_stack[stack_slot].index])->params);
c0d09d00:	6920      	ldr	r0, [r4, #16]
c0d09d02:	f7fb fd19 	bl	c0d05738 <pic>
c0d09d06:	8aa1      	ldrh	r1, [r4, #20]
c0d09d08:	0089      	lsls	r1, r1, #2
c0d09d0a:	5840      	ldr	r0, [r0, r1]
c0d09d0c:	f7fb fd14 	bl	c0d05738 <pic>
c0d09d10:	6840      	ldr	r0, [r0, #4]
c0d09d12:	f7fb fd11 	bl	c0d05738 <pic>
}
c0d09d16:	bd10      	pop	{r4, pc}
c0d09d18:	20001a00 	.word	0x20001a00

c0d09d1c <ux_stack_get_current_step_params>:

void* ux_stack_get_current_step_params(void) {
c0d09d1c:	b580      	push	{r7, lr}
	return ux_stack_get_step_params(G_ux.stack_count-1);
c0d09d1e:	4803      	ldr	r0, [pc, #12]	; (c0d09d2c <ux_stack_get_current_step_params+0x10>)
c0d09d20:	7800      	ldrb	r0, [r0, #0]
c0d09d22:	1e40      	subs	r0, r0, #1
c0d09d24:	f7ff ffe2 	bl	c0d09cec <ux_stack_get_step_params>
c0d09d28:	bd80      	pop	{r7, pc}
c0d09d2a:	46c0      	nop			; (mov r8, r8)
c0d09d2c:	20001a00 	.word	0x20001a00

c0d09d30 <ux_layout_bb_init_common>:
  }
  return &G_ux.tmp_element;
}
*/

void ux_layout_bb_init_common(unsigned int stack_slot) {
c0d09d30:	b510      	push	{r4, lr}
c0d09d32:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0d09d34:	f000 fb9c 	bl	c0d0a470 <ux_stack_init>
c0d09d38:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_bb_elements;
c0d09d3a:	4360      	muls	r0, r4
c0d09d3c:	4908      	ldr	r1, [pc, #32]	; (c0d09d60 <ux_layout_bb_init_common+0x30>)
c0d09d3e:	1808      	adds	r0, r1, r0
c0d09d40:	21c4      	movs	r1, #196	; 0xc4
c0d09d42:	2205      	movs	r2, #5
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_bb_elements);
c0d09d44:	5442      	strb	r2, [r0, r1]
c0d09d46:	21c0      	movs	r1, #192	; 0xc0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_bb_elements;
c0d09d48:	4a06      	ldr	r2, [pc, #24]	; (c0d09d64 <ux_layout_bb_init_common+0x34>)
c0d09d4a:	447a      	add	r2, pc
c0d09d4c:	5042      	str	r2, [r0, r1]
c0d09d4e:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0d09d50:	4a05      	ldr	r2, [pc, #20]	; (c0d09d68 <ux_layout_bb_init_common+0x38>)
c0d09d52:	447a      	add	r2, pc
c0d09d54:	5042      	str	r2, [r0, r1]
c0d09d56:	21bd      	movs	r1, #189	; 0xbd
c0d09d58:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0d09d5a:	5442      	strb	r2, [r0, r1]
}
c0d09d5c:	bd10      	pop	{r4, pc}
c0d09d5e:	46c0      	nop			; (mov r8, r8)
c0d09d60:	20001a00 	.word	0x20001a00
c0d09d64:	0000382e 	.word	0x0000382e
c0d09d68:	ffffff5f 	.word	0xffffff5f

c0d09d6c <ux_layout_bn_prepro>:
#endif
#endif
};
*/

const bagl_element_t* ux_layout_bn_prepro(const bagl_element_t* element) {
c0d09d6c:	b580      	push	{r7, lr}
      G_ux.tmp_element.text = params->line2;
      break;
  }
  return &G_ux.tmp_element;
*/
  const bagl_element_t* e = ux_layout_strings_prepro(element);
c0d09d6e:	f000 fae3 	bl	c0d0a338 <ux_layout_strings_prepro>
  if (e && G_ux.tmp_element.component.userid == 0x11) {
c0d09d72:	2800      	cmp	r0, #0
c0d09d74:	d007      	beq.n	c0d09d86 <ux_layout_bn_prepro+0x1a>
c0d09d76:	229d      	movs	r2, #157	; 0x9d
c0d09d78:	4903      	ldr	r1, [pc, #12]	; (c0d09d88 <ux_layout_bn_prepro+0x1c>)
c0d09d7a:	5c8a      	ldrb	r2, [r1, r2]
c0d09d7c:	2a11      	cmp	r2, #17
c0d09d7e:	d102      	bne.n	c0d09d86 <ux_layout_bn_prepro+0x1a>
c0d09d80:	22b4      	movs	r2, #180	; 0xb4
c0d09d82:	4b02      	ldr	r3, [pc, #8]	; (c0d09d8c <ux_layout_bn_prepro+0x20>)
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER;
c0d09d84:	528b      	strh	r3, [r1, r2]
  }
  return e;
c0d09d86:	bd80      	pop	{r7, pc}
c0d09d88:	20001a00 	.word	0x20001a00
c0d09d8c:	0000800a 	.word	0x0000800a

c0d09d90 <ux_layout_bn_init>:
}

void ux_layout_bn_init(unsigned int stack_slot) { 
c0d09d90:	b510      	push	{r4, lr}
c0d09d92:	4604      	mov	r4, r0
  ux_layout_bb_init_common(stack_slot);
c0d09d94:	f7ff ffcc 	bl	c0d09d30 <ux_layout_bb_init_common>
c0d09d98:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_bn_prepro;
c0d09d9a:	4360      	muls	r0, r4
c0d09d9c:	4904      	ldr	r1, [pc, #16]	; (c0d09db0 <ux_layout_bn_init+0x20>)
c0d09d9e:	1808      	adds	r0, r1, r0
c0d09da0:	21cc      	movs	r1, #204	; 0xcc
c0d09da2:	4a04      	ldr	r2, [pc, #16]	; (c0d09db4 <ux_layout_bn_init+0x24>)
c0d09da4:	447a      	add	r2, pc
c0d09da6:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d09da8:	4620      	mov	r0, r4
c0d09daa:	f000 fb3b 	bl	c0d0a424 <ux_stack_display>
}
c0d09dae:	bd10      	pop	{r4, pc}
c0d09db0:	20001a00 	.word	0x20001a00
c0d09db4:	ffffffc5 	.word	0xffffffc5

c0d09db8 <ux_layout_nn_prepro>:
  {{BAGL_LABELINE                       , 0x11,   0,  26, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL},
#endif // TARGET_NANOX
};
*/

const bagl_element_t* ux_layout_nn_prepro(const bagl_element_t* element) {
c0d09db8:	b580      	push	{r7, lr}
      G_ux.tmp_element.text = params->line2;
      break;
  }
  return &G_ux.tmp_element;
*/
  const bagl_element_t* e = ux_layout_strings_prepro(element);
c0d09dba:	f000 fabd 	bl	c0d0a338 <ux_layout_strings_prepro>
  if (e && G_ux.tmp_element.component.userid >= 0x10) {
c0d09dbe:	2800      	cmp	r0, #0
c0d09dc0:	d007      	beq.n	c0d09dd2 <ux_layout_nn_prepro+0x1a>
c0d09dc2:	229d      	movs	r2, #157	; 0x9d
c0d09dc4:	4903      	ldr	r1, [pc, #12]	; (c0d09dd4 <ux_layout_nn_prepro+0x1c>)
c0d09dc6:	5c8a      	ldrb	r2, [r1, r2]
c0d09dc8:	2a10      	cmp	r2, #16
c0d09dca:	d302      	bcc.n	c0d09dd2 <ux_layout_nn_prepro+0x1a>
c0d09dcc:	22b4      	movs	r2, #180	; 0xb4
c0d09dce:	4b02      	ldr	r3, [pc, #8]	; (c0d09dd8 <ux_layout_nn_prepro+0x20>)
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER;
c0d09dd0:	528b      	strh	r3, [r1, r2]
  }
  return e;
c0d09dd2:	bd80      	pop	{r7, pc}
c0d09dd4:	20001a00 	.word	0x20001a00
c0d09dd8:	0000800a 	.word	0x0000800a

c0d09ddc <ux_layout_nn_init>:
}

void ux_layout_nn_init(unsigned int stack_slot) {
c0d09ddc:	b510      	push	{r4, lr}
c0d09dde:	4604      	mov	r4, r0
  ux_layout_bb_init_common(stack_slot);
c0d09de0:	f7ff ffa6 	bl	c0d09d30 <ux_layout_bb_init_common>
c0d09de4:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_nn_prepro;
c0d09de6:	4360      	muls	r0, r4
c0d09de8:	4904      	ldr	r1, [pc, #16]	; (c0d09dfc <ux_layout_nn_init+0x20>)
c0d09dea:	1808      	adds	r0, r1, r0
c0d09dec:	21cc      	movs	r1, #204	; 0xcc
c0d09dee:	4a04      	ldr	r2, [pc, #16]	; (c0d09e00 <ux_layout_nn_init+0x24>)
c0d09df0:	447a      	add	r2, pc
c0d09df2:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d09df4:	4620      	mov	r0, r4
c0d09df6:	f000 fb15 	bl	c0d0a424 <ux_stack_display>
}
c0d09dfa:	bd10      	pop	{r4, pc}
c0d09dfc:	20001a00 	.word	0x20001a00
c0d09e00:	ffffffc5 	.word	0xffffffc5

c0d09e04 <ux_layout_paging_compute>:
  //       || (c >= '0' && c <= '9'));
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
}

// return the number of pages to be displayed when current page to show is -1
unsigned int ux_layout_paging_compute(unsigned int stack_slot, unsigned int page_to_display) {
c0d09e04:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09e06:	b087      	sub	sp, #28
c0d09e08:	460e      	mov	r6, r1
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_step_params(stack_slot);
c0d09e0a:	f7ff ff6f 	bl	c0d09cec <ux_stack_get_step_params>
c0d09e0e:	9006      	str	r0, [sp, #24]

  // reset length and offset of lines
  os_memset(&G_ux.layout_paging.offsets, 0, sizeof(G_ux.layout_paging.offsets));
c0d09e10:	4c44      	ldr	r4, [pc, #272]	; (c0d09f24 <ux_layout_paging_compute+0x120>)
c0d09e12:	4620      	mov	r0, r4
c0d09e14:	300c      	adds	r0, #12
c0d09e16:	2500      	movs	r5, #0
c0d09e18:	2702      	movs	r7, #2
c0d09e1a:	4629      	mov	r1, r5
c0d09e1c:	463a      	mov	r2, r7
c0d09e1e:	f7fa fa92 	bl	c0d04346 <os_memset>
  os_memset(&G_ux.layout_paging.lengths, 0, sizeof(G_ux.layout_paging.lengths));
c0d09e22:	4620      	mov	r0, r4
c0d09e24:	300e      	adds	r0, #14
c0d09e26:	9505      	str	r5, [sp, #20]
c0d09e28:	4629      	mov	r1, r5
c0d09e2a:	463a      	mov	r2, r7
c0d09e2c:	f7fa fa8b 	bl	c0d04346 <os_memset>

  // a page has been asked, but no page exists
  if (page_to_display != -1UL && G_ux.layout_paging.count == 0) {
c0d09e30:	1c70      	adds	r0, r6, #1
c0d09e32:	9004      	str	r0, [sp, #16]
c0d09e34:	d002      	beq.n	c0d09e3c <ux_layout_paging_compute+0x38>
c0d09e36:	68a0      	ldr	r0, [r4, #8]
c0d09e38:	2800      	cmp	r0, #0
c0d09e3a:	d06f      	beq.n	c0d09f1c <ux_layout_paging_compute+0x118>
  }

  // compute offset/length of text of each line for the current page
  unsigned int page = 0;
  unsigned int line = 0;
  const char* start = STRPIC(params->text);
c0d09e3c:	9806      	ldr	r0, [sp, #24]
c0d09e3e:	6840      	ldr	r0, [r0, #4]
c0d09e40:	f7fb fc7a 	bl	c0d05738 <pic>
c0d09e44:	4606      	mov	r6, r0
  const char* start2 = start;
  const char* end = start + strlen(start);
c0d09e46:	f000 fdd7 	bl	c0d0a9f8 <strlen>
  while (start < end) {
c0d09e4a:	2801      	cmp	r0, #1
c0d09e4c:	db5d      	blt.n	c0d09f0a <ux_layout_paging_compute+0x106>
c0d09e4e:	1830      	adds	r0, r6, r0
c0d09e50:	6861      	ldr	r1, [r4, #4]
c0d09e52:	9105      	str	r1, [sp, #20]
c0d09e54:	68a1      	ldr	r1, [r4, #8]
c0d09e56:	9102      	str	r1, [sp, #8]
c0d09e58:	2100      	movs	r1, #0
c0d09e5a:	9103      	str	r1, [sp, #12]
c0d09e5c:	9106      	str	r1, [sp, #24]
c0d09e5e:	9601      	str	r6, [sp, #4]
c0d09e60:	9a03      	ldr	r2, [sp, #12]
c0d09e62:	4613      	mov	r3, r2
c0d09e64:	4631      	mov	r1, r6
    unsigned int len = 0;
    unsigned int linew = 0; 
    const char* last_word_delim = start;
    // not reached end of content
    while (start + len < end
c0d09e66:	18b7      	adds	r7, r6, r2
c0d09e68:	4287      	cmp	r7, r0
c0d09e6a:	d212      	bcs.n	c0d09e92 <ux_layout_paging_compute+0x8e>
      #else // TARGET_NANOX
      // nano s does not have the bagl lib o nthe SE side
      linew = (len+1)*7 /* width of a capitalized W (the largest char in each font) */;
      #endif //TARGET_NANOX
      //if (start[len] )
      if (linew > PIXEL_PER_LINE) {
c0d09e6c:	1ddb      	adds	r3, r3, #7
c0d09e6e:	2b72      	cmp	r3, #114	; 0x72
c0d09e70:	d80f      	bhi.n	c0d09e92 <ux_layout_paging_compute+0x8e>
        // we got a full line
        break;
      }
      unsigned char c = start[len];
c0d09e72:	783d      	ldrb	r5, [r7, #0]
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
c0d09e74:	462c      	mov	r4, r5
c0d09e76:	3c09      	subs	r4, #9
c0d09e78:	2c02      	cmp	r4, #2
c0d09e7a:	d306      	bcc.n	c0d09e8a <ux_layout_paging_compute+0x86>
c0d09e7c:	2d20      	cmp	r5, #32
c0d09e7e:	d004      	beq.n	c0d09e8a <ux_layout_paging_compute+0x86>
c0d09e80:	2d2d      	cmp	r5, #45	; 0x2d
c0d09e82:	d002      	beq.n	c0d09e8a <ux_layout_paging_compute+0x86>
      if (is_word_delim(c)) {
c0d09e84:	2d5f      	cmp	r5, #95	; 0x5f
c0d09e86:	d000      	beq.n	c0d09e8a <ux_layout_paging_compute+0x86>
c0d09e88:	460f      	mov	r7, r1
c0d09e8a:	4639      	mov	r1, r7
c0d09e8c:	1c52      	adds	r2, r2, #1
c0d09e8e:	2d0a      	cmp	r5, #10
c0d09e90:	d1e9      	bne.n	c0d09e66 <ux_layout_paging_compute+0x62>
        break;
      }
    }

    // if not splitting line onto a word delimiter, then cut at the previous word_delim, adjust len accordingly (and a wor delim has been found already)
    if (start + len < end && last_word_delim != start && len) {
c0d09e92:	18b3      	adds	r3, r6, r2
c0d09e94:	4283      	cmp	r3, r0
c0d09e96:	d222      	bcs.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09e98:	2a00      	cmp	r2, #0
c0d09e9a:	d020      	beq.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09e9c:	42b1      	cmp	r1, r6
c0d09e9e:	d01e      	beq.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09ea0:	2400      	movs	r4, #0
c0d09ea2:	43e4      	mvns	r4, r4
      // if line split within a word
      if ((!is_word_delim(start[len-1]) && !is_word_delim(start[len]))) {
c0d09ea4:	5d1c      	ldrb	r4, [r3, r4]
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
c0d09ea6:	2c2c      	cmp	r4, #44	; 0x2c
c0d09ea8:	dc06      	bgt.n	c0d09eb8 <ux_layout_paging_compute+0xb4>
c0d09eaa:	4625      	mov	r5, r4
c0d09eac:	3d09      	subs	r5, #9
c0d09eae:	2d02      	cmp	r5, #2
c0d09eb0:	d315      	bcc.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09eb2:	2c20      	cmp	r4, #32
c0d09eb4:	d013      	beq.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09eb6:	e003      	b.n	c0d09ec0 <ux_layout_paging_compute+0xbc>
c0d09eb8:	2c2d      	cmp	r4, #45	; 0x2d
c0d09eba:	d010      	beq.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09ebc:	2c5f      	cmp	r4, #95	; 0x5f
c0d09ebe:	d00e      	beq.n	c0d09ede <ux_layout_paging_compute+0xda>
      if ((!is_word_delim(start[len-1]) && !is_word_delim(start[len]))) {
c0d09ec0:	781b      	ldrb	r3, [r3, #0]
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
c0d09ec2:	2b2c      	cmp	r3, #44	; 0x2c
c0d09ec4:	dc06      	bgt.n	c0d09ed4 <ux_layout_paging_compute+0xd0>
c0d09ec6:	461c      	mov	r4, r3
c0d09ec8:	3c09      	subs	r4, #9
c0d09eca:	2c02      	cmp	r4, #2
c0d09ecc:	d307      	bcc.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09ece:	2b20      	cmp	r3, #32
c0d09ed0:	d005      	beq.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09ed2:	e003      	b.n	c0d09edc <ux_layout_paging_compute+0xd8>
c0d09ed4:	2b2d      	cmp	r3, #45	; 0x2d
c0d09ed6:	d002      	beq.n	c0d09ede <ux_layout_paging_compute+0xda>
c0d09ed8:	2b5f      	cmp	r3, #95	; 0x5f
c0d09eda:	d000      	beq.n	c0d09ede <ux_layout_paging_compute+0xda>
        len = last_word_delim - start;
c0d09edc:	1b8a      	subs	r2, r1, r6
      }
    }

    // fill up the paging structure
    if (page_to_display != -1UL && G_ux.layout_paging.current == page && G_ux.layout_paging.current < G_ux.layout_paging.count) {
c0d09ede:	9904      	ldr	r1, [sp, #16]
c0d09ee0:	2900      	cmp	r1, #0
c0d09ee2:	d007      	beq.n	c0d09ef4 <ux_layout_paging_compute+0xf0>
c0d09ee4:	9905      	ldr	r1, [sp, #20]
c0d09ee6:	9b06      	ldr	r3, [sp, #24]
c0d09ee8:	4299      	cmp	r1, r3
c0d09eea:	d103      	bne.n	c0d09ef4 <ux_layout_paging_compute+0xf0>
c0d09eec:	9905      	ldr	r1, [sp, #20]
c0d09eee:	9b02      	ldr	r3, [sp, #8]
c0d09ef0:	4299      	cmp	r1, r3
c0d09ef2:	d30d      	bcc.n	c0d09f10 <ux_layout_paging_compute+0x10c>
        return page;
      }
    }

    // prepare for next line
    start += len;
c0d09ef4:	18b6      	adds	r6, r6, r2
    line++;
    if (
#if UX_LAYOUT_PAGING_LINE > 1
      line >= UX_LAYOUT_PAGING_LINE && 
#endif // UX_LAYOUT_PAGING_LINE
      start < end) {
c0d09ef6:	4286      	cmp	r6, r0
c0d09ef8:	d202      	bcs.n	c0d09f00 <ux_layout_paging_compute+0xfc>
c0d09efa:	9906      	ldr	r1, [sp, #24]
c0d09efc:	1c49      	adds	r1, r1, #1
c0d09efe:	9106      	str	r1, [sp, #24]
  while (start < end) {
c0d09f00:	4286      	cmp	r6, r0
c0d09f02:	d3ad      	bcc.n	c0d09e60 <ux_layout_paging_compute+0x5c>
      page++;
      line = 0;
    }
  }
  return page+1;
c0d09f04:	9806      	ldr	r0, [sp, #24]
c0d09f06:	1c40      	adds	r0, r0, #1
c0d09f08:	e000      	b.n	c0d09f0c <ux_layout_paging_compute+0x108>
c0d09f0a:	2001      	movs	r0, #1
c0d09f0c:	9005      	str	r0, [sp, #20]
c0d09f0e:	e005      	b.n	c0d09f1c <ux_layout_paging_compute+0x118>
c0d09f10:	4804      	ldr	r0, [pc, #16]	; (c0d09f24 <ux_layout_paging_compute+0x120>)
c0d09f12:	4601      	mov	r1, r0
      G_ux.layout_paging.lengths[line] = len;
c0d09f14:	81c2      	strh	r2, [r0, #14]
      G_ux.layout_paging.offsets[line] = start - start2;
c0d09f16:	9801      	ldr	r0, [sp, #4]
c0d09f18:	1a30      	subs	r0, r6, r0
c0d09f1a:	8188      	strh	r0, [r1, #12]
}
c0d09f1c:	9805      	ldr	r0, [sp, #20]
c0d09f1e:	b007      	add	sp, #28
c0d09f20:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d09f22:	46c0      	nop			; (mov r8, r8)
c0d09f24:	20001a00 	.word	0x20001a00

c0d09f28 <ux_layout_paging_redisplay>:

// redisplay current page
void ux_layout_paging_redisplay(unsigned int stack_slot) {
c0d09f28:	b5b0      	push	{r4, r5, r7, lr}
c0d09f2a:	4604      	mov	r4, r0

#ifndef TARGET_NANOX
  ux_layout_bb_init_common(stack_slot);
c0d09f2c:	f7ff ff00 	bl	c0d09d30 <ux_layout_bb_init_common>
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_paging_elements);
  G_ux.stack[stack_slot].element_arrays_count = 1;
#endif // TARGET_NANOX

  // request offsets and lengths of lines for the current page
  ux_layout_paging_compute(stack_slot, G_ux.layout_paging.current);
c0d09f30:	4d09      	ldr	r5, [pc, #36]	; (c0d09f58 <ux_layout_paging_redisplay+0x30>)
c0d09f32:	6869      	ldr	r1, [r5, #4]
c0d09f34:	4620      	mov	r0, r4
c0d09f36:	f7ff ff65 	bl	c0d09e04 <ux_layout_paging_compute>
c0d09f3a:	2024      	movs	r0, #36	; 0x24

  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_paging_prepro;
c0d09f3c:	4360      	muls	r0, r4
c0d09f3e:	1828      	adds	r0, r5, r0
c0d09f40:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].button_push_callback = ux_layout_paging_button_callback;
c0d09f42:	4a06      	ldr	r2, [pc, #24]	; (c0d09f5c <ux_layout_paging_redisplay+0x34>)
c0d09f44:	447a      	add	r2, pc
c0d09f46:	5042      	str	r2, [r0, r1]
c0d09f48:	21cc      	movs	r1, #204	; 0xcc
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_paging_prepro;
c0d09f4a:	4a05      	ldr	r2, [pc, #20]	; (c0d09f60 <ux_layout_paging_redisplay+0x38>)
c0d09f4c:	447a      	add	r2, pc
c0d09f4e:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d09f50:	4620      	mov	r0, r4
c0d09f52:	f000 fa67 	bl	c0d0a424 <ux_stack_display>
}
c0d09f56:	bdb0      	pop	{r4, r5, r7, pc}
c0d09f58:	20001a00 	.word	0x20001a00
c0d09f5c:	0000011d 	.word	0x0000011d
c0d09f60:	00000015 	.word	0x00000015

c0d09f64 <ux_layout_paging_prepro>:
static const bagl_element_t* ux_layout_paging_prepro(const bagl_element_t* element) {
c0d09f64:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09f66:	b083      	sub	sp, #12
c0d09f68:	4606      	mov	r6, r0
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_current_step_params();
c0d09f6a:	f7ff fed7 	bl	c0d09d1c <ux_stack_get_current_step_params>
c0d09f6e:	4605      	mov	r5, r0
  os_memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0d09f70:	4f37      	ldr	r7, [pc, #220]	; (c0d0a050 <ux_layout_paging_prepro+0xec>)
c0d09f72:	463c      	mov	r4, r7
c0d09f74:	349c      	adds	r4, #156	; 0x9c
c0d09f76:	2220      	movs	r2, #32
c0d09f78:	4620      	mov	r0, r4
c0d09f7a:	4631      	mov	r1, r6
c0d09f7c:	f7fa f9cd 	bl	c0d0431a <os_memmove>
  switch (element->component.userid) {
c0d09f80:	7870      	ldrb	r0, [r6, #1]
c0d09f82:	2810      	cmp	r0, #16
c0d09f84:	dc17      	bgt.n	c0d09fb6 <ux_layout_paging_prepro+0x52>
c0d09f86:	2801      	cmp	r0, #1
c0d09f88:	d036      	beq.n	c0d09ff8 <ux_layout_paging_prepro+0x94>
c0d09f8a:	2802      	cmp	r0, #2
c0d09f8c:	d03c      	beq.n	c0d0a008 <ux_layout_paging_prepro+0xa4>
c0d09f8e:	2810      	cmp	r0, #16
c0d09f90:	d15b      	bne.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
    	if (params->title) {
c0d09f92:	6828      	ldr	r0, [r5, #0]
c0d09f94:	463e      	mov	r6, r7
c0d09f96:	2800      	cmp	r0, #0
c0d09f98:	d041      	beq.n	c0d0a01e <ux_layout_paging_prepro+0xba>
        SPRINTF(G_ux.string_buffer, (G_ux.layout_paging.count>1)?"%s (%d/%d)":"%s", STRPIC(params->title), G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0d09f9a:	68bd      	ldr	r5, [r7, #8]
c0d09f9c:	f7fb fbcc 	bl	c0d05738 <pic>
c0d09fa0:	4603      	mov	r3, r0
c0d09fa2:	6878      	ldr	r0, [r7, #4]
c0d09fa4:	68b9      	ldr	r1, [r7, #8]
c0d09fa6:	466a      	mov	r2, sp
c0d09fa8:	1c40      	adds	r0, r0, #1
c0d09faa:	c203      	stmia	r2!, {r0, r1}
c0d09fac:	2d01      	cmp	r5, #1
c0d09fae:	d841      	bhi.n	c0d0a034 <ux_layout_paging_prepro+0xd0>
c0d09fb0:	4a29      	ldr	r2, [pc, #164]	; (c0d0a058 <ux_layout_paging_prepro+0xf4>)
c0d09fb2:	447a      	add	r2, pc
c0d09fb4:	e040      	b.n	c0d0a038 <ux_layout_paging_prepro+0xd4>
  switch (element->component.userid) {
c0d09fb6:	4601      	mov	r1, r0
c0d09fb8:	3911      	subs	r1, #17
c0d09fba:	2903      	cmp	r1, #3
c0d09fbc:	d245      	bcs.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
c0d09fbe:	210f      	movs	r1, #15
      unsigned int lineidx = (element->component.userid&0xF)-1;
c0d09fc0:	4008      	ands	r0, r1
c0d09fc2:	1e40      	subs	r0, r0, #1
      if (G_ux.layout_paging.lengths[lineidx]) {
c0d09fc4:	0040      	lsls	r0, r0, #1
c0d09fc6:	4922      	ldr	r1, [pc, #136]	; (c0d0a050 <ux_layout_paging_prepro+0xec>)
c0d09fc8:	180f      	adds	r7, r1, r0
c0d09fca:	89fe      	ldrh	r6, [r7, #14]
c0d09fcc:	2e00      	cmp	r6, #0
c0d09fce:	d03c      	beq.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
        SPRINTF(G_ux.string_buffer, "%.*s", G_ux.layout_paging.lengths[lineidx], STRPIC(params->text) + G_ux.layout_paging.offsets[lineidx]);
c0d09fd0:	6868      	ldr	r0, [r5, #4]
c0d09fd2:	f7fb fbb1 	bl	c0d05738 <pic>
c0d09fd6:	89b9      	ldrh	r1, [r7, #12]
c0d09fd8:	1840      	adds	r0, r0, r1
c0d09fda:	4669      	mov	r1, sp
c0d09fdc:	6008      	str	r0, [r1, #0]
c0d09fde:	4f1c      	ldr	r7, [pc, #112]	; (c0d0a050 <ux_layout_paging_prepro+0xec>)
c0d09fe0:	463d      	mov	r5, r7
c0d09fe2:	351c      	adds	r5, #28
c0d09fe4:	2180      	movs	r1, #128	; 0x80
c0d09fe6:	4a1e      	ldr	r2, [pc, #120]	; (c0d0a060 <ux_layout_paging_prepro+0xfc>)
c0d09fe8:	447a      	add	r2, pc
c0d09fea:	4628      	mov	r0, r5
c0d09fec:	4633      	mov	r3, r6
c0d09fee:	f7fb f9cf 	bl	c0d05390 <snprintf>
c0d09ff2:	20b8      	movs	r0, #184	; 0xb8
        G_ux.tmp_element.text = G_ux.string_buffer;
c0d09ff4:	503d      	str	r5, [r7, r0]
c0d09ff6:	e028      	b.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
  		if (ux_flow_is_first() && G_ux.layout_paging.current == 0) {
c0d09ff8:	f7ff fcb4 	bl	c0d09964 <ux_flow_is_first>
c0d09ffc:	2800      	cmp	r0, #0
c0d09ffe:	d024      	beq.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
c0d0a000:	6878      	ldr	r0, [r7, #4]
c0d0a002:	2800      	cmp	r0, #0
c0d0a004:	d009      	beq.n	c0d0a01a <ux_layout_paging_prepro+0xb6>
c0d0a006:	e020      	b.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
  		if (ux_flow_is_last() && G_ux.layout_paging.current == G_ux.layout_paging.count -1 ) {
c0d0a008:	f7ff fcd4 	bl	c0d099b4 <ux_flow_is_last>
c0d0a00c:	2800      	cmp	r0, #0
c0d0a00e:	d01c      	beq.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
c0d0a010:	6878      	ldr	r0, [r7, #4]
c0d0a012:	68b9      	ldr	r1, [r7, #8]
c0d0a014:	1e49      	subs	r1, r1, #1
c0d0a016:	4288      	cmp	r0, r1
c0d0a018:	d117      	bne.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
c0d0a01a:	2400      	movs	r4, #0
c0d0a01c:	e015      	b.n	c0d0a04a <ux_layout_paging_prepro+0xe6>
        SPRINTF(G_ux.string_buffer, "%d/%d", G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0d0a01e:	6879      	ldr	r1, [r7, #4]
c0d0a020:	68b8      	ldr	r0, [r7, #8]
c0d0a022:	466a      	mov	r2, sp
c0d0a024:	6010      	str	r0, [r2, #0]
c0d0a026:	4638      	mov	r0, r7
c0d0a028:	301c      	adds	r0, #28
c0d0a02a:	1c4b      	adds	r3, r1, #1
c0d0a02c:	2180      	movs	r1, #128	; 0x80
c0d0a02e:	4a0b      	ldr	r2, [pc, #44]	; (c0d0a05c <ux_layout_paging_prepro+0xf8>)
c0d0a030:	447a      	add	r2, pc
c0d0a032:	e004      	b.n	c0d0a03e <ux_layout_paging_prepro+0xda>
c0d0a034:	4a07      	ldr	r2, [pc, #28]	; (c0d0a054 <ux_layout_paging_prepro+0xf0>)
c0d0a036:	447a      	add	r2, pc
        SPRINTF(G_ux.string_buffer, (G_ux.layout_paging.count>1)?"%s (%d/%d)":"%s", STRPIC(params->title), G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0d0a038:	4630      	mov	r0, r6
c0d0a03a:	301c      	adds	r0, #28
c0d0a03c:	2180      	movs	r1, #128	; 0x80
c0d0a03e:	f7fb f9a7 	bl	c0d05390 <snprintf>
      G_ux.tmp_element.text = G_ux.string_buffer;
c0d0a042:	4630      	mov	r0, r6
c0d0a044:	301c      	adds	r0, #28
c0d0a046:	21b8      	movs	r1, #184	; 0xb8
c0d0a048:	5070      	str	r0, [r6, r1]
}
c0d0a04a:	4620      	mov	r0, r4
c0d0a04c:	b003      	add	sp, #12
c0d0a04e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a050:	20001a00 	.word	0x20001a00
c0d0a054:	000035e2 	.word	0x000035e2
c0d0a058:	00003671 	.word	0x00003671
c0d0a05c:	000035f6 	.word	0x000035f6
c0d0a060:	00000c40 	.word	0x00000c40

c0d0a064 <ux_layout_paging_button_callback>:
    G_ux.layout_paging.current--;
    ux_layout_paging_redisplay(G_ux.stack_count-1);
  }
}

static unsigned int ux_layout_paging_button_callback(unsigned int button_mask, unsigned int button_mask_counter) {
c0d0a064:	b580      	push	{r7, lr}
c0d0a066:	4917      	ldr	r1, [pc, #92]	; (c0d0a0c4 <ux_layout_paging_button_callback+0x60>)
  UNUSED(button_mask_counter);
  switch(button_mask) {
c0d0a068:	4288      	cmp	r0, r1
c0d0a06a:	d00b      	beq.n	c0d0a084 <ux_layout_paging_button_callback+0x20>
c0d0a06c:	4916      	ldr	r1, [pc, #88]	; (c0d0a0c8 <ux_layout_paging_button_callback+0x64>)
c0d0a06e:	4288      	cmp	r0, r1
c0d0a070:	d013      	beq.n	c0d0a09a <ux_layout_paging_button_callback+0x36>
c0d0a072:	4916      	ldr	r1, [pc, #88]	; (c0d0a0cc <ux_layout_paging_button_callback+0x68>)
c0d0a074:	4288      	cmp	r0, r1
c0d0a076:	d122      	bne.n	c0d0a0be <ux_layout_paging_button_callback+0x5a>
  if (G_ux.layout_paging.current == 0) {
c0d0a078:	4815      	ldr	r0, [pc, #84]	; (c0d0a0d0 <ux_layout_paging_button_callback+0x6c>)
c0d0a07a:	6841      	ldr	r1, [r0, #4]
c0d0a07c:	2900      	cmp	r1, #0
c0d0a07e:	d01c      	beq.n	c0d0a0ba <ux_layout_paging_button_callback+0x56>
    G_ux.layout_paging.current--;
c0d0a080:	1e49      	subs	r1, r1, #1
c0d0a082:	e014      	b.n	c0d0a0ae <ux_layout_paging_button_callback+0x4a>
      break;
    case BUTTON_EVT_RELEASED|BUTTON_RIGHT:
      ux_layout_paging_next();
      break;
    case BUTTON_EVT_RELEASED|BUTTON_LEFT|BUTTON_RIGHT:
      if (G_ux.layout_paging.count == 0 
c0d0a084:	4912      	ldr	r1, [pc, #72]	; (c0d0a0d0 <ux_layout_paging_button_callback+0x6c>)
c0d0a086:	6888      	ldr	r0, [r1, #8]
        || G_ux.layout_paging.count-1 == G_ux.layout_paging.current) {
c0d0a088:	2800      	cmp	r0, #0
c0d0a08a:	d003      	beq.n	c0d0a094 <ux_layout_paging_button_callback+0x30>
c0d0a08c:	6849      	ldr	r1, [r1, #4]
c0d0a08e:	1e40      	subs	r0, r0, #1
      if (G_ux.layout_paging.count == 0 
c0d0a090:	4288      	cmp	r0, r1
c0d0a092:	d114      	bne.n	c0d0a0be <ux_layout_paging_button_callback+0x5a>
        ux_flow_validate();
c0d0a094:	f7ff fd68 	bl	c0d09b68 <ux_flow_validate>
c0d0a098:	e011      	b.n	c0d0a0be <ux_layout_paging_button_callback+0x5a>
  if (G_ux.layout_paging.current == G_ux.layout_paging.count-1) {
c0d0a09a:	480d      	ldr	r0, [pc, #52]	; (c0d0a0d0 <ux_layout_paging_button_callback+0x6c>)
c0d0a09c:	6841      	ldr	r1, [r0, #4]
c0d0a09e:	6882      	ldr	r2, [r0, #8]
c0d0a0a0:	1e52      	subs	r2, r2, #1
c0d0a0a2:	4291      	cmp	r1, r2
c0d0a0a4:	d102      	bne.n	c0d0a0ac <ux_layout_paging_button_callback+0x48>
    ux_flow_next();
c0d0a0a6:	f7ff fceb 	bl	c0d09a80 <ux_flow_next>
c0d0a0aa:	e008      	b.n	c0d0a0be <ux_layout_paging_button_callback+0x5a>
    G_ux.layout_paging.current++;
c0d0a0ac:	1c49      	adds	r1, r1, #1
c0d0a0ae:	6041      	str	r1, [r0, #4]
c0d0a0b0:	7800      	ldrb	r0, [r0, #0]
c0d0a0b2:	1e40      	subs	r0, r0, #1
c0d0a0b4:	f7ff ff38 	bl	c0d09f28 <ux_layout_paging_redisplay>
c0d0a0b8:	e001      	b.n	c0d0a0be <ux_layout_paging_button_callback+0x5a>
    ux_flow_prev();
c0d0a0ba:	f7ff fce7 	bl	c0d09a8c <ux_flow_prev>
c0d0a0be:	2000      	movs	r0, #0
      }
      break;
  }
  return 0;
c0d0a0c0:	bd80      	pop	{r7, pc}
c0d0a0c2:	46c0      	nop			; (mov r8, r8)
c0d0a0c4:	80000003 	.word	0x80000003
c0d0a0c8:	80000002 	.word	0x80000002
c0d0a0cc:	80000001 	.word	0x80000001
c0d0a0d0:	20001a00 	.word	0x20001a00

c0d0a0d4 <ux_layout_paging_init>:
}

unsigned short bagl_compute_line_width(unsigned short font_id, unsigned short width, const void * text, unsigned char text_length, unsigned char text_encoding);

void ux_layout_paging_init(unsigned int stack_slot) {
c0d0a0d4:	b570      	push	{r4, r5, r6, lr}
c0d0a0d6:	4604      	mov	r4, r0

  // depending flow browsing direction, select the correct page to display
  switch(ux_flow_direction()) {
c0d0a0d8:	f7ff fc8c 	bl	c0d099f4 <ux_flow_direction>
c0d0a0dc:	2801      	cmp	r0, #1
c0d0a0de:	d00b      	beq.n	c0d0a0f8 <ux_layout_paging_init+0x24>
c0d0a0e0:	1c40      	adds	r0, r0, #1
c0d0a0e2:	d10f      	bne.n	c0d0a104 <ux_layout_paging_init+0x30>
  ux_layout_paging_redisplay(stack_slot);
}

// function callable externally which reset the paging (to be called before init when willing to redisplay the first page)
void ux_layout_paging_reset(void) {
  os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d0a0e4:	4e1c      	ldr	r6, [pc, #112]	; (c0d0a158 <ux_layout_paging_init+0x84>)
c0d0a0e6:	1d30      	adds	r0, r6, #4
c0d0a0e8:	2500      	movs	r5, #0
c0d0a0ea:	220c      	movs	r2, #12
c0d0a0ec:	4629      	mov	r1, r5
c0d0a0ee:	f7fa f92a 	bl	c0d04346 <os_memset>
c0d0a0f2:	43e8      	mvns	r0, r5
      G_ux.layout_paging.current = -1UL;
c0d0a0f4:	6070      	str	r0, [r6, #4]
c0d0a0f6:	e005      	b.n	c0d0a104 <ux_layout_paging_init+0x30>
  os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d0a0f8:	4817      	ldr	r0, [pc, #92]	; (c0d0a158 <ux_layout_paging_init+0x84>)
c0d0a0fa:	1d00      	adds	r0, r0, #4
c0d0a0fc:	2100      	movs	r1, #0
c0d0a0fe:	220c      	movs	r2, #12
c0d0a100:	f7fa f921 	bl	c0d04346 <os_memset>
  ux_stack_init(stack_slot);
c0d0a104:	4620      	mov	r0, r4
c0d0a106:	f000 f9b3 	bl	c0d0a470 <ux_stack_init>
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_step_params(stack_slot);
c0d0a10a:	4620      	mov	r0, r4
c0d0a10c:	f7ff fdee 	bl	c0d09cec <ux_stack_get_step_params>
  if (params->text == NULL /*|| strlen(STRPIC(params->text)) == 0*/) {
c0d0a110:	6840      	ldr	r0, [r0, #4]
c0d0a112:	2800      	cmp	r0, #0
c0d0a114:	d019      	beq.n	c0d0a14a <ux_layout_paging_init+0x76>
c0d0a116:	2000      	movs	r0, #0
c0d0a118:	43c1      	mvns	r1, r0
  G_ux.layout_paging.count = ux_layout_paging_compute(stack_slot, -1UL); // at least one page
c0d0a11a:	4620      	mov	r0, r4
c0d0a11c:	f7ff fe72 	bl	c0d09e04 <ux_layout_paging_compute>
c0d0a120:	4d0d      	ldr	r5, [pc, #52]	; (c0d0a158 <ux_layout_paging_init+0x84>)
c0d0a122:	60a8      	str	r0, [r5, #8]
  if (G_ux.layout_paging.count == 0) {
c0d0a124:	2800      	cmp	r0, #0
c0d0a126:	d107      	bne.n	c0d0a138 <ux_layout_paging_init+0x64>
  os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d0a128:	1d28      	adds	r0, r5, #4
c0d0a12a:	2100      	movs	r1, #0
c0d0a12c:	220c      	movs	r2, #12
c0d0a12e:	f7fa f90a 	bl	c0d04346 <os_memset>
  if (G_ux.layout_paging.count && G_ux.layout_paging.current > G_ux.layout_paging.count-1UL) {
c0d0a132:	68a8      	ldr	r0, [r5, #8]
c0d0a134:	2800      	cmp	r0, #0
c0d0a136:	d004      	beq.n	c0d0a142 <ux_layout_paging_init+0x6e>
c0d0a138:	1e40      	subs	r0, r0, #1
c0d0a13a:	6869      	ldr	r1, [r5, #4]
c0d0a13c:	4281      	cmp	r1, r0
c0d0a13e:	d900      	bls.n	c0d0a142 <ux_layout_paging_init+0x6e>
    G_ux.layout_paging.current = G_ux.layout_paging.count-1;
c0d0a140:	6068      	str	r0, [r5, #4]
  ux_layout_paging_redisplay(stack_slot);
c0d0a142:	4620      	mov	r0, r4
c0d0a144:	f7ff fef0 	bl	c0d09f28 <ux_layout_paging_redisplay>
}
c0d0a148:	bd70      	pop	{r4, r5, r6, pc}
  os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d0a14a:	4803      	ldr	r0, [pc, #12]	; (c0d0a158 <ux_layout_paging_init+0x84>)
c0d0a14c:	1d00      	adds	r0, r0, #4
c0d0a14e:	2100      	movs	r1, #0
c0d0a150:	220c      	movs	r2, #12
c0d0a152:	f7fa f8f8 	bl	c0d04346 <os_memset>
}
c0d0a156:	bd70      	pop	{r4, r5, r6, pc}
c0d0a158:	20001a00 	.word	0x20001a00

c0d0a15c <ux_layout_pb_prepro>:
  {{BAGL_ICON                           , 0x10,  56,  2,  16,  16, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL},
  {{BAGL_LABELINE                       , 0x11,   0, 28, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL},
#endif // TARGET_NANOX
};

const bagl_element_t* ux_layout_pb_prepro(const bagl_element_t* element) {
c0d0a15c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0a15e:	b081      	sub	sp, #4
c0d0a160:	4606      	mov	r6, r0
  // don't display if null
  const ux_layout_pb_params_t* params = (const ux_layout_pb_params_t*)ux_stack_get_current_step_params();
c0d0a162:	f7ff fddb 	bl	c0d09d1c <ux_stack_get_current_step_params>
c0d0a166:	4605      	mov	r5, r0

	// copy element before any mod
	os_memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0d0a168:	4f11      	ldr	r7, [pc, #68]	; (c0d0a1b0 <ux_layout_pb_prepro+0x54>)
c0d0a16a:	463c      	mov	r4, r7
c0d0a16c:	349c      	adds	r4, #156	; 0x9c
c0d0a16e:	2220      	movs	r2, #32
c0d0a170:	4620      	mov	r0, r4
c0d0a172:	4631      	mov	r1, r6
c0d0a174:	f7fa f8d1 	bl	c0d0431a <os_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0d0a178:	7870      	ldrb	r0, [r6, #1]
c0d0a17a:	280f      	cmp	r0, #15
c0d0a17c:	dc06      	bgt.n	c0d0a18c <ux_layout_pb_prepro+0x30>
c0d0a17e:	2801      	cmp	r0, #1
c0d0a180:	d00a      	beq.n	c0d0a198 <ux_layout_pb_prepro+0x3c>
c0d0a182:	2802      	cmp	r0, #2
c0d0a184:	d111      	bne.n	c0d0a1aa <ux_layout_pb_prepro+0x4e>
  			return NULL;
  		}
  		break;

  	case 0x02:
  		if (ux_flow_is_last()) {
c0d0a186:	f7ff fc15 	bl	c0d099b4 <ux_flow_is_last>
c0d0a18a:	e007      	b.n	c0d0a19c <ux_layout_pb_prepro+0x40>
  switch (element->component.userid) {
c0d0a18c:	2810      	cmp	r0, #16
c0d0a18e:	d009      	beq.n	c0d0a1a4 <ux_layout_pb_prepro+0x48>
c0d0a190:	2811      	cmp	r0, #17
c0d0a192:	d10a      	bne.n	c0d0a1aa <ux_layout_pb_prepro+0x4e>
    case 0x10:
  		G_ux.tmp_element.text = (const char*)params->icon;
      break;

    case 0x11:
  		G_ux.tmp_element.text = params->line1;
c0d0a194:	6868      	ldr	r0, [r5, #4]
c0d0a196:	e006      	b.n	c0d0a1a6 <ux_layout_pb_prepro+0x4a>
  		if (ux_flow_is_first()) {
c0d0a198:	f7ff fbe4 	bl	c0d09964 <ux_flow_is_first>
c0d0a19c:	2800      	cmp	r0, #0
c0d0a19e:	d004      	beq.n	c0d0a1aa <ux_layout_pb_prepro+0x4e>
c0d0a1a0:	2400      	movs	r4, #0
c0d0a1a2:	e002      	b.n	c0d0a1aa <ux_layout_pb_prepro+0x4e>
  		G_ux.tmp_element.text = (const char*)params->icon;
c0d0a1a4:	6828      	ldr	r0, [r5, #0]
c0d0a1a6:	21b8      	movs	r1, #184	; 0xb8
c0d0a1a8:	5078      	str	r0, [r7, r1]
      break;
  }
  return &G_ux.tmp_element;
}
c0d0a1aa:	4620      	mov	r0, r4
c0d0a1ac:	b001      	add	sp, #4
c0d0a1ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a1b0:	20001a00 	.word	0x20001a00

c0d0a1b4 <ux_layout_pb_init>:

void ux_layout_pb_init(unsigned int stack_slot) {
c0d0a1b4:	b510      	push	{r4, lr}
c0d0a1b6:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0d0a1b8:	f000 f95a 	bl	c0d0a470 <ux_stack_init>
c0d0a1bc:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pb_elements;
c0d0a1be:	4360      	muls	r0, r4
c0d0a1c0:	490b      	ldr	r1, [pc, #44]	; (c0d0a1f0 <ux_layout_pb_init+0x3c>)
c0d0a1c2:	1808      	adds	r0, r1, r0
c0d0a1c4:	21c4      	movs	r1, #196	; 0xc4
c0d0a1c6:	2205      	movs	r2, #5
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_pb_elements);
c0d0a1c8:	5442      	strb	r2, [r0, r1]
c0d0a1ca:	21c0      	movs	r1, #192	; 0xc0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pb_elements;
c0d0a1cc:	4a09      	ldr	r2, [pc, #36]	; (c0d0a1f4 <ux_layout_pb_init+0x40>)
c0d0a1ce:	447a      	add	r2, pc
c0d0a1d0:	5042      	str	r2, [r0, r1]
c0d0a1d2:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pb_prepro;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0d0a1d4:	4a08      	ldr	r2, [pc, #32]	; (c0d0a1f8 <ux_layout_pb_init+0x44>)
c0d0a1d6:	447a      	add	r2, pc
c0d0a1d8:	5042      	str	r2, [r0, r1]
c0d0a1da:	21cc      	movs	r1, #204	; 0xcc
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pb_prepro;
c0d0a1dc:	4a07      	ldr	r2, [pc, #28]	; (c0d0a1fc <ux_layout_pb_init+0x48>)
c0d0a1de:	447a      	add	r2, pc
c0d0a1e0:	5042      	str	r2, [r0, r1]
c0d0a1e2:	21bd      	movs	r1, #189	; 0xbd
c0d0a1e4:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0d0a1e6:	5442      	strb	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d0a1e8:	4620      	mov	r0, r4
c0d0a1ea:	f000 f91b 	bl	c0d0a424 <ux_stack_display>
}
c0d0a1ee:	bd10      	pop	{r4, pc}
c0d0a1f0:	20001a00 	.word	0x20001a00
c0d0a1f4:	0000345e 	.word	0x0000345e
c0d0a1f8:	fffffadb 	.word	0xfffffadb
c0d0a1fc:	ffffff7b 	.word	0xffffff7b

c0d0a200 <ux_layout_pbb_prepro>:
  {{BAGL_LABELINE                       , 0x10,  41,  12, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px, 0  }, NULL},
  {{BAGL_LABELINE                       , 0x11,  41,  26, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px, 0  }, NULL},
#endif // TARGET_NANOX
};

const bagl_element_t* ux_layout_pbb_prepro(const bagl_element_t* element) {
c0d0a200:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0a202:	b081      	sub	sp, #4
c0d0a204:	4606      	mov	r6, r0
  // don't display if null
  const ux_layout_icon_strings_params_t* params = (const ux_layout_icon_strings_params_t*)ux_stack_get_current_step_params();
c0d0a206:	f7ff fd89 	bl	c0d09d1c <ux_stack_get_current_step_params>
c0d0a20a:	4605      	mov	r5, r0

	// ocpy element before any mod
	os_memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0d0a20c:	4f15      	ldr	r7, [pc, #84]	; (c0d0a264 <ux_layout_pbb_prepro+0x64>)
c0d0a20e:	463c      	mov	r4, r7
c0d0a210:	349c      	adds	r4, #156	; 0x9c
c0d0a212:	2220      	movs	r2, #32
c0d0a214:	4620      	mov	r0, r4
c0d0a216:	4631      	mov	r1, r6
c0d0a218:	f7fa f87f 	bl	c0d0431a <os_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0d0a21c:	7870      	ldrb	r0, [r6, #1]
c0d0a21e:	280f      	cmp	r0, #15
c0d0a220:	dc07      	bgt.n	c0d0a232 <ux_layout_pbb_prepro+0x32>
c0d0a222:	2801      	cmp	r0, #1
c0d0a224:	d012      	beq.n	c0d0a24c <ux_layout_pbb_prepro+0x4c>
c0d0a226:	2802      	cmp	r0, #2
c0d0a228:	d013      	beq.n	c0d0a252 <ux_layout_pbb_prepro+0x52>
c0d0a22a:	280f      	cmp	r0, #15
c0d0a22c:	d116      	bne.n	c0d0a25c <ux_layout_pbb_prepro+0x5c>
  			return NULL;
  		}
  		break;

    case 0x0F:
  		G_ux.tmp_element.text = (const char*)params->icon;
c0d0a22e:	6828      	ldr	r0, [r5, #0]
c0d0a230:	e009      	b.n	c0d0a246 <ux_layout_pbb_prepro+0x46>
  switch (element->component.userid) {
c0d0a232:	3810      	subs	r0, #16
c0d0a234:	2802      	cmp	r0, #2
c0d0a236:	d211      	bcs.n	c0d0a25c <ux_layout_pbb_prepro+0x5c>
c0d0a238:	209d      	movs	r0, #157	; 0x9d
      break;

    case 0x10:
    case 0x11:
      G_ux.tmp_element.text = params->lines[G_ux.tmp_element.component.userid&0xF];
c0d0a23a:	5c38      	ldrb	r0, [r7, r0]
c0d0a23c:	210f      	movs	r1, #15
c0d0a23e:	4001      	ands	r1, r0
c0d0a240:	0088      	lsls	r0, r1, #2
c0d0a242:	1828      	adds	r0, r5, r0
c0d0a244:	6840      	ldr	r0, [r0, #4]
c0d0a246:	21b8      	movs	r1, #184	; 0xb8
c0d0a248:	5078      	str	r0, [r7, r1]
c0d0a24a:	e007      	b.n	c0d0a25c <ux_layout_pbb_prepro+0x5c>
  		if (ux_flow_is_first()) {
c0d0a24c:	f7ff fb8a 	bl	c0d09964 <ux_flow_is_first>
c0d0a250:	e001      	b.n	c0d0a256 <ux_layout_pbb_prepro+0x56>
  		if (ux_flow_is_last()) {
c0d0a252:	f7ff fbaf 	bl	c0d099b4 <ux_flow_is_last>
c0d0a256:	2800      	cmp	r0, #0
c0d0a258:	d000      	beq.n	c0d0a25c <ux_layout_pbb_prepro+0x5c>
c0d0a25a:	2400      	movs	r4, #0
      break;

  }
  return &G_ux.tmp_element;
}
c0d0a25c:	4620      	mov	r0, r4
c0d0a25e:	b001      	add	sp, #4
c0d0a260:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a262:	46c0      	nop			; (mov r8, r8)
c0d0a264:	20001a00 	.word	0x20001a00

c0d0a268 <ux_layout_pbb_init_common>:


void ux_layout_pbb_init_common(unsigned int stack_slot) {
c0d0a268:	b510      	push	{r4, lr}
c0d0a26a:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0d0a26c:	f000 f900 	bl	c0d0a470 <ux_stack_init>
c0d0a270:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0d0a272:	4360      	muls	r0, r4
c0d0a274:	4908      	ldr	r1, [pc, #32]	; (c0d0a298 <ux_layout_pbb_init_common+0x30>)
c0d0a276:	1808      	adds	r0, r1, r0
c0d0a278:	21c4      	movs	r1, #196	; 0xc4
c0d0a27a:	2206      	movs	r2, #6
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_pbb_elements);
c0d0a27c:	5442      	strb	r2, [r0, r1]
c0d0a27e:	21c0      	movs	r1, #192	; 0xc0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0d0a280:	4a06      	ldr	r2, [pc, #24]	; (c0d0a29c <ux_layout_pbb_init_common+0x34>)
c0d0a282:	447a      	add	r2, pc
c0d0a284:	5042      	str	r2, [r0, r1]
c0d0a286:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0d0a288:	4a05      	ldr	r2, [pc, #20]	; (c0d0a2a0 <ux_layout_pbb_init_common+0x38>)
c0d0a28a:	447a      	add	r2, pc
c0d0a28c:	5042      	str	r2, [r0, r1]
c0d0a28e:	21bd      	movs	r1, #189	; 0xbd
c0d0a290:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0d0a292:	5442      	strb	r2, [r0, r1]
}
c0d0a294:	bd10      	pop	{r4, pc}
c0d0a296:	46c0      	nop			; (mov r8, r8)
c0d0a298:	20001a00 	.word	0x20001a00
c0d0a29c:	0000344a 	.word	0x0000344a
c0d0a2a0:	fffffa27 	.word	0xfffffa27

c0d0a2a4 <ux_layout_pbb_init>:

void ux_layout_pbb_init(unsigned int stack_slot) {
c0d0a2a4:	b510      	push	{r4, lr}
c0d0a2a6:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0d0a2a8:	f000 f8e2 	bl	c0d0a470 <ux_stack_init>
c0d0a2ac:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0d0a2ae:	4360      	muls	r0, r4
c0d0a2b0:	490b      	ldr	r1, [pc, #44]	; (c0d0a2e0 <ux_layout_pbb_init+0x3c>)
c0d0a2b2:	1808      	adds	r0, r1, r0
c0d0a2b4:	21c4      	movs	r1, #196	; 0xc4
c0d0a2b6:	2206      	movs	r2, #6
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_pbb_elements);
c0d0a2b8:	5442      	strb	r2, [r0, r1]
c0d0a2ba:	21c0      	movs	r1, #192	; 0xc0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0d0a2bc:	4a09      	ldr	r2, [pc, #36]	; (c0d0a2e4 <ux_layout_pbb_init+0x40>)
c0d0a2be:	447a      	add	r2, pc
c0d0a2c0:	5042      	str	r2, [r0, r1]
c0d0a2c2:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0d0a2c4:	4a08      	ldr	r2, [pc, #32]	; (c0d0a2e8 <ux_layout_pbb_init+0x44>)
c0d0a2c6:	447a      	add	r2, pc
c0d0a2c8:	5042      	str	r2, [r0, r1]
c0d0a2ca:	21bd      	movs	r1, #189	; 0xbd
c0d0a2cc:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0d0a2ce:	5442      	strb	r2, [r0, r1]
c0d0a2d0:	21cc      	movs	r1, #204	; 0xcc
  ux_layout_pbb_init_common(stack_slot);
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pbb_prepro;
c0d0a2d2:	4a06      	ldr	r2, [pc, #24]	; (c0d0a2ec <ux_layout_pbb_init+0x48>)
c0d0a2d4:	447a      	add	r2, pc
c0d0a2d6:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d0a2d8:	4620      	mov	r0, r4
c0d0a2da:	f000 f8a3 	bl	c0d0a424 <ux_stack_display>
}
c0d0a2de:	bd10      	pop	{r4, pc}
c0d0a2e0:	20001a00 	.word	0x20001a00
c0d0a2e4:	0000340e 	.word	0x0000340e
c0d0a2e8:	fffff9eb 	.word	0xfffff9eb
c0d0a2ec:	ffffff29 	.word	0xffffff29

c0d0a2f0 <ux_layout_pnn_prepro>:
#endif // TARGET_NANOX

};
*/

const bagl_element_t* ux_layout_pnn_prepro(const bagl_element_t* element) {
c0d0a2f0:	b580      	push	{r7, lr}
      G_ux.tmp_element.text = params->line2;
      break;
  }
  return &G_ux.tmp_element;
  */
  const bagl_element_t* e = ux_layout_pbb_prepro(element);
c0d0a2f2:	f7ff ff85 	bl	c0d0a200 <ux_layout_pbb_prepro>
  if (e && G_ux.tmp_element.component.userid >= 0x10) {
c0d0a2f6:	2800      	cmp	r0, #0
c0d0a2f8:	d007      	beq.n	c0d0a30a <ux_layout_pnn_prepro+0x1a>
c0d0a2fa:	229d      	movs	r2, #157	; 0x9d
c0d0a2fc:	4903      	ldr	r1, [pc, #12]	; (c0d0a30c <ux_layout_pnn_prepro+0x1c>)
c0d0a2fe:	5c8a      	ldrb	r2, [r1, r2]
c0d0a300:	2a10      	cmp	r2, #16
c0d0a302:	d302      	bcc.n	c0d0a30a <ux_layout_pnn_prepro+0x1a>
c0d0a304:	22b4      	movs	r2, #180	; 0xb4
c0d0a306:	230a      	movs	r3, #10
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px;
c0d0a308:	528b      	strh	r3, [r1, r2]
  }
  return e;
c0d0a30a:	bd80      	pop	{r7, pc}
c0d0a30c:	20001a00 	.word	0x20001a00

c0d0a310 <ux_layout_pnn_init>:
}

void ux_layout_pnn_init(unsigned int stack_slot) { 
c0d0a310:	b510      	push	{r4, lr}
c0d0a312:	4604      	mov	r4, r0
  ux_layout_pbb_init_common(stack_slot);
c0d0a314:	f7ff ffa8 	bl	c0d0a268 <ux_layout_pbb_init_common>
c0d0a318:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pnn_prepro;
c0d0a31a:	4360      	muls	r0, r4
c0d0a31c:	4904      	ldr	r1, [pc, #16]	; (c0d0a330 <ux_layout_pnn_init+0x20>)
c0d0a31e:	1808      	adds	r0, r1, r0
c0d0a320:	21cc      	movs	r1, #204	; 0xcc
c0d0a322:	4a04      	ldr	r2, [pc, #16]	; (c0d0a334 <ux_layout_pnn_init+0x24>)
c0d0a324:	447a      	add	r2, pc
c0d0a326:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d0a328:	4620      	mov	r0, r4
c0d0a32a:	f000 f87b 	bl	c0d0a424 <ux_stack_display>
}
c0d0a32e:	bd10      	pop	{r4, pc}
c0d0a330:	20001a00 	.word	0x20001a00
c0d0a334:	ffffffc9 	.word	0xffffffc9

c0d0a338 <ux_layout_strings_prepro>:
    G_ux.stack[stack_slot].ticker_value = ms;
    G_ux.stack[stack_slot].ticker_interval = ms; // restart
  }
}

const bagl_element_t* ux_layout_strings_prepro(const bagl_element_t* element) {
c0d0a338:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0a33a:	b081      	sub	sp, #4
c0d0a33c:	4606      	mov	r6, r0
  // don't display if null
  const ux_layout_strings_params_t* params = (const ux_layout_strings_params_t*)ux_stack_get_current_step_params();
c0d0a33e:	f7ff fced 	bl	c0d09d1c <ux_stack_get_current_step_params>
c0d0a342:	4605      	mov	r5, r0
  // ocpy element before any mod
  os_memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0d0a344:	4f11      	ldr	r7, [pc, #68]	; (c0d0a38c <ux_layout_strings_prepro+0x54>)
c0d0a346:	463c      	mov	r4, r7
c0d0a348:	349c      	adds	r4, #156	; 0x9c
c0d0a34a:	2220      	movs	r2, #32
c0d0a34c:	4620      	mov	r0, r4
c0d0a34e:	4631      	mov	r1, r6
c0d0a350:	f7f9 ffe3 	bl	c0d0431a <os_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0d0a354:	7870      	ldrb	r0, [r6, #1]
c0d0a356:	2802      	cmp	r0, #2
c0d0a358:	d004      	beq.n	c0d0a364 <ux_layout_strings_prepro+0x2c>
c0d0a35a:	2801      	cmp	r0, #1
c0d0a35c:	d108      	bne.n	c0d0a370 <ux_layout_strings_prepro+0x38>
    case 0x01:
      if (ux_flow_is_first()) {
c0d0a35e:	f7ff fb01 	bl	c0d09964 <ux_flow_is_first>
c0d0a362:	e001      	b.n	c0d0a368 <ux_layout_strings_prepro+0x30>
        return NULL;
      }
      break;

    case 0x02:
      if (ux_flow_is_last()) {
c0d0a364:	f7ff fb26 	bl	c0d099b4 <ux_flow_is_last>
c0d0a368:	2800      	cmp	r0, #0
c0d0a36a:	d00c      	beq.n	c0d0a386 <ux_layout_strings_prepro+0x4e>
c0d0a36c:	2400      	movs	r4, #0
c0d0a36e:	e00a      	b.n	c0d0a386 <ux_layout_strings_prepro+0x4e>
c0d0a370:	209d      	movs	r0, #157	; 0x9d
        return NULL;
      }
      break;

    default:
      if (G_ux.tmp_element.component.userid&0xF0) {
c0d0a372:	5c38      	ldrb	r0, [r7, r0]
c0d0a374:	0601      	lsls	r1, r0, #24
c0d0a376:	0f09      	lsrs	r1, r1, #28
c0d0a378:	d005      	beq.n	c0d0a386 <ux_layout_strings_prepro+0x4e>
c0d0a37a:	210f      	movs	r1, #15
        G_ux.tmp_element.text = params->lines[G_ux.tmp_element.component.userid&0xF];
c0d0a37c:	4008      	ands	r0, r1
c0d0a37e:	0080      	lsls	r0, r0, #2
c0d0a380:	5828      	ldr	r0, [r5, r0]
c0d0a382:	21b8      	movs	r1, #184	; 0xb8
c0d0a384:	5078      	str	r0, [r7, r1]
      }
      break;
  }
  return &G_ux.tmp_element;
}
c0d0a386:	4620      	mov	r0, r4
c0d0a388:	b001      	add	sp, #4
c0d0a38a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a38c:	20001a00 	.word	0x20001a00

c0d0a390 <ux_stack_push>:
    }
  }
  return 0;
}

unsigned int ux_stack_push(void) {
c0d0a390:	b5b0      	push	{r4, r5, r7, lr}
  // only push if an available slot exists
  if (G_ux.stack_count < ARRAYLEN(G_ux.stack)) {
c0d0a392:	4d0c      	ldr	r5, [pc, #48]	; (c0d0a3c4 <ux_stack_push+0x34>)
c0d0a394:	7828      	ldrb	r0, [r5, #0]
c0d0a396:	2800      	cmp	r0, #0
c0d0a398:	d111      	bne.n	c0d0a3be <ux_stack_push+0x2e>
    os_memset(&G_ux.stack[G_ux.stack_count], 0, sizeof(G_ux.stack[0]));
c0d0a39a:	4628      	mov	r0, r5
c0d0a39c:	30bc      	adds	r0, #188	; 0xbc
c0d0a39e:	2400      	movs	r4, #0
c0d0a3a0:	2224      	movs	r2, #36	; 0x24
c0d0a3a2:	4621      	mov	r1, r4
c0d0a3a4:	f7f9 ffcf 	bl	c0d04346 <os_memset>
#ifdef HAVE_UX_FLOW
    os_memset(&G_ux.flow_stack[G_ux.stack_count], 0, sizeof(G_ux.flow_stack[0]));
c0d0a3a8:	7828      	ldrb	r0, [r5, #0]
c0d0a3aa:	220c      	movs	r2, #12
c0d0a3ac:	4350      	muls	r0, r2
c0d0a3ae:	1828      	adds	r0, r5, r0
c0d0a3b0:	3010      	adds	r0, #16
c0d0a3b2:	4621      	mov	r1, r4
c0d0a3b4:	f7f9 ffc7 	bl	c0d04346 <os_memset>
#endif // HAVE_UX_FLOW
    G_ux.stack_count++;
c0d0a3b8:	7828      	ldrb	r0, [r5, #0]
c0d0a3ba:	1c40      	adds	r0, r0, #1
c0d0a3bc:	7028      	strb	r0, [r5, #0]
  }
  // return the stack top index
  return G_ux.stack_count-1;
c0d0a3be:	b2c0      	uxtb	r0, r0
c0d0a3c0:	1e40      	subs	r0, r0, #1
c0d0a3c2:	bdb0      	pop	{r4, r5, r7, pc}
c0d0a3c4:	20001a00 	.word	0x20001a00

c0d0a3c8 <ux_stack_pop>:
}
unsigned int ux_stack_pop(void) {
c0d0a3c8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0a3ca:	b081      	sub	sp, #4
  unsigned int exit_code = BOLOS_UX_OK;
  // only pop if more than two stack entry (0 and 1,top is an index not a count)
  if (G_ux.stack_count > 0) {
c0d0a3cc:	4e14      	ldr	r6, [pc, #80]	; (c0d0a420 <ux_stack_pop+0x58>)
c0d0a3ce:	7830      	ldrb	r0, [r6, #0]
c0d0a3d0:	2800      	cmp	r0, #0
c0d0a3d2:	d01e      	beq.n	c0d0a412 <ux_stack_pop+0x4a>
    G_ux.stack_count--;
c0d0a3d4:	1e40      	subs	r0, r0, #1
c0d0a3d6:	7030      	strb	r0, [r6, #0]
    exit_code = G_ux.stack[G_ux.stack_count].exit_code_after_elements_displayed;
c0d0a3d8:	b2c0      	uxtb	r0, r0
c0d0a3da:	2424      	movs	r4, #36	; 0x24
c0d0a3dc:	4360      	muls	r0, r4
c0d0a3de:	1830      	adds	r0, r6, r0
c0d0a3e0:	21bc      	movs	r1, #188	; 0xbc
c0d0a3e2:	5c47      	ldrb	r7, [r0, r1]
c0d0a3e4:	30bc      	adds	r0, #188	; 0xbc
c0d0a3e6:	2500      	movs	r5, #0
    // wipe popped slot
    os_memset(&G_ux.stack[G_ux.stack_count], 0, sizeof(G_ux.stack[0]));
c0d0a3e8:	4629      	mov	r1, r5
c0d0a3ea:	4622      	mov	r2, r4
c0d0a3ec:	f7f9 ffab 	bl	c0d04346 <os_memset>
#ifdef HAVE_UX_FLOW
    os_memset(&G_ux.flow_stack[G_ux.stack_count], 0, sizeof(G_ux.flow_stack[0]));
c0d0a3f0:	7830      	ldrb	r0, [r6, #0]
c0d0a3f2:	220c      	movs	r2, #12
c0d0a3f4:	4350      	muls	r0, r2
c0d0a3f6:	1830      	adds	r0, r6, r0
c0d0a3f8:	3010      	adds	r0, #16
c0d0a3fa:	4629      	mov	r1, r5
c0d0a3fc:	f7f9 ffa3 	bl	c0d04346 <os_memset>
#endif // HAVE_UX_FLOW
  }

  // prepare output code when popping the last stack screen
  if (G_ux.stack_count==0) {
c0d0a400:	7830      	ldrb	r0, [r6, #0]
c0d0a402:	2800      	cmp	r0, #0
c0d0a404:	d006      	beq.n	c0d0a414 <ux_stack_pop+0x4c>
    G_ux.exit_code = exit_code;
  }
  // ask for a complete redraw (optimisation due to blink must be avoided as we're returning from a modal, and within the bolos ux screen stack)
  else {
    // prepare to redraw the slot when asked
    G_ux.stack[G_ux.stack_count-1].element_index = 0;
c0d0a406:	1e40      	subs	r0, r0, #1
c0d0a408:	4344      	muls	r4, r0
c0d0a40a:	1931      	adds	r1, r6, r4
c0d0a40c:	22be      	movs	r2, #190	; 0xbe
c0d0a40e:	528d      	strh	r5, [r1, r2]
c0d0a410:	e003      	b.n	c0d0a41a <ux_stack_pop+0x52>
c0d0a412:	27aa      	movs	r7, #170	; 0xaa
    G_ux.exit_code = exit_code;
c0d0a414:	7077      	strb	r7, [r6, #1]
c0d0a416:	2000      	movs	r0, #0
c0d0a418:	43c0      	mvns	r0, r0
  }
  // return the stack top index (or -1 if no top)
  return G_ux.stack_count-1; 
c0d0a41a:	b001      	add	sp, #4
c0d0a41c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a41e:	46c0      	nop			; (mov r8, r8)
c0d0a420:	20001a00 	.word	0x20001a00

c0d0a424 <ux_stack_display>:
}
#endif // UX_STACK_SLOT_ARRAY_COUNT == 1
#endif // TARGET_NANOX

// common code for all screens
void ux_stack_display(unsigned int stack_slot) {
c0d0a424:	b5b0      	push	{r4, r5, r7, lr}
c0d0a426:	4604      	mov	r4, r0
  // don't display any elements of a previous screen replacement
  if(G_ux.stack_count > 0 && stack_slot+1 == G_ux.stack_count) {
c0d0a428:	4810      	ldr	r0, [pc, #64]	; (c0d0a46c <ux_stack_display+0x48>)
c0d0a42a:	7801      	ldrb	r1, [r0, #0]
c0d0a42c:	2900      	cmp	r1, #0
c0d0a42e:	d00e      	beq.n	c0d0a44e <ux_stack_display+0x2a>
c0d0a430:	1c62      	adds	r2, r4, #1
c0d0a432:	428a      	cmp	r2, r1
c0d0a434:	d10b      	bne.n	c0d0a44e <ux_stack_display+0x2a>
c0d0a436:	2124      	movs	r1, #36	; 0x24
    io_seproxyhal_init_ux();
    // at worse a redisplay of the current screen has been requested, ensure to redraw it correctly
    G_ux.stack[stack_slot].element_index = 0;
c0d0a438:	4361      	muls	r1, r4
c0d0a43a:	1845      	adds	r5, r0, r1
    io_seproxyhal_init_ux();
c0d0a43c:	f7fa fa00 	bl	c0d04840 <io_seproxyhal_init_ux>
c0d0a440:	20be      	movs	r0, #190	; 0xbe
c0d0a442:	2100      	movs	r1, #0
    G_ux.stack[stack_slot].element_index = 0;
c0d0a444:	5229      	strh	r1, [r5, r0]
#ifdef TARGET_NANOX
    ux_stack_display_elements(&G_ux.stack[stack_slot]); // on balenos, no need to wait for the display processed event
#else // TARGET_NANOX
    ux_stack_al_display_next_element(stack_slot);
c0d0a446:	4620      	mov	r0, r4
c0d0a448:	f000 f826 	bl	c0d0a498 <ux_stack_al_display_next_element>
    if (G_ux.exit_code == BOLOS_UX_OK) {
      G_ux.exit_code = BOLOS_UX_REDRAW;
    }
  }
  // else don't draw (in stack insertion)
}
c0d0a44c:	bdb0      	pop	{r4, r5, r7, pc}
  if(G_ux.stack_count > 0 && stack_slot+1 == G_ux.stack_count) {
c0d0a44e:	424a      	negs	r2, r1
c0d0a450:	414a      	adcs	r2, r1
  else if (stack_slot == -1UL || G_ux.stack_count == 0) {
c0d0a452:	1c61      	adds	r1, r4, #1
c0d0a454:	424b      	negs	r3, r1
c0d0a456:	414b      	adcs	r3, r1
c0d0a458:	4313      	orrs	r3, r2
c0d0a45a:	2b01      	cmp	r3, #1
c0d0a45c:	d104      	bne.n	c0d0a468 <ux_stack_display+0x44>
c0d0a45e:	7841      	ldrb	r1, [r0, #1]
c0d0a460:	29aa      	cmp	r1, #170	; 0xaa
c0d0a462:	d101      	bne.n	c0d0a468 <ux_stack_display+0x44>
c0d0a464:	2169      	movs	r1, #105	; 0x69
      G_ux.exit_code = BOLOS_UX_REDRAW;
c0d0a466:	7041      	strb	r1, [r0, #1]
}
c0d0a468:	bdb0      	pop	{r4, r5, r7, pc}
c0d0a46a:	46c0      	nop			; (mov r8, r8)
c0d0a46c:	20001a00 	.word	0x20001a00

c0d0a470 <ux_stack_init>:
void ux_stack_init(unsigned int stack_slot) {
c0d0a470:	b570      	push	{r4, r5, r6, lr}
c0d0a472:	2424      	movs	r4, #36	; 0x24
  os_memset(&G_ux.stack[stack_slot], 0, sizeof(G_ux.stack[0]));
c0d0a474:	4360      	muls	r0, r4
c0d0a476:	4907      	ldr	r1, [pc, #28]	; (c0d0a494 <ux_stack_init+0x24>)
c0d0a478:	180e      	adds	r6, r1, r0
  io_seproxyhal_init_ux(); // glitch upon ux_stack_display for a button being pressed in a previous screen
c0d0a47a:	f7fa f9e1 	bl	c0d04840 <io_seproxyhal_init_ux>
  os_memset(&G_ux.stack[stack_slot], 0, sizeof(G_ux.stack[0]));
c0d0a47e:	4630      	mov	r0, r6
c0d0a480:	30bc      	adds	r0, #188	; 0xbc
c0d0a482:	2500      	movs	r5, #0
c0d0a484:	4629      	mov	r1, r5
c0d0a486:	4622      	mov	r2, r4
c0d0a488:	f7f9 ff5d 	bl	c0d04346 <os_memset>
c0d0a48c:	20bc      	movs	r0, #188	; 0xbc
  G_ux.stack[stack_slot].exit_code_after_elements_displayed = BOLOS_UX_CONTINUE;
c0d0a48e:	5435      	strb	r5, [r6, r0]
}
c0d0a490:	bd70      	pop	{r4, r5, r6, pc}
c0d0a492:	46c0      	nop			; (mov r8, r8)
c0d0a494:	20001a00 	.word	0x20001a00

c0d0a498 <ux_stack_al_display_next_element>:
void ux_stack_al_display_next_element(unsigned int stack_slot) {
c0d0a498:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0a49a:	b081      	sub	sp, #4
c0d0a49c:	4604      	mov	r4, r0
c0d0a49e:	2004      	movs	r0, #4
  unsigned int status = os_sched_last_status(TASK_BOLOS_UX);
c0d0a4a0:	f7fc fb82 	bl	c0d06ba8 <os_sched_last_status>
  if (status != BOLOS_UX_IGNORE && status != BOLOS_UX_CONTINUE) {
c0d0a4a4:	2800      	cmp	r0, #0
c0d0a4a6:	d039      	beq.n	c0d0a51c <ux_stack_al_display_next_element+0x84>
c0d0a4a8:	2897      	cmp	r0, #151	; 0x97
c0d0a4aa:	d037      	beq.n	c0d0a51c <ux_stack_al_display_next_element+0x84>
c0d0a4ac:	2024      	movs	r0, #36	; 0x24
      && G_ux.stack[stack_slot].element_index < G_ux.stack[stack_slot].element_arrays[0].element_array_count
c0d0a4ae:	4360      	muls	r0, r4
c0d0a4b0:	491b      	ldr	r1, [pc, #108]	; (c0d0a520 <ux_stack_al_display_next_element+0x88>)
c0d0a4b2:	180c      	adds	r4, r1, r0
c0d0a4b4:	20c0      	movs	r0, #192	; 0xc0
    while (G_ux.stack[stack_slot].element_arrays[0].element_array
c0d0a4b6:	5820      	ldr	r0, [r4, r0]
      && G_ux.stack[stack_slot].element_index < G_ux.stack[stack_slot].element_arrays[0].element_array_count
c0d0a4b8:	2800      	cmp	r0, #0
c0d0a4ba:	d02f      	beq.n	c0d0a51c <ux_stack_al_display_next_element+0x84>
c0d0a4bc:	4625      	mov	r5, r4
c0d0a4be:	35c0      	adds	r5, #192	; 0xc0
c0d0a4c0:	4626      	mov	r6, r4
c0d0a4c2:	36be      	adds	r6, #190	; 0xbe
c0d0a4c4:	4627      	mov	r7, r4
c0d0a4c6:	37cc      	adds	r7, #204	; 0xcc
c0d0a4c8:	34c4      	adds	r4, #196	; 0xc4
c0d0a4ca:	8830      	ldrh	r0, [r6, #0]
c0d0a4cc:	7821      	ldrb	r1, [r4, #0]
c0d0a4ce:	b280      	uxth	r0, r0
      && ! io_seproxyhal_spi_is_status_sent()
c0d0a4d0:	4288      	cmp	r0, r1
c0d0a4d2:	d223      	bcs.n	c0d0a51c <ux_stack_al_display_next_element+0x84>
c0d0a4d4:	f7fc fb34 	bl	c0d06b40 <io_seph_is_status_sent>
      && (os_perso_isonboarded() != BOLOS_UX_OK || os_global_pin_is_validated() == BOLOS_UX_OK)) {
c0d0a4d8:	2800      	cmp	r0, #0
c0d0a4da:	d11f      	bne.n	c0d0a51c <ux_stack_al_display_next_element+0x84>
c0d0a4dc:	f7fc faa6 	bl	c0d06a2c <os_perso_isonboarded>
c0d0a4e0:	28aa      	cmp	r0, #170	; 0xaa
c0d0a4e2:	d103      	bne.n	c0d0a4ec <ux_stack_al_display_next_element+0x54>
c0d0a4e4:	f7fc facc 	bl	c0d06a80 <os_global_pin_is_validated>
    while (G_ux.stack[stack_slot].element_arrays[0].element_array
c0d0a4e8:	28aa      	cmp	r0, #170	; 0xaa
c0d0a4ea:	d117      	bne.n	c0d0a51c <ux_stack_al_display_next_element+0x84>
      const bagl_element_t* element = &G_ux.stack[stack_slot].element_arrays[0].element_array[G_ux.stack[stack_slot].element_index];
c0d0a4ec:	6828      	ldr	r0, [r5, #0]
c0d0a4ee:	8831      	ldrh	r1, [r6, #0]
c0d0a4f0:	0149      	lsls	r1, r1, #5
c0d0a4f2:	1840      	adds	r0, r0, r1
      if (!G_ux.stack[stack_slot].screen_before_element_display_callback || (element = G_ux.stack[stack_slot].screen_before_element_display_callback(element)) ) {
c0d0a4f4:	6839      	ldr	r1, [r7, #0]
c0d0a4f6:	2900      	cmp	r1, #0
c0d0a4f8:	d002      	beq.n	c0d0a500 <ux_stack_al_display_next_element+0x68>
c0d0a4fa:	4788      	blx	r1
c0d0a4fc:	2800      	cmp	r0, #0
c0d0a4fe:	d007      	beq.n	c0d0a510 <ux_stack_al_display_next_element+0x78>
        if ((unsigned int)element == 1) { /*backward compat with coding to avoid smashing everything*/
c0d0a500:	2801      	cmp	r0, #1
c0d0a502:	d103      	bne.n	c0d0a50c <ux_stack_al_display_next_element+0x74>
          element = &G_ux.stack[stack_slot].element_arrays[0].element_array[G_ux.stack[stack_slot].element_index];
c0d0a504:	6828      	ldr	r0, [r5, #0]
c0d0a506:	8831      	ldrh	r1, [r6, #0]
c0d0a508:	0149      	lsls	r1, r1, #5
c0d0a50a:	1840      	adds	r0, r0, r1
        io_seproxyhal_display(element);
c0d0a50c:	f7f9 fc10 	bl	c0d03d30 <io_seproxyhal_display>
      G_ux.stack[stack_slot].element_index++;
c0d0a510:	8830      	ldrh	r0, [r6, #0]
c0d0a512:	1c40      	adds	r0, r0, #1
c0d0a514:	8030      	strh	r0, [r6, #0]
    while (G_ux.stack[stack_slot].element_arrays[0].element_array
c0d0a516:	6829      	ldr	r1, [r5, #0]
      && G_ux.stack[stack_slot].element_index < G_ux.stack[stack_slot].element_arrays[0].element_array_count
c0d0a518:	2900      	cmp	r1, #0
c0d0a51a:	d1d7      	bne.n	c0d0a4cc <ux_stack_al_display_next_element+0x34>
}
c0d0a51c:	b001      	add	sp, #4
c0d0a51e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a520:	20001a00 	.word	0x20001a00

c0d0a524 <__udivsi3>:
c0d0a524:	2200      	movs	r2, #0
c0d0a526:	0843      	lsrs	r3, r0, #1
c0d0a528:	428b      	cmp	r3, r1
c0d0a52a:	d374      	bcc.n	c0d0a616 <__udivsi3+0xf2>
c0d0a52c:	0903      	lsrs	r3, r0, #4
c0d0a52e:	428b      	cmp	r3, r1
c0d0a530:	d35f      	bcc.n	c0d0a5f2 <__udivsi3+0xce>
c0d0a532:	0a03      	lsrs	r3, r0, #8
c0d0a534:	428b      	cmp	r3, r1
c0d0a536:	d344      	bcc.n	c0d0a5c2 <__udivsi3+0x9e>
c0d0a538:	0b03      	lsrs	r3, r0, #12
c0d0a53a:	428b      	cmp	r3, r1
c0d0a53c:	d328      	bcc.n	c0d0a590 <__udivsi3+0x6c>
c0d0a53e:	0c03      	lsrs	r3, r0, #16
c0d0a540:	428b      	cmp	r3, r1
c0d0a542:	d30d      	bcc.n	c0d0a560 <__udivsi3+0x3c>
c0d0a544:	22ff      	movs	r2, #255	; 0xff
c0d0a546:	0209      	lsls	r1, r1, #8
c0d0a548:	ba12      	rev	r2, r2
c0d0a54a:	0c03      	lsrs	r3, r0, #16
c0d0a54c:	428b      	cmp	r3, r1
c0d0a54e:	d302      	bcc.n	c0d0a556 <__udivsi3+0x32>
c0d0a550:	1212      	asrs	r2, r2, #8
c0d0a552:	0209      	lsls	r1, r1, #8
c0d0a554:	d065      	beq.n	c0d0a622 <__udivsi3+0xfe>
c0d0a556:	0b03      	lsrs	r3, r0, #12
c0d0a558:	428b      	cmp	r3, r1
c0d0a55a:	d319      	bcc.n	c0d0a590 <__udivsi3+0x6c>
c0d0a55c:	e000      	b.n	c0d0a560 <__udivsi3+0x3c>
c0d0a55e:	0a09      	lsrs	r1, r1, #8
c0d0a560:	0bc3      	lsrs	r3, r0, #15
c0d0a562:	428b      	cmp	r3, r1
c0d0a564:	d301      	bcc.n	c0d0a56a <__udivsi3+0x46>
c0d0a566:	03cb      	lsls	r3, r1, #15
c0d0a568:	1ac0      	subs	r0, r0, r3
c0d0a56a:	4152      	adcs	r2, r2
c0d0a56c:	0b83      	lsrs	r3, r0, #14
c0d0a56e:	428b      	cmp	r3, r1
c0d0a570:	d301      	bcc.n	c0d0a576 <__udivsi3+0x52>
c0d0a572:	038b      	lsls	r3, r1, #14
c0d0a574:	1ac0      	subs	r0, r0, r3
c0d0a576:	4152      	adcs	r2, r2
c0d0a578:	0b43      	lsrs	r3, r0, #13
c0d0a57a:	428b      	cmp	r3, r1
c0d0a57c:	d301      	bcc.n	c0d0a582 <__udivsi3+0x5e>
c0d0a57e:	034b      	lsls	r3, r1, #13
c0d0a580:	1ac0      	subs	r0, r0, r3
c0d0a582:	4152      	adcs	r2, r2
c0d0a584:	0b03      	lsrs	r3, r0, #12
c0d0a586:	428b      	cmp	r3, r1
c0d0a588:	d301      	bcc.n	c0d0a58e <__udivsi3+0x6a>
c0d0a58a:	030b      	lsls	r3, r1, #12
c0d0a58c:	1ac0      	subs	r0, r0, r3
c0d0a58e:	4152      	adcs	r2, r2
c0d0a590:	0ac3      	lsrs	r3, r0, #11
c0d0a592:	428b      	cmp	r3, r1
c0d0a594:	d301      	bcc.n	c0d0a59a <__udivsi3+0x76>
c0d0a596:	02cb      	lsls	r3, r1, #11
c0d0a598:	1ac0      	subs	r0, r0, r3
c0d0a59a:	4152      	adcs	r2, r2
c0d0a59c:	0a83      	lsrs	r3, r0, #10
c0d0a59e:	428b      	cmp	r3, r1
c0d0a5a0:	d301      	bcc.n	c0d0a5a6 <__udivsi3+0x82>
c0d0a5a2:	028b      	lsls	r3, r1, #10
c0d0a5a4:	1ac0      	subs	r0, r0, r3
c0d0a5a6:	4152      	adcs	r2, r2
c0d0a5a8:	0a43      	lsrs	r3, r0, #9
c0d0a5aa:	428b      	cmp	r3, r1
c0d0a5ac:	d301      	bcc.n	c0d0a5b2 <__udivsi3+0x8e>
c0d0a5ae:	024b      	lsls	r3, r1, #9
c0d0a5b0:	1ac0      	subs	r0, r0, r3
c0d0a5b2:	4152      	adcs	r2, r2
c0d0a5b4:	0a03      	lsrs	r3, r0, #8
c0d0a5b6:	428b      	cmp	r3, r1
c0d0a5b8:	d301      	bcc.n	c0d0a5be <__udivsi3+0x9a>
c0d0a5ba:	020b      	lsls	r3, r1, #8
c0d0a5bc:	1ac0      	subs	r0, r0, r3
c0d0a5be:	4152      	adcs	r2, r2
c0d0a5c0:	d2cd      	bcs.n	c0d0a55e <__udivsi3+0x3a>
c0d0a5c2:	09c3      	lsrs	r3, r0, #7
c0d0a5c4:	428b      	cmp	r3, r1
c0d0a5c6:	d301      	bcc.n	c0d0a5cc <__udivsi3+0xa8>
c0d0a5c8:	01cb      	lsls	r3, r1, #7
c0d0a5ca:	1ac0      	subs	r0, r0, r3
c0d0a5cc:	4152      	adcs	r2, r2
c0d0a5ce:	0983      	lsrs	r3, r0, #6
c0d0a5d0:	428b      	cmp	r3, r1
c0d0a5d2:	d301      	bcc.n	c0d0a5d8 <__udivsi3+0xb4>
c0d0a5d4:	018b      	lsls	r3, r1, #6
c0d0a5d6:	1ac0      	subs	r0, r0, r3
c0d0a5d8:	4152      	adcs	r2, r2
c0d0a5da:	0943      	lsrs	r3, r0, #5
c0d0a5dc:	428b      	cmp	r3, r1
c0d0a5de:	d301      	bcc.n	c0d0a5e4 <__udivsi3+0xc0>
c0d0a5e0:	014b      	lsls	r3, r1, #5
c0d0a5e2:	1ac0      	subs	r0, r0, r3
c0d0a5e4:	4152      	adcs	r2, r2
c0d0a5e6:	0903      	lsrs	r3, r0, #4
c0d0a5e8:	428b      	cmp	r3, r1
c0d0a5ea:	d301      	bcc.n	c0d0a5f0 <__udivsi3+0xcc>
c0d0a5ec:	010b      	lsls	r3, r1, #4
c0d0a5ee:	1ac0      	subs	r0, r0, r3
c0d0a5f0:	4152      	adcs	r2, r2
c0d0a5f2:	08c3      	lsrs	r3, r0, #3
c0d0a5f4:	428b      	cmp	r3, r1
c0d0a5f6:	d301      	bcc.n	c0d0a5fc <__udivsi3+0xd8>
c0d0a5f8:	00cb      	lsls	r3, r1, #3
c0d0a5fa:	1ac0      	subs	r0, r0, r3
c0d0a5fc:	4152      	adcs	r2, r2
c0d0a5fe:	0883      	lsrs	r3, r0, #2
c0d0a600:	428b      	cmp	r3, r1
c0d0a602:	d301      	bcc.n	c0d0a608 <__udivsi3+0xe4>
c0d0a604:	008b      	lsls	r3, r1, #2
c0d0a606:	1ac0      	subs	r0, r0, r3
c0d0a608:	4152      	adcs	r2, r2
c0d0a60a:	0843      	lsrs	r3, r0, #1
c0d0a60c:	428b      	cmp	r3, r1
c0d0a60e:	d301      	bcc.n	c0d0a614 <__udivsi3+0xf0>
c0d0a610:	004b      	lsls	r3, r1, #1
c0d0a612:	1ac0      	subs	r0, r0, r3
c0d0a614:	4152      	adcs	r2, r2
c0d0a616:	1a41      	subs	r1, r0, r1
c0d0a618:	d200      	bcs.n	c0d0a61c <__udivsi3+0xf8>
c0d0a61a:	4601      	mov	r1, r0
c0d0a61c:	4152      	adcs	r2, r2
c0d0a61e:	4610      	mov	r0, r2
c0d0a620:	4770      	bx	lr
c0d0a622:	e7ff      	b.n	c0d0a624 <__udivsi3+0x100>
c0d0a624:	b501      	push	{r0, lr}
c0d0a626:	2000      	movs	r0, #0
c0d0a628:	f000 f806 	bl	c0d0a638 <__aeabi_idiv0>
c0d0a62c:	bd02      	pop	{r1, pc}
c0d0a62e:	46c0      	nop			; (mov r8, r8)

c0d0a630 <__aeabi_uidivmod>:
c0d0a630:	2900      	cmp	r1, #0
c0d0a632:	d0f7      	beq.n	c0d0a624 <__udivsi3+0x100>
c0d0a634:	e776      	b.n	c0d0a524 <__udivsi3>
c0d0a636:	4770      	bx	lr

c0d0a638 <__aeabi_idiv0>:
c0d0a638:	4770      	bx	lr
c0d0a63a:	46c0      	nop			; (mov r8, r8)

c0d0a63c <__aeabi_llsr>:
c0d0a63c:	40d0      	lsrs	r0, r2
c0d0a63e:	000b      	movs	r3, r1
c0d0a640:	40d1      	lsrs	r1, r2
c0d0a642:	469c      	mov	ip, r3
c0d0a644:	3a20      	subs	r2, #32
c0d0a646:	40d3      	lsrs	r3, r2
c0d0a648:	4318      	orrs	r0, r3
c0d0a64a:	4252      	negs	r2, r2
c0d0a64c:	4663      	mov	r3, ip
c0d0a64e:	4093      	lsls	r3, r2
c0d0a650:	4318      	orrs	r0, r3
c0d0a652:	4770      	bx	lr

c0d0a654 <__aeabi_llsl>:
c0d0a654:	4091      	lsls	r1, r2
c0d0a656:	0003      	movs	r3, r0
c0d0a658:	4090      	lsls	r0, r2
c0d0a65a:	469c      	mov	ip, r3
c0d0a65c:	3a20      	subs	r2, #32
c0d0a65e:	4093      	lsls	r3, r2
c0d0a660:	4319      	orrs	r1, r3
c0d0a662:	4252      	negs	r2, r2
c0d0a664:	4663      	mov	r3, ip
c0d0a666:	40d3      	lsrs	r3, r2
c0d0a668:	4319      	orrs	r1, r3
c0d0a66a:	4770      	bx	lr

c0d0a66c <__aeabi_memclr>:
c0d0a66c:	b510      	push	{r4, lr}
c0d0a66e:	2200      	movs	r2, #0
c0d0a670:	f000 f80a 	bl	c0d0a688 <__aeabi_memset>
c0d0a674:	bd10      	pop	{r4, pc}
c0d0a676:	46c0      	nop			; (mov r8, r8)

c0d0a678 <__aeabi_memcpy>:
c0d0a678:	b510      	push	{r4, lr}
c0d0a67a:	f000 f835 	bl	c0d0a6e8 <memcpy>
c0d0a67e:	bd10      	pop	{r4, pc}

c0d0a680 <__aeabi_memmove>:
c0d0a680:	b510      	push	{r4, lr}
c0d0a682:	f000 f883 	bl	c0d0a78c <memmove>
c0d0a686:	bd10      	pop	{r4, pc}

c0d0a688 <__aeabi_memset>:
c0d0a688:	000b      	movs	r3, r1
c0d0a68a:	b510      	push	{r4, lr}
c0d0a68c:	0011      	movs	r1, r2
c0d0a68e:	001a      	movs	r2, r3
c0d0a690:	f000 f8d2 	bl	c0d0a838 <memset>
c0d0a694:	bd10      	pop	{r4, pc}
c0d0a696:	46c0      	nop			; (mov r8, r8)

c0d0a698 <explicit_bzero>:
c0d0a698:	b510      	push	{r4, lr}
c0d0a69a:	f000 fa5d 	bl	c0d0ab58 <bzero>
c0d0a69e:	bd10      	pop	{r4, pc}

c0d0a6a0 <memcmp>:
c0d0a6a0:	b530      	push	{r4, r5, lr}
c0d0a6a2:	2a03      	cmp	r2, #3
c0d0a6a4:	d90c      	bls.n	c0d0a6c0 <memcmp+0x20>
c0d0a6a6:	0003      	movs	r3, r0
c0d0a6a8:	430b      	orrs	r3, r1
c0d0a6aa:	079b      	lsls	r3, r3, #30
c0d0a6ac:	d119      	bne.n	c0d0a6e2 <memcmp+0x42>
c0d0a6ae:	6803      	ldr	r3, [r0, #0]
c0d0a6b0:	680c      	ldr	r4, [r1, #0]
c0d0a6b2:	42a3      	cmp	r3, r4
c0d0a6b4:	d115      	bne.n	c0d0a6e2 <memcmp+0x42>
c0d0a6b6:	3a04      	subs	r2, #4
c0d0a6b8:	3004      	adds	r0, #4
c0d0a6ba:	3104      	adds	r1, #4
c0d0a6bc:	2a03      	cmp	r2, #3
c0d0a6be:	d8f6      	bhi.n	c0d0a6ae <memcmp+0xe>
c0d0a6c0:	1e55      	subs	r5, r2, #1
c0d0a6c2:	2a00      	cmp	r2, #0
c0d0a6c4:	d00b      	beq.n	c0d0a6de <memcmp+0x3e>
c0d0a6c6:	2300      	movs	r3, #0
c0d0a6c8:	e003      	b.n	c0d0a6d2 <memcmp+0x32>
c0d0a6ca:	1c5a      	adds	r2, r3, #1
c0d0a6cc:	429d      	cmp	r5, r3
c0d0a6ce:	d006      	beq.n	c0d0a6de <memcmp+0x3e>
c0d0a6d0:	0013      	movs	r3, r2
c0d0a6d2:	5cc2      	ldrb	r2, [r0, r3]
c0d0a6d4:	5ccc      	ldrb	r4, [r1, r3]
c0d0a6d6:	42a2      	cmp	r2, r4
c0d0a6d8:	d0f7      	beq.n	c0d0a6ca <memcmp+0x2a>
c0d0a6da:	1b10      	subs	r0, r2, r4
c0d0a6dc:	e000      	b.n	c0d0a6e0 <memcmp+0x40>
c0d0a6de:	2000      	movs	r0, #0
c0d0a6e0:	bd30      	pop	{r4, r5, pc}
c0d0a6e2:	1e55      	subs	r5, r2, #1
c0d0a6e4:	e7ef      	b.n	c0d0a6c6 <memcmp+0x26>
c0d0a6e6:	46c0      	nop			; (mov r8, r8)

c0d0a6e8 <memcpy>:
c0d0a6e8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0a6ea:	46c6      	mov	lr, r8
c0d0a6ec:	b500      	push	{lr}
c0d0a6ee:	2a0f      	cmp	r2, #15
c0d0a6f0:	d941      	bls.n	c0d0a776 <memcpy+0x8e>
c0d0a6f2:	2703      	movs	r7, #3
c0d0a6f4:	000d      	movs	r5, r1
c0d0a6f6:	003e      	movs	r6, r7
c0d0a6f8:	4305      	orrs	r5, r0
c0d0a6fa:	000c      	movs	r4, r1
c0d0a6fc:	0003      	movs	r3, r0
c0d0a6fe:	402e      	ands	r6, r5
c0d0a700:	422f      	tst	r7, r5
c0d0a702:	d13d      	bne.n	c0d0a780 <memcpy+0x98>
c0d0a704:	0015      	movs	r5, r2
c0d0a706:	3d10      	subs	r5, #16
c0d0a708:	092d      	lsrs	r5, r5, #4
c0d0a70a:	46a8      	mov	r8, r5
c0d0a70c:	012d      	lsls	r5, r5, #4
c0d0a70e:	46ac      	mov	ip, r5
c0d0a710:	4484      	add	ip, r0
c0d0a712:	6827      	ldr	r7, [r4, #0]
c0d0a714:	001d      	movs	r5, r3
c0d0a716:	601f      	str	r7, [r3, #0]
c0d0a718:	6867      	ldr	r7, [r4, #4]
c0d0a71a:	605f      	str	r7, [r3, #4]
c0d0a71c:	68a7      	ldr	r7, [r4, #8]
c0d0a71e:	609f      	str	r7, [r3, #8]
c0d0a720:	68e7      	ldr	r7, [r4, #12]
c0d0a722:	3410      	adds	r4, #16
c0d0a724:	60df      	str	r7, [r3, #12]
c0d0a726:	3310      	adds	r3, #16
c0d0a728:	4565      	cmp	r5, ip
c0d0a72a:	d1f2      	bne.n	c0d0a712 <memcpy+0x2a>
c0d0a72c:	4645      	mov	r5, r8
c0d0a72e:	230f      	movs	r3, #15
c0d0a730:	240c      	movs	r4, #12
c0d0a732:	3501      	adds	r5, #1
c0d0a734:	012d      	lsls	r5, r5, #4
c0d0a736:	1949      	adds	r1, r1, r5
c0d0a738:	4013      	ands	r3, r2
c0d0a73a:	1945      	adds	r5, r0, r5
c0d0a73c:	4214      	tst	r4, r2
c0d0a73e:	d022      	beq.n	c0d0a786 <memcpy+0x9e>
c0d0a740:	598c      	ldr	r4, [r1, r6]
c0d0a742:	51ac      	str	r4, [r5, r6]
c0d0a744:	3604      	adds	r6, #4
c0d0a746:	1b9c      	subs	r4, r3, r6
c0d0a748:	2c03      	cmp	r4, #3
c0d0a74a:	d8f9      	bhi.n	c0d0a740 <memcpy+0x58>
c0d0a74c:	3b04      	subs	r3, #4
c0d0a74e:	089b      	lsrs	r3, r3, #2
c0d0a750:	3301      	adds	r3, #1
c0d0a752:	009b      	lsls	r3, r3, #2
c0d0a754:	18ed      	adds	r5, r5, r3
c0d0a756:	18c9      	adds	r1, r1, r3
c0d0a758:	2303      	movs	r3, #3
c0d0a75a:	401a      	ands	r2, r3
c0d0a75c:	1e56      	subs	r6, r2, #1
c0d0a75e:	2a00      	cmp	r2, #0
c0d0a760:	d006      	beq.n	c0d0a770 <memcpy+0x88>
c0d0a762:	2300      	movs	r3, #0
c0d0a764:	5ccc      	ldrb	r4, [r1, r3]
c0d0a766:	001a      	movs	r2, r3
c0d0a768:	54ec      	strb	r4, [r5, r3]
c0d0a76a:	3301      	adds	r3, #1
c0d0a76c:	4296      	cmp	r6, r2
c0d0a76e:	d1f9      	bne.n	c0d0a764 <memcpy+0x7c>
c0d0a770:	bc80      	pop	{r7}
c0d0a772:	46b8      	mov	r8, r7
c0d0a774:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a776:	0005      	movs	r5, r0
c0d0a778:	1e56      	subs	r6, r2, #1
c0d0a77a:	2a00      	cmp	r2, #0
c0d0a77c:	d1f1      	bne.n	c0d0a762 <memcpy+0x7a>
c0d0a77e:	e7f7      	b.n	c0d0a770 <memcpy+0x88>
c0d0a780:	0005      	movs	r5, r0
c0d0a782:	1e56      	subs	r6, r2, #1
c0d0a784:	e7ed      	b.n	c0d0a762 <memcpy+0x7a>
c0d0a786:	001a      	movs	r2, r3
c0d0a788:	e7f6      	b.n	c0d0a778 <memcpy+0x90>
c0d0a78a:	46c0      	nop			; (mov r8, r8)

c0d0a78c <memmove>:
c0d0a78c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0a78e:	4288      	cmp	r0, r1
c0d0a790:	d90a      	bls.n	c0d0a7a8 <memmove+0x1c>
c0d0a792:	188b      	adds	r3, r1, r2
c0d0a794:	4298      	cmp	r0, r3
c0d0a796:	d207      	bcs.n	c0d0a7a8 <memmove+0x1c>
c0d0a798:	1e53      	subs	r3, r2, #1
c0d0a79a:	2a00      	cmp	r2, #0
c0d0a79c:	d003      	beq.n	c0d0a7a6 <memmove+0x1a>
c0d0a79e:	5cca      	ldrb	r2, [r1, r3]
c0d0a7a0:	54c2      	strb	r2, [r0, r3]
c0d0a7a2:	3b01      	subs	r3, #1
c0d0a7a4:	d2fb      	bcs.n	c0d0a79e <memmove+0x12>
c0d0a7a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a7a8:	2a0f      	cmp	r2, #15
c0d0a7aa:	d80b      	bhi.n	c0d0a7c4 <memmove+0x38>
c0d0a7ac:	0005      	movs	r5, r0
c0d0a7ae:	1e56      	subs	r6, r2, #1
c0d0a7b0:	2a00      	cmp	r2, #0
c0d0a7b2:	d0f8      	beq.n	c0d0a7a6 <memmove+0x1a>
c0d0a7b4:	2300      	movs	r3, #0
c0d0a7b6:	5ccc      	ldrb	r4, [r1, r3]
c0d0a7b8:	001a      	movs	r2, r3
c0d0a7ba:	54ec      	strb	r4, [r5, r3]
c0d0a7bc:	3301      	adds	r3, #1
c0d0a7be:	4296      	cmp	r6, r2
c0d0a7c0:	d1f9      	bne.n	c0d0a7b6 <memmove+0x2a>
c0d0a7c2:	e7f0      	b.n	c0d0a7a6 <memmove+0x1a>
c0d0a7c4:	2703      	movs	r7, #3
c0d0a7c6:	000d      	movs	r5, r1
c0d0a7c8:	003e      	movs	r6, r7
c0d0a7ca:	4305      	orrs	r5, r0
c0d0a7cc:	000c      	movs	r4, r1
c0d0a7ce:	0003      	movs	r3, r0
c0d0a7d0:	402e      	ands	r6, r5
c0d0a7d2:	422f      	tst	r7, r5
c0d0a7d4:	d12b      	bne.n	c0d0a82e <memmove+0xa2>
c0d0a7d6:	0015      	movs	r5, r2
c0d0a7d8:	3d10      	subs	r5, #16
c0d0a7da:	092d      	lsrs	r5, r5, #4
c0d0a7dc:	46ac      	mov	ip, r5
c0d0a7de:	012f      	lsls	r7, r5, #4
c0d0a7e0:	183f      	adds	r7, r7, r0
c0d0a7e2:	6825      	ldr	r5, [r4, #0]
c0d0a7e4:	601d      	str	r5, [r3, #0]
c0d0a7e6:	6865      	ldr	r5, [r4, #4]
c0d0a7e8:	605d      	str	r5, [r3, #4]
c0d0a7ea:	68a5      	ldr	r5, [r4, #8]
c0d0a7ec:	609d      	str	r5, [r3, #8]
c0d0a7ee:	68e5      	ldr	r5, [r4, #12]
c0d0a7f0:	3410      	adds	r4, #16
c0d0a7f2:	60dd      	str	r5, [r3, #12]
c0d0a7f4:	001d      	movs	r5, r3
c0d0a7f6:	3310      	adds	r3, #16
c0d0a7f8:	42bd      	cmp	r5, r7
c0d0a7fa:	d1f2      	bne.n	c0d0a7e2 <memmove+0x56>
c0d0a7fc:	4665      	mov	r5, ip
c0d0a7fe:	230f      	movs	r3, #15
c0d0a800:	240c      	movs	r4, #12
c0d0a802:	3501      	adds	r5, #1
c0d0a804:	012d      	lsls	r5, r5, #4
c0d0a806:	1949      	adds	r1, r1, r5
c0d0a808:	4013      	ands	r3, r2
c0d0a80a:	1945      	adds	r5, r0, r5
c0d0a80c:	4214      	tst	r4, r2
c0d0a80e:	d011      	beq.n	c0d0a834 <memmove+0xa8>
c0d0a810:	598c      	ldr	r4, [r1, r6]
c0d0a812:	51ac      	str	r4, [r5, r6]
c0d0a814:	3604      	adds	r6, #4
c0d0a816:	1b9c      	subs	r4, r3, r6
c0d0a818:	2c03      	cmp	r4, #3
c0d0a81a:	d8f9      	bhi.n	c0d0a810 <memmove+0x84>
c0d0a81c:	3b04      	subs	r3, #4
c0d0a81e:	089b      	lsrs	r3, r3, #2
c0d0a820:	3301      	adds	r3, #1
c0d0a822:	009b      	lsls	r3, r3, #2
c0d0a824:	18ed      	adds	r5, r5, r3
c0d0a826:	18c9      	adds	r1, r1, r3
c0d0a828:	2303      	movs	r3, #3
c0d0a82a:	401a      	ands	r2, r3
c0d0a82c:	e7bf      	b.n	c0d0a7ae <memmove+0x22>
c0d0a82e:	0005      	movs	r5, r0
c0d0a830:	1e56      	subs	r6, r2, #1
c0d0a832:	e7bf      	b.n	c0d0a7b4 <memmove+0x28>
c0d0a834:	001a      	movs	r2, r3
c0d0a836:	e7ba      	b.n	c0d0a7ae <memmove+0x22>

c0d0a838 <memset>:
c0d0a838:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0a83a:	0005      	movs	r5, r0
c0d0a83c:	0783      	lsls	r3, r0, #30
c0d0a83e:	d049      	beq.n	c0d0a8d4 <memset+0x9c>
c0d0a840:	1e54      	subs	r4, r2, #1
c0d0a842:	2a00      	cmp	r2, #0
c0d0a844:	d045      	beq.n	c0d0a8d2 <memset+0x9a>
c0d0a846:	0003      	movs	r3, r0
c0d0a848:	2603      	movs	r6, #3
c0d0a84a:	b2ca      	uxtb	r2, r1
c0d0a84c:	e002      	b.n	c0d0a854 <memset+0x1c>
c0d0a84e:	3501      	adds	r5, #1
c0d0a850:	3c01      	subs	r4, #1
c0d0a852:	d33e      	bcc.n	c0d0a8d2 <memset+0x9a>
c0d0a854:	3301      	adds	r3, #1
c0d0a856:	702a      	strb	r2, [r5, #0]
c0d0a858:	4233      	tst	r3, r6
c0d0a85a:	d1f8      	bne.n	c0d0a84e <memset+0x16>
c0d0a85c:	2c03      	cmp	r4, #3
c0d0a85e:	d930      	bls.n	c0d0a8c2 <memset+0x8a>
c0d0a860:	22ff      	movs	r2, #255	; 0xff
c0d0a862:	400a      	ands	r2, r1
c0d0a864:	0215      	lsls	r5, r2, #8
c0d0a866:	4315      	orrs	r5, r2
c0d0a868:	042a      	lsls	r2, r5, #16
c0d0a86a:	4315      	orrs	r5, r2
c0d0a86c:	2c0f      	cmp	r4, #15
c0d0a86e:	d934      	bls.n	c0d0a8da <memset+0xa2>
c0d0a870:	0027      	movs	r7, r4
c0d0a872:	3f10      	subs	r7, #16
c0d0a874:	093f      	lsrs	r7, r7, #4
c0d0a876:	013e      	lsls	r6, r7, #4
c0d0a878:	46b4      	mov	ip, r6
c0d0a87a:	001e      	movs	r6, r3
c0d0a87c:	001a      	movs	r2, r3
c0d0a87e:	3610      	adds	r6, #16
c0d0a880:	4466      	add	r6, ip
c0d0a882:	6015      	str	r5, [r2, #0]
c0d0a884:	6055      	str	r5, [r2, #4]
c0d0a886:	6095      	str	r5, [r2, #8]
c0d0a888:	60d5      	str	r5, [r2, #12]
c0d0a88a:	3210      	adds	r2, #16
c0d0a88c:	42b2      	cmp	r2, r6
c0d0a88e:	d1f8      	bne.n	c0d0a882 <memset+0x4a>
c0d0a890:	3701      	adds	r7, #1
c0d0a892:	013f      	lsls	r7, r7, #4
c0d0a894:	19db      	adds	r3, r3, r7
c0d0a896:	270f      	movs	r7, #15
c0d0a898:	220c      	movs	r2, #12
c0d0a89a:	4027      	ands	r7, r4
c0d0a89c:	4022      	ands	r2, r4
c0d0a89e:	003c      	movs	r4, r7
c0d0a8a0:	2a00      	cmp	r2, #0
c0d0a8a2:	d00e      	beq.n	c0d0a8c2 <memset+0x8a>
c0d0a8a4:	1f3e      	subs	r6, r7, #4
c0d0a8a6:	08b6      	lsrs	r6, r6, #2
c0d0a8a8:	00b4      	lsls	r4, r6, #2
c0d0a8aa:	46a4      	mov	ip, r4
c0d0a8ac:	001a      	movs	r2, r3
c0d0a8ae:	1d1c      	adds	r4, r3, #4
c0d0a8b0:	4464      	add	r4, ip
c0d0a8b2:	c220      	stmia	r2!, {r5}
c0d0a8b4:	42a2      	cmp	r2, r4
c0d0a8b6:	d1fc      	bne.n	c0d0a8b2 <memset+0x7a>
c0d0a8b8:	2403      	movs	r4, #3
c0d0a8ba:	3601      	adds	r6, #1
c0d0a8bc:	00b6      	lsls	r6, r6, #2
c0d0a8be:	199b      	adds	r3, r3, r6
c0d0a8c0:	403c      	ands	r4, r7
c0d0a8c2:	2c00      	cmp	r4, #0
c0d0a8c4:	d005      	beq.n	c0d0a8d2 <memset+0x9a>
c0d0a8c6:	b2c9      	uxtb	r1, r1
c0d0a8c8:	191c      	adds	r4, r3, r4
c0d0a8ca:	7019      	strb	r1, [r3, #0]
c0d0a8cc:	3301      	adds	r3, #1
c0d0a8ce:	429c      	cmp	r4, r3
c0d0a8d0:	d1fb      	bne.n	c0d0a8ca <memset+0x92>
c0d0a8d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0a8d4:	0003      	movs	r3, r0
c0d0a8d6:	0014      	movs	r4, r2
c0d0a8d8:	e7c0      	b.n	c0d0a85c <memset+0x24>
c0d0a8da:	0027      	movs	r7, r4
c0d0a8dc:	e7e2      	b.n	c0d0a8a4 <memset+0x6c>
c0d0a8de:	46c0      	nop			; (mov r8, r8)

c0d0a8e0 <setjmp>:
c0d0a8e0:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
c0d0a8e2:	4641      	mov	r1, r8
c0d0a8e4:	464a      	mov	r2, r9
c0d0a8e6:	4653      	mov	r3, sl
c0d0a8e8:	465c      	mov	r4, fp
c0d0a8ea:	466d      	mov	r5, sp
c0d0a8ec:	4676      	mov	r6, lr
c0d0a8ee:	c07e      	stmia	r0!, {r1, r2, r3, r4, r5, r6}
c0d0a8f0:	3828      	subs	r0, #40	; 0x28
c0d0a8f2:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
c0d0a8f4:	2000      	movs	r0, #0
c0d0a8f6:	4770      	bx	lr

c0d0a8f8 <longjmp>:
c0d0a8f8:	3010      	adds	r0, #16
c0d0a8fa:	c87c      	ldmia	r0!, {r2, r3, r4, r5, r6}
c0d0a8fc:	4690      	mov	r8, r2
c0d0a8fe:	4699      	mov	r9, r3
c0d0a900:	46a2      	mov	sl, r4
c0d0a902:	46ab      	mov	fp, r5
c0d0a904:	46b5      	mov	sp, r6
c0d0a906:	c808      	ldmia	r0!, {r3}
c0d0a908:	3828      	subs	r0, #40	; 0x28
c0d0a90a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
c0d0a90c:	1c08      	adds	r0, r1, #0
c0d0a90e:	d100      	bne.n	c0d0a912 <longjmp+0x1a>
c0d0a910:	2001      	movs	r0, #1
c0d0a912:	4718      	bx	r3

c0d0a914 <strcat>:
c0d0a914:	b570      	push	{r4, r5, r6, lr}
c0d0a916:	0004      	movs	r4, r0
c0d0a918:	0783      	lsls	r3, r0, #30
c0d0a91a:	d116      	bne.n	c0d0a94a <strcat+0x36>
c0d0a91c:	6802      	ldr	r2, [r0, #0]
c0d0a91e:	4b0e      	ldr	r3, [pc, #56]	; (c0d0a958 <strcat+0x44>)
c0d0a920:	4d0e      	ldr	r5, [pc, #56]	; (c0d0a95c <strcat+0x48>)
c0d0a922:	18d3      	adds	r3, r2, r3
c0d0a924:	4393      	bics	r3, r2
c0d0a926:	422b      	tst	r3, r5
c0d0a928:	d10f      	bne.n	c0d0a94a <strcat+0x36>
c0d0a92a:	6842      	ldr	r2, [r0, #4]
c0d0a92c:	4b0a      	ldr	r3, [pc, #40]	; (c0d0a958 <strcat+0x44>)
c0d0a92e:	3004      	adds	r0, #4
c0d0a930:	18d3      	adds	r3, r2, r3
c0d0a932:	4393      	bics	r3, r2
c0d0a934:	422b      	tst	r3, r5
c0d0a936:	d108      	bne.n	c0d0a94a <strcat+0x36>
c0d0a938:	6842      	ldr	r2, [r0, #4]
c0d0a93a:	4b07      	ldr	r3, [pc, #28]	; (c0d0a958 <strcat+0x44>)
c0d0a93c:	3004      	adds	r0, #4
c0d0a93e:	18d3      	adds	r3, r2, r3
c0d0a940:	4393      	bics	r3, r2
c0d0a942:	422b      	tst	r3, r5
c0d0a944:	d0f1      	beq.n	c0d0a92a <strcat+0x16>
c0d0a946:	e000      	b.n	c0d0a94a <strcat+0x36>
c0d0a948:	3001      	adds	r0, #1
c0d0a94a:	7803      	ldrb	r3, [r0, #0]
c0d0a94c:	2b00      	cmp	r3, #0
c0d0a94e:	d1fb      	bne.n	c0d0a948 <strcat+0x34>
c0d0a950:	f000 f84a 	bl	c0d0a9e8 <strcpy>
c0d0a954:	0020      	movs	r0, r4
c0d0a956:	bd70      	pop	{r4, r5, r6, pc}
c0d0a958:	fefefeff 	.word	0xfefefeff
c0d0a95c:	80808080 	.word	0x80808080

c0d0a960 <strcmp>:
c0d0a960:	4602      	mov	r2, r0
c0d0a962:	b570      	push	{r4, r5, r6, lr}
c0d0a964:	430a      	orrs	r2, r1
c0d0a966:	0792      	lsls	r2, r2, #30
c0d0a968:	d12a      	bne.n	c0d0a9c0 <strcmp+0x60>
c0d0a96a:	4d1e      	ldr	r5, [pc, #120]	; (c0d0a9e4 <strcmp+0x84>)
c0d0a96c:	01ee      	lsls	r6, r5, #7
c0d0a96e:	c804      	ldmia	r0!, {r2}
c0d0a970:	c908      	ldmia	r1!, {r3}
c0d0a972:	1b54      	subs	r4, r2, r5
c0d0a974:	4394      	bics	r4, r2
c0d0a976:	4034      	ands	r4, r6
c0d0a978:	d017      	beq.n	c0d0a9aa <strcmp+0x4a>
c0d0a97a:	b2d0      	uxtb	r0, r2
c0d0a97c:	b2d9      	uxtb	r1, r3
c0d0a97e:	1a40      	subs	r0, r0, r1
c0d0a980:	0621      	lsls	r1, r4, #24
c0d0a982:	4301      	orrs	r1, r0
c0d0a984:	d110      	bne.n	c0d0a9a8 <strcmp+0x48>
c0d0a986:	b290      	uxth	r0, r2
c0d0a988:	b299      	uxth	r1, r3
c0d0a98a:	1a40      	subs	r0, r0, r1
c0d0a98c:	0421      	lsls	r1, r4, #16
c0d0a98e:	4301      	orrs	r1, r0
c0d0a990:	d10a      	bne.n	c0d0a9a8 <strcmp+0x48>
c0d0a992:	0210      	lsls	r0, r2, #8
c0d0a994:	0219      	lsls	r1, r3, #8
c0d0a996:	0a00      	lsrs	r0, r0, #8
c0d0a998:	0a09      	lsrs	r1, r1, #8
c0d0a99a:	1a40      	subs	r0, r0, r1
c0d0a99c:	0221      	lsls	r1, r4, #8
c0d0a99e:	4301      	orrs	r1, r0
c0d0a9a0:	d102      	bne.n	c0d0a9a8 <strcmp+0x48>
c0d0a9a2:	0e10      	lsrs	r0, r2, #24
c0d0a9a4:	0e19      	lsrs	r1, r3, #24
c0d0a9a6:	1a40      	subs	r0, r0, r1
c0d0a9a8:	bd70      	pop	{r4, r5, r6, pc}
c0d0a9aa:	429a      	cmp	r2, r3
c0d0a9ac:	d0df      	beq.n	c0d0a96e <strcmp+0xe>
c0d0a9ae:	ba10      	rev	r0, r2
c0d0a9b0:	ba19      	rev	r1, r3
c0d0a9b2:	4288      	cmp	r0, r1
c0d0a9b4:	d901      	bls.n	c0d0a9ba <strcmp+0x5a>
c0d0a9b6:	2001      	movs	r0, #1
c0d0a9b8:	bd70      	pop	{r4, r5, r6, pc}
c0d0a9ba:	2000      	movs	r0, #0
c0d0a9bc:	43c0      	mvns	r0, r0
c0d0a9be:	bd70      	pop	{r4, r5, r6, pc}
c0d0a9c0:	7802      	ldrb	r2, [r0, #0]
c0d0a9c2:	780b      	ldrb	r3, [r1, #0]
c0d0a9c4:	3001      	adds	r0, #1
c0d0a9c6:	3101      	adds	r1, #1
c0d0a9c8:	2a00      	cmp	r2, #0
c0d0a9ca:	d009      	beq.n	c0d0a9e0 <strcmp+0x80>
c0d0a9cc:	429a      	cmp	r2, r3
c0d0a9ce:	d107      	bne.n	c0d0a9e0 <strcmp+0x80>
c0d0a9d0:	7802      	ldrb	r2, [r0, #0]
c0d0a9d2:	780b      	ldrb	r3, [r1, #0]
c0d0a9d4:	3001      	adds	r0, #1
c0d0a9d6:	3101      	adds	r1, #1
c0d0a9d8:	2a00      	cmp	r2, #0
c0d0a9da:	d001      	beq.n	c0d0a9e0 <strcmp+0x80>
c0d0a9dc:	429a      	cmp	r2, r3
c0d0a9de:	d0ef      	beq.n	c0d0a9c0 <strcmp+0x60>
c0d0a9e0:	1ad0      	subs	r0, r2, r3
c0d0a9e2:	bd70      	pop	{r4, r5, r6, pc}
c0d0a9e4:	01010101 	.word	0x01010101

c0d0a9e8 <strcpy>:
c0d0a9e8:	0003      	movs	r3, r0
c0d0a9ea:	780a      	ldrb	r2, [r1, #0]
c0d0a9ec:	3101      	adds	r1, #1
c0d0a9ee:	701a      	strb	r2, [r3, #0]
c0d0a9f0:	3301      	adds	r3, #1
c0d0a9f2:	2a00      	cmp	r2, #0
c0d0a9f4:	d1f9      	bne.n	c0d0a9ea <strcpy+0x2>
c0d0a9f6:	4770      	bx	lr

c0d0a9f8 <strlen>:
c0d0a9f8:	b510      	push	{r4, lr}
c0d0a9fa:	0783      	lsls	r3, r0, #30
c0d0a9fc:	d00a      	beq.n	c0d0aa14 <strlen+0x1c>
c0d0a9fe:	0003      	movs	r3, r0
c0d0aa00:	2103      	movs	r1, #3
c0d0aa02:	e002      	b.n	c0d0aa0a <strlen+0x12>
c0d0aa04:	3301      	adds	r3, #1
c0d0aa06:	420b      	tst	r3, r1
c0d0aa08:	d005      	beq.n	c0d0aa16 <strlen+0x1e>
c0d0aa0a:	781a      	ldrb	r2, [r3, #0]
c0d0aa0c:	2a00      	cmp	r2, #0
c0d0aa0e:	d1f9      	bne.n	c0d0aa04 <strlen+0xc>
c0d0aa10:	1a18      	subs	r0, r3, r0
c0d0aa12:	bd10      	pop	{r4, pc}
c0d0aa14:	0003      	movs	r3, r0
c0d0aa16:	6819      	ldr	r1, [r3, #0]
c0d0aa18:	4a0c      	ldr	r2, [pc, #48]	; (c0d0aa4c <strlen+0x54>)
c0d0aa1a:	4c0d      	ldr	r4, [pc, #52]	; (c0d0aa50 <strlen+0x58>)
c0d0aa1c:	188a      	adds	r2, r1, r2
c0d0aa1e:	438a      	bics	r2, r1
c0d0aa20:	4222      	tst	r2, r4
c0d0aa22:	d10f      	bne.n	c0d0aa44 <strlen+0x4c>
c0d0aa24:	6859      	ldr	r1, [r3, #4]
c0d0aa26:	4a09      	ldr	r2, [pc, #36]	; (c0d0aa4c <strlen+0x54>)
c0d0aa28:	3304      	adds	r3, #4
c0d0aa2a:	188a      	adds	r2, r1, r2
c0d0aa2c:	438a      	bics	r2, r1
c0d0aa2e:	4222      	tst	r2, r4
c0d0aa30:	d108      	bne.n	c0d0aa44 <strlen+0x4c>
c0d0aa32:	6859      	ldr	r1, [r3, #4]
c0d0aa34:	4a05      	ldr	r2, [pc, #20]	; (c0d0aa4c <strlen+0x54>)
c0d0aa36:	3304      	adds	r3, #4
c0d0aa38:	188a      	adds	r2, r1, r2
c0d0aa3a:	438a      	bics	r2, r1
c0d0aa3c:	4222      	tst	r2, r4
c0d0aa3e:	d0f1      	beq.n	c0d0aa24 <strlen+0x2c>
c0d0aa40:	e000      	b.n	c0d0aa44 <strlen+0x4c>
c0d0aa42:	3301      	adds	r3, #1
c0d0aa44:	781a      	ldrb	r2, [r3, #0]
c0d0aa46:	2a00      	cmp	r2, #0
c0d0aa48:	d1fb      	bne.n	c0d0aa42 <strlen+0x4a>
c0d0aa4a:	e7e1      	b.n	c0d0aa10 <strlen+0x18>
c0d0aa4c:	fefefeff 	.word	0xfefefeff
c0d0aa50:	80808080 	.word	0x80808080

c0d0aa54 <strncmp>:
c0d0aa54:	b530      	push	{r4, r5, lr}
c0d0aa56:	2a00      	cmp	r2, #0
c0d0aa58:	d026      	beq.n	c0d0aaa8 <strncmp+0x54>
c0d0aa5a:	0003      	movs	r3, r0
c0d0aa5c:	430b      	orrs	r3, r1
c0d0aa5e:	079b      	lsls	r3, r3, #30
c0d0aa60:	d124      	bne.n	c0d0aaac <strncmp+0x58>
c0d0aa62:	2a03      	cmp	r2, #3
c0d0aa64:	d922      	bls.n	c0d0aaac <strncmp+0x58>
c0d0aa66:	4d16      	ldr	r5, [pc, #88]	; (c0d0aac0 <strncmp+0x6c>)
c0d0aa68:	e00b      	b.n	c0d0aa82 <strncmp+0x2e>
c0d0aa6a:	3a04      	subs	r2, #4
c0d0aa6c:	2a00      	cmp	r2, #0
c0d0aa6e:	d01b      	beq.n	c0d0aaa8 <strncmp+0x54>
c0d0aa70:	4c14      	ldr	r4, [pc, #80]	; (c0d0aac4 <strncmp+0x70>)
c0d0aa72:	191c      	adds	r4, r3, r4
c0d0aa74:	439c      	bics	r4, r3
c0d0aa76:	422c      	tst	r4, r5
c0d0aa78:	d116      	bne.n	c0d0aaa8 <strncmp+0x54>
c0d0aa7a:	3004      	adds	r0, #4
c0d0aa7c:	3104      	adds	r1, #4
c0d0aa7e:	2a03      	cmp	r2, #3
c0d0aa80:	d914      	bls.n	c0d0aaac <strncmp+0x58>
c0d0aa82:	6803      	ldr	r3, [r0, #0]
c0d0aa84:	680c      	ldr	r4, [r1, #0]
c0d0aa86:	42a3      	cmp	r3, r4
c0d0aa88:	d0ef      	beq.n	c0d0aa6a <strncmp+0x16>
c0d0aa8a:	7804      	ldrb	r4, [r0, #0]
c0d0aa8c:	780d      	ldrb	r5, [r1, #0]
c0d0aa8e:	42ac      	cmp	r4, r5
c0d0aa90:	d113      	bne.n	c0d0aaba <strncmp+0x66>
c0d0aa92:	2301      	movs	r3, #1
c0d0aa94:	e006      	b.n	c0d0aaa4 <strncmp+0x50>
c0d0aa96:	5cc4      	ldrb	r4, [r0, r3]
c0d0aa98:	5ccd      	ldrb	r5, [r1, r3]
c0d0aa9a:	42ac      	cmp	r4, r5
c0d0aa9c:	d10d      	bne.n	c0d0aaba <strncmp+0x66>
c0d0aa9e:	3301      	adds	r3, #1
c0d0aaa0:	4293      	cmp	r3, r2
c0d0aaa2:	d001      	beq.n	c0d0aaa8 <strncmp+0x54>
c0d0aaa4:	2c00      	cmp	r4, #0
c0d0aaa6:	d1f6      	bne.n	c0d0aa96 <strncmp+0x42>
c0d0aaa8:	2000      	movs	r0, #0
c0d0aaaa:	bd30      	pop	{r4, r5, pc}
c0d0aaac:	7804      	ldrb	r4, [r0, #0]
c0d0aaae:	780d      	ldrb	r5, [r1, #0]
c0d0aab0:	42a5      	cmp	r5, r4
c0d0aab2:	d102      	bne.n	c0d0aaba <strncmp+0x66>
c0d0aab4:	2a01      	cmp	r2, #1
c0d0aab6:	d1ec      	bne.n	c0d0aa92 <strncmp+0x3e>
c0d0aab8:	e7f6      	b.n	c0d0aaa8 <strncmp+0x54>
c0d0aaba:	1b60      	subs	r0, r4, r5
c0d0aabc:	e7f5      	b.n	c0d0aaaa <strncmp+0x56>
c0d0aabe:	46c0      	nop			; (mov r8, r8)
c0d0aac0:	80808080 	.word	0x80808080
c0d0aac4:	fefefeff 	.word	0xfefefeff

c0d0aac8 <strncpy>:
c0d0aac8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0aaca:	000c      	movs	r4, r1
c0d0aacc:	4304      	orrs	r4, r0
c0d0aace:	0003      	movs	r3, r0
c0d0aad0:	0007      	movs	r7, r0
c0d0aad2:	07a4      	lsls	r4, r4, #30
c0d0aad4:	d112      	bne.n	c0d0aafc <strncpy+0x34>
c0d0aad6:	2a03      	cmp	r2, #3
c0d0aad8:	d910      	bls.n	c0d0aafc <strncpy+0x34>
c0d0aada:	4c14      	ldr	r4, [pc, #80]	; (c0d0ab2c <strncpy+0x64>)
c0d0aadc:	46a4      	mov	ip, r4
c0d0aade:	4667      	mov	r7, ip
c0d0aae0:	680d      	ldr	r5, [r1, #0]
c0d0aae2:	4c13      	ldr	r4, [pc, #76]	; (c0d0ab30 <strncpy+0x68>)
c0d0aae4:	001e      	movs	r6, r3
c0d0aae6:	192c      	adds	r4, r5, r4
c0d0aae8:	43ac      	bics	r4, r5
c0d0aaea:	423c      	tst	r4, r7
c0d0aaec:	d11b      	bne.n	c0d0ab26 <strncpy+0x5e>
c0d0aaee:	3304      	adds	r3, #4
c0d0aaf0:	3a04      	subs	r2, #4
c0d0aaf2:	001f      	movs	r7, r3
c0d0aaf4:	3104      	adds	r1, #4
c0d0aaf6:	6035      	str	r5, [r6, #0]
c0d0aaf8:	2a03      	cmp	r2, #3
c0d0aafa:	d8f0      	bhi.n	c0d0aade <strncpy+0x16>
c0d0aafc:	2400      	movs	r4, #0
c0d0aafe:	18be      	adds	r6, r7, r2
c0d0ab00:	e006      	b.n	c0d0ab10 <strncpy+0x48>
c0d0ab02:	5d0d      	ldrb	r5, [r1, r4]
c0d0ab04:	3a01      	subs	r2, #1
c0d0ab06:	553d      	strb	r5, [r7, r4]
c0d0ab08:	1ab3      	subs	r3, r6, r2
c0d0ab0a:	3401      	adds	r4, #1
c0d0ab0c:	2d00      	cmp	r5, #0
c0d0ab0e:	d002      	beq.n	c0d0ab16 <strncpy+0x4e>
c0d0ab10:	2a00      	cmp	r2, #0
c0d0ab12:	d1f6      	bne.n	c0d0ab02 <strncpy+0x3a>
c0d0ab14:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0ab16:	2100      	movs	r1, #0
c0d0ab18:	2a00      	cmp	r2, #0
c0d0ab1a:	d0fb      	beq.n	c0d0ab14 <strncpy+0x4c>
c0d0ab1c:	7019      	strb	r1, [r3, #0]
c0d0ab1e:	3301      	adds	r3, #1
c0d0ab20:	429e      	cmp	r6, r3
c0d0ab22:	d1fb      	bne.n	c0d0ab1c <strncpy+0x54>
c0d0ab24:	e7f6      	b.n	c0d0ab14 <strncpy+0x4c>
c0d0ab26:	001f      	movs	r7, r3
c0d0ab28:	e7e8      	b.n	c0d0aafc <strncpy+0x34>
c0d0ab2a:	46c0      	nop			; (mov r8, r8)
c0d0ab2c:	80808080 	.word	0x80808080
c0d0ab30:	fefefeff 	.word	0xfefefeff

c0d0ab34 <strnlen>:
c0d0ab34:	b510      	push	{r4, lr}
c0d0ab36:	0003      	movs	r3, r0
c0d0ab38:	1844      	adds	r4, r0, r1
c0d0ab3a:	2900      	cmp	r1, #0
c0d0ab3c:	d103      	bne.n	c0d0ab46 <strnlen+0x12>
c0d0ab3e:	e009      	b.n	c0d0ab54 <strnlen+0x20>
c0d0ab40:	3301      	adds	r3, #1
c0d0ab42:	429c      	cmp	r4, r3
c0d0ab44:	d004      	beq.n	c0d0ab50 <strnlen+0x1c>
c0d0ab46:	781a      	ldrb	r2, [r3, #0]
c0d0ab48:	2a00      	cmp	r2, #0
c0d0ab4a:	d1f9      	bne.n	c0d0ab40 <strnlen+0xc>
c0d0ab4c:	1a18      	subs	r0, r3, r0
c0d0ab4e:	bd10      	pop	{r4, pc}
c0d0ab50:	1a20      	subs	r0, r4, r0
c0d0ab52:	e7fc      	b.n	c0d0ab4e <strnlen+0x1a>
c0d0ab54:	2000      	movs	r0, #0
c0d0ab56:	e7fa      	b.n	c0d0ab4e <strnlen+0x1a>

c0d0ab58 <bzero>:
c0d0ab58:	b510      	push	{r4, lr}
c0d0ab5a:	000a      	movs	r2, r1
c0d0ab5c:	2100      	movs	r1, #0
c0d0ab5e:	f7ff fe6b 	bl	c0d0a838 <memset>
c0d0ab62:	bd10      	pop	{r4, pc}

c0d0ab64 <basis_64>:
c0d0ab64:	4241 4443 4645 4847 4a49 4c4b 4e4d 504f     ABCDEFGHIJKLMNOP
c0d0ab74:	5251 5453 5655 5857 5a59 6261 6463 6665     QRSTUVWXYZabcdef
c0d0ab84:	6867 6a69 6c6b 6e6d 706f 7271 7473 7675     ghijklmnopqrstuv
c0d0ab94:	7877 7a79 3130 3332 3534 3736 3938 2f2b     wxyz0123456789+/
c0d0aba4:	5000 6e65 6964 676e 4c00 6465 6567 2072     .Pending.Ledger 
c0d0abb4:	6572 6976 7765 0000                         review..

c0d0abbc <ui_audited_elements>:
c0d0abbc:	0003 0000 0000 0080 0020 0000 0001 0000     ........ .......
c0d0abcc:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0d0abdc:	0107 0000 000c 0080 0020 0000 0000 0000     ........ .......
c0d0abec:	ffff 00ff 0000 0000 8008 0000 aba5 c0d0     ................
c0d0abfc:	0107 0000 0018 0080 0020 0000 0000 0000     ........ .......
c0d0ac0c:	ffff 00ff 0000 0000 8008 0000 abad c0d0     ................
c0d0ac1c:	6e49 6176 696c 2064 6170 6874 000a 7830     Invalid path..0x
c0d0ac2c:	2e25 732a 5000 6f72 6976 6973 6e6f 6e69     %.*s.Provisionin
c0d0ac3c:	2067 7563 7272 6e65 5474 6b6f 6e65 6e49     g currentTokenIn
c0d0ac4c:	6564 2078 6425 000a 6843 6961 496e 2064     dex %d..ChainId 
c0d0ac5c:	6f74 656b 206e 696d 6d73 7461 6863 000a     token mismatch..
c0d0ac6c:	6e49 6176 696c 2064 6f74 656b 206e 6973     Invalid token si
c0d0ac7c:	6e67 7461 7275 0a65                          gnature..

c0d0ac85 <TOKEN_SIGNATURE_PUBLIC_KEY>:
c0d0ac85:	5e04 106c c120 c44d 4264 89fe 7cf9 680b     .^l. .M.dB...|.h
c0d0ac95:	b1cd 7659 24dc 4cf2 6e31 307b 4efe c78c     ..Yv.$.L1n{0.N..
c0d0aca5:	146b 1589 210c 4e51 44bf f50f a5de 3d39     k....!QN.D....9=
c0d0acb5:	de83 5853 09cd ce8f d08f 1df8 94aa 9197     ..SX............
c0d0acc5:	4983 766e 6c61 6469 6420 7461 0a61 5300     .Invalid data..S
c0d0acd5:	6769 616e 7574 6572 6e20 746f 6920 696e     ignature not ini
c0d0ace5:	6974 6c61 7a69 6465 000a                    tialized..

c0d0acef <SIGN_MAGIC>:
c0d0acef:	4519 6874 7265 7565 206d 6953 6e67 6465     .Ethereum Signed
c0d0acff:	4d20 7365 6173 6567 0a3a 6a00 6c78 676f      Message:..jxlog
c0d0ad0f:	3132 203a 656c 676e 6874 2520 0a64 5000     21: length %d..P
c0d0ad1f:	7261 6573 2072 6f6e 2074 6e69 7469 6169     arser not initia
c0d0ad2f:	696c 657a 0a64 5500 656e 7078 6365 6574     lized..Unexpecte
c0d0ad3f:	2064 6170 7372 7265 7320 6174 7574 0a73     d parser status.
c0d0ad4f:	3000 2578 2a2e 0048 7341 6f73 6963 7461     .0x%.*H.Associat
c0d0ad5f:	6465 7420 6b6f 6e65 6e20 746f 6620 756f     ed token not fou
c0d0ad6f:	646e 000a 7453 726f 6e69 2067 6170 6874     nd..Storing path
c0d0ad7f:	2520 2064 6425 000a 6146 7463 2520 2a2e      %d %d..Fact %.*
c0d0ad8f:	0a48 4100 6464 6572 7373 2520 2a2e 0a48     H..Address %.*H.
c0d0ad9f:	7300 6174 6b72 2d20 7520 656e 7078 6365     .stark - unexpec
c0d0adaf:	6574 2064 7571 6e61 7574 206d 6564 6373     ted quantum desc
c0d0adbf:	6972 7470 726f 7420 7079 2065 6f66 2072     riptor type for 
c0d0adcf:	756e 6c6c 6620 7269 7473 6120 6464 6572     null first addre
c0d0addf:	7373 2520 0a64 7300 6174 6b72 2d20 6320     ss %d..stark - c
c0d0adef:	6e61 6f6e 2074 7270 636f 7365 2073 6e75     annot process un
c0d0adff:	6e6b 776f 206e 6f74 656b 206e 2e25 482a     known token %.*H
c0d0ae0f:	7300 6174 6b72 2d20 7520 656e 7078 6365     .stark - unexpec
c0d0ae1f:	6574 2064 7571 6e61 7574 206d 6564 6373     ted quantum desc
c0d0ae2f:	6972 7470 726f 7420 7079 2065 6f66 2072     riptor type for 
c0d0ae3f:	756e 6c6c 7320 6365 6e6f 2064 6461 7264     null second addr
c0d0ae4f:	7365 2073 6425 000a 7473 7261 206b 3177     ess %d..stark w1
c0d0ae5f:	2520 2a2e 0a48 7300 6174 6b72 7720 2032      %.*H..stark w2 
c0d0ae6f:	2e25 482a 000a 7473 7261 206b 3377 2520     %.*H..stark w3 %
c0d0ae7f:	2a2e 0a48 7300 6174 6b72 7720 2034 2e25     .*H..stark w4 %.
c0d0ae8f:	482a 000a 6573 666c 7420 6172 736e 6566     *H..self transfe
c0d0ae9f:	2072 6425 000a                              r %d..

c0d0aea5 <UNDERLYING_ASSET_DECIMALS>:
c0d0aea5:	4463 4941 0000 0000 0000 0000 4312 5445     cDAI.........CET
c0d0aeb5:	0048 0000 0000 0000 1200 5543 4453 0043     H.........CUSDC.
c0d0aec5:	0000 0000 0000 4306 525a 0058 0000 0000     .......CZRX.....
c0d0aed5:	0000 1200 5543 4453 0054 0000 0000 0000     ....CUSDT.......
c0d0aee5:	4306 5442 0043 0000 0000 0000 0800 4243     .CBTC.........CB
c0d0aef5:	5441 0000 0000 0000 0000 4312 4552 0050     AT.........CREP.
c0d0af05:	0000 0000 0000 1200 5363 4941 0000 0000     ........cSAI....
c0d0af15:	0000 0000 5512 6b6e 6f6e 6e77 7320 6c65     .....Unknown sel
c0d0af25:	6365 6f74 2072 2e25 482a 000a 6e55 7865     ector %.*H..Unex
c0d0af35:	6570 7463 6465 6420 7461 2061 6973 657a     pected data size
c0d0af45:	6620 726f 6320 6d6f 616d 646e 2520 2064      for command %d 
c0d0af55:	7865 6570 7463 6465 2520 2064 6f67 2074     expected %d got 
c0d0af65:	6425 000a 6f63 706d 756f 646e 7020 756c     %d..compound plu
c0d0af75:	6967 206e 6e69 7469 7469 6169 696c 657a     gin inititialize
c0d0af85:	0a64 6300 6d6f 6f70 6e75 2064 6c70 6775     d..compound plug
c0d0af95:	6e69 7020 6f72 6976 6564 7020 7261 6d61     in provide param
c0d0afa5:	7465 7265 2520 2064 2e25 482a 000a 6e55     eter %d %.*H..Un
c0d0afb5:	6168 646e 656c 2064 6170 6172 656d 6574     handled paramete
c0d0afc5:	2072 666f 7366 7465 000a 4543 4854 6320     r offset..CETH c
c0d0afd5:	6e6f 7274 6361 2074 7865 6570 7463 2073     ontract expects 
c0d0afe5:	6f6e 7020 7261 6d61 7465 7265 0a73 6300     no parameters..c
c0d0aff5:	6d6f 6f70 6e75 2064 6c70 6775 6e69 6620     ompound plugin f
c0d0b005:	6e69 6c61 7a69 0a65 6300 6d6f 6f70 6e75     inalize..compoun
c0d0b015:	2064 6c70 6775 6e69 7020 6f72 6976 6564     d plugin provide
c0d0b025:	7420 6b6f 6e65 203a 6425 000a 7954 6570      token: %d..Type
c0d0b035:	5200 6465 6565 006d 654c 646e 4100 6f6d     .Redeem.Lend.Amo
c0d0b045:	6e75 0074 6e55 6168 646e 656c 2064 656d     unt.Unhandled me
c0d0b055:	7373 6761 2065 6425 000a                    ssage %d..

c0d0b05f <COMPOUND_EXPECTED_DATA_SIZE>:
c0d0b05f:	2424 0424 4300 6d6f 6f70 6e75 2064           $$$..Compound .

c0d0b06e <COMPOUND_BINDINGS>:
c0d0b06e:	4144 0049 0000 0000 0000 0000 4443 4941     DAI.........CDAI
	...
c0d0b086:	4557 4854 0000 0000 0000 0000 4543 4854     WETH........CETH
	...
c0d0b09e:	5355 4344 0000 0000 0000 0000 5543 4453     USDC........CUSD
c0d0b0ae:	0043 0000 0000 0000 525a 0058 0000 0000     C.......ZRX.....
c0d0b0be:	0000 0000 5a43 5852 0000 0000 0000 0000     ....CZRX........
c0d0b0ce:	5355 5444 0000 0000 0000 0000 5543 4453     USDT........CUSD
c0d0b0de:	0054 0000 0000 0000 4257 4354 0000 0000     T.......WBTC....
c0d0b0ee:	0000 0000 4243 4354 0000 0000 0000 0000     ....CBTC........
c0d0b0fe:	4142 0054 0000 0000 0000 0000 4243 5441     BAT.........CBAT
	...
c0d0b116:	4552 7650 0032 0000 0000 0000 5243 5045     REPv2.......CREP
	...
c0d0b12e:	4153 0049 0000 0000 0000 0000 5343 4941     SAI.........CSAI
	...
c0d0b146:	7245 3a72 5420 6172 736e 6361 6974 6e6f     Err: Transaction
c0d0b156:	6120 6f6d 6e75 2074 7369 6e20 746f 3020      amount is not 0
c0d0b166:	000a 7265 3263 2030 6c70 6775 6e69 6920     ..erc20 plugin i
c0d0b176:	696e 0a74 6500 6372 3032 7020 756c 6967     nit..erc20 plugi
c0d0b186:	206e 7270 766f 6469 2065 6170 6172 656d     n provide parame
c0d0b196:	6574 2072 6425 2520 2a2e 0a48 6500 6372     ter %d %.*H..erc
c0d0b1a6:	3032 7020 756c 6967 206e 6966 616e 696c     20 plugin finali
c0d0b1b6:	657a 000a 7265 3263 2030 6c70 6775 6e69     ze..erc20 plugin
c0d0b1c6:	7020 6f72 6976 6564 7420 6b6f 6e65 3120      provide token 1
c0d0b1d6:	203a 6425 2d20 3220 203a 6425 000a 6e55     : %d - 2: %d..Un
c0d0b1e6:	696c 696d 6574 2064 4500 7272 203a 7254     limited .Err: Tr
c0d0b1f6:	6e61 6173 7463 6f69 206e 6d61 756f 746e     ansaction amount
c0d0b206:	6920 2073 6f6e 2074 2030 6f66 2072 7265      is not 0 for er
c0d0b216:	3763 3132 6120 7070 6f72 6176 0a6c 5500     c721 approval..U
c0d0b226:	6b6e 6f6e 6e77 6520 6372 3237 2031 6573     nknown erc721 se
c0d0b236:	656c 7463 726f 2520 2a2e 0a48 4900 766e     lector %.*H..Inv
c0d0b246:	6c61 6469 6520 6372 3237 2031 7061 7270     alid erc721 appr
c0d0b256:	766f 6c61 6420 7461 2061 6973 657a 2520     oval data size %
c0d0b266:	0a64 6500 6372 3237 2031 6c70 6775 6e69     d..erc721 plugin
c0d0b276:	6920 696e 0a74 6500 6372 3237 2031 6c70      init..erc721 pl
c0d0b286:	6775 6e69 7020 6f72 6976 6564 7020 7261     ugin provide par
c0d0b296:	6d61 7465 7265 2520 2064 2e25 482a 000a     ameter %d %.*H..
c0d0b2a6:	7265 3763 3132 7020 756c 6967 206e 6966     erc721 plugin fi
c0d0b2b6:	616e 696c 657a 000a 7265 3763 3132 7020     nalize..erc721 p
c0d0b2c6:	756c 6967 206e 7270 766f 6469 2065 6f74     lugin provide to
c0d0b2d6:	656b 206e 6564 7473 203a 6425 2d20 6120     ken dest: %d - a
c0d0b2e6:	6464 6572 7373 203a 6425 000a 0000 6c41     ddress: %d....Al
c0d0b2f6:	6f6c 6177 636e 0065 0000 6f43 746e 6172     lowance...Contra
c0d0b306:	7463 4e20 6d61 0065 0000 464e 2054 6f43     ct Name...NFT Co
c0d0b316:	746e 6172 7463 7200 6165 5464 4278 7479     ntract.readTxByt
c0d0b326:	2065 6e55 6564 6672 6f6c 0a77 6300 706f     e Underflow..cop
c0d0b336:	5479 4478 7461 2061 6e55 6564 6672 6f6c     yTxData Underflo
c0d0b346:	0a77 6a00 6c78 676f 3239 203a 6568 6572     w..jxlog92: here
c0d0b356:	0a20 5200 504c 7020 6572 642d 6365 646f      ..RLP pre-decod
c0d0b366:	2065 7265 6f72 0a72 5200 504c 7020 6572     e error..RLP pre
c0d0b376:	642d 6365 646f 2065 6f6c 6967 2063 7265     -decode logic er
c0d0b386:	6f72 0a72 5200 504c 6420 6365 646f 2065     ror..RLP decode 
c0d0b396:	7265 6f72 0a72 4300 7375 6f74 206d 7270     error..Custom pr
c0d0b3a6:	636f 7365 6f73 2072 6261 726f 6574 0a64     ocessor aborted.
c0d0b3b6:	5500 686e 6e61 6c64 6465 6320 7375 6f74     .Unhandled custo
c0d0b3c6:	206d 7270 636f 7365 6f73 2072 7473 7461     m processor stat
c0d0b3d6:	7375 000a 6e49 6176 696c 2064 4c52 2050     us..Invalid RLP 
c0d0b3e6:	6564 6f63 6564 2072 6f63 746e 7865 0a74     decoder context.
c0d0b3f6:	4900 766e 6c61 6469 7420 7079 2065 6f66     .Invalid type fo
c0d0b406:	2072 4c52 5f50 4f43 544e 4e45 0a54 4900     r RLP_CONTENT..I
c0d0b416:	766e 6c61 6469 7420 7079 2065 6f66 2072     nvalid type for 
c0d0b426:	4c52 5f50 5954 4550 000a 6e49 6176 696c     RLP_TYPE..Invali
c0d0b436:	2064 656c 676e 6874 6620 726f 5220 504c     d length for RLP
c0d0b446:	545f 5059 0a45 4900 766e 6c61 6469 7420     _TYPE..Invalid t
c0d0b456:	7079 2065 6f66 2072 4c52 5f50 4f4e 434e     ype for RLP_NONC
c0d0b466:	0a45 4900 766e 6c61 6469 6c20 6e65 7467     E..Invalid lengt
c0d0b476:	2068 6f66 2072 4c52 5f50 4f4e 434e 0a45     h for RLP_NONCE.
c0d0b486:	4900 766e 6c61 6469 7420 7079 2065 6f66     .Invalid type fo
c0d0b496:	2072 4c52 5f50 4147 5053 4952 4543 000a     r RLP_GASPRICE..
c0d0b4a6:	6e49 6176 696c 2064 656c 676e 6874 6620     Invalid length f
c0d0b4b6:	726f 5220 504c 475f 5341 5250 4349 0a45     or RLP_GASPRICE.
c0d0b4c6:	4900 766e 6c61 6469 7420 7079 2065 6f66     .Invalid type fo
c0d0b4d6:	2072 4c52 5f50 5453 5241 4754 5341 000a     r RLP_STARTGAS..
c0d0b4e6:	6e49 6176 696c 2064 656c 676e 6874 6620     Invalid length f
c0d0b4f6:	726f 5220 504c 535f 4154 5452 4147 2053     or RLP_STARTGAS 
c0d0b506:	6425 000a 6e49 6176 696c 2064 7974 6570     %d..Invalid type
c0d0b516:	6620 726f 5220 504c 565f 4c41 4555 000a      for RLP_VALUE..
c0d0b526:	6e49 6176 696c 2064 656c 676e 6874 6620     Invalid length f
c0d0b536:	726f 5220 504c 565f 4c41 4555 000a 6e49     or RLP_VALUE..In
c0d0b546:	6176 696c 2064 7974 6570 6620 726f 5220     valid type for R
c0d0b556:	504c 545f 0a4f 4900 766e 6c61 6469 6c20     LP_TO..Invalid l
c0d0b566:	6e65 7467 2068 6f66 2072 4c52 5f50 4f54     ength for RLP_TO
c0d0b576:	000a 6e49 6176 696c 2064 7974 6570 6620     ..Invalid type f
c0d0b586:	726f 5220 504c 445f 5441 0a41 6a00 6c78     or RLP_DATA..jxl
c0d0b596:	676f 3232 203a 656c 676e 6874 2520 2c64     og22: length %d,
c0d0b5a6:	7020 736f 2520 2c64 6320 706f 7379 7a69      pos %d, copysiz
c0d0b5b6:	2065 6425 0a20 4900 766e 6c61 6469 7420     e %d ..Invalid t
c0d0b5c6:	7079 2065 6f66 2072 4c52 5f50 0a56 4900     ype for RLP_V..I
c0d0b5d6:	766e 6c61 6469 6c20 6e65 7467 2068 6f66     nvalid length fo
c0d0b5e6:	2072 4c52 5f50 0a56                          r RLP_V..

c0d0b5ef <HEXDIGITS>:
c0d0b5ef:	3130 3332 3534 3736 3938 6261 6463 6665     0123456789abcdef
c0d0b5ff:	6a00 6c78 676f 3432 203a 6874 7465 5461     .jxlog24: thetaT
c0d0b60f:	2058 7325 2c20 6c20 6e65 7467 2068 6425     X %s , length %d
c0d0b61f:	0a20 6a00 6c78 676f 3332 5520 5453 4552      ..jxlog23 USTRE
c0d0b62f:	4d41 465f 5541 544c 0a20 2500 3064 0078     AM_FAULT ..%d0x.
c0d0b63f:	6553 656c 7463 726f 2520 2a2e 0a48 6500     Selector %.*H..e
c0d0b64f:	6874 705f 756c 5f67 6e69 7469 6120 6f62     th_plug_init abo
c0d0b65f:	7472 6465 6920 206e 7773 7061 6d20 646f     rted in swap mod
c0d0b66f:	0a65 6500 6874 705f 756c 6967 5f6e 6e69     e..eth_plugin_in
c0d0b67f:	7469 000a 7254 6979 676e 6120 6464 6572     it..Trying addre
c0d0b68f:	7373 2520 2a2e 0a48 5400 7972 6e69 2067     ss %.*H..Trying 
c0d0b69f:	6c61 6169 2073 7325 000a 786a 6f6c 3967     alias %s..jxlog9
c0d0b6af:	3a31 7320 6174 7574 2073 203d 6425 0a20     1: status = %d .
c0d0b6bf:	6500 6874 705f 756c 6967 5f6e 6e69 7469     .eth_plugin_init
c0d0b6cf:	6f20 206b 7325 000a 6143 6863 6465 7020      ok %s..Cached p
c0d0b6df:	756c 6967 206e 6163 6c6c 6220 7475 6e20     lugin call but n
c0d0b6ef:	206f 6c70 6775 6e69 6120 6176 6c69 6261     o plugin availab
c0d0b6ff:	656c 000a 6e55 6e6b 776f 206e 6c70 6775     le..Unknown plug
c0d0b70f:	6e69 6d20 7465 6f68 2064 6425 000a 6c50     in method %d..Pl
c0d0b71f:	6775 6e69 6320 6c61 206c 7865 6563 7470     ugin call except
c0d0b72f:	6f69 206e 6f66 2072 7325 000a               ion for %s..

c0d0b73b <ERC20_TRANSFER_SELECTOR>:
c0d0b73b:	05a9 bb9c                                   ....

c0d0b73f <ERC20_APPROVE_SELECTOR>:
c0d0b73f:	5e09 b3a7                                    .^...

c0d0b744 <ERC20_SELECTORS>:
c0d0b744:	b73b c0d0 b73f c0d0                         ;...?...

c0d0b74c <ERC721_APPROVE_SELECTOR>:
c0d0b74c:	5e09 b3a7                                   .^..

c0d0b750 <ERC721_SELECTORS>:
c0d0b750:	b74c c0d0                                   L...

c0d0b754 <COMPOUND_REDEEM_UNDERLYING_SELECTOR>:
c0d0b754:	2a85 e312                                   .*..

c0d0b758 <COMPOUND_REDEEM_SELECTOR>:
c0d0b758:	00db 756a                                   ..ju

c0d0b75c <COMPOUND_MINT_SELECTOR>:
c0d0b75c:	71a0 682d                                   .q-h

c0d0b760 <CETH_MINT_SELECTOR>:
c0d0b760:	4912 8bc5                                   .I..

c0d0b764 <COMPOUND_SELECTORS>:
c0d0b764:	b754 c0d0 b758 c0d0 b75c c0d0 b760 c0d0     T...X...\...`...

c0d0b774 <STARKWARE_REGISTER_ID>:
c0d0b774:	24dd d414                                   .$..

c0d0b778 <STARKWARE_DEPOSIT_TOKEN_ID>:
c0d0b778:	0525 d9c3                                   %...

c0d0b77c <STARKWARE_DEPOSIT_ETH_ID>:
c0d0b77c:	ae00 8aef                                   ....

c0d0b780 <STARKWARE_DEPOSIT_CANCEL_ID>:
c0d0b780:	f77d 04dc                                   }...

c0d0b784 <STARKWARE_DEPOSIT_RECLAIM_ID>:
c0d0b784:	87ae 1638                                   ..8.

c0d0b788 <STARKWARE_WITHDRAW_ID>:
c0d0b788:	1a44 703e                                   D.>p

c0d0b78c <STARKWARE_FULL_WITHDRAWAL_ID>:
c0d0b78c:	33a9 c410                                   .3..

c0d0b790 <STARKWARE_FREEZE_ID>:
c0d0b790:	c193 66e4                                   ...f

c0d0b794 <STARKWARE_ESCAPE_ID>:
c0d0b794:	3a9e c4da                                   .:..

c0d0b798 <STARKWARE_VERIFY_ESCAPE_ID>:
c0d0b798:	d52d 0630                                   -.0.

c0d0b79c <STARKWARE_WITHDRAW_TO_ID>:
c0d0b79c:	cd14 e470                                   ..p.

c0d0b7a0 <STARKWARE_DEPOSIT_NFT_ID>:
c0d0b7a0:	1cae e6dd                                   ....

c0d0b7a4 <STARKWARE_DEPOSIT_NFT_RECLAIM_ID>:
c0d0b7a4:	b0fc 2258                                   ..X"

c0d0b7a8 <STARKWARE_WITHDRAW_AND_MINT_ID>:
c0d0b7a8:	14d9 b743                                   ..C.

c0d0b7ac <STARKWARE_WITHDRAW_NFT_ID>:
c0d0b7ac:	9b01 7a41                                   ..Az

c0d0b7b0 <STARKWARE_WITHDRAW_NFT_TO_ID>:
c0d0b7b0:	efeb d00f                                   ....

c0d0b7b4 <STARKWARE_SELECTORS>:
c0d0b7b4:	b774 c0d0 b778 c0d0 b77c c0d0 b780 c0d0     t...x...|.......
c0d0b7c4:	b784 c0d0 b788 c0d0 b78c c0d0 b790 c0d0     ................
c0d0b7d4:	b794 c0d0 b798 c0d0 b79c c0d0 b7a0 c0d0     ................
c0d0b7e4:	b7a4 c0d0 b7a8 c0d0 b7ac c0d0 b7b0 c0d0     ................

c0d0b7f4 <INTERNAL_ETH_PLUGINS>:
c0d0b7f4:	1779 c0d0 b744 c0d0 2d02 7265 3263 0030     y...D....-erc20.
c0d0b804:	17a1 c0d0 1ad5 c0d0 b750 c0d0 2d01 7265     ........P....-er
c0d0b814:	3237 0031 1afd c0d0 0000 0000 b764 c0d0     721.........d...
c0d0b824:	2d04 6d63 6470 0000 1451 c0d0 0000 0000     .-cmpd..Q.......
c0d0b834:	b7b4 c0d0 2d0a 7473 6b72 0000 6135 c0d0     .....-strk..5a..
	...
c0d0b858:	6c50 6775 6e69 7120 6575 7972 6320 6e6f     Plugin query con
c0d0b868:	7274 6361 2074 4449 6320 6c61 206c 6166     tract ID call fa
c0d0b878:	6c69 6465 000a 6c50 6775 6e69 7120 6575     iled..Plugin que
c0d0b888:	7972 6320 6e6f 7274 6361 2074 4955 6320     ry contract UI c
c0d0b898:	6c61 206c 6166 6c69 6465 000a 6552 6976     all failed..Revi
c0d0b8a8:	7765 6300 6e6f 7274 6361 2074 6163 6c6c     ew.contract call
c0d0b8b8:	4d00 7861 4620 6565 0073 6341 6563 7470     .Max Fees.Accept
c0d0b8c8:	6100 646e 7320 6e65 0064 6552 656a 7463     .and send.Reject
c0d0b8d8:	0000 0000                                   ....

c0d0b8dc <ux_plugin_approval_intro_step_val>:
c0d0b8dc:	baec c0d0 b8a4 c0d0 b8ab c0d0               ............

c0d0b8e8 <ux_plugin_approval_intro_step>:
c0d0b8e8:	a311 c0d0 b8dc c0d0 0000 0000 0000 0000     ................

c0d0b8f8 <ux_plugin_approval_id_step_val>:
c0d0b8f8:	1cca 2000 1d2e 2000                         ... ... 

c0d0b900 <ux_plugin_approval_id_step>:
c0d0b900:	2dad c0d0 b8f8 c0d0 0000 0000 0000 0000     .-..............

c0d0b910 <ux_plugin_approval_before_step>:
c0d0b910:	2dbd c0d0 0000 0000 0000 0000 0000 0000     .-..............

c0d0b920 <ux_plugin_approval_display_step_val>:
c0d0b920:	1cca 2000 1d2e 2000                         ... ... 

c0d0b928 <ux_plugin_approval_display_step>:
c0d0b928:	a0d5 c0d0 b920 c0d0 0000 0000 0000 0000     .... ...........

c0d0b938 <ux_plugin_approval_after_step>:
c0d0b938:	2dc7 c0d0 0000 0000 0000 0000 0000 0000     .-..............

c0d0b948 <ux_plugin_approval_fees_step_val>:
c0d0b948:	b8b9 c0d0 1d27 2000                         ....'.. 

c0d0b950 <ux_plugin_approval_fees_step>:
c0d0b950:	2dd1 c0d0 b948 c0d0 0000 0000 0000 0000     .-..H...........

c0d0b960 <ux_plugin_approval_ok_step_validate_step>:
c0d0b960:	2ded c0d0 0000 0000 0000 0000 0000 0000     .-..............

c0d0b970 <ux_plugin_approval_ok_step_validate>:
c0d0b970:	b960 c0d0 ffff ffff                         `.......

c0d0b978 <ux_plugin_approval_ok_step_val>:
c0d0b978:	bb64 c0d0 b8c2 c0d0 b8c9 c0d0               d...........

c0d0b984 <ux_plugin_approval_ok_step>:
c0d0b984:	a2a5 c0d0 b978 c0d0 b970 c0d0 0000 0000     ....x...p.......

c0d0b994 <ux_plugin_approval_cancel_step_validate_step>:
c0d0b994:	2df7 c0d0 0000 0000 0000 0000 0000 0000     .-..............

c0d0b9a4 <ux_plugin_approval_cancel_step_validate>:
c0d0b9a4:	b994 c0d0 ffff ffff                         ........

c0d0b9ac <ux_plugin_approval_cancel_step_val>:
c0d0b9ac:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0b9b4 <ux_plugin_approval_cancel_step>:
c0d0b9b4:	a1b5 c0d0 b9ac c0d0 b9a4 c0d0 0000 0000     ................

c0d0b9c4 <ux_plugin_approval_flow>:
c0d0b9c4:	b8e8 c0d0 b900 c0d0 b910 c0d0 b928 c0d0     ............(...
c0d0b9d4:	b938 c0d0 b950 c0d0 b984 c0d0 b9b4 c0d0     8...P...........
c0d0b9e4:	ffff ffff                                   ....

c0d0b9e8 <C_icon_back_x_colors>:
c0d0b9e8:	0000 0000 ffff 00ff                         ........

c0d0b9f0 <C_icon_back_x_bitmap>:
c0d0b9f0:	0000 0000 800c 7003 0e00 ffc0 3ff0 0038     .......p.....?8.
c0d0ba00:	001c 000e 0003 0000 0000 0000               ............

c0d0ba0c <C_icon_back_x>:
c0d0ba0c:	000e 0000 000e 0000 0001 0000 b9e8 c0d0     ................
c0d0ba1c:	b9f0 c0d0                                   ....

c0d0ba20 <C_icon_certificate_colors>:
c0d0ba20:	0000 0000 ffff 00ff                         ........

c0d0ba28 <C_icon_certificate_bitmap>:
c0d0ba28:	0000 c1fe 30ff ec30 030d dec3 3030 0dec     .....00.....00..
c0d0ba38:	c303 f0c0 f83f 0007 0000 0000               ....?.......

c0d0ba44 <C_icon_certificate>:
c0d0ba44:	000e 0000 000e 0000 0001 0000 ba20 c0d0     ............ ...
c0d0ba54:	ba28 c0d0                                   (...

c0d0ba58 <C_icon_crossmark_colors>:
c0d0ba58:	0000 0000 ffff 00ff                         ........

c0d0ba60 <C_icon_crossmark_bitmap>:
c0d0ba60:	8000 e601 71c0 3838 fc07 1e00 0780 03f0     .....q88........
c0d0ba70:	c1ce 38e1 0670 0018 0000 0000               ...8p.......

c0d0ba7c <C_icon_crossmark>:
c0d0ba7c:	000e 0000 000e 0000 0001 0000 ba58 c0d0     ............X...
c0d0ba8c:	ba60 c0d0                                   `...

c0d0ba90 <C_icon_dashboard_x_colors>:
c0d0ba90:	0000 0000 ffff 00ff                         ........

c0d0ba98 <C_icon_dashboard_x_bitmap>:
c0d0ba98:	0000 0000 800c f007 fe03 ffc1 3ff0 03f0     .............?..
c0d0baa8:	00cc c033 000c 0000 0000 0000               ..3.........

c0d0bab4 <C_icon_dashboard_x>:
c0d0bab4:	000e 0000 000e 0000 0001 0000 ba90 c0d0     ................
c0d0bac4:	ba98 c0d0                                   ....

c0d0bac8 <C_icon_eye_colors>:
c0d0bac8:	0000 0000 ffff 00ff                         ........

c0d0bad0 <C_icon_eye_bitmap>:
c0d0bad0:	0000 0000 e01e 1c1f 030e 8c63 6319 0c0c     ..........c..c..
c0d0bae0:	8387 807f 0007 0000 0000 0000               ............

c0d0baec <C_icon_eye>:
c0d0baec:	000e 0000 000e 0000 0001 0000 bac8 c0d0     ................
c0d0bafc:	bad0 c0d0                                   ....

c0d0bb00 <C_icon_left_colors>:
c0d0bb00:	0000 0000 ffff 00ff                         ........

c0d0bb08 <C_icon_left_bitmap>:
c0d0bb08:	1248 0842                                   H.B.

c0d0bb0c <C_icon_left>:
c0d0bb0c:	0004 0000 0007 0000 0001 0000 bb00 c0d0     ................
c0d0bb1c:	bb08 c0d0                                   ....

c0d0bb20 <C_icon_right_colors>:
c0d0bb20:	0000 0000 ffff 00ff                         ........

c0d0bb28 <C_icon_right_bitmap>:
c0d0bb28:	8421 0124                                   !.$.

c0d0bb2c <C_icon_right>:
c0d0bb2c:	0004 0000 0007 0000 0001 0000 bb20 c0d0     ............ ...
c0d0bb3c:	bb28 c0d0                                   (...

c0d0bb40 <C_icon_validate_14_colors>:
c0d0bb40:	0000 0000 ffff 00ff                         ........

c0d0bb48 <C_icon_validate_14_bitmap>:
c0d0bb48:	0000 0000 0000 00c0 0038 e067 1c38 039c     ........8.g.8...
c0d0bb58:	007e 800f 0001 0000 0000 0000               ~...........

c0d0bb64 <C_icon_validate_14>:
c0d0bb64:	000e 0000 000e 0000 0001 0000 bb40 c0d0     ............@...
c0d0bb74:	bb48 c0d0                                   H...

c0d0bb78 <C_icon_warning_colors>:
c0d0bb78:	0000 0000 ffff 00ff                         ........

c0d0bb80 <C_icon_warning_bitmap>:
c0d0bb80:	0000 0030 800c 2007 cc01 3300 1ce0 0738     ..0.... ...3..8.
c0d0bb90:	c3ff f8f3 fe7c 001f 0000 0000               ....|.......

c0d0bb9c <C_icon_warning>:
c0d0bb9c:	000e 0000 000e 0000 0001 0000 bb78 c0d0     ............x...
c0d0bbac:	bb80 c0d0 6150 6172 736d 6f20 206e 6874     ....Params on th
c0d0bbbc:	2065 6461 7264 7365 2073 6425 000a 6441     e address %d..Ad
c0d0bbcc:	7264 7365 2073 6f74 6320 6568 6b63 2520     dress to check %
c0d0bbdc:	0a73 4900 736e 6469 2065 6168 646e 656c     s..Inside handle
c0d0bbec:	635f 6568 6b63 615f 6464 6572 7373 000a     _check_address..
c0d0bbfc:	6441 7264 7365 2073 6f74 6320 6568 6b63     Address to check
c0d0bc0c:	3d20 203d 0a30 4100 6464 6572 7373 7365      == 0..Addresses
c0d0bc1c:	6420 6e6f 7427 6d20 7461 6863 000a 6441      don't match..Ad
c0d0bc2c:	7264 7365 6573 2073 6d20 7461 6863 000a     dresses  match..
c0d0bc3c:	6d41 756f 746e 6920 2073 6f74 206f 6962     Amount is too bi
c0d0bc4c:	2c67 3320 2032 7962 6574 2073 616d 2078     g, 32 bytes max 
c0d0bc5c:	7562 2074 7562 6666 7265 6820 7361 2520     but buffer has %
c0d0bc6c:	2075 7962 6574 0073 7245 6f72 2072 6877     u bytes.Error wh
c0d0bc7c:	6c69 2065 6170 7372 6e69 2067 6f63 666e     ile parsing conf
c0d0bc8c:	6769 000a 5355 2042 6f70 6577 2072 4e4f     ig..USB power ON
c0d0bc9c:	4f2f 4646 000a 694d 7373 6e69 2067 7566     /OFF..Missing fu
c0d0bcac:	636e 6974 6e6f 7320 6c65 6365 6f74 0a72     nction selector.
c0d0bcbc:	7000 756c 6967 416e 6176 6c69 6261 656c     .pluginAvailable
c0d0bccc:	2520 0a64 4400 7461 2061 6966 6c65 2064      %d..Data field 
c0d0bcdc:	6f66 6272 6469 6564 0a6e 5500 636e 6e6f     forbidden..Uncon
c0d0bcec:	6973 7473 6e65 2074 6164 6174 000a 7563     sistent data..cu
c0d0bcfc:	7272 6e65 4674 6569 646c 6f50 2073 6425     rrentFieldPos %d
c0d0bd0c:	6320 706f 5379 7a69 2065 6425 000a 6c50      copySize %d..Pl
c0d0bd1c:	6775 6e69 7020 7261 6d61 7465 7265 6320     ugin parameter c
c0d0bd2c:	6c61 206c 6166 6c69 6465 000a 6946 6c65     all failed..Fiel
c0d0bd3c:	2064 6425 4d00 7861 6620 6565 000a 6e49     d %d.Max fee..In
c0d0bd4c:	6176 696c 2064 6863 6961 496e 2064 6425     valid chainId %d
c0d0bd5c:	6520 7078 6365 6574 2064 6425 000a 6c50      expected %d..Pl
c0d0bd6c:	6775 6e69 6620 6e69 6c61 7a69 2065 6163     ugin finalize ca
c0d0bd7c:	6c6c 6620 6961 656c 0a64 5000 756c 6967     ll failed..Plugi
c0d0bd8c:	206e 7270 766f 6469 2065 6f74 656b 206e     n provide token 
c0d0bd9c:	6163 6c6c 6620 6961 656c 0a64 4900 636e     call failed..Inc
c0d0bdac:	726f 6572 7463 6120 6f6d 6e75 2f74 6461     orrect amount/ad
c0d0bdbc:	7264 7365 2073 6573 2074 7962 7020 756c     dress set by plu
c0d0bdcc:	6967 0a6e 7500 2069 7974 6570 2520 2064     gin..ui type %d 
c0d0bddc:	6f6e 2074 7573 7070 726f 6574 0a64 6a00     not supported..j
c0d0bdec:	6c78 676f 3539 6420 7369 6c70 7961 7542     xlog95 displayBu
c0d0bdfc:	6666 7265 6920 2073 7325 0a20 5400 6b6f     ffer is %s ..Tok
c0d0be0c:	6e65 6620 756f 646e 6120 2074 6e69 6564     en found at inde
c0d0be1c:	2078 6425 000a 654e 2077 5041 5544 7220     x %d..New APDU r
c0d0be2c:	6365 6965 6576 3a64 250a 2a2e 0a48 5400     eceived:.%.*H..T
c0d0be3c:	4548 4154 0020 4654 4555 204c 4900 736e     HETA .TFUEL .Ins
c0d0be4c:	6469 2065 2061 696c 7262 7261 2079 000a     ide a library ..
c0d0be5c:	7865 6563 7470 6f69 5b6e 6425 3a5d 4c20     exception[%d]: L
c0d0be6c:	3d52 7830 3025 5838 000a 01b0 0000 b000     R=0x%08X........
c0d0be7c:	00a7 0000 02b0 0000 4500 5252 524f           .........ERROR.

c0d0be8b <g_pcHex>:
c0d0be8b:	3130 3332 3534 3736 3938 6261 6463 6665     0123456789abcdef

c0d0be9b <g_pcHex_cap>:
c0d0be9b:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
c0d0beab:	6e49 6176 696c 2064 7453 7261 206b 6564     Invalid Stark de
c0d0bebb:	6972 6176 6974 6e6f 7020 7461 2068 6425     rivation path %d
c0d0becb:	2520 0a64 5000 6972 6176 6574 6b20 7965      %d..Private key
c0d0bedb:	6220 6665 726f 2065 7270 636f 7365 6973      before processi
c0d0beeb:	676e 2520 2a2e 0a48 4b00 7965 6820 7361     ng %.*H..Key has
c0d0befb:	2068 2e25 482a 000a 654b 2079 6572 7573     h %.*H..Key resu
c0d0bf0b:	746c 2520 2a2e 0a48 7300 6174 6b72 675f     lt %.*H..stark_g
c0d0bf1b:	7465 615f 6f6d 6e75 5f74 7473 6972 676e     et_amount_string
c0d0bf2b:	2520 2a2e 0a48 7300 6174 6b72 675f 7465      %.*H..stark_get
c0d0bf3b:	615f 6f6d 6e75 5f74 7473 6972 676e 2d20     _amount_string -
c0d0bf4b:	4520 4854 000a 7473 7261 5f6b 6567 5f74      ETH..stark_get_
c0d0bf5b:	6d61 756f 746e 735f 7274 6e69 2067 202d     amount_string - 
c0d0bf6b:	6564 6963 616d 736c 2520 2064 6974 6b63     decimals %d tick
c0d0bf7b:	7265 2520 0a73 7300 6174 6b72 675f 7465     er %s..stark_get
c0d0bf8b:	615f 6f6d 6e75 5f74 7473 6972 676e 2d20     _amount_string -
c0d0bf9b:	6d20 6c75 3532 2036 7325 000a 6567 5f74      mul256 %s..get_
c0d0bfab:	6d61 756f 746e 735f 7274 6e69 2067 7325     amount_string %s
c0d0bfbb:	000a                                        ..

c0d0bfbd <STARK_DERIVE_BIAS>:
c0d0bfbd:	00f8 0000 0000 0e02 ffff ffff ffff f7ff     ................
c0d0bfcd:	a138 4b3b 0e92 1194 6dae f4a5 030b b158     8.;K.....m....X.

c0d0bfdd <C_cx_Stark256_n>:
c0d0bfdd:	0008 0000 0000 1000 ffff ffff ffff ffff     ................
c0d0bfed:	81b7 6d12 e7ca 32b2 661e 41a2 c6ad 2f4d     ...m...2.f.A..M/

c0d0bffd <PEDERSEN_POINTS>:
c0d0bffd:	0204 2834 cb7d feaf 967f 749c 5586 a9fc     ..4(}......t.U..
c0d0c00d:	8fe5 12a8 6d0b eb56 100c d180 5779 e4eb     .....mV.....yW..
c0d0c01d:	037b 56b0 00f1 6ff9 1eb2 9588 d427 4e1f     {..V...o....'..N
c0d0c02d:	9439 3501 7add 946c 6ecc 26d0 e88e 569e     9..5.zl..n.&...V
c0d0c03d:	0415 fa04 f356 c876 b33d 9d3f 26ab 5556     ....V.v.=.?..&VU
c0d0c04d:	338f 0999 c19e 5ede 1830 a6b7 2d93 8aba     .3.....^0....-..
c0d0c05d:	78a3 fa03 8409 31c9 e3c9 1381 c0e0 7ee4     .x.....1.......~
c0d0c06d:	0144 2756 f961 7a2a b423 6851 e8f4 f50f     D.V'a.*z#.Qh....
c0d0c07d:	4db5 0404 4cba 66c1 8dbe 76ec 1049 5bf7     .M...L.f...vI..[
c0d0c08d:	f745 404b 90c6 47c7 e909 3a0f 72a3 bdf0     E.K@...G...:.r..
c0d0c09d:	692d 0097 3040 f51c 75c1 4b1f 1e97 c446     -i..@0...u.K..F.
c0d0c0ad:	e8ed ca5f c5c5 5c9a aee5 487c 1f15 b227     .._....\..|H..'.
c0d0c0bd:	214b 049c 4305 dc02 e6b0 1ccc 446e a8cc     K!...C......nD..
c0d0c0cd:	1af6 bb63 a62c 4850 3fd5 25b3 6fd3 2cf1     ..c.,.PH.?.%.o.,
c0d0c0dd:	a549 0282 b701 3e7b d137 0435 48b3 6204     I.....{>7.5..H.b
c0d0c0ed:	d868 25ae 98ce 78ad 253c 1a56 9d87 77cc     h..%...x<%V....w
c0d0c0fd:	9ce9 2624 0000                               ..$&...

c0d0c104 <PEDERSEN_SHIFT>:
c0d0c104:	0404 e39e a8eb 60c1 0007 1bee eb87 9f59     .......`......Y.
c0d0c114:	7116 0b6b 2210 7794 5533 de1f 5040 68ca     .qk..".w3U..@P.h
c0d0c124:	0304 0cca 4bfe c63b f3dd d446 069d 0eea     .....K;...F.....
c0d0c134:	4ed3 1062 c062 56e0 d0c1 5d40 6e26 2610     .Nb.b..V..@]&n.&
c0d0c144:	538a 6174 6b72 7320 6769 206e 736d 2067     .Stark sign msg 
c0d0c154:	3177 2520 2a2e 0a48 5300 6174 6b72 7320     w1 %.*H..Stark s
c0d0c164:	6769 206e 736d 2067 3277 2520 2a2e 0a48     ign msg w2 %.*H.
c0d0c174:	5300 6174 6b72 7320 6769 206e 3377 2520     .Stark sign w3 %
c0d0c184:	2a2e 0a48 5300 6174 6b72 7320 6769 206e     .*H..Stark sign 
c0d0c194:	3477 2520 2a2e 0a48 5000 6465 7265 6573     w4 %.*H..Pederse
c0d0c1a4:	206e 6168 6873 3120 2520 2a2e 0a48 5000     n hash 1 %.*H..P
c0d0c1b4:	6465 7265 6573 206e 6168 6873 6320 6e6f     edersen hash con
c0d0c1c4:	6964 6974 6e6f 2520 2a2e 0a48 5000 6465     dition %.*H..Ped
c0d0c1d4:	7265 6573 206e 6168 6873 3220 2520 2a2e     ersen hash 2 %.*
c0d0c1e4:	0a48 5300 6174 6b72 7320 6769 616e 7574     H..Stark signatu
c0d0c1f4:	6572 2520 2a2e 0a48 5500 736e 7075 6f70     re %.*H..Unsuppo
c0d0c204:	7472 6465 7120 6175 746e 6d75 7420 7079     rted quantum typ
c0d0c214:	2065 6425 000a 6f63 706d 7475 5f65 6f74     e %d..compute_to
c0d0c224:	656b 5f6e 6469 6620 726f 2520 2a2e 0a48     ken_id for %.*H.
c0d0c234:	6300 6d6f 7570 6574 745f 6b6f 6e65 695f     .compute_token_i
c0d0c244:	2064 6f66 2072 5445 0a48 6300 6d6f 7570     d for ETH..compu
c0d0c254:	6574 745f 6b6f 6e65 695f 2064 7571 6e61     te_token_id quan
c0d0c264:	7574 206d 2e25 482a 000a 6e55 7573 7070     tum %.*H..Unsupp
c0d0c274:	726f 6574 2064 6f6e 206e 6564 6166 6c75     orted non defaul
c0d0c284:	2074 7571 6e61 7574 206d 7974 6570 2520     t quantum type %
c0d0c294:	0a64 6300 6d6f 7570 6574 745f 6b6f 6e65     d..compute_token
c0d0c2a4:	695f 2064 6f63 706d 7475 6465 7420 6b6f     _id computed tok
c0d0c2b4:	6e65 2520 2a2e 0a48                          en %.*H..

c0d0c2bd <ERC20_SELECTOR>:
c0d0c2bd:	72f4 b061                                   .ra.

c0d0c2c1 <ERC721_SELECTOR>:
c0d0c2c1:	5702 9217                                   .W..

c0d0c2c5 <MINTABLE_ERC20_SELECTOR>:
c0d0c2c5:	6468 2d6e                                   hdn-

c0d0c2c9 <MINTABLE_ERC721_SELECTOR>:
c0d0c2c9:	b8b8 7266                                   ..fr

c0d0c2cd <ETH_SELECTOR>:
c0d0c2cd:	2283 f2ff                                   ."..

c0d0c2d1 <MINTABLE_ASSET_ID_PREFIX>:
c0d0c2d1:	494d 544e 4241 454c 003a                    MINTABLE:.

c0d0c2db <DEVERSIFI_CONTRACT>:
c0d0c2db:	5d01 0422 ac5d b0ea 153b 3180 b7ec d0d9     .]".]...;..1....
c0d0c2eb:	ad6f 6024 549b 6b6f 6e65 4920 2044 6f6e     o.$`.Token ID no
c0d0c2fb:	2074 616d 6374 6968 676e 2d20 6320 6d6f     t matching - com
c0d0c30b:	7570 6574 2064 2e25 482a 000a 7543 7272     puted %.*H..Curr
c0d0c31b:	6e65 2074 7571 6e61 7574 206d 2e25 482a     ent quantum %.*H
c0d0c32b:	000a 6552 7571 7365 6574 2064 2e25 482a     ..Requested %.*H
c0d0c33b:	000a 7551 6e61 7574 206d 6f6e 2074 6573     ..Quantum not se
c0d0c34b:	0a74 5500 656e 7078 6365 6574 2064 7571     t..Unexpected qu
c0d0c35b:	6e61 7574 206d 7974 6570 6620 726f 4e20     antum type for N
c0d0c36b:	5446 7420 6b6f 6e65 6920 2064 6863 6365     FT token id chec
c0d0c37b:	206b 6425 000a 6f54 656b 206e 4449 6e20     k %d..Token ID n
c0d0c38b:	746f 6d20 7461 6863 6e69 2067 202d 7865     ot matching - ex
c0d0c39b:	6570 7463 6465 2520 2a2e 0a48 4300 7275     pected %.*H..Cur
c0d0c3ab:	6572 746e 7420 6b6f 6e65 4920 2044 2e25     rent token ID %.
c0d0c3bb:	482a 000a 7473 7261 776b 7261 2065 6c70     *H..starkware pl
c0d0c3cb:	6775 6e69 6920 696e 0a74 7300 6174 6b72     ugin init..stark
c0d0c3db:	6177 6572 7020 756c 6967 206e 7270 766f     ware plugin prov
c0d0c3eb:	6469 2065 6170 6172 656d 6574 2072 6425     ide parameter %d
c0d0c3fb:	2520 2a2e 0a48 7300 6174 6b72 6177 6572      %.*H..starkware
c0d0c40b:	7020 756c 6967 206e 6966 616e 696c 657a      plugin finalize
c0d0c41b:	000a 7473 7261 776b 7261 2065 7571 7265     ..starkware quer
c0d0c42b:	2079 6f63 746e 6172 7463 6920 0a64 4600     y contract id..F
c0d0c43b:	6572 7a65 0065 7345 6163 6570 5300 6174     reeze.Escape.Sta
c0d0c44b:	6b72 6177 6572 5500 656e 7078 6365 6574     rkware.Unexpecte
c0d0c45b:	2064 6373 6572 6e65 2520 2064 6f66 2072     d screen %d for 
c0d0c46b:	6425 000a                                   %d..

c0d0c46f <STARKWARE_EXPECTED_DATA_SIZE>:
c0d0c46f:	8400 6464 4464 4444 0084 8464 0084 8464     ..dddDDD..d...d.

c0d0c47f <STARKWARE_NUM_SCREENS>:
c0d0c47f:	0403 0304 0403 0303 0104 0504 0305 0505     ................
c0d0c48f:	5200 6765 7369 6574 0072 0000 4300 6e61     .Register....Can
c0d0c49f:	6563 206c 6544 6f70 6973 0074 5200 6365     cel Deposit..Rec
c0d0c4af:	616c 6d69 4420 7065 736f 7469 5700 7469     laim Deposit.Wit
c0d0c4bf:	6468 6172 6177 006c 4600 6c75 206c 6957     hdrawal..Full Wi
c0d0c4cf:	6874 7264 7761 6c61 5600 7265 6669 2079     thdrawal.Verify 
c0d0c4df:	7345 6163 6570 0000 5700 7469 6468 6172     Escape...Withdra
c0d0c4ef:	6177 206c 6f54 0000 4400 7665 7265 6973     wal To...Deversi
c0d0c4ff:	6946 0000 4600 6f72 206d 5445 2048 6441     Fi...From ETH Ad
c0d0c50f:	7264 7365 0073 0000 4d00 7361 6574 2072     dress....Master 
c0d0c51f:	6341 6f63 6e75 0074 5400 6b6f 6e65 4120     Account..Token A
c0d0c52f:	6363 756f 746e 0000 5400 206f 5445 2048     ccount...To ETH 
c0d0c53f:	6441 7264 7365 0073 4100 7373 7465 4320     Address..Asset C
c0d0c54f:	6e6f 7274 6361 0074 5400 6b6f 6e65 5320     ontract..Token S
c0d0c55f:	6d79 6f62 006c                              ymbol.

c0d0c565 <SW_INTERNAL>:
c0d0c565:	006f                                        o.

c0d0c567 <SW_BUSY>:
c0d0c567:	0190                                        ..

c0d0c569 <SW_WRONG_LENGTH>:
c0d0c569:	0067                                        g.

c0d0c56b <SW_PROOF_OF_PRESENCE_REQUIRED>:
c0d0c56b:	8569 d0f1 0000 0000 6674 6575 006c 0090     i.......tfuel...
c0d0c57b:	0090                                         ...

c0d0c57e <SW_BAD_KEY_HANDLE>:
c0d0c57e:	806a                                        j.

c0d0c580 <U2F_VERSION>:
c0d0c580:	3255 5f46 3256 0090                         U2F_V2..

c0d0c588 <INFO>:
c0d0c588:	0901 0090                                   ....

c0d0c58c <SW_UNKNOWN_CLASS>:
c0d0c58c:	006e                                        n.

c0d0c58e <SW_UNKNOWN_INSTRUCTION>:
c0d0c58e:	006d 6552 7571 7365 2074 6f74 7320 6e65     m.Request to sen
c0d0c59e:	2064 6e6f 7520 736e 7075 6f70 7472 6465     d on unsupported
c0d0c5ae:	6d20 6465 6169 2520 0a64                      media %d..

c0d0c5b9 <BROADCAST_CHANNEL>:
c0d0c5b9:	ffff ffff                                   ....

c0d0c5bd <FORBIDDEN_CHANNEL>:
c0d0c5bd:	0000 0000                                   ....

c0d0c5c1 <EIP_712_MAGIC>:
c0d0c5c1:	0119 4945 3750 3231 6820 7361 2068 6f74     ..EIP712 hash to
c0d0c5d1:	7320 6769 206e 2e25 482a 000a 7041 6c70      sign %.*H..Appl
c0d0c5e1:	6369 7461 6f69 006e 7369 7220 6165 7964     ication.is ready
c0d0c5f1:	5600 7265 6973 6e6f 3100 302e 302e 5300     .Version.1.0.0.S
c0d0c601:	7465 6974 676e 0073 7551 7469 4300 6e6f     ettings.Quit.Con
c0d0c611:	7274 6361 2074 6164 6174 4400 6265 6775     tract data.Debug
c0d0c621:	6420 7461 0061 6142 6b63 4e00 544f 4120      data.Back.NOT A
c0d0c631:	6c6c 776f 6465 4e00 544f 4420 7369 6c70     llowed.NOT Displ
c0d0c641:	7961 6465 0000                               ayed...

c0d0c648 <ux_idle_flow_1_step_val>:
c0d0c648:	c5dd c0d0 c5e9 c0d0                         ........

c0d0c650 <ux_idle_flow_1_step>:
c0d0c650:	9ddd c0d0 c648 c0d0 0000 0000 0000 0000     ....H...........

c0d0c660 <ux_idle_flow_2_step_val>:
c0d0c660:	c5f2 c0d0 c5fa c0d0                         ........

c0d0c668 <ux_idle_flow_2_step>:
c0d0c668:	9d91 c0d0 c660 c0d0 0000 0000 0000 0000     ....`...........

c0d0c678 <ux_idle_flow_3_step_validate_step>:
c0d0c678:	7a35 c0d0 0000 0000 0000 0000 0000 0000     5z..............

c0d0c688 <ux_idle_flow_3_step_validate>:
c0d0c688:	c678 c0d0 ffff ffff                         x.......

c0d0c690 <ux_idle_flow_3_step_val>:
c0d0c690:	baec c0d0 c600 c0d0                         ........

c0d0c698 <ux_idle_flow_3_step>:
c0d0c698:	a1b5 c0d0 c690 c0d0 c688 c0d0 0000 0000     ................

c0d0c6a8 <ux_idle_flow_4_step_validate_step>:
c0d0c6a8:	7aa9 c0d0 0000 0000 0000 0000 0000 0000     .z..............

c0d0c6b8 <ux_idle_flow_4_step_validate>:
c0d0c6b8:	c6a8 c0d0 ffff ffff                         ........

c0d0c6c0 <ux_idle_flow_4_step_val>:
c0d0c6c0:	bab4 c0d0 c609 c0d0                         ........

c0d0c6c8 <ux_idle_flow_4_step>:
c0d0c6c8:	a1b5 c0d0 c6c0 c0d0 c6b8 c0d0 0000 0000     ................

c0d0c6d8 <ux_idle_flow>:
c0d0c6d8:	c650 c0d0 c668 c0d0 c698 c0d0 c6c8 c0d0     P...h...........
c0d0c6e8:	fffd ffff ffff ffff                         ........

c0d0c6f0 <ux_settings_flow_1_step_validate_step>:
c0d0c6f0:	7ab3 c0d0 0000 0000 0000 0000 0000 0000     .z..............

c0d0c700 <ux_settings_flow_1_step_validate>:
c0d0c700:	c6f0 c0d0 ffff ffff                         ........

c0d0c708 <ux_settings_flow_1_step_val>:
c0d0c708:	c60e c0d0 1cca 2000                         ....... 

c0d0c710 <ux_settings_flow_1_step>:
c0d0c710:	a0d5 c0d0 c708 c0d0 c700 c0d0 0000 0000     ................

c0d0c720 <ux_settings_flow_2_step_validate_step>:
c0d0c720:	7af1 c0d0 0000 0000 0000 0000 0000 0000     .z..............

c0d0c730 <ux_settings_flow_2_step_validate>:
c0d0c730:	c720 c0d0 ffff ffff                          .......

c0d0c738 <ux_settings_flow_2_step_val>:
c0d0c738:	c61c c0d0 1cde 2000                         ....... 

c0d0c740 <ux_settings_flow_2_step>:
c0d0c740:	a0d5 c0d0 c738 c0d0 c730 c0d0 0000 0000     ....8...0.......

c0d0c750 <ux_settings_flow_3_step_validate_step>:
c0d0c750:	7b2d c0d0 0000 0000 0000 0000 0000 0000     -{..............

c0d0c760 <ux_settings_flow_3_step_validate>:
c0d0c760:	c750 c0d0 ffff ffff                         P.......

c0d0c768 <ux_settings_flow_3_step_val>:
c0d0c768:	ba0c c0d0 c627 c0d0                         ....'...

c0d0c770 <ux_settings_flow_3_step>:
c0d0c770:	a1b5 c0d0 c768 c0d0 c760 c0d0 0000 0000     ....h...`.......

c0d0c780 <ux_settings_flow>:
c0d0c780:	c710 c0d0 c740 c0d0 c770 c0d0 ffff ffff     ....@...p.......
c0d0c790:	6556 6972 7966 6100 6464 6572 7373 4100     Verify.address.A
c0d0c7a0:	7070 6f72 6576 0000                         pprove..

c0d0c7a8 <ux_display_public_flow_1_step_val>:
c0d0c7a8:	baec c0d0 c790 c0d0 c797 c0d0               ............

c0d0c7b4 <ux_display_public_flow_1_step>:
c0d0c7b4:	a311 c0d0 c7a8 c0d0 0000 0000 0000 0000     ................

c0d0c7c4 <ux_display_public_flow_2_step_val>:
c0d0c7c4:	cdd0 c0d0 1cca 2000                         ....... 

c0d0c7cc <ux_display_public_flow_2_step>:
c0d0c7cc:	a0d5 c0d0 c7c4 c0d0 0000 0000 0000 0000     ................

c0d0c7dc <ux_display_public_flow_3_step_validate_step>:
c0d0c7dc:	7b35 c0d0 0000 0000 0000 0000 0000 0000     5{..............

c0d0c7ec <ux_display_public_flow_3_step_validate>:
c0d0c7ec:	c7dc c0d0 ffff ffff                         ........

c0d0c7f4 <ux_display_public_flow_3_step_val>:
c0d0c7f4:	bb64 c0d0 c79f c0d0                         d.......

c0d0c7fc <ux_display_public_flow_3_step>:
c0d0c7fc:	a1b5 c0d0 c7f4 c0d0 c7ec c0d0 0000 0000     ................

c0d0c80c <ux_display_public_flow_4_step_validate_step>:
c0d0c80c:	7b3f c0d0 0000 0000 0000 0000 0000 0000     ?{..............

c0d0c81c <ux_display_public_flow_4_step_validate>:
c0d0c81c:	c80c c0d0 ffff ffff                         ........

c0d0c824 <ux_display_public_flow_4_step_val>:
c0d0c824:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0c82c <ux_display_public_flow_4_step>:
c0d0c82c:	a1b5 c0d0 c824 c0d0 c81c c0d0 0000 0000     ....$...........

c0d0c83c <ux_display_public_flow>:
c0d0c83c:	c7b4 c0d0 c7cc c0d0 c7fc c0d0 c82c c0d0     ............,...
c0d0c84c:	ffff ffff 654d 7373 6761 2065 6168 6873     ....Message hash
c0d0c85c:	4300 6e61 6563 006c 6973 6e67 7461 7275     .Cancel.signatur
c0d0c86c:	0065 0000                                   e...

c0d0c870 <ux_sign_flow_1_step_val>:
c0d0c870:	ba44 c0d0 d105 c0d0 c926 c0d0               D.......&...

c0d0c87c <ux_sign_flow_1_step>:
c0d0c87c:	a311 c0d0 c870 c0d0 0000 0000 0000 0000     ....p...........

c0d0c88c <ux_sign_flow_2_step_val>:
c0d0c88c:	c850 c0d0 1cca 2000                         P...... 

c0d0c894 <ux_sign_flow_2_step>:
c0d0c894:	a0d5 c0d0 c88c c0d0 0000 0000 0000 0000     ................

c0d0c8a4 <ux_sign_flow_3_step_validate_step>:
c0d0c8a4:	7b49 c0d0 0000 0000 0000 0000 0000 0000     I{..............

c0d0c8b4 <ux_sign_flow_3_step_validate>:
c0d0c8b4:	c8a4 c0d0 ffff ffff                         ........

c0d0c8bc <ux_sign_flow_3_step_val>:
c0d0c8bc:	bb64 c0d0 d105 c0d0 c926 c0d0               d.......&...

c0d0c8c8 <ux_sign_flow_3_step>:
c0d0c8c8:	a2a5 c0d0 c8bc c0d0 c8b4 c0d0 0000 0000     ................

c0d0c8d8 <ux_sign_flow_4_step_validate_step>:
c0d0c8d8:	7b53 c0d0 0000 0000 0000 0000 0000 0000     S{..............

c0d0c8e8 <ux_sign_flow_4_step_validate>:
c0d0c8e8:	c8d8 c0d0 ffff ffff                         ........

c0d0c8f0 <ux_sign_flow_4_step_val>:
c0d0c8f0:	ba7c c0d0 c85d c0d0 c864 c0d0               |...]...d...

c0d0c8fc <ux_sign_flow_4_step>:
c0d0c8fc:	a2a5 c0d0 c8f0 c0d0 c8e8 c0d0 0000 0000     ................

c0d0c90c <ux_sign_flow>:
c0d0c90c:	c87c c0d0 c894 c0d0 c8c8 c0d0 c8fc c0d0     |...............
c0d0c91c:	ffff ffff 7974 6570 2064 656d 7373 6761     ....typed messag
c0d0c92c:	0065 6f44 616d 6e69 6820 7361 0068 0000     e.Domain hash...

c0d0c93c <ux_sign_712_v0_flow_1_step_val>:
c0d0c93c:	ba44 c0d0 d105 c0d0 c920 c0d0               D....... ...

c0d0c948 <ux_sign_712_v0_flow_1_step>:
c0d0c948:	a311 c0d0 c93c c0d0 0000 0000 0000 0000     ....<...........

c0d0c958 <ux_sign_712_v0_flow_2_step_val>:
c0d0c958:	c92e c0d0 1cca 2000                         ....... 

c0d0c960 <ux_sign_712_v0_flow_2_step>:
c0d0c960:	7b5d c0d0 c958 c0d0 0000 0000 0000 0000     ]{..X...........

c0d0c970 <ux_sign_712_v0_flow_3_step_val>:
c0d0c970:	c850 c0d0 1cca 2000                         P...... 

c0d0c978 <ux_sign_712_v0_flow_3_step>:
c0d0c978:	7b91 c0d0 c970 c0d0 0000 0000 0000 0000     .{..p...........

c0d0c988 <ux_sign_712_v0_flow_4_step_validate_step>:
c0d0c988:	7bc5 c0d0 0000 0000 0000 0000 0000 0000     .{..............

c0d0c998 <ux_sign_712_v0_flow_4_step_validate>:
c0d0c998:	c988 c0d0 ffff ffff                         ........

c0d0c9a0 <ux_sign_712_v0_flow_4_step_val>:
c0d0c9a0:	bb64 c0d0 d105 c0d0 c926 c0d0               d.......&...

c0d0c9ac <ux_sign_712_v0_flow_4_step>:
c0d0c9ac:	a2a5 c0d0 c9a0 c0d0 c998 c0d0 0000 0000     ................

c0d0c9bc <ux_sign_712_v0_flow_5_step_validate_step>:
c0d0c9bc:	7bcf c0d0 0000 0000 0000 0000 0000 0000     .{..............

c0d0c9cc <ux_sign_712_v0_flow_5_step_validate>:
c0d0c9cc:	c9bc c0d0 ffff ffff                         ........

c0d0c9d4 <ux_sign_712_v0_flow_5_step_val>:
c0d0c9d4:	ba7c c0d0 c85d c0d0 c864 c0d0               |...]...d...

c0d0c9e0 <ux_sign_712_v0_flow_5_step>:
c0d0c9e0:	a2a5 c0d0 c9d4 c0d0 c9cc c0d0 0000 0000     ................

c0d0c9f0 <ux_sign_712_v0_flow>:
c0d0c9f0:	c948 c0d0 c960 c0d0 c978 c0d0 c9ac c0d0     H...`...x.......
c0d0ca00:	c9e0 c0d0 ffff ffff 6573 656c 7463 726f     ........selector
c0d0ca10:	5300 6c65 6365 6f74 0072 6150 6172 656d     .Selector.Parame
c0d0ca20:	6574 0072 7274 6e61 6173 7463 6f69 006e     ter.transaction.
c0d0ca30:	6144 6174 5000 6572 6573 746e 0000 0000     Data.Present....

c0d0ca40 <ux_confirm_selector_flow_1_step_val>:
c0d0ca40:	baec c0d0 c790 c0d0 ca08 c0d0               ............

c0d0ca4c <ux_confirm_selector_flow_1_step>:
c0d0ca4c:	a311 c0d0 ca40 c0d0 0000 0000 0000 0000     ....@...........

c0d0ca5c <ux_confirm_selector_flow_2_step_val>:
c0d0ca5c:	ca11 c0d0 1cca 2000                         ....... 

c0d0ca64 <ux_confirm_selector_flow_2_step>:
c0d0ca64:	9d91 c0d0 ca5c c0d0 0000 0000 0000 0000     ....\...........

c0d0ca74 <ux_confirm_selector_flow_3_step_validate_step>:
c0d0ca74:	7bd9 c0d0 0000 0000 0000 0000 0000 0000     .{..............

c0d0ca84 <ux_confirm_selector_flow_3_step_validate>:
c0d0ca84:	ca74 c0d0 ffff ffff                         t.......

c0d0ca8c <ux_confirm_selector_flow_3_step_val>:
c0d0ca8c:	bb64 c0d0 c79f c0d0                         d.......

c0d0ca94 <ux_confirm_selector_flow_3_step>:
c0d0ca94:	a1b5 c0d0 ca8c c0d0 ca84 c0d0 0000 0000     ................

c0d0caa4 <ux_confirm_selector_flow_4_step_validate_step>:
c0d0caa4:	7be3 c0d0 0000 0000 0000 0000 0000 0000     .{..............

c0d0cab4 <ux_confirm_selector_flow_4_step_validate>:
c0d0cab4:	caa4 c0d0 ffff ffff                         ........

c0d0cabc <ux_confirm_selector_flow_4_step_val>:
c0d0cabc:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0cac4 <ux_confirm_selector_flow_4_step>:
c0d0cac4:	a1b5 c0d0 cabc c0d0 cab4 c0d0 0000 0000     ................

c0d0cad4 <ux_confirm_selector_flow>:
c0d0cad4:	ca4c c0d0 ca64 c0d0 ca94 c0d0 cac4 c0d0     L...d...........
c0d0cae4:	ffff ffff                                   ....

c0d0cae8 <ux_confirm_parameter_flow_1_step_val>:
c0d0cae8:	baec c0d0 c790 c0d0 1d2e 2000               ........... 

c0d0caf4 <ux_confirm_parameter_flow_1_step>:
c0d0caf4:	a311 c0d0 cae8 c0d0 0000 0000 0000 0000     ................

c0d0cb04 <ux_confirm_parameter_flow_2_step_val>:
c0d0cb04:	ca1a c0d0 1cca 2000                         ....... 

c0d0cb0c <ux_confirm_parameter_flow_2_step>:
c0d0cb0c:	a0d5 c0d0 cb04 c0d0 0000 0000 0000 0000     ................

c0d0cb1c <ux_confirm_parameter_flow_3_step_validate_step>:
c0d0cb1c:	7bed c0d0 0000 0000 0000 0000 0000 0000     .{..............

c0d0cb2c <ux_confirm_parameter_flow_3_step_validate>:
c0d0cb2c:	cb1c c0d0 ffff ffff                         ........

c0d0cb34 <ux_confirm_parameter_flow_3_step_val>:
c0d0cb34:	bb64 c0d0 c79f c0d0                         d.......

c0d0cb3c <ux_confirm_parameter_flow_3_step>:
c0d0cb3c:	a1b5 c0d0 cb34 c0d0 cb2c c0d0 0000 0000     ....4...,.......

c0d0cb4c <ux_confirm_parameter_flow_4_step_validate_step>:
c0d0cb4c:	7bf7 c0d0 0000 0000 0000 0000 0000 0000     .{..............

c0d0cb5c <ux_confirm_parameter_flow_4_step_validate>:
c0d0cb5c:	cb4c c0d0 ffff ffff                         L.......

c0d0cb64 <ux_confirm_parameter_flow_4_step_val>:
c0d0cb64:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0cb6c <ux_confirm_parameter_flow_4_step>:
c0d0cb6c:	a1b5 c0d0 cb64 c0d0 cb5c c0d0 0000 0000     ....d...\.......

c0d0cb7c <ux_confirm_parameter_flow>:
c0d0cb7c:	caf4 c0d0 cb0c c0d0 cb3c c0d0 cb6c c0d0     ........<...l...
c0d0cb8c:	ffff ffff                                   ....

c0d0cb90 <ux_approval_tx_1_step_val>:
c0d0cb90:	baec c0d0 b8a4 c0d0 ca24 c0d0               ........$...

c0d0cb9c <ux_approval_tx_1_step>:
c0d0cb9c:	a311 c0d0 cb90 c0d0 0000 0000 0000 0000     ................

c0d0cbac <ux_approval_tx_2_step_val>:
c0d0cbac:	b042 c0d0 1cf5 2000                         B...... 

c0d0cbb4 <ux_approval_tx_2_step>:
c0d0cbb4:	a0d5 c0d0 cbac c0d0 0000 0000 0000 0000     ................

c0d0cbc4 <ux_approval_tx_3_step_val>:
c0d0cbc4:	cdd0 c0d0 1cca 2000                         ....... 

c0d0cbcc <ux_approval_tx_3_step>:
c0d0cbcc:	a0d5 c0d0 cbc4 c0d0 0000 0000 0000 0000     ................

c0d0cbdc <ux_approval_tx_4_step_val>:
c0d0cbdc:	b8b9 c0d0 1d27 2000                         ....'.. 

c0d0cbe4 <ux_approval_tx_4_step>:
c0d0cbe4:	a0d5 c0d0 cbdc c0d0 0000 0000 0000 0000     ................

c0d0cbf4 <ux_approval_tx_5_step_validate_step>:
c0d0cbf4:	7c01 c0d0 0000 0000 0000 0000 0000 0000     .|..............

c0d0cc04 <ux_approval_tx_5_step_validate>:
c0d0cc04:	cbf4 c0d0 ffff ffff                         ........

c0d0cc0c <ux_approval_tx_5_step_val>:
c0d0cc0c:	bb64 c0d0 b8c2 c0d0 b8c9 c0d0               d...........

c0d0cc18 <ux_approval_tx_5_step>:
c0d0cc18:	a2a5 c0d0 cc0c c0d0 cc04 c0d0 0000 0000     ................

c0d0cc28 <ux_approval_tx_6_step_validate_step>:
c0d0cc28:	7c0b c0d0 0000 0000 0000 0000 0000 0000     .|..............

c0d0cc38 <ux_approval_tx_6_step_validate>:
c0d0cc38:	cc28 c0d0 ffff ffff                         (.......

c0d0cc40 <ux_approval_tx_6_step_val>:
c0d0cc40:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0cc48 <ux_approval_tx_6_step>:
c0d0cc48:	a1b5 c0d0 cc40 c0d0 cc38 c0d0 0000 0000     ....@...8.......

c0d0cc58 <ux_approval_tx_data_warning_step_val>:
c0d0cc58:	bb9c c0d0 ca30 c0d0 ca35 c0d0               ....0...5...

c0d0cc64 <ux_approval_tx_data_warning_step>:
c0d0cc64:	a2a5 c0d0 cc58 c0d0 0000 0000 0000 0000     ....X...........

c0d0cc74 <ux_approval_tx_flow>:
c0d0cc74:	cb9c c0d0 cbb4 c0d0 cbcc c0d0 cbe4 c0d0     ................
c0d0cc84:	cc18 c0d0 cc48 c0d0 ffff ffff               ....H.......

c0d0cc90 <ux_approval_tx_data_warning_flow>:
c0d0cc90:	cb9c c0d0 cc64 c0d0 cbb4 c0d0 cbcc c0d0     ....d...........
c0d0cca0:	cbe4 c0d0 cc18 c0d0 cc48 c0d0 ffff ffff     ........H.......
c0d0ccb0:	7453 7261 206b 656b 0079 7453 7261 206b     Stark key.Stark 
c0d0ccc0:	654b 0079                                   Key.

c0d0ccc4 <ux_display_stark_public_flow_1_step_val>:
c0d0ccc4:	baec c0d0 c790 c0d0 ccb0 c0d0               ............

c0d0ccd0 <ux_display_stark_public_flow_1_step>:
c0d0ccd0:	a311 c0d0 ccc4 c0d0 0000 0000 0000 0000     ................

c0d0cce0 <ux_display_stark_public_flow_2_step_val>:
c0d0cce0:	ccba c0d0 1cca 2000                         ....... 

c0d0cce8 <ux_display_stark_public_flow_2_step>:
c0d0cce8:	a0d5 c0d0 cce0 c0d0 0000 0000 0000 0000     ................

c0d0ccf8 <ux_display_stark_public_flow_3_step_validate_step>:
c0d0ccf8:	7c15 c0d0 0000 0000 0000 0000 0000 0000     .|..............

c0d0cd08 <ux_display_stark_public_flow_3_step_validate>:
c0d0cd08:	ccf8 c0d0 ffff ffff                         ........

c0d0cd10 <ux_display_stark_public_flow_3_step_val>:
c0d0cd10:	bb64 c0d0 c79f c0d0                         d.......

c0d0cd18 <ux_display_stark_public_flow_3_step>:
c0d0cd18:	a1b5 c0d0 cd10 c0d0 cd08 c0d0 0000 0000     ................

c0d0cd28 <ux_display_stark_public_flow_4_step_validate_step>:
c0d0cd28:	7c1f c0d0 0000 0000 0000 0000 0000 0000     .|..............

c0d0cd38 <ux_display_stark_public_flow_4_step_validate>:
c0d0cd38:	cd28 c0d0 ffff ffff                         (.......

c0d0cd40 <ux_display_stark_public_flow_4_step_val>:
c0d0cd40:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0cd48 <ux_display_stark_public_flow_4_step>:
c0d0cd48:	a1b5 c0d0 cd40 c0d0 cd38 c0d0 0000 0000     ....@...8.......

c0d0cd58 <ux_display_stark_public_flow>:
c0d0cd58:	ccd0 c0d0 cce8 c0d0 cd18 c0d0 cd48 c0d0     ............H...
c0d0cd68:	ffff ffff 694c 696d 0074 724f 6564 0072     ....Limit.Order.
c0d0cd78:	7254 6461 6e69 0067 6150 7269 5300 6c65     Trading.Pair.Sel
c0d0cd88:	006c 7542 0079 6f54 656b 206e 6341 6f63     l.Buy.Token Acco
c0d0cd98:	6e75 0074 6553 666c 4300 6e6f 6964 6974     unt.Self.Conditi
c0d0cda8:	6e6f 6c61 5300 6c65 2066 7254 6e61 6673     onal.Self Transf
c0d0cdb8:	7265 4d00 7361 6574 2072 6341 6f63 6e75     er.Master Accoun
c0d0cdc8:	0074 6f43 646e 202e 6441 7264 7365 0073     t.Cond. Address.
c0d0cdd8:	6f43 646e 202e 6146 7463 0000               Cond. Fact..

c0d0cde4 <ux_stark_limit_order_1_step_val>:
c0d0cde4:	baec c0d0 b8a4 c0d0 ca24 c0d0               ........$...

c0d0cdf0 <ux_stark_limit_order_1_step>:
c0d0cdf0:	a311 c0d0 cde4 c0d0 0000 0000 0000 0000     ................

c0d0ce00 <ux_stark_limit_order_2_step_val>:
c0d0ce00:	cd6c c0d0 cd72 c0d0                         l...r...

c0d0ce08 <ux_stark_limit_order_2_step>:
c0d0ce08:	a0d5 c0d0 ce00 c0d0 0000 0000 0000 0000     ................

c0d0ce18 <ux_stark_limit_order_3_step_val>:
c0d0ce18:	cd78 c0d0 cd80 c0d0                         x.......

c0d0ce20 <ux_stark_limit_order_3_step>:
c0d0ce20:	a0d5 c0d0 ce18 c0d0 0000 0000 0000 0000     ................

c0d0ce30 <ux_stark_limit_order_4_step_val>:
c0d0ce30:	cd85 c0d0 1cf5 2000                         ....... 

c0d0ce38 <ux_stark_limit_order_4_step>:
c0d0ce38:	a0d5 c0d0 ce30 c0d0 0000 0000 0000 0000     ....0...........

c0d0ce48 <ux_stark_limit_order_5_step_val>:
c0d0ce48:	cd8a c0d0 1d27 2000                         ....'.. 

c0d0ce50 <ux_stark_limit_order_5_step>:
c0d0ce50:	a0d5 c0d0 ce48 c0d0 0000 0000 0000 0000     ....H...........

c0d0ce60 <ux_stark_limit_order_6_step_val>:
c0d0ce60:	cd8e c0d0 1cca 2000                         ....... 

c0d0ce68 <ux_stark_limit_order_6_step>:
c0d0ce68:	a0d5 c0d0 ce60 c0d0 0000 0000 0000 0000     ....`...........

c0d0ce78 <ux_stark_limit_order_7_step_validate_step>:
c0d0ce78:	7c29 c0d0 0000 0000 0000 0000 0000 0000     )|..............

c0d0ce88 <ux_stark_limit_order_7_step_validate>:
c0d0ce88:	ce78 c0d0 ffff ffff                         x.......

c0d0ce90 <ux_stark_limit_order_7_step_val>:
c0d0ce90:	bb64 c0d0 b8c2 c0d0 b8c9 c0d0               d...........

c0d0ce9c <ux_stark_limit_order_7_step>:
c0d0ce9c:	a2a5 c0d0 ce90 c0d0 ce88 c0d0 0000 0000     ................

c0d0ceac <ux_stark_limit_order_8_step_validate_step>:
c0d0ceac:	7c33 c0d0 0000 0000 0000 0000 0000 0000     3|..............

c0d0cebc <ux_stark_limit_order_8_step_validate>:
c0d0cebc:	ceac c0d0 ffff ffff                         ........

c0d0cec4 <ux_stark_limit_order_8_step_val>:
c0d0cec4:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0cecc <ux_stark_limit_order_8_step>:
c0d0cecc:	a1b5 c0d0 cec4 c0d0 cebc c0d0 0000 0000     ................

c0d0cedc <ux_stark_limit_order_flow>:
c0d0cedc:	cdf0 c0d0 ce08 c0d0 ce20 c0d0 ce38 c0d0     ........ ...8...
c0d0ceec:	ce50 c0d0 ce68 c0d0 ce9c c0d0 cecc c0d0     P...h...........
c0d0cefc:	ffff ffff                                   ....

c0d0cf00 <ux_stark_transfer_1_step_val>:
c0d0cf00:	baec c0d0 b8a4 c0d0 ca24 c0d0               ........$...

c0d0cf0c <ux_stark_transfer_1_step>:
c0d0cf0c:	a311 c0d0 cf00 c0d0 0000 0000 0000 0000     ................

c0d0cf1c <ux_stark_transfer_2_step_val>:
c0d0cf1c:	cdb2 c0d0 be40 c0d0                         ....@...

c0d0cf24 <ux_stark_transfer_2_step>:
c0d0cf24:	a0d5 c0d0 cf1c c0d0 0000 0000 0000 0000     ................

c0d0cf34 <ux_stark_self_transfer_2_step_val>:
c0d0cf34:	cd9c c0d0 cdb2 c0d0                         ........

c0d0cf3c <ux_stark_self_transfer_2_step>:
c0d0cf3c:	a0d5 c0d0 cf34 c0d0 0000 0000 0000 0000     ....4...........

c0d0cf4c <ux_stark_conditional_transfer_2_step_val>:
c0d0cf4c:	cda1 c0d0 cdb2 c0d0                         ........

c0d0cf54 <ux_stark_conditional_transfer_2_step>:
c0d0cf54:	a0d5 c0d0 cf4c c0d0 0000 0000 0000 0000     ....L...........

c0d0cf64 <ux_stark_self_conditional_transfer_2_step_val>:
c0d0cf64:	cda1 c0d0 cdad c0d0                         ........

c0d0cf6c <ux_stark_self_conditional_transfer_2_step>:
c0d0cf6c:	a0d5 c0d0 cf64 c0d0 0000 0000 0000 0000     ....d...........

c0d0cf7c <ux_stark_transfer_3_step_val>:
c0d0cf7c:	b042 c0d0 18dc 2000                         B...... 

c0d0cf84 <ux_stark_transfer_3_step>:
c0d0cf84:	a0d5 c0d0 cf7c c0d0 0000 0000 0000 0000     ....|...........

c0d0cf94 <ux_stark_transfer_4_step_val>:
c0d0cf94:	cdbb c0d0 1cca 2000                         ....... 

c0d0cf9c <ux_stark_transfer_4_step>:
c0d0cf9c:	a0d5 c0d0 cf94 c0d0 0000 0000 0000 0000     ................

c0d0cfac <ux_stark_transfer_5_step_val>:
c0d0cfac:	cd8e c0d0 1d2e 2000                         ....... 

c0d0cfb4 <ux_stark_transfer_5_step>:
c0d0cfb4:	a0d5 c0d0 cfac c0d0 0000 0000 0000 0000     ................

c0d0cfc4 <ux_stark_transfer_6_step_validate_step>:
c0d0cfc4:	7c3d c0d0 0000 0000 0000 0000 0000 0000     =|..............

c0d0cfd4 <ux_stark_transfer_6_step_validate>:
c0d0cfd4:	cfc4 c0d0 ffff ffff                         ........

c0d0cfdc <ux_stark_transfer_6_step_val>:
c0d0cfdc:	bb64 c0d0 b8c2 c0d0 b8c9 c0d0               d...........

c0d0cfe8 <ux_stark_transfer_6_step>:
c0d0cfe8:	a2a5 c0d0 cfdc c0d0 cfd4 c0d0 0000 0000     ................

c0d0cff8 <ux_stark_transfer_7_step_validate_step>:
c0d0cff8:	7c47 c0d0 0000 0000 0000 0000 0000 0000     G|..............

c0d0d008 <ux_stark_transfer_7_step_validate>:
c0d0d008:	cff8 c0d0 ffff ffff                         ........

c0d0d010 <ux_stark_transfer_7_step_val>:
c0d0d010:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0d018 <ux_stark_transfer_7_step>:
c0d0d018:	a1b5 c0d0 d010 c0d0 d008 c0d0 0000 0000     ................

c0d0d028 <ux_stark_conditional_transfer_4_step_val>:
c0d0d028:	cdbb c0d0 1cca 2000                         ....... 

c0d0d030 <ux_stark_conditional_transfer_4_step>:
c0d0d030:	7c51 c0d0 d028 c0d0 0000 0000 0000 0000     Q|..(...........

c0d0d040 <ux_stark_conditional_transfer_8_step_val>:
c0d0d040:	cdca c0d0 1cca 2000                         ....... 

c0d0d048 <ux_stark_conditional_transfer_8_step>:
c0d0d048:	7c85 c0d0 d040 c0d0 0000 0000 0000 0000     .|..@...........

c0d0d058 <ux_stark_conditional_transfer_9_step_val>:
c0d0d058:	cdd8 c0d0 1cca 2000                         ....... 

c0d0d060 <ux_stark_conditional_transfer_9_step>:
c0d0d060:	7cc1 c0d0 d058 c0d0 0000 0000 0000 0000     .|..X...........

c0d0d070 <ux_stark_transfer_flow>:
c0d0d070:	cf0c c0d0 cf24 c0d0 cf84 c0d0 cf9c c0d0     ....$...........
c0d0d080:	cfb4 c0d0 cfe8 c0d0 d018 c0d0 ffff ffff     ................

c0d0d090 <ux_stark_self_transfer_flow>:
c0d0d090:	cf0c c0d0 cf3c c0d0 cf84 c0d0 cfb4 c0d0     ....<...........
c0d0d0a0:	cfe8 c0d0 d018 c0d0 ffff ffff               ............

c0d0d0ac <ux_stark_transfer_conditional_flow>:
c0d0d0ac:	cf0c c0d0 cf54 c0d0 cf84 c0d0 d030 c0d0     ....T.......0...
c0d0d0bc:	cfb4 c0d0 d048 c0d0 d060 c0d0 cfe8 c0d0     ....H...`.......
c0d0d0cc:	d018 c0d0 ffff ffff                         ........

c0d0d0d4 <ux_stark_self_transfer_conditional_flow>:
c0d0d0d4:	cf0c c0d0 cf6c c0d0 cf84 c0d0 cfb4 c0d0     ....l...........
c0d0d0e4:	d048 c0d0 d060 c0d0 cfe8 c0d0 d018 c0d0     H...`...........
c0d0d0f4:	ffff ffff 6e55 6173 6566 5300 6174 6b72     ....Unsafe.Stark
c0d0d104:	5320 6769 006e 7246 6d6f 4120 6363 756f      Sign.From Accou
c0d0d114:	746e 4800 7361 0068                         nt.Hash.

c0d0d11c <ux_stark_unsafe_sign_1_step_val>:
c0d0d11c:	bb9c c0d0 d0f8 c0d0 d0ff c0d0               ............

c0d0d128 <ux_stark_unsafe_sign_1_step>:
c0d0d128:	a311 c0d0 d11c c0d0 0000 0000 0000 0000     ................

c0d0d138 <ux_stark_unsafe_sign_2_step_val>:
c0d0d138:	d10a c0d0 1cca 2000                         ....... 

c0d0d140 <ux_stark_unsafe_sign_2_step>:
c0d0d140:	7cf5 c0d0 d138 c0d0 0000 0000 0000 0000     .|..8...........

c0d0d150 <ux_stark_unsafe_sign_3_step_val>:
c0d0d150:	d117 c0d0 1cca 2000                         ....... 

c0d0d158 <ux_stark_unsafe_sign_3_step>:
c0d0d158:	7d25 c0d0 d150 c0d0 0000 0000 0000 0000     %}..P...........

c0d0d168 <ux_stark_unsafe_sign_4_step_validate_step>:
c0d0d168:	7d59 c0d0 0000 0000 0000 0000 0000 0000     Y}..............

c0d0d178 <ux_stark_unsafe_sign_4_step_validate>:
c0d0d178:	d168 c0d0 ffff ffff                         h.......

c0d0d180 <ux_stark_unsafe_sign_4_step_val>:
c0d0d180:	bb64 c0d0 b8c2 c0d0 b8c9 c0d0               d...........

c0d0d18c <ux_stark_unsafe_sign_4_step>:
c0d0d18c:	a2a5 c0d0 d180 c0d0 d178 c0d0 0000 0000     ........x.......

c0d0d19c <ux_stark_unsafe_sign_5_step_validate_step>:
c0d0d19c:	7d63 c0d0 0000 0000 0000 0000 0000 0000     c}..............

c0d0d1ac <ux_stark_unsafe_sign_5_step_validate>:
c0d0d1ac:	d19c c0d0 ffff ffff                         ........

c0d0d1b4 <ux_stark_unsafe_sign_5_step_val>:
c0d0d1b4:	ba7c c0d0 b8d2 c0d0                         |.......

c0d0d1bc <ux_stark_unsafe_sign_5_step>:
c0d0d1bc:	a1b5 c0d0 d1b4 c0d0 d1ac c0d0 0000 0000     ................

c0d0d1cc <ux_stark_unsafe_sign_flow>:
c0d0d1cc:	d128 c0d0 d140 c0d0 d158 c0d0 d18c c0d0     (...@...X.......
c0d0d1dc:	d1bc c0d0 ffff ffff                         ........

c0d0d1e4 <USBD_HID_Desc_fido>:
c0d0d1e4:	2109 0111 0121 2222 0000 0000               .!..!.""....

c0d0d1f0 <USBD_HID_Desc>:
c0d0d1f0:	2109 0111 0100 2222                          .!...."".

c0d0d1f9 <HID_ReportDesc_fido>:
c0d0d1f9:	d006 09f1 a101 0901 1503 2600 00ff 0875     ...........&..u.
c0d0d209:	4095 0881 0409 0015 ff26 7500 9508 9140     .@......&..u..@.
c0d0d219:	c008                                        ..

c0d0d21b <HID_ReportDesc>:
c0d0d21b:	a006 09ff a101 0901 1503 2600 00ff 0875     ...........&..u.
c0d0d22b:	4095 0881 0409 0015 ff26 7500 9508 9140     .@......&..u..@.
c0d0d23b:	c008                                        ..

c0d0d23d <C_usb_bos>:
c0d0d23d:	0f05 0039 1802 0510 3800 08b6 a934 a009     ..9......8..4...
c0d0d24d:	8b47 a0fd 8876 b615 0065 1e01 1c00 0510     G...v...e.......
c0d0d25d:	df00 dd60 89d8 c745 9c4c 65d2 9e9d 8a64     ..`...E.L..e..d.
c0d0d26d:	009f 0300 b206 7700 0000                     .......w...

c0d0d278 <HID_Desc>:
c0d0d278:	9545 c0d0 9555 c0d0 9565 c0d0 9575 c0d0     E...U...e...u...
c0d0d288:	9585 c0d0 9595 c0d0 95a5 c0d0 95b5 c0d0     ................

c0d0d298 <C_winusb_string_descriptor>:
c0d0d298:	0312 004d 0053 0046 0054 0031 0030 0030     ..M.S.F.T.1.0.0.
c0d0d2a8:	0077                                        w.

c0d0d2aa <C_winusb_guid>:
c0d0d2aa:	0092 0000 0100 0005 0001 0088 0000 0007     ................
c0d0d2ba:	0000 002a 0044 0065 0076 0069 0063 0065     ..*.D.e.v.i.c.e.
c0d0d2ca:	0049 006e 0074 0065 0072 0066 0061 0063     I.n.t.e.r.f.a.c.
c0d0d2da:	0065 0047 0055 0049 0044 0073 0000 0050     e.G.U.I.D.s...P.
c0d0d2ea:	0000 007b 0031 0033 0064 0036 0033 0034     ..{.1.3.d.6.3.4.
c0d0d2fa:	0030 0030 002d 0032 0043 0039 0037 002d     0.0.-.2.C.9.7.-.
c0d0d30a:	0030 0030 0030 0034 002d 0030 0030 0030     0.0.0.4.-.0.0.0.
c0d0d31a:	0030 002d 0034 0063 0036 0035 0036 0034     0.-.4.c.6.5.6.4.
c0d0d32a:	0036 0037 0036 0035 0037 0032 007d 0000     6.7.6.5.7.2.}...
	...

c0d0d33c <C_winusb_request_descriptor>:
c0d0d33c:	000a 0000 0000 0603 00b2 0008 0001 0000     ................
c0d0d34c:	00a8 0008 0002 0002 00a0 0014 0003 4957     ..............WI
c0d0d35c:	554e 4253 0000 0000 0000 0000 0000 0084     NUSB............
c0d0d36c:	0004 0007 002a 0044 0065 0076 0069 0063     ....*.D.e.v.i.c.
c0d0d37c:	0065 0049 006e 0074 0065 0072 0066 0061     e.I.n.t.e.r.f.a.
c0d0d38c:	0063 0065 0047 0055 0049 0044 0073 0000     c.e.G.U.I.D.s...
c0d0d39c:	0050 007b 0043 0045 0038 0030 0039 0032     P.{.C.E.8.0.9.2.
c0d0d3ac:	0036 0034 002d 0034 0042 0032 0034 002d     6.4.-.4.B.2.4.-.
c0d0d3bc:	0034 0045 0038 0031 002d 0041 0038 0042     4.E.8.1.-.A.8.B.
c0d0d3cc:	0032 002d 0035 0037 0045 0044 0030 0031     2.-.5.7.E.D.0.1.
c0d0d3dc:	0044 0035 0038 0030 0045 0031 007d 0000     D.5.8.0.E.1.}...
c0d0d3ec:	0000 0000                                   ....

c0d0d3f0 <USBD_HID>:
c0d0d3f0:	92ef c0d0 9321 c0d0 9259 c0d0 0000 0000     ....!...Y.......
c0d0d400:	0000 0000 9449 c0d0 9461 c0d0 0000 0000     ....I...a.......
	...
c0d0d418:	9709 c0d0 9709 c0d0 9709 c0d0 9719 c0d0     ................

c0d0d428 <USBD_U2F>:
c0d0d428:	93d1 c0d0 9321 c0d0 9259 c0d0 0000 0000     ....!...Y.......
c0d0d438:	0000 0000 9405 c0d0 941d c0d0 0000 0000     ................
	...
c0d0d450:	9709 c0d0 9709 c0d0 9709 c0d0 9719 c0d0     ................

c0d0d460 <USBD_WEBUSB>:
c0d0d460:	94ad c0d0 94d9 c0d0 94dd c0d0 0000 0000     ................
c0d0d470:	0000 0000 94e1 c0d0 94f9 c0d0 0000 0000     ................
	...
c0d0d488:	9709 c0d0 9709 c0d0 9709 c0d0 9719 c0d0     ................

c0d0d498 <USBD_DeviceDesc>:
c0d0d498:	0112 0210 0000 4000 2c97 1015 0201 0201     .......@.,......
c0d0d4a8:	0103                                        ..

c0d0d4aa <USBD_LangIDDesc>:
c0d0d4aa:	0304 0409                                   ....

c0d0d4ae <USBD_MANUFACTURER_STRING>:
c0d0d4ae:	030e 004c 0065 0064 0067 0065 0072          ..L.e.d.g.e.r.

c0d0d4bc <USBD_PRODUCT_FS_STRING>:
c0d0d4bc:	030e 004e 0061 006e 006f 0020 0053          ..N.a.n.o. .S.

c0d0d4ca <USB_SERIAL_STRING>:
c0d0d4ca:	030a 0030 0030 0030 0031                    ..0.0.0.1.

c0d0d4d4 <C_winusb_wcid>:
c0d0d4d4:	0028 0000 0100 0004 0001 0000 0000 0000     (...............
c0d0d4e4:	0102 4957 554e 4253 0000 0000 0000 0000     ..WINUSB........
	...

c0d0d4fc <USBD_CfgDesc>:
c0d0d4fc:	0209 0060 0103 c002 0932 0004 0200 0003     ..`.....2.......
c0d0d50c:	0200 2109 0111 0100 2222 0700 8205 4003     ...!...."".....@
c0d0d51c:	0100 0507 0302 0040 0901 0104 0200 0103     ......@.........
c0d0d52c:	0201 2109 0111 0121 2222 0700 8105 4003     ...!..!."".....@
c0d0d53c:	0100 0507 0301 0040 0901 0204 0200 ffff     ......@.........
c0d0d54c:	02ff 0507 0383 0040 0701 0305 4003 0100     ......@......@..

c0d0d55c <USBD_DeviceQualifierDesc>:
c0d0d55c:	060a 0200 0000 4000 0001 6e55 7865 6570     .......@..Unexpe
c0d0d56c:	7463 6465 7620 6620 726f 616d 0a74 0000     cted v format...

c0d0d57c <ux_layout_bb_elements>:
c0d0d57c:	0003 0000 0000 0080 0020 0000 0001 0000     ........ .......
c0d0d58c:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0d0d59c:	0105 0002 000c 0004 0007 0000 0000 0000     ................
c0d0d5ac:	ffff 00ff 0000 0000 0000 0000 bb0c c0d0     ................
c0d0d5bc:	0205 007a 000c 0004 0007 0000 0000 0000     ..z.............
c0d0d5cc:	ffff 00ff 0000 0000 0000 0000 bb2c c0d0     ............,...
c0d0d5dc:	1007 0000 000c 0080 0020 0000 0000 0000     ........ .......
c0d0d5ec:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................
c0d0d5fc:	1107 0000 001a 0080 0020 0000 0000 0000     ........ .......
c0d0d60c:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................
c0d0d61c:	7325 2820 6425 252f 2964 2500 0073 6425     %s (%d/%d).%s.%d
c0d0d62c:	252f 0064                                   /%d.

c0d0d630 <ux_layout_pb_elements>:
c0d0d630:	0003 0000 0000 0080 0020 0000 0001 0000     ........ .......
c0d0d640:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0d0d650:	0105 0002 000c 0004 0007 0000 0000 0000     ................
c0d0d660:	ffff 00ff 0000 0000 0000 0000 bb0c c0d0     ................
c0d0d670:	0205 007a 000c 0004 0007 0000 0000 0000     ..z.............
c0d0d680:	ffff 00ff 0000 0000 0000 0000 bb2c c0d0     ............,...
c0d0d690:	1005 0038 0002 0010 0010 0000 0000 0000     ..8.............
c0d0d6a0:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................
c0d0d6b0:	1107 0000 001c 0080 0020 0000 0000 0000     ........ .......
c0d0d6c0:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................

c0d0d6d0 <ux_layout_pbb_elements>:
c0d0d6d0:	0003 0000 0000 0080 0020 0000 0001 0000     ........ .......
c0d0d6e0:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0d0d6f0:	0105 0002 000c 0004 0007 0000 0000 0000     ................
c0d0d700:	ffff 00ff 0000 0000 0000 0000 bb0c c0d0     ................
c0d0d710:	0205 007a 000c 0004 0007 0000 0000 0000     ..z.............
c0d0d720:	ffff 00ff 0000 0000 0000 0000 bb2c c0d0     ............,...
c0d0d730:	0f05 0010 0008 0010 0010 0000 0000 0000     ................
c0d0d740:	ffff 00ff 0000 0000 0000 0000 0000 0000     ................
c0d0d750:	1007 0029 000c 0080 0020 0000 0000 0000     ..)..... .......
c0d0d760:	ffff 00ff 0000 0000 0008 0000 0000 0000     ................
c0d0d770:	1107 0029 001a 0080 0020 0000 0000 0000     ..)..... .......
c0d0d780:	ffff 00ff 0000 0000 0008 0000 0000 0000     ................

c0d0d790 <NFT_ASSET_ID_PREFIX>:
c0d0d790:	464e 3a54 0000 0000                         NFT:....

c0d0d798 <_etext>:
	...

c0d0d7c0 <N_storage_real>:
	...
