
bin/app.elf:     file format elf32-littlearm


Disassembly of section .text:

c0d00000 <main>:
        }
        END_TRY;
    }
}

__attribute__((section(".boot"))) int main(int arg0) {
c0d00000:	b510      	push	{r4, lr}
c0d00002:	4604      	mov	r4, r0
    }
    END_TRY;
    // no return
#else
    // exit critical section
    __asm volatile("cpsie i");
c0d00004:	b662      	cpsie	i

    // ensure exception will work as planned
    os_boot();
c0d00006:	f003 fcc3 	bl	c0d03990 <os_boot>

    if (!arg0) {
c0d0000a:	2c00      	cmp	r4, #0
c0d0000c:	d00d      	beq.n	c0d0002a <main+0x2a>
c0d0000e:	2001      	movs	r0, #1
c0d00010:	0200      	lsls	r0, r0, #8
        coin_main(NULL);
        return 0;
    }

    struct libargs_s *args = (struct libargs_s *) arg0;
    if (args->id != 0x100) {
c0d00012:	6821      	ldr	r1, [r4, #0]
c0d00014:	4281      	cmp	r1, r0
c0d00016:	d105      	bne.n	c0d00024 <main+0x24>
        app_exit();
        return 0;
    }
    switch (args->command) {
c0d00018:	6860      	ldr	r0, [r4, #4]
c0d0001a:	2801      	cmp	r0, #1
c0d0001c:	d10a      	bne.n	c0d00034 <main+0x34>
        case RUN_APPLICATION:
            // coin application launched from dashboard
            if (args->chain_config == NULL)
c0d0001e:	68a0      	ldr	r0, [r4, #8]
c0d00020:	2800      	cmp	r0, #0
c0d00022:	d103      	bne.n	c0d0002c <main+0x2c>
c0d00024:	f003 fbc4 	bl	c0d037b0 <app_exit>
c0d00028:	e002      	b.n	c0d00030 <main+0x30>
c0d0002a:	2000      	movs	r0, #0
c0d0002c:	f003 fbe0 	bl	c0d037f0 <coin_main>
c0d00030:	2000      	movs	r0, #0
            // called as bitcoin or altcoin library
            library_main(args);
    }
#endif
    return 0;
}
c0d00032:	bd10      	pop	{r4, pc}
            library_main(args);
c0d00034:	4620      	mov	r0, r4
c0d00036:	f003 fc55 	bl	c0d038e4 <library_main>
	...

c0d0003c <Base64encode>:

int Base64encode_len(int len) {
    return ((len + 2) / 3 * 4) + 1;
}

int Base64encode(char *encoded, const char *string, int len) {
c0d0003c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0003e:	b082      	sub	sp, #8
c0d00040:	4607      	mov	r7, r0
c0d00042:	9201      	str	r2, [sp, #4]
    int i;
    char *p;

    p = encoded;
    for (i = 0; i < len - 2; i += 3) {
c0d00044:	1e92      	subs	r2, r2, #2
c0d00046:	2400      	movs	r4, #0
c0d00048:	2a01      	cmp	r2, #1
c0d0004a:	db23      	blt.n	c0d00094 <Base64encode+0x58>
c0d0004c:	4e25      	ldr	r6, [pc, #148]	; (c0d000e4 <Base64encode+0xa8>)
c0d0004e:	447e      	add	r6, pc
c0d00050:	9700      	str	r7, [sp, #0]
c0d00052:	463b      	mov	r3, r7
        *p++ = basis_64[(string[i] >> 2) & 0x3F];
c0d00054:	5d0f      	ldrb	r7, [r1, r4]
c0d00056:	08bf      	lsrs	r7, r7, #2
c0d00058:	5df7      	ldrb	r7, [r6, r7]
c0d0005a:	701f      	strb	r7, [r3, #0]
c0d0005c:	190f      	adds	r7, r1, r4
        *p++ = basis_64[((string[i] & 0x3) << 4) | ((int) (string[i + 1] & 0xF0) >> 4)];
c0d0005e:	787d      	ldrb	r5, [r7, #1]
c0d00060:	092d      	lsrs	r5, r5, #4
c0d00062:	5d08      	ldrb	r0, [r1, r4]
c0d00064:	0780      	lsls	r0, r0, #30
c0d00066:	0e80      	lsrs	r0, r0, #26
c0d00068:	1940      	adds	r0, r0, r5
c0d0006a:	5c30      	ldrb	r0, [r6, r0]
c0d0006c:	7058      	strb	r0, [r3, #1]
        *p++ = basis_64[((string[i + 1] & 0xF) << 2) | ((int) (string[i + 2] & 0xC0) >> 6)];
c0d0006e:	78b8      	ldrb	r0, [r7, #2]
c0d00070:	0980      	lsrs	r0, r0, #6
c0d00072:	787d      	ldrb	r5, [r7, #1]
c0d00074:	072d      	lsls	r5, r5, #28
c0d00076:	0ead      	lsrs	r5, r5, #26
c0d00078:	1828      	adds	r0, r5, r0
c0d0007a:	5c30      	ldrb	r0, [r6, r0]
c0d0007c:	7098      	strb	r0, [r3, #2]
        *p++ = basis_64[string[i + 2] & 0x3F];
c0d0007e:	78b8      	ldrb	r0, [r7, #2]
c0d00080:	253f      	movs	r5, #63	; 0x3f
c0d00082:	4005      	ands	r5, r0
c0d00084:	5d70      	ldrb	r0, [r6, r5]
c0d00086:	70d8      	strb	r0, [r3, #3]
c0d00088:	1d1b      	adds	r3, r3, #4
    for (i = 0; i < len - 2; i += 3) {
c0d0008a:	1ce4      	adds	r4, r4, #3
c0d0008c:	4294      	cmp	r4, r2
c0d0008e:	dbe1      	blt.n	c0d00054 <Base64encode+0x18>
c0d00090:	9f00      	ldr	r7, [sp, #0]
c0d00092:	e000      	b.n	c0d00096 <Base64encode+0x5a>
c0d00094:	463b      	mov	r3, r7
c0d00096:	9a01      	ldr	r2, [sp, #4]
    }
    if (i < len) {
c0d00098:	4294      	cmp	r4, r2
c0d0009a:	da1d      	bge.n	c0d000d8 <Base64encode+0x9c>
        *p++ = basis_64[(string[i] >> 2) & 0x3F];
c0d0009c:	5d08      	ldrb	r0, [r1, r4]
c0d0009e:	0880      	lsrs	r0, r0, #2
c0d000a0:	4d11      	ldr	r5, [pc, #68]	; (c0d000e8 <Base64encode+0xac>)
c0d000a2:	447d      	add	r5, pc
c0d000a4:	5c28      	ldrb	r0, [r5, r0]
c0d000a6:	7018      	strb	r0, [r3, #0]
c0d000a8:	5d08      	ldrb	r0, [r1, r4]
c0d000aa:	0780      	lsls	r0, r0, #30
c0d000ac:	0e86      	lsrs	r6, r0, #26
        if (i == (len - 1)) {
c0d000ae:	1e50      	subs	r0, r2, #1
c0d000b0:	4284      	cmp	r4, r0
c0d000b2:	d103      	bne.n	c0d000bc <Base64encode+0x80>
            *p++ = basis_64[((string[i] & 0x3) << 4)];
c0d000b4:	5da8      	ldrb	r0, [r5, r6]
c0d000b6:	7058      	strb	r0, [r3, #1]
c0d000b8:	213d      	movs	r1, #61	; 0x3d
c0d000ba:	e009      	b.n	c0d000d0 <Base64encode+0x94>
            *p++ = '=';
        } else {
            *p++ = basis_64[((string[i] & 0x3) << 4) | ((int) (string[i + 1] & 0xF0) >> 4)];
c0d000bc:	1908      	adds	r0, r1, r4
c0d000be:	7841      	ldrb	r1, [r0, #1]
c0d000c0:	0909      	lsrs	r1, r1, #4
c0d000c2:	4331      	orrs	r1, r6
c0d000c4:	5c69      	ldrb	r1, [r5, r1]
c0d000c6:	7059      	strb	r1, [r3, #1]
            *p++ = basis_64[((string[i + 1] & 0xF) << 2)];
c0d000c8:	7840      	ldrb	r0, [r0, #1]
c0d000ca:	0700      	lsls	r0, r0, #28
c0d000cc:	0e80      	lsrs	r0, r0, #26
c0d000ce:	5c29      	ldrb	r1, [r5, r0]
c0d000d0:	203d      	movs	r0, #61	; 0x3d
        }
        *p++ = '=';
c0d000d2:	70d8      	strb	r0, [r3, #3]
            *p++ = basis_64[((string[i + 1] & 0xF) << 2)];
c0d000d4:	7099      	strb	r1, [r3, #2]
        *p++ = '=';
c0d000d6:	1d1b      	adds	r3, r3, #4
c0d000d8:	2000      	movs	r0, #0
    }

    *p++ = '\0';
c0d000da:	7018      	strb	r0, [r3, #0]
c0d000dc:	1c58      	adds	r0, r3, #1
    return p - encoded;
c0d000de:	1bc0      	subs	r0, r0, r7
c0d000e0:	b002      	add	sp, #8
c0d000e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d000e4:	00009a8e 	.word	0x00009a8e
c0d000e8:	00009a3a 	.word	0x00009a3a

c0d000ec <check_audited_app>:

// This function is called at the end of the seph initialization.
// It checks the install parameters of the application to be run, and if this area contains the
// CHECK_NOT_AUDITED_TLV_TAG tag with the CHECK_NOT_AUDITED_TLV_VAL value, a specific display
// is triggered before the actual application's splash screen.
void check_audited_app(void) {
c0d000ec:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d000ee:	b089      	sub	sp, #36	; 0x24
c0d000f0:	ac08      	add	r4, sp, #32
c0d000f2:	2055      	movs	r0, #85	; 0x55
  unsigned char     data = BOLOS_FALSE;
c0d000f4:	7020      	strb	r0, [r4, #0]
  unsigned char*    buffer = &data;
c0d000f6:	9407      	str	r4, [sp, #28]
c0d000f8:	2001      	movs	r0, #1
  unsigned int      length = os_parse_bertlv((unsigned char*)(&_install_parameters),
c0d000fa:	4669      	mov	r1, sp
c0d000fc:	6088      	str	r0, [r1, #8]
c0d000fe:	a807      	add	r0, sp, #28
c0d00100:	6048      	str	r0, [r1, #4]
c0d00102:	2600      	movs	r6, #0
c0d00104:	600e      	str	r6, [r1, #0]
c0d00106:	4872      	ldr	r0, [pc, #456]	; (c0d002d0 <check_audited_app+0x1e4>)
c0d00108:	4478      	add	r0, pc
c0d0010a:	2140      	movs	r1, #64	; 0x40
c0d0010c:	239f      	movs	r3, #159	; 0x9f
c0d0010e:	4632      	mov	r2, r6
c0d00110:	f003 fc9c 	bl	c0d03a4c <os_parse_bertlv>
                                             sizeof(data));

  // We trigger the associated behaviour only when the tag was present and the value corresponds to
  // the expected one.
  if (   (length)
      && (CHECK_NOT_AUDITED_TLV_VAL == data))
c0d00114:	2800      	cmp	r0, #0
c0d00116:	d100      	bne.n	c0d0011a <check_audited_app+0x2e>
c0d00118:	e0d2      	b.n	c0d002c0 <check_audited_app+0x1d4>
c0d0011a:	7820      	ldrb	r0, [r4, #0]
c0d0011c:	2801      	cmp	r0, #1
c0d0011e:	d000      	beq.n	c0d00122 <check_audited_app+0x36>
c0d00120:	e0ce      	b.n	c0d002c0 <check_audited_app+0x1d4>
  {
    // We reserve the first slot for this display.
    ux_stack_push();
c0d00122:	f009 f8f3 	bl	c0d0930c <ux_stack_push>
    ux_stack_init(0);
c0d00126:	4630      	mov	r0, r6
c0d00128:	f009 f960 	bl	c0d093ec <ux_stack_init>
c0d0012c:	21d0      	movs	r1, #208	; 0xd0

    // We trigger the additional display and wait for it to be completed.
    UX_DISPLAY(ui_audited_elements, NULL);
c0d0012e:	4d65      	ldr	r5, [pc, #404]	; (c0d002c4 <check_audited_app+0x1d8>)
c0d00130:	4868      	ldr	r0, [pc, #416]	; (c0d002d4 <check_audited_app+0x1e8>)
c0d00132:	4478      	add	r0, pc
c0d00134:	9103      	str	r1, [sp, #12]
c0d00136:	5068      	str	r0, [r5, r1]
c0d00138:	27c4      	movs	r7, #196	; 0xc4
c0d0013a:	2303      	movs	r3, #3
c0d0013c:	55eb      	strb	r3, [r5, r7]
c0d0013e:	22c0      	movs	r2, #192	; 0xc0
c0d00140:	4965      	ldr	r1, [pc, #404]	; (c0d002d8 <check_audited_app+0x1ec>)
c0d00142:	4479      	add	r1, pc
c0d00144:	9204      	str	r2, [sp, #16]
c0d00146:	50a9      	str	r1, [r5, r2]
c0d00148:	21cc      	movs	r1, #204	; 0xcc
c0d0014a:	9106      	str	r1, [sp, #24]
c0d0014c:	506e      	str	r6, [r5, r1]
c0d0014e:	485e      	ldr	r0, [pc, #376]	; (c0d002c8 <check_audited_app+0x1dc>)
c0d00150:	6046      	str	r6, [r0, #4]
c0d00152:	7003      	strb	r3, [r0, #0]
c0d00154:	4604      	mov	r4, r0
c0d00156:	f005 fc85 	bl	c0d05a64 <os_ux>
c0d0015a:	2004      	movs	r0, #4
c0d0015c:	9005      	str	r0, [sp, #20]
c0d0015e:	f005 fd09 	bl	c0d05b74 <os_sched_last_status>
c0d00162:	6060      	str	r0, [r4, #4]
c0d00164:	f003 fea4 	bl	c0d03eb0 <io_seproxyhal_init_ux>
c0d00168:	f003 fea4 	bl	c0d03eb4 <io_seproxyhal_init_button>
c0d0016c:	24be      	movs	r4, #190	; 0xbe
c0d0016e:	532e      	strh	r6, [r5, r4]
c0d00170:	9805      	ldr	r0, [sp, #20]
c0d00172:	f005 fcff 	bl	c0d05b74 <os_sched_last_status>
c0d00176:	4954      	ldr	r1, [pc, #336]	; (c0d002c8 <check_audited_app+0x1dc>)
c0d00178:	6048      	str	r0, [r1, #4]
c0d0017a:	2800      	cmp	r0, #0
c0d0017c:	d032      	beq.n	c0d001e4 <check_audited_app+0xf8>
c0d0017e:	2897      	cmp	r0, #151	; 0x97
c0d00180:	d030      	beq.n	c0d001e4 <check_audited_app+0xf8>
c0d00182:	9804      	ldr	r0, [sp, #16]
c0d00184:	5828      	ldr	r0, [r5, r0]
c0d00186:	2800      	cmp	r0, #0
c0d00188:	d02c      	beq.n	c0d001e4 <check_audited_app+0xf8>
c0d0018a:	5b28      	ldrh	r0, [r5, r4]
c0d0018c:	5de9      	ldrb	r1, [r5, r7]
c0d0018e:	b280      	uxth	r0, r0
c0d00190:	4288      	cmp	r0, r1
c0d00192:	d227      	bcs.n	c0d001e4 <check_audited_app+0xf8>
c0d00194:	f005 fcba 	bl	c0d05b0c <io_seph_is_status_sent>
c0d00198:	2800      	cmp	r0, #0
c0d0019a:	d123      	bne.n	c0d001e4 <check_audited_app+0xf8>
c0d0019c:	f005 fc2c 	bl	c0d059f8 <os_perso_isonboarded>
c0d001a0:	28aa      	cmp	r0, #170	; 0xaa
c0d001a2:	d103      	bne.n	c0d001ac <check_audited_app+0xc0>
c0d001a4:	f005 fc52 	bl	c0d05a4c <os_global_pin_is_validated>
c0d001a8:	28aa      	cmp	r0, #170	; 0xaa
c0d001aa:	d11b      	bne.n	c0d001e4 <check_audited_app+0xf8>
c0d001ac:	9804      	ldr	r0, [sp, #16]
c0d001ae:	5828      	ldr	r0, [r5, r0]
c0d001b0:	5b29      	ldrh	r1, [r5, r4]
c0d001b2:	0149      	lsls	r1, r1, #5
c0d001b4:	1840      	adds	r0, r0, r1
c0d001b6:	9906      	ldr	r1, [sp, #24]
c0d001b8:	5869      	ldr	r1, [r5, r1]
c0d001ba:	2900      	cmp	r1, #0
c0d001bc:	d002      	beq.n	c0d001c4 <check_audited_app+0xd8>
c0d001be:	4788      	blx	r1
c0d001c0:	2800      	cmp	r0, #0
c0d001c2:	d008      	beq.n	c0d001d6 <check_audited_app+0xea>
c0d001c4:	2801      	cmp	r0, #1
c0d001c6:	d104      	bne.n	c0d001d2 <check_audited_app+0xe6>
c0d001c8:	9804      	ldr	r0, [sp, #16]
c0d001ca:	5828      	ldr	r0, [r5, r0]
c0d001cc:	5b29      	ldrh	r1, [r5, r4]
c0d001ce:	0149      	lsls	r1, r1, #5
c0d001d0:	1840      	adds	r0, r0, r1
c0d001d2:	f003 f90f 	bl	c0d033f4 <io_seproxyhal_display>
c0d001d6:	5b28      	ldrh	r0, [r5, r4]
c0d001d8:	1c40      	adds	r0, r0, #1
c0d001da:	5328      	strh	r0, [r5, r4]
c0d001dc:	9904      	ldr	r1, [sp, #16]
c0d001de:	5869      	ldr	r1, [r5, r1]
c0d001e0:	2900      	cmp	r1, #0
c0d001e2:	d1d3      	bne.n	c0d0018c <check_audited_app+0xa0>
    UX_WAIT_DISPLAYED();
c0d001e4:	5dee      	ldrb	r6, [r5, r7]
c0d001e6:	5b28      	ldrh	r0, [r5, r4]
c0d001e8:	9005      	str	r0, [sp, #20]
c0d001ea:	4838      	ldr	r0, [pc, #224]	; (c0d002cc <check_audited_app+0x1e0>)
c0d001ec:	2148      	movs	r1, #72	; 0x48
c0d001ee:	2200      	movs	r2, #0
c0d001f0:	f005 fc98 	bl	c0d05b24 <io_seph_recv>
c0d001f4:	f003 fdfc 	bl	c0d03df0 <io_seproxyhal_handle_event>
c0d001f8:	9805      	ldr	r0, [sp, #20]
c0d001fa:	42b0      	cmp	r0, r6
c0d001fc:	d23c      	bcs.n	c0d00278 <check_audited_app+0x18c>
c0d001fe:	9e04      	ldr	r6, [sp, #16]
c0d00200:	59a8      	ldr	r0, [r5, r6]
c0d00202:	2800      	cmp	r0, #0
c0d00204:	d029      	beq.n	c0d0025a <check_audited_app+0x16e>
c0d00206:	5b28      	ldrh	r0, [r5, r4]
c0d00208:	5de9      	ldrb	r1, [r5, r7]
c0d0020a:	b280      	uxth	r0, r0
c0d0020c:	4288      	cmp	r0, r1
c0d0020e:	d224      	bcs.n	c0d0025a <check_audited_app+0x16e>
c0d00210:	f005 fc7c 	bl	c0d05b0c <io_seph_is_status_sent>
c0d00214:	2800      	cmp	r0, #0
c0d00216:	d120      	bne.n	c0d0025a <check_audited_app+0x16e>
c0d00218:	f005 fbee 	bl	c0d059f8 <os_perso_isonboarded>
c0d0021c:	28aa      	cmp	r0, #170	; 0xaa
c0d0021e:	d103      	bne.n	c0d00228 <check_audited_app+0x13c>
c0d00220:	f005 fc14 	bl	c0d05a4c <os_global_pin_is_validated>
c0d00224:	28aa      	cmp	r0, #170	; 0xaa
c0d00226:	d118      	bne.n	c0d0025a <check_audited_app+0x16e>
c0d00228:	59a8      	ldr	r0, [r5, r6]
c0d0022a:	5b29      	ldrh	r1, [r5, r4]
c0d0022c:	0149      	lsls	r1, r1, #5
c0d0022e:	1840      	adds	r0, r0, r1
c0d00230:	9906      	ldr	r1, [sp, #24]
c0d00232:	5869      	ldr	r1, [r5, r1]
c0d00234:	2900      	cmp	r1, #0
c0d00236:	d002      	beq.n	c0d0023e <check_audited_app+0x152>
c0d00238:	4788      	blx	r1
c0d0023a:	2800      	cmp	r0, #0
c0d0023c:	d007      	beq.n	c0d0024e <check_audited_app+0x162>
c0d0023e:	2801      	cmp	r0, #1
c0d00240:	d103      	bne.n	c0d0024a <check_audited_app+0x15e>
c0d00242:	59a8      	ldr	r0, [r5, r6]
c0d00244:	5b29      	ldrh	r1, [r5, r4]
c0d00246:	0149      	lsls	r1, r1, #5
c0d00248:	1840      	adds	r0, r0, r1
c0d0024a:	f003 f8d3 	bl	c0d033f4 <io_seproxyhal_display>
c0d0024e:	5b28      	ldrh	r0, [r5, r4]
c0d00250:	1c40      	adds	r0, r0, #1
c0d00252:	5328      	strh	r0, [r5, r4]
c0d00254:	59a9      	ldr	r1, [r5, r6]
c0d00256:	2900      	cmp	r1, #0
c0d00258:	d1d6      	bne.n	c0d00208 <check_audited_app+0x11c>
c0d0025a:	5de8      	ldrb	r0, [r5, r7]
c0d0025c:	9005      	str	r0, [sp, #20]
c0d0025e:	463e      	mov	r6, r7
c0d00260:	5b2f      	ldrh	r7, [r5, r4]
c0d00262:	2148      	movs	r1, #72	; 0x48
c0d00264:	2200      	movs	r2, #0
c0d00266:	4819      	ldr	r0, [pc, #100]	; (c0d002cc <check_audited_app+0x1e0>)
c0d00268:	f005 fc5c 	bl	c0d05b24 <io_seph_recv>
c0d0026c:	f003 fdc0 	bl	c0d03df0 <io_seproxyhal_handle_event>
c0d00270:	9805      	ldr	r0, [sp, #20]
c0d00272:	4287      	cmp	r7, r0
c0d00274:	4637      	mov	r7, r6
c0d00276:	d3c2      	bcc.n	c0d001fe <check_audited_app+0x112>
c0d00278:	f003 fcd4 	bl	c0d03c24 <io_seproxyhal_general_status>
c0d0027c:	4c13      	ldr	r4, [pc, #76]	; (c0d002cc <check_audited_app+0x1e0>)
c0d0027e:	2148      	movs	r1, #72	; 0x48
c0d00280:	2200      	movs	r2, #0
c0d00282:	4620      	mov	r0, r4
c0d00284:	f005 fc4e 	bl	c0d05b24 <io_seph_recv>

    io_seproxyhal_general_status();
c0d00288:	f003 fccc 	bl	c0d03c24 <io_seproxyhal_general_status>
c0d0028c:	9e03      	ldr	r6, [sp, #12]
c0d0028e:	2148      	movs	r1, #72	; 0x48
c0d00290:	2200      	movs	r2, #0

    // We wait for the button callback pointer to wiped, and we process the incoming MCU events in the
    // meantime. This callback will be wiped within the actual 'ui_audited_elements_button' function,
    // as soon as the user presses both buttons.
    do {
      io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d00292:	4620      	mov	r0, r4
c0d00294:	f005 fc46 	bl	c0d05b24 <io_seph_recv>
      io_seproxyhal_handle_event();
c0d00298:	f003 fdaa 	bl	c0d03df0 <io_seproxyhal_handle_event>
    } while (io_seproxyhal_spi_is_status_sent() && G_ux.stack[0].button_push_callback);
c0d0029c:	f005 fc36 	bl	c0d05b0c <io_seph_is_status_sent>
c0d002a0:	2800      	cmp	r0, #0
c0d002a2:	d002      	beq.n	c0d002aa <check_audited_app+0x1be>
c0d002a4:	59a8      	ldr	r0, [r5, r6]
c0d002a6:	2800      	cmp	r0, #0
c0d002a8:	d1f1      	bne.n	c0d0028e <check_audited_app+0x1a2>

    // We pop the reserved slot but we do not care about the returned value (since we do not need it for
    // further displays at the moment) and reinitialize the UX and buttons.
    ux_stack_pop();
c0d002aa:	f009 f84b 	bl	c0d09344 <ux_stack_pop>
    io_seproxyhal_init_ux();
c0d002ae:	f003 fdff 	bl	c0d03eb0 <io_seproxyhal_init_ux>
    io_seproxyhal_init_button();
c0d002b2:	f003 fdff 	bl	c0d03eb4 <io_seproxyhal_init_button>

    // Now we can wait for the next MCU status and exit.
    io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d002b6:	4805      	ldr	r0, [pc, #20]	; (c0d002cc <check_audited_app+0x1e0>)
c0d002b8:	2148      	movs	r1, #72	; 0x48
c0d002ba:	2200      	movs	r2, #0
c0d002bc:	f005 fc32 	bl	c0d05b24 <io_seph_recv>
  }
}
c0d002c0:	b009      	add	sp, #36	; 0x24
c0d002c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d002c4:	2000195c 	.word	0x2000195c
c0d002c8:	20001aa4 	.word	0x20001aa4
c0d002cc:	20001a5c 	.word	0x20001a5c
c0d002d0:	0000b634 	.word	0x0000b634
c0d002d4:	000001a7 	.word	0x000001a7
c0d002d8:	000099f2 	.word	0x000099f2

c0d002dc <ui_audited_elements_button>:
static unsigned int ui_audited_elements_button(unsigned int button_mask, unsigned int button_mask_counter) {
c0d002dc:	4904      	ldr	r1, [pc, #16]	; (c0d002f0 <ui_audited_elements_button+0x14>)
  if ((button_mask & (BUTTON_EVT_RELEASED | BUTTON_LEFT | BUTTON_RIGHT)) == (BUTTON_EVT_RELEASED | BUTTON_LEFT | BUTTON_RIGHT)) {
c0d002de:	4008      	ands	r0, r1
c0d002e0:	4288      	cmp	r0, r1
c0d002e2:	d103      	bne.n	c0d002ec <ui_audited_elements_button+0x10>
c0d002e4:	20d0      	movs	r0, #208	; 0xd0
    G_ux.stack[0].button_push_callback = NULL;
c0d002e6:	4903      	ldr	r1, [pc, #12]	; (c0d002f4 <ui_audited_elements_button+0x18>)
c0d002e8:	2200      	movs	r2, #0
c0d002ea:	500a      	str	r2, [r1, r0]
c0d002ec:	2000      	movs	r0, #0
  return 0;
c0d002ee:	4770      	bx	lr
c0d002f0:	80000003 	.word	0x80000003
c0d002f4:	2000195c 	.word	0x2000195c

c0d002f8 <handleGetAppConfiguration>:
    UNUSED(p1);
    UNUSED(p2);
    UNUSED(workBuffer);
    UNUSED(dataLength);
    UNUSED(flags);
    G_io_apdu_buffer[0] = (N_storage.dataAllowed ? APP_FLAG_DATA_ALLOWED : 0x00);
c0d002f8:	480c      	ldr	r0, [pc, #48]	; (c0d0032c <handleGetAppConfiguration+0x34>)
c0d002fa:	4478      	add	r0, pc
c0d002fc:	f004 fb6a 	bl	c0d049d4 <pic>
c0d00300:	7802      	ldrb	r2, [r0, #0]
#ifndef HAVE_TOKENS_LIST
    G_io_apdu_buffer[0] |= APP_FLAG_EXTERNAL_TOKEN_NEEDED;
#endif
#ifdef HAVE_STARKWARE
    G_io_apdu_buffer[0] |= APP_FLAG_STARKWARE;
    G_io_apdu_buffer[0] |= APP_FLAG_STARKWARE_V2;
c0d00302:	4909      	ldr	r1, [pc, #36]	; (c0d00328 <handleGetAppConfiguration+0x30>)
c0d00304:	2004      	movs	r0, #4
#endif
    G_io_apdu_buffer[1] = LEDGER_MAJOR_VERSION;
    G_io_apdu_buffer[2] = LEDGER_MINOR_VERSION;
    G_io_apdu_buffer[3] = LEDGER_PATCH_VERSION;
c0d00306:	70c8      	strb	r0, [r1, #3]
c0d00308:	2306      	movs	r3, #6
    G_io_apdu_buffer[2] = LEDGER_MINOR_VERSION;
c0d0030a:	708b      	strb	r3, [r1, #2]
c0d0030c:	2301      	movs	r3, #1
    G_io_apdu_buffer[1] = LEDGER_MAJOR_VERSION;
c0d0030e:	704b      	strb	r3, [r1, #1]
    G_io_apdu_buffer[0] = (N_storage.dataAllowed ? APP_FLAG_DATA_ALLOWED : 0x00);
c0d00310:	2a00      	cmp	r2, #0
c0d00312:	d100      	bne.n	c0d00316 <handleGetAppConfiguration+0x1e>
c0d00314:	4613      	mov	r3, r2
    G_io_apdu_buffer[0] |= APP_FLAG_STARKWARE_V2;
c0d00316:	330e      	adds	r3, #14
c0d00318:	700b      	strb	r3, [r1, #0]
c0d0031a:	9901      	ldr	r1, [sp, #4]
    *tx = 4;
c0d0031c:	6008      	str	r0, [r1, #0]
c0d0031e:	2009      	movs	r0, #9
c0d00320:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0d00322:	f003 fb6e 	bl	c0d03a02 <os_longjmp>
c0d00326:	46c0      	nop			; (mov r8, r8)
c0d00328:	20001e61 	.word	0x20001e61
c0d0032c:	0000b402 	.word	0x0000b402

c0d00330 <handleGetPublicKey>:
void handleGetPublicKey(uint8_t p1,
                        uint8_t p2,
                        uint8_t *dataBuffer,
                        uint16_t dataLength,
                        unsigned int *flags,
                        unsigned int *tx) {
c0d00330:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00332:	b0a1      	sub	sp, #132	; 0x84
c0d00334:	4617      	mov	r7, r2
c0d00336:	460e      	mov	r6, r1
c0d00338:	4604      	mov	r4, r0
    UNUSED(dataLength);
    uint8_t privateKeyData[32];
    uint32_t bip32Path[MAX_BIP32_PATH];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer++);
c0d0033a:	7815      	ldrb	r5, [r2, #0]
    cx_ecfp_private_key_t privateKey;
    if (!called_from_swap) {
c0d0033c:	4844      	ldr	r0, [pc, #272]	; (c0d00450 <handleGetPublicKey+0x120>)
c0d0033e:	7800      	ldrb	r0, [r0, #0]
c0d00340:	2800      	cmp	r0, #0
c0d00342:	d101      	bne.n	c0d00348 <handleGetPublicKey+0x18>
        reset_app_context();
c0d00344:	f002 fdfc 	bl	c0d02f40 <reset_app_context>
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0d00348:	1e68      	subs	r0, r5, #1
c0d0034a:	b2c0      	uxtb	r0, r0
c0d0034c:	280a      	cmp	r0, #10
c0d0034e:	d272      	bcs.n	c0d00436 <handleGetPublicKey+0x106>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0d00350:	2c02      	cmp	r4, #2
c0d00352:	d26b      	bcs.n	c0d0042c <handleGetPublicKey+0xfc>
c0d00354:	9403      	str	r4, [sp, #12]
        THROW(0x6B00);
    }
    if ((p2 != P2_CHAINCODE) && (p2 != P2_NO_CHAINCODE)) {
c0d00356:	2e01      	cmp	r6, #1
c0d00358:	d868      	bhi.n	c0d0042c <handleGetPublicKey+0xfc>
c0d0035a:	1c78      	adds	r0, r7, #1
c0d0035c:	9927      	ldr	r1, [sp, #156]	; 0x9c
c0d0035e:	9101      	str	r1, [sp, #4]
c0d00360:	9926      	ldr	r1, [sp, #152]	; 0x98
c0d00362:	9104      	str	r1, [sp, #16]
c0d00364:	a90f      	add	r1, sp, #60	; 0x3c
c0d00366:	462a      	mov	r2, r5
        THROW(0x6B00);
    }
    for (i = 0; i < bip32PathLength; i++) {
        bip32Path[i] = U4BE(dataBuffer, 0);
c0d00368:	78c3      	ldrb	r3, [r0, #3]
c0d0036a:	7884      	ldrb	r4, [r0, #2]
c0d0036c:	0224      	lsls	r4, r4, #8
c0d0036e:	18e3      	adds	r3, r4, r3
c0d00370:	7844      	ldrb	r4, [r0, #1]
c0d00372:	7807      	ldrb	r7, [r0, #0]
c0d00374:	023f      	lsls	r7, r7, #8
c0d00376:	193c      	adds	r4, r7, r4
c0d00378:	0424      	lsls	r4, r4, #16
c0d0037a:	191b      	adds	r3, r3, r4
c0d0037c:	c108      	stmia	r1!, {r3}
    for (i = 0; i < bip32PathLength; i++) {
c0d0037e:	1d00      	adds	r0, r0, #4
c0d00380:	1e52      	subs	r2, r2, #1
c0d00382:	d1f1      	bne.n	c0d00368 <handleGetPublicKey+0x38>
        dataBuffer += 4;
    }
    tmpCtx.publicKeyContext.getChaincode = (p2 == P2_CHAINCODE);
c0d00384:	1e70      	subs	r0, r6, #1
c0d00386:	4241      	negs	r1, r0
c0d00388:	4141      	adcs	r1, r0
c0d0038a:	2495      	movs	r4, #149	; 0x95
c0d0038c:	4e31      	ldr	r6, [pc, #196]	; (c0d00454 <handleGetPublicKey+0x124>)
c0d0038e:	5531      	strb	r1, [r6, r4]
    io_seproxyhal_io_heartbeat();
c0d00390:	f004 f80a 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(
        CX_CURVE_256K1,
        bip32Path,
        bip32PathLength,
        privateKeyData,
        (tmpCtx.publicKeyContext.getChaincode ? tmpCtx.publicKeyContext.chainCode : NULL));
c0d00394:	5d30      	ldrb	r0, [r6, r4]
c0d00396:	2800      	cmp	r0, #0
c0d00398:	d001      	beq.n	c0d0039e <handleGetPublicKey+0x6e>
c0d0039a:	4630      	mov	r0, r6
c0d0039c:	3075      	adds	r0, #117	; 0x75
    os_perso_derive_node_bip32(
c0d0039e:	4669      	mov	r1, sp
c0d003a0:	6008      	str	r0, [r1, #0]
c0d003a2:	2421      	movs	r4, #33	; 0x21
c0d003a4:	a90f      	add	r1, sp, #60	; 0x3c
c0d003a6:	af19      	add	r7, sp, #100	; 0x64
c0d003a8:	4620      	mov	r0, r4
c0d003aa:	462a      	mov	r2, r5
c0d003ac:	463b      	mov	r3, r7
c0d003ae:	f005 fb2f 	bl	c0d05a10 <os_perso_derive_node_bip32>
c0d003b2:	2220      	movs	r2, #32
c0d003b4:	9202      	str	r2, [sp, #8]
c0d003b6:	ae05      	add	r6, sp, #20
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d003b8:	4620      	mov	r0, r4
c0d003ba:	4639      	mov	r1, r7
c0d003bc:	4633      	mov	r3, r6
c0d003be:	f005 fa93 	bl	c0d058e8 <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d003c2:	f003 fff1 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d003c6:	2301      	movs	r3, #1
    cx_ecfp_generate_pair(CX_CURVE_256K1, &tmpCtx.publicKeyContext.publicKey, &privateKey, 1);
c0d003c8:	4620      	mov	r0, r4
c0d003ca:	4d22      	ldr	r5, [pc, #136]	; (c0d00454 <handleGetPublicKey+0x124>)
c0d003cc:	4629      	mov	r1, r5
c0d003ce:	4632      	mov	r2, r6
c0d003d0:	f005 fa9a 	bl	c0d05908 <cx_ecfp_generate_pair>
c0d003d4:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d003d6:	4630      	mov	r0, r6
c0d003d8:	f009 f91c 	bl	c0d09614 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d003dc:	4638      	mov	r0, r7
c0d003de:	9902      	ldr	r1, [sp, #8]
c0d003e0:	f009 f918 	bl	c0d09614 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0d003e4:	f003 ffe0 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
                               tmpCtx.publicKeyContext.address,
                               &global_sha3,
                               chainConfig);
c0d003e8:	481b      	ldr	r0, [pc, #108]	; (c0d00458 <handleGetPublicKey+0x128>)
c0d003ea:	6803      	ldr	r3, [r0, #0]
    getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey,
c0d003ec:	462c      	mov	r4, r5
c0d003ee:	344c      	adds	r4, #76	; 0x4c
c0d003f0:	4a1a      	ldr	r2, [pc, #104]	; (c0d0045c <handleGetPublicKey+0x12c>)
c0d003f2:	4628      	mov	r0, r5
c0d003f4:	4621      	mov	r1, r4
c0d003f6:	f001 fd9d 	bl	c0d01f34 <getEthAddressStringFromKey>
#ifndef NO_CONSENT
    if (p1 == P1_NON_CONFIRM)
c0d003fa:	9803      	ldr	r0, [sp, #12]
c0d003fc:	2800      	cmp	r0, #0
c0d003fe:	d01e      	beq.n	c0d0043e <handleGetPublicKey+0x10e>
        *tx = set_result_get_publicKey();
        THROW(0x9000);
    }
#ifndef NO_CONSENT
    else {
        snprintf(strings.common.fullAddress,
c0d00400:	4668      	mov	r0, sp
c0d00402:	6004      	str	r4, [r0, #0]
c0d00404:	4816      	ldr	r0, [pc, #88]	; (c0d00460 <handleGetPublicKey+0x130>)
c0d00406:	212b      	movs	r1, #43	; 0x2b
c0d00408:	4a16      	ldr	r2, [pc, #88]	; (c0d00464 <handleGetPublicKey+0x134>)
c0d0040a:	447a      	add	r2, pc
c0d0040c:	2328      	movs	r3, #40	; 0x28
c0d0040e:	f004 f90d 	bl	c0d0462c <snprintf>
                 sizeof(strings.common.fullAddress),
                 "0x%.*s",
                 40,
                 tmpCtx.publicKeyContext.address);
        ux_flow_init(0, ux_display_public_flow, NULL);
c0d00412:	4915      	ldr	r1, [pc, #84]	; (c0d00468 <handleGetPublicKey+0x138>)
c0d00414:	4479      	add	r1, pc
c0d00416:	2000      	movs	r0, #0
c0d00418:	4602      	mov	r2, r0
c0d0041a:	f008 fbbb 	bl	c0d08b94 <ux_flow_init>
c0d0041e:	9a04      	ldr	r2, [sp, #16]

        *flags |= IO_ASYNCH_REPLY;
c0d00420:	6810      	ldr	r0, [r2, #0]
c0d00422:	2110      	movs	r1, #16
c0d00424:	4301      	orrs	r1, r0
c0d00426:	6011      	str	r1, [r2, #0]
    }
#endif  // NO_CONSENT
}
c0d00428:	b021      	add	sp, #132	; 0x84
c0d0042a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0042c:	20d5      	movs	r0, #213	; 0xd5
c0d0042e:	01c0      	lsls	r0, r0, #7
c0d00430:	3080      	adds	r0, #128	; 0x80
c0d00432:	f003 fae6 	bl	c0d03a02 <os_longjmp>
c0d00436:	20d5      	movs	r0, #213	; 0xd5
c0d00438:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0d0043a:	f003 fae2 	bl	c0d03a02 <os_longjmp>
        *tx = set_result_get_publicKey();
c0d0043e:	f002 fa27 	bl	c0d02890 <set_result_get_publicKey>
c0d00442:	9901      	ldr	r1, [sp, #4]
c0d00444:	6008      	str	r0, [r1, #0]
c0d00446:	2009      	movs	r0, #9
c0d00448:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0d0044a:	f003 fada 	bl	c0d03a02 <os_longjmp>
c0d0044e:	46c0      	nop			; (mov r8, r8)
c0d00450:	2000189c 	.word	0x2000189c
c0d00454:	20001804 	.word	0x20001804
c0d00458:	20001b3c 	.word	0x20001b3c
c0d0045c:	20001cb8 	.word	0x20001cb8
c0d00460:	20001c26 	.word	0x20001c26
c0d00464:	0000978a 	.word	0x0000978a
c0d00468:	0000a364 	.word	0x0000a364

c0d0046c <handleProvideErc20TokenInformation>:
void handleProvideErc20TokenInformation(uint8_t p1,
                                        uint8_t p2,
                                        uint8_t *workBuffer,
                                        uint16_t dataLength,
                                        unsigned int *flags,
                                        unsigned int *tx) {
c0d0046c:	b0a4      	sub	sp, #144	; 0x90
c0d0046e:	2590      	movs	r5, #144	; 0x90
    uint32_t chainId;
    uint8_t hash[32];
    cx_ecfp_public_key_t tokenKey;

    tmpCtx.transactionContext.currentTokenIndex =
        (tmpCtx.transactionContext.currentTokenIndex + 1) % MAX_TOKEN;
c0d00470:	493a      	ldr	r1, [pc, #232]	; (c0d0055c <handleProvideErc20TokenInformation+0xf0>)
c0d00472:	5d48      	ldrb	r0, [r1, r5]
c0d00474:	2601      	movs	r6, #1
c0d00476:	4386      	bics	r6, r0
    tmpCtx.transactionContext.currentTokenIndex =
c0d00478:	554e      	strb	r6, [r1, r5]
    tokenDefinition_t *token =
        &tmpCtx.transactionContext.tokens[tmpCtx.transactionContext.currentTokenIndex];

    PRINTF("Provisioning currentTokenIndex %d\n", tmpCtx.transactionContext.currentTokenIndex);

    if (dataLength < 1) {
c0d0047a:	2b00      	cmp	r3, #0
c0d0047c:	d060      	beq.n	c0d00540 <handleProvideErc20TokenInformation+0xd4>
c0d0047e:	4617      	mov	r7, r2
        THROW(0x6A80);
    }
    tickerLength = workBuffer[offset++];
c0d00480:	7812      	ldrb	r2, [r2, #0]
    dataLength--;
    if ((tickerLength + 1) >= sizeof(token->ticker)) {
c0d00482:	2a0b      	cmp	r2, #11
c0d00484:	d25c      	bcs.n	c0d00540 <handleProvideErc20TokenInformation+0xd4>
c0d00486:	461c      	mov	r4, r3
        THROW(0x6A80);
    }
    if (dataLength < tickerLength + 20 + 4 + 4) {
c0d00488:	4611      	mov	r1, r2
c0d0048a:	311c      	adds	r1, #28
    dataLength--;
c0d0048c:	1e58      	subs	r0, r3, #1
    if (dataLength < tickerLength + 20 + 4 + 4) {
c0d0048e:	b280      	uxth	r0, r0
c0d00490:	4281      	cmp	r1, r0
c0d00492:	d855      	bhi.n	c0d00540 <handleProvideErc20TokenInformation+0xd4>
c0d00494:	1c50      	adds	r0, r2, #1
        THROW(0x6A80);
    }
    cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash, 32);
c0d00496:	9004      	str	r0, [sp, #16]
c0d00498:	1c78      	adds	r0, r7, #1
c0d0049a:	9005      	str	r0, [sp, #20]
c0d0049c:	9208      	str	r2, [sp, #32]
c0d0049e:	aa1c      	add	r2, sp, #112	; 0x70
c0d004a0:	2020      	movs	r0, #32
c0d004a2:	9007      	str	r0, [sp, #28]
c0d004a4:	9805      	ldr	r0, [sp, #20]
c0d004a6:	9103      	str	r1, [sp, #12]
c0d004a8:	9b07      	ldr	r3, [sp, #28]
c0d004aa:	f005 f9cb 	bl	c0d05844 <cx_hash_sha256>
c0d004ae:	2021      	movs	r0, #33	; 0x21
    memmove(token->ticker, workBuffer + offset, tickerLength);
c0d004b0:	4370      	muls	r0, r6
c0d004b2:	492a      	ldr	r1, [pc, #168]	; (c0d0055c <handleProvideErc20TokenInformation+0xf0>)
c0d004b4:	180e      	adds	r6, r1, r0
c0d004b6:	9606      	str	r6, [sp, #24]
c0d004b8:	3660      	adds	r6, #96	; 0x60
c0d004ba:	4630      	mov	r0, r6
c0d004bc:	9905      	ldr	r1, [sp, #20]
c0d004be:	9a08      	ldr	r2, [sp, #32]
c0d004c0:	f009 f89c 	bl	c0d095fc <__aeabi_memmove>
    token->ticker[tickerLength] = ' ';
c0d004c4:	9808      	ldr	r0, [sp, #32]
c0d004c6:	9907      	ldr	r1, [sp, #28]
c0d004c8:	5431      	strb	r1, [r6, r0]
c0d004ca:	2000      	movs	r0, #0
c0d004cc:	9904      	ldr	r1, [sp, #16]
    token->ticker[tickerLength + 1] = '\0';
c0d004ce:	5470      	strb	r0, [r6, r1]
    offset += tickerLength;
    dataLength -= tickerLength;
    memmove(token->address, workBuffer + offset, 20);
c0d004d0:	1879      	adds	r1, r7, r1
    memmove(token->ticker, workBuffer + offset, tickerLength);
c0d004d2:	9806      	ldr	r0, [sp, #24]
c0d004d4:	304c      	adds	r0, #76	; 0x4c
c0d004d6:	2214      	movs	r2, #20
    memmove(token->address, workBuffer + offset, 20);
c0d004d8:	f009 f890 	bl	c0d095fc <__aeabi_memmove>
    cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash, 32);
c0d004dc:	9808      	ldr	r0, [sp, #32]
c0d004de:	183e      	adds	r6, r7, r0
    offset += 20;
    dataLength -= 20;
    token->decimals = U4BE(workBuffer, offset);
c0d004e0:	7e30      	ldrb	r0, [r6, #24]
c0d004e2:	216c      	movs	r1, #108	; 0x6c
c0d004e4:	9a06      	ldr	r2, [sp, #24]
c0d004e6:	5450      	strb	r0, [r2, r1]
    offset += 4;
    dataLength -= 4;
    chainId = U4BE(workBuffer, offset);
    if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
c0d004e8:	481d      	ldr	r0, [pc, #116]	; (c0d00560 <handleProvideErc20TokenInformation+0xf4>)
c0d004ea:	6800      	ldr	r0, [r0, #0]
c0d004ec:	68c0      	ldr	r0, [r0, #12]
c0d004ee:	2800      	cmp	r0, #0
c0d004f0:	d00c      	beq.n	c0d0050c <handleProvideErc20TokenInformation+0xa0>
    chainId = U4BE(workBuffer, offset);
c0d004f2:	9903      	ldr	r1, [sp, #12]
c0d004f4:	5c79      	ldrb	r1, [r7, r1]
c0d004f6:	7ef2      	ldrb	r2, [r6, #27]
c0d004f8:	0212      	lsls	r2, r2, #8
c0d004fa:	1851      	adds	r1, r2, r1
c0d004fc:	7eb2      	ldrb	r2, [r6, #26]
c0d004fe:	7e73      	ldrb	r3, [r6, #25]
c0d00500:	021b      	lsls	r3, r3, #8
c0d00502:	189a      	adds	r2, r3, r2
c0d00504:	0412      	lsls	r2, r2, #16
c0d00506:	1889      	adds	r1, r1, r2
    if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
c0d00508:	4288      	cmp	r0, r1
c0d0050a:	d119      	bne.n	c0d00540 <handleProvideErc20TokenInformation+0xd4>
c0d0050c:	2021      	movs	r0, #33	; 0x21
        }
    }

#else

    cx_ecfp_init_public_key(CX_CURVE_256K1,
c0d0050e:	4915      	ldr	r1, [pc, #84]	; (c0d00564 <handleProvideErc20TokenInformation+0xf8>)
c0d00510:	4479      	add	r1, pc
c0d00512:	2241      	movs	r2, #65	; 0x41
c0d00514:	af09      	add	r7, sp, #36	; 0x24
c0d00516:	463b      	mov	r3, r7
c0d00518:	f005 f9d6 	bl	c0d058c8 <cx_ecfp_init_public_key>
    dataLength -= tickerLength;
c0d0051c:	3c1d      	subs	r4, #29
    dataLength -= 4;
c0d0051e:	9808      	ldr	r0, [sp, #32]
c0d00520:	1a20      	subs	r0, r4, r0
                         CX_LAST,
                         CX_SHA256,
                         hash,
                         32,
                         workBuffer + offset,
                         dataLength)) {
c0d00522:	b280      	uxth	r0, r0
    if (!cx_ecdsa_verify(&tokenKey,
c0d00524:	4669      	mov	r1, sp
                         workBuffer + offset,
c0d00526:	361d      	adds	r6, #29
    if (!cx_ecdsa_verify(&tokenKey,
c0d00528:	9a07      	ldr	r2, [sp, #28]
c0d0052a:	c144      	stmia	r1!, {r2, r6}
c0d0052c:	6008      	str	r0, [r1, #0]
c0d0052e:	2401      	movs	r4, #1
c0d00530:	2203      	movs	r2, #3
c0d00532:	ab1c      	add	r3, sp, #112	; 0x70
c0d00534:	4638      	mov	r0, r7
c0d00536:	4621      	mov	r1, r4
c0d00538:	f005 fa0e 	bl	c0d05958 <cx_ecdsa_verify>
c0d0053c:	2800      	cmp	r0, #0
c0d0053e:	d103      	bne.n	c0d00548 <handleProvideErc20TokenInformation+0xdc>
c0d00540:	20d5      	movs	r0, #213	; 0xd5
c0d00542:	01c0      	lsls	r0, r0, #7
c0d00544:	f003 fa5d 	bl	c0d03a02 <os_longjmp>
c0d00548:	4804      	ldr	r0, [pc, #16]	; (c0d0055c <handleProvideErc20TokenInformation+0xf0>)
c0d0054a:	4601      	mov	r1, r0
        PRINTF("Invalid token signature\n");
        THROW(0x6A80);
    }
#endif

    tmpCtx.transactionContext.tokenSet[tmpCtx.transactionContext.currentTokenIndex] = 1;
c0d0054c:	5d40      	ldrb	r0, [r0, r5]
c0d0054e:	1808      	adds	r0, r1, r0
c0d00550:	218e      	movs	r1, #142	; 0x8e
c0d00552:	5444      	strb	r4, [r0, r1]
c0d00554:	2009      	movs	r0, #9
c0d00556:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0d00558:	f003 fa53 	bl	c0d03a02 <os_longjmp>
c0d0055c:	20001804 	.word	0x20001804
c0d00560:	20001b3c 	.word	0x20001b3c
c0d00564:	0000968b 	.word	0x0000968b

c0d00568 <handleSignPersonalMessage>:
void handleSignPersonalMessage(uint8_t p1,
                               uint8_t p2,
                               uint8_t *workBuffer,
                               uint16_t dataLength,
                               unsigned int *flags,
                               unsigned int *tx) {
c0d00568:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0056a:	b091      	sub	sp, #68	; 0x44
c0d0056c:	461d      	mov	r5, r3
c0d0056e:	4614      	mov	r4, r2
c0d00570:	460f      	mov	r7, r1
c0d00572:	4606      	mov	r6, r0
    UNUSED(tx);
    uint8_t hashMessage[32];
    if (p1 == P1_FIRST) {
c0d00574:	2880      	cmp	r0, #128	; 0x80
c0d00576:	d100      	bne.n	c0d0057a <handleSignPersonalMessage+0x12>
c0d00578:	e0a0      	b.n	c0d006bc <handleSignPersonalMessage+0x154>
c0d0057a:	2e00      	cmp	r6, #0
c0d0057c:	d000      	beq.n	c0d00580 <handleSignPersonalMessage+0x18>
c0d0057e:	e0f4      	b.n	c0d0076a <handleSignPersonalMessage+0x202>
        char tmp[11];
        uint32_t index;
        uint32_t base = 10;
        uint8_t pos = 0;
        uint32_t i;
        if (dataLength < 1) {
c0d00580:	2d00      	cmp	r5, #0
c0d00582:	d100      	bne.n	c0d00586 <handleSignPersonalMessage+0x1e>
c0d00584:	e0ed      	b.n	c0d00762 <handleSignPersonalMessage+0x1fa>
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        if (appState != APP_STATE_IDLE) {
c0d00586:	497f      	ldr	r1, [pc, #508]	; (c0d00784 <handleSignPersonalMessage+0x21c>)
c0d00588:	7808      	ldrb	r0, [r1, #0]
c0d0058a:	2800      	cmp	r0, #0
c0d0058c:	d002      	beq.n	c0d00594 <handleSignPersonalMessage+0x2c>
            reset_app_context();
c0d0058e:	f002 fcd7 	bl	c0d02f40 <reset_app_context>
c0d00592:	497c      	ldr	r1, [pc, #496]	; (c0d00784 <handleSignPersonalMessage+0x21c>)
c0d00594:	2002      	movs	r0, #2
        }
        appState = APP_STATE_SIGNING_MESSAGE;
c0d00596:	7008      	strb	r0, [r1, #0]
        tmpCtx.messageSigningContext.pathLength = workBuffer[0];
c0d00598:	7820      	ldrb	r0, [r4, #0]
c0d0059a:	4a7b      	ldr	r2, [pc, #492]	; (c0d00788 <handleSignPersonalMessage+0x220>)
c0d0059c:	7010      	strb	r0, [r2, #0]
c0d0059e:	9006      	str	r0, [sp, #24]
        if ((tmpCtx.messageSigningContext.pathLength < 0x01) ||
c0d005a0:	1e40      	subs	r0, r0, #1
c0d005a2:	b2c0      	uxtb	r0, r0
c0d005a4:	280a      	cmp	r0, #10
c0d005a6:	d300      	bcc.n	c0d005aa <handleSignPersonalMessage+0x42>
c0d005a8:	e0db      	b.n	c0d00762 <handleSignPersonalMessage+0x1fa>
            (tmpCtx.messageSigningContext.pathLength > MAX_BIP32_PATH)) {
            PRINTF("Invalid path\n");
            THROW(0x6a80);
        }
        workBuffer++;
        dataLength--;
c0d005aa:	1e6b      	subs	r3, r5, #1
c0d005ac:	b298      	uxth	r0, r3
c0d005ae:	2100      	movs	r1, #0
c0d005b0:	2804      	cmp	r0, #4
c0d005b2:	9604      	str	r6, [sp, #16]
c0d005b4:	9703      	str	r7, [sp, #12]
c0d005b6:	d301      	bcc.n	c0d005bc <handleSignPersonalMessage+0x54>
c0d005b8:	460f      	mov	r7, r1
c0d005ba:	e000      	b.n	c0d005be <handleSignPersonalMessage+0x56>
c0d005bc:	2701      	movs	r7, #1
c0d005be:	1d15      	adds	r5, r2, #4
        for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
            if (dataLength < 4) {
c0d005c0:	1d64      	adds	r4, r4, #5
c0d005c2:	2003      	movs	r0, #3
c0d005c4:	43c0      	mvns	r0, r0
c0d005c6:	9008      	str	r0, [sp, #32]
c0d005c8:	07f8      	lsls	r0, r7, #31
c0d005ca:	d000      	beq.n	c0d005ce <handleSignPersonalMessage+0x66>
c0d005cc:	e0c9      	b.n	c0d00762 <handleSignPersonalMessage+0x1fa>
c0d005ce:	9808      	ldr	r0, [sp, #32]
c0d005d0:	1820      	adds	r0, r4, r0
c0d005d2:	9307      	str	r3, [sp, #28]
                PRINTF("Invalid data\n");
                THROW(0x6a80);
            }
            tmpCtx.messageSigningContext.bip32Path[i] = U4BE(workBuffer, 0);
            workBuffer += 4;
            dataLength -= 4;
c0d005d4:	1f1b      	subs	r3, r3, #4
c0d005d6:	b29a      	uxth	r2, r3
c0d005d8:	9205      	str	r2, [sp, #20]
c0d005da:	4626      	mov	r6, r4
c0d005dc:	2a04      	cmp	r2, #4
c0d005de:	d301      	bcc.n	c0d005e4 <handleSignPersonalMessage+0x7c>
c0d005e0:	2700      	movs	r7, #0
c0d005e2:	e000      	b.n	c0d005e6 <handleSignPersonalMessage+0x7e>
c0d005e4:	2701      	movs	r7, #1
            tmpCtx.messageSigningContext.bip32Path[i] = U4BE(workBuffer, 0);
c0d005e6:	78c2      	ldrb	r2, [r0, #3]
c0d005e8:	7884      	ldrb	r4, [r0, #2]
c0d005ea:	0224      	lsls	r4, r4, #8
c0d005ec:	18a2      	adds	r2, r4, r2
c0d005ee:	7844      	ldrb	r4, [r0, #1]
c0d005f0:	7800      	ldrb	r0, [r0, #0]
c0d005f2:	0200      	lsls	r0, r0, #8
c0d005f4:	1900      	adds	r0, r0, r4
c0d005f6:	0400      	lsls	r0, r0, #16
c0d005f8:	1810      	adds	r0, r2, r0
c0d005fa:	c501      	stmia	r5!, {r0}
c0d005fc:	4634      	mov	r4, r6
        for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0d005fe:	1d34      	adds	r4, r6, #4
c0d00600:	1c49      	adds	r1, r1, #1
c0d00602:	9806      	ldr	r0, [sp, #24]
c0d00604:	4281      	cmp	r1, r0
c0d00606:	d3df      	bcc.n	c0d005c8 <handleSignPersonalMessage+0x60>
        }
        if (dataLength < 4) {
c0d00608:	9805      	ldr	r0, [sp, #20]
c0d0060a:	2803      	cmp	r0, #3
c0d0060c:	d800      	bhi.n	c0d00610 <handleSignPersonalMessage+0xa8>
c0d0060e:	e0a8      	b.n	c0d00762 <handleSignPersonalMessage+0x1fa>
c0d00610:	9b08      	ldr	r3, [sp, #32]
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        tmpCtx.messageSigningContext.remainingLength = U4BE(workBuffer, 0);
c0d00612:	18e0      	adds	r0, r4, r3
c0d00614:	78c1      	ldrb	r1, [r0, #3]
c0d00616:	7882      	ldrb	r2, [r0, #2]
c0d00618:	0212      	lsls	r2, r2, #8
c0d0061a:	1851      	adds	r1, r2, r1
c0d0061c:	7840      	ldrb	r0, [r0, #1]
c0d0061e:	5ce2      	ldrb	r2, [r4, r3]
c0d00620:	0212      	lsls	r2, r2, #8
c0d00622:	1810      	adds	r0, r2, r0
c0d00624:	0400      	lsls	r0, r0, #16
c0d00626:	1808      	adds	r0, r1, r0
c0d00628:	4f57      	ldr	r7, [pc, #348]	; (c0d00788 <handleSignPersonalMessage+0x220>)
c0d0062a:	64f8      	str	r0, [r7, #76]	; 0x4c
c0d0062c:	2601      	movs	r6, #1
c0d0062e:	0231      	lsls	r1, r6, #8
        workBuffer += 4;
        dataLength -= 4;
        // Initialize message header + length
        cx_keccak_init(&global_sha3, 256);
c0d00630:	4d56      	ldr	r5, [pc, #344]	; (c0d0078c <handleSignPersonalMessage+0x224>)
c0d00632:	4628      	mov	r0, r5
c0d00634:	f005 f916 	bl	c0d05864 <cx_keccak_init>
c0d00638:	2100      	movs	r1, #0
        cx_hash((cx_hash_t *) &global_sha3,
c0d0063a:	4668      	mov	r0, sp
c0d0063c:	6001      	str	r1, [r0, #0]
c0d0063e:	6041      	str	r1, [r0, #4]
c0d00640:	4a55      	ldr	r2, [pc, #340]	; (c0d00798 <handleSignPersonalMessage+0x230>)
c0d00642:	447a      	add	r2, pc
c0d00644:	231a      	movs	r3, #26
c0d00646:	4628      	mov	r0, r5
c0d00648:	9106      	str	r1, [sp, #24]
c0d0064a:	f005 f8db 	bl	c0d05804 <cx_hash>
c0d0064e:	6cfd      	ldr	r5, [r7, #76]	; 0x4c
c0d00650:	4637      	mov	r7, r6
c0d00652:	210a      	movs	r1, #10
                0,
                (uint8_t *) SIGN_MAGIC,
                sizeof(SIGN_MAGIC) - 1,
                NULL,
                0);
        for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
c0d00654:	460e      	mov	r6, r1
c0d00656:	437e      	muls	r6, r7
                         (((index * base) / base) == index));
c0d00658:	4630      	mov	r0, r6
c0d0065a:	f008 ff21 	bl	c0d094a0 <__udivsi3>
        for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
c0d0065e:	42ae      	cmp	r6, r5
c0d00660:	d801      	bhi.n	c0d00666 <handleSignPersonalMessage+0xfe>
c0d00662:	42b8      	cmp	r0, r7
c0d00664:	d0f4      	beq.n	c0d00650 <handleSignPersonalMessage+0xe8>
             index *= base)
            ;
        for (; index; index /= base) {
c0d00666:	2f00      	cmp	r7, #0
c0d00668:	9b06      	ldr	r3, [sp, #24]
c0d0066a:	d017      	beq.n	c0d0069c <handleSignPersonalMessage+0x134>
c0d0066c:	9508      	str	r5, [sp, #32]
c0d0066e:	2500      	movs	r5, #0
            tmp[pos++] = '0' + ((tmpCtx.messageSigningContext.remainingLength / index) % base);
c0d00670:	9808      	ldr	r0, [sp, #32]
c0d00672:	4639      	mov	r1, r7
c0d00674:	f008 ff14 	bl	c0d094a0 <__udivsi3>
c0d00678:	260a      	movs	r6, #10
c0d0067a:	4631      	mov	r1, r6
c0d0067c:	f008 ff96 	bl	c0d095ac <__aeabi_uidivmod>
c0d00680:	2030      	movs	r0, #48	; 0x30
c0d00682:	4308      	orrs	r0, r1
c0d00684:	b2e9      	uxtb	r1, r5
c0d00686:	aa09      	add	r2, sp, #36	; 0x24
c0d00688:	5450      	strb	r0, [r2, r1]
        for (; index; index /= base) {
c0d0068a:	4638      	mov	r0, r7
c0d0068c:	4631      	mov	r1, r6
c0d0068e:	f008 ff07 	bl	c0d094a0 <__udivsi3>
            tmp[pos++] = '0' + ((tmpCtx.messageSigningContext.remainingLength / index) % base);
c0d00692:	1c6d      	adds	r5, r5, #1
        for (; index; index /= base) {
c0d00694:	2f09      	cmp	r7, #9
c0d00696:	4607      	mov	r7, r0
c0d00698:	d8ea      	bhi.n	c0d00670 <handleSignPersonalMessage+0x108>
        }
        tmp[pos] = '\0';
c0d0069a:	b2eb      	uxtb	r3, r5
c0d0069c:	9d07      	ldr	r5, [sp, #28]
c0d0069e:	3d08      	subs	r5, #8
c0d006a0:	aa09      	add	r2, sp, #36	; 0x24
c0d006a2:	9906      	ldr	r1, [sp, #24]
c0d006a4:	54d1      	strb	r1, [r2, r3]
        cx_hash((cx_hash_t *) &global_sha3, 0, (uint8_t *) tmp, pos, NULL, 0);
c0d006a6:	4668      	mov	r0, sp
c0d006a8:	6001      	str	r1, [r0, #0]
c0d006aa:	6041      	str	r1, [r0, #4]
c0d006ac:	4837      	ldr	r0, [pc, #220]	; (c0d0078c <handleSignPersonalMessage+0x224>)
c0d006ae:	f005 f8a9 	bl	c0d05804 <cx_hash>
        cx_sha256_init(&tmpContent.sha2);
c0d006b2:	4837      	ldr	r0, [pc, #220]	; (c0d00790 <handleSignPersonalMessage+0x228>)
c0d006b4:	f005 f8ba 	bl	c0d0582c <cx_sha256_init>
c0d006b8:	9e04      	ldr	r6, [sp, #16]
c0d006ba:	9f03      	ldr	r7, [sp, #12]
    } else if (p1 != P1_MORE) {
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0d006bc:	2f00      	cmp	r7, #0
c0d006be:	d154      	bne.n	c0d0076a <handleSignPersonalMessage+0x202>
        THROW(0x6B00);
    }
    if ((p1 == P1_MORE) && (appState != APP_STATE_SIGNING_MESSAGE)) {
c0d006c0:	2e80      	cmp	r6, #128	; 0x80
c0d006c2:	d103      	bne.n	c0d006cc <handleSignPersonalMessage+0x164>
c0d006c4:	482f      	ldr	r0, [pc, #188]	; (c0d00784 <handleSignPersonalMessage+0x21c>)
c0d006c6:	7800      	ldrb	r0, [r0, #0]
c0d006c8:	2802      	cmp	r0, #2
c0d006ca:	d152      	bne.n	c0d00772 <handleSignPersonalMessage+0x20a>
        PRINTF("Signature not initialized\n");
        THROW(0x6985);
    }
    if (dataLength > tmpCtx.messageSigningContext.remainingLength) {
c0d006cc:	b2ad      	uxth	r5, r5
c0d006ce:	4f2e      	ldr	r7, [pc, #184]	; (c0d00788 <handleSignPersonalMessage+0x220>)
c0d006d0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
c0d006d2:	42a8      	cmp	r0, r5
c0d006d4:	d345      	bcc.n	c0d00762 <handleSignPersonalMessage+0x1fa>
c0d006d6:	2600      	movs	r6, #0
        THROW(0x6A80);
    }
    cx_hash((cx_hash_t *) &global_sha3, 0, workBuffer, dataLength, NULL, 0);
c0d006d8:	4668      	mov	r0, sp
c0d006da:	6006      	str	r6, [r0, #0]
c0d006dc:	6046      	str	r6, [r0, #4]
c0d006de:	482b      	ldr	r0, [pc, #172]	; (c0d0078c <handleSignPersonalMessage+0x224>)
c0d006e0:	4631      	mov	r1, r6
c0d006e2:	4622      	mov	r2, r4
c0d006e4:	462b      	mov	r3, r5
c0d006e6:	f005 f88d 	bl	c0d05804 <cx_hash>
    cx_hash((cx_hash_t *) &tmpContent.sha2, 0, workBuffer, dataLength, NULL, 0);
c0d006ea:	4668      	mov	r0, sp
c0d006ec:	6006      	str	r6, [r0, #0]
c0d006ee:	6046      	str	r6, [r0, #4]
c0d006f0:	4827      	ldr	r0, [pc, #156]	; (c0d00790 <handleSignPersonalMessage+0x228>)
c0d006f2:	4631      	mov	r1, r6
c0d006f4:	4622      	mov	r2, r4
c0d006f6:	462b      	mov	r3, r5
c0d006f8:	f005 f884 	bl	c0d05804 <cx_hash>
    tmpCtx.messageSigningContext.remainingLength -= dataLength;
c0d006fc:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
c0d006fe:	1b40      	subs	r0, r0, r5
c0d00700:	64f8      	str	r0, [r7, #76]	; 0x4c
    if (tmpCtx.messageSigningContext.remainingLength == 0) {
c0d00702:	d13b      	bne.n	c0d0077c <handleSignPersonalMessage+0x214>
c0d00704:	9816      	ldr	r0, [sp, #88]	; 0x58
        cx_hash((cx_hash_t *) &global_sha3,
c0d00706:	9008      	str	r0, [sp, #32]
c0d00708:	2520      	movs	r5, #32
c0d0070a:	4668      	mov	r0, sp
c0d0070c:	372c      	adds	r7, #44	; 0x2c
c0d0070e:	6007      	str	r7, [r0, #0]
c0d00710:	6045      	str	r5, [r0, #4]
c0d00712:	481e      	ldr	r0, [pc, #120]	; (c0d0078c <handleSignPersonalMessage+0x224>)
c0d00714:	2701      	movs	r7, #1
c0d00716:	2600      	movs	r6, #0
c0d00718:	4639      	mov	r1, r7
c0d0071a:	4622      	mov	r2, r4
c0d0071c:	4633      	mov	r3, r6
c0d0071e:	f005 f871 	bl	c0d05804 <cx_hash>
                CX_LAST,
                workBuffer,
                0,
                tmpCtx.messageSigningContext.hash,
                32);
        cx_hash((cx_hash_t *) &tmpContent.sha2, CX_LAST, workBuffer, 0, hashMessage, 32);
c0d00722:	4668      	mov	r0, sp
c0d00724:	6045      	str	r5, [r0, #4]
c0d00726:	4622      	mov	r2, r4
c0d00728:	ac09      	add	r4, sp, #36	; 0x24
c0d0072a:	6004      	str	r4, [r0, #0]
c0d0072c:	4818      	ldr	r0, [pc, #96]	; (c0d00790 <handleSignPersonalMessage+0x228>)
c0d0072e:	4639      	mov	r1, r7
c0d00730:	4633      	mov	r3, r6
c0d00732:	f005 f867 	bl	c0d05804 <cx_hash>
        snprintf(strings.tmp.tmp,
c0d00736:	4668      	mov	r0, sp
c0d00738:	6004      	str	r4, [r0, #0]
c0d0073a:	4816      	ldr	r0, [pc, #88]	; (c0d00794 <handleSignPersonalMessage+0x22c>)
c0d0073c:	2164      	movs	r1, #100	; 0x64
c0d0073e:	4a17      	ldr	r2, [pc, #92]	; (c0d0079c <handleSignPersonalMessage+0x234>)
c0d00740:	447a      	add	r2, pc
c0d00742:	462b      	mov	r3, r5
c0d00744:	f003 ff72 	bl	c0d0462c <snprintf>
                 hashMessage);

#ifdef NO_CONSENT
        io_seproxyhal_touch_signMessage_ok(NULL);
#else   // NO_CONSENT
        ux_flow_init(0, ux_sign_flow, NULL);
c0d00748:	4915      	ldr	r1, [pc, #84]	; (c0d007a0 <handleSignPersonalMessage+0x238>)
c0d0074a:	4479      	add	r1, pc
c0d0074c:	4630      	mov	r0, r6
c0d0074e:	4632      	mov	r2, r6
c0d00750:	f008 fa20 	bl	c0d08b94 <ux_flow_init>
c0d00754:	9a08      	ldr	r2, [sp, #32]
#endif  // NO_CONSENT

        *flags |= IO_ASYNCH_REPLY;
c0d00756:	6810      	ldr	r0, [r2, #0]
c0d00758:	2110      	movs	r1, #16
c0d0075a:	4301      	orrs	r1, r0
c0d0075c:	6011      	str	r1, [r2, #0]

    } else {
        THROW(0x9000);
    }
}
c0d0075e:	b011      	add	sp, #68	; 0x44
c0d00760:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00762:	20d5      	movs	r0, #213	; 0xd5
c0d00764:	01c0      	lsls	r0, r0, #7
c0d00766:	f003 f94c 	bl	c0d03a02 <os_longjmp>
c0d0076a:	206b      	movs	r0, #107	; 0x6b
c0d0076c:	0200      	lsls	r0, r0, #8
c0d0076e:	f003 f948 	bl	c0d03a02 <os_longjmp>
c0d00772:	20d5      	movs	r0, #213	; 0xd5
c0d00774:	01c0      	lsls	r0, r0, #7
        THROW(0x6985);
c0d00776:	38fb      	subs	r0, #251	; 0xfb
c0d00778:	f003 f943 	bl	c0d03a02 <os_longjmp>
c0d0077c:	2009      	movs	r0, #9
c0d0077e:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0d00780:	f003 f93f 	bl	c0d03a02 <os_longjmp>
c0d00784:	20001800 	.word	0x20001800
c0d00788:	20001804 	.word	0x20001804
c0d0078c:	20001cb8 	.word	0x20001cb8
c0d00790:	200018dc 	.word	0x200018dc
c0d00794:	20001c26 	.word	0x20001c26
c0d00798:	0000959a 	.word	0x0000959a
c0d0079c:	000094b9 	.word	0x000094b9
c0d007a0:	0000a0fe 	.word	0x0000a0fe

c0d007a4 <handleSignEIP712Message>:
void handleSignEIP712Message(uint8_t p1,
                             uint8_t p2,
                             uint8_t *workBuffer,
                             uint16_t dataLength,
                             unsigned int *flags,
                             unsigned int *tx) {
c0d007a4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d007a6:	b083      	sub	sp, #12
    uint8_t i;

    UNUSED(tx);
    if ((p1 != 00) || (p2 != 00)) {
c0d007a8:	4308      	orrs	r0, r1
c0d007aa:	2800      	cmp	r0, #0
c0d007ac:	d150      	bne.n	c0d00850 <handleSignEIP712Message+0xac>
c0d007ae:	461e      	mov	r6, r3
c0d007b0:	4614      	mov	r4, r2
        THROW(0x6B00);
    }
    if (appState != APP_STATE_IDLE) {
c0d007b2:	482a      	ldr	r0, [pc, #168]	; (c0d0085c <handleSignEIP712Message+0xb8>)
c0d007b4:	7800      	ldrb	r0, [r0, #0]
c0d007b6:	2800      	cmp	r0, #0
c0d007b8:	d001      	beq.n	c0d007be <handleSignEIP712Message+0x1a>
        reset_app_context();
c0d007ba:	f002 fbc1 	bl	c0d02f40 <reset_app_context>
    }
    if (dataLength < 1) {
c0d007be:	2e00      	cmp	r6, #0
c0d007c0:	d042      	beq.n	c0d00848 <handleSignEIP712Message+0xa4>
        PRINTF("Invalid data\n");
        THROW(0x6a80);
    }
    tmpCtx.messageSigningContext712.pathLength = workBuffer[0];
c0d007c2:	7820      	ldrb	r0, [r4, #0]
c0d007c4:	4a26      	ldr	r2, [pc, #152]	; (c0d00860 <handleSignEIP712Message+0xbc>)
c0d007c6:	7010      	strb	r0, [r2, #0]
c0d007c8:	9002      	str	r0, [sp, #8]
    if ((tmpCtx.messageSigningContext712.pathLength < 0x01) ||
c0d007ca:	1e41      	subs	r1, r0, #1
c0d007cc:	b2c9      	uxtb	r1, r1
c0d007ce:	290a      	cmp	r1, #10
c0d007d0:	d23a      	bcs.n	c0d00848 <handleSignEIP712Message+0xa4>
c0d007d2:	9808      	ldr	r0, [sp, #32]
c0d007d4:	9001      	str	r0, [sp, #4]
c0d007d6:	1d12      	adds	r2, r2, #4
        THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
        if (dataLength < 4) {
c0d007d8:	3421      	adds	r4, #33	; 0x21
    dataLength--;
c0d007da:	1e73      	subs	r3, r6, #1
c0d007dc:	211f      	movs	r1, #31
c0d007de:	43c9      	mvns	r1, r1
c0d007e0:	2600      	movs	r6, #0
        if (dataLength < 4) {
c0d007e2:	b29f      	uxth	r7, r3
c0d007e4:	2f03      	cmp	r7, #3
c0d007e6:	d92f      	bls.n	c0d00848 <handleSignEIP712Message+0xa4>
c0d007e8:	1867      	adds	r7, r4, r1
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        tmpCtx.messageSigningContext712.bip32Path[i] = U4BE(workBuffer, 0);
c0d007ea:	78fd      	ldrb	r5, [r7, #3]
c0d007ec:	78b8      	ldrb	r0, [r7, #2]
c0d007ee:	0200      	lsls	r0, r0, #8
c0d007f0:	1940      	adds	r0, r0, r5
c0d007f2:	787d      	ldrb	r5, [r7, #1]
c0d007f4:	783f      	ldrb	r7, [r7, #0]
c0d007f6:	023f      	lsls	r7, r7, #8
c0d007f8:	197d      	adds	r5, r7, r5
c0d007fa:	042d      	lsls	r5, r5, #16
c0d007fc:	1940      	adds	r0, r0, r5
c0d007fe:	c201      	stmia	r2!, {r0}
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
c0d00800:	1d24      	adds	r4, r4, #4
c0d00802:	1c76      	adds	r6, r6, #1
        workBuffer += 4;
        dataLength -= 4;
c0d00804:	1f1b      	subs	r3, r3, #4
    for (i = 0; i < tmpCtx.messageSigningContext712.pathLength; i++) {
c0d00806:	9802      	ldr	r0, [sp, #8]
c0d00808:	4286      	cmp	r6, r0
c0d0080a:	d3ea      	bcc.n	c0d007e2 <handleSignEIP712Message+0x3e>
    }
    if (dataLength < 32 + 32) {
c0d0080c:	b298      	uxth	r0, r3
c0d0080e:	283f      	cmp	r0, #63	; 0x3f
c0d00810:	d91a      	bls.n	c0d00848 <handleSignEIP712Message+0xa4>
c0d00812:	1861      	adds	r1, r4, r1
c0d00814:	4d12      	ldr	r5, [pc, #72]	; (c0d00860 <handleSignEIP712Message+0xbc>)
        PRINTF("Invalid data\n");
        THROW(0x6a80);
    }
    memmove(tmpCtx.messageSigningContext712.domainHash, workBuffer, 32);
c0d00816:	4628      	mov	r0, r5
c0d00818:	302c      	adds	r0, #44	; 0x2c
c0d0081a:	2620      	movs	r6, #32
c0d0081c:	4632      	mov	r2, r6
c0d0081e:	f008 feed 	bl	c0d095fc <__aeabi_memmove>
    memmove(tmpCtx.messageSigningContext712.messageHash, workBuffer + 32, 32);
c0d00822:	354c      	adds	r5, #76	; 0x4c
c0d00824:	4628      	mov	r0, r5
c0d00826:	4621      	mov	r1, r4
c0d00828:	4632      	mov	r2, r6
c0d0082a:	f008 fee7 	bl	c0d095fc <__aeabi_memmove>

#ifdef NO_CONSENT
    io_seproxyhal_touch_signMessage_ok(NULL);
#else   // NO_CONSENT
    ux_flow_init(0, ux_sign_712_v0_flow, NULL);
c0d0082e:	490d      	ldr	r1, [pc, #52]	; (c0d00864 <handleSignEIP712Message+0xc0>)
c0d00830:	4479      	add	r1, pc
c0d00832:	2000      	movs	r0, #0
c0d00834:	4602      	mov	r2, r0
c0d00836:	f008 f9ad 	bl	c0d08b94 <ux_flow_init>
c0d0083a:	9a01      	ldr	r2, [sp, #4]
#endif  // NO_CONSENT

    *flags |= IO_ASYNCH_REPLY;
c0d0083c:	6810      	ldr	r0, [r2, #0]
c0d0083e:	2110      	movs	r1, #16
c0d00840:	4301      	orrs	r1, r0
c0d00842:	6011      	str	r1, [r2, #0]
}
c0d00844:	b003      	add	sp, #12
c0d00846:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00848:	20d5      	movs	r0, #213	; 0xd5
c0d0084a:	01c0      	lsls	r0, r0, #7
c0d0084c:	f003 f8d9 	bl	c0d03a02 <os_longjmp>
c0d00850:	20d5      	movs	r0, #213	; 0xd5
c0d00852:	01c0      	lsls	r0, r0, #7
        THROW(0x6B00);
c0d00854:	3080      	adds	r0, #128	; 0x80
c0d00856:	f003 f8d4 	bl	c0d03a02 <os_longjmp>
c0d0085a:	46c0      	nop			; (mov r8, r8)
c0d0085c:	20001800 	.word	0x20001800
c0d00860:	20001804 	.word	0x20001804
c0d00864:	0000a0fc 	.word	0x0000a0fc

c0d00868 <handleSign>:
void handleSign(uint8_t p1,
                uint8_t p2,
                uint8_t *workBuffer,
                uint16_t dataLength,
                unsigned int *flags,
                unsigned int *tx) {
c0d00868:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0086a:	b083      	sub	sp, #12
c0d0086c:	461d      	mov	r5, r3
c0d0086e:	4614      	mov	r4, r2
c0d00870:	4606      	mov	r6, r0
    UNUSED(tx);
    parserStatus_e txResult;
    uint32_t i;
    if (p1 == P1_FIRST) {
c0d00872:	2880      	cmp	r0, #128	; 0x80
c0d00874:	d03b      	beq.n	c0d008ee <handleSign+0x86>
c0d00876:	2e00      	cmp	r6, #0
c0d00878:	d165      	bne.n	c0d00946 <handleSign+0xde>
c0d0087a:	9101      	str	r1, [sp, #4]
        if (dataLength < 1) {
c0d0087c:	2d00      	cmp	r5, #0
c0d0087e:	d06c      	beq.n	c0d0095a <handleSign+0xf2>
            PRINTF("Invalid data\n");
            THROW(0x6a80);
        }
        if (appState != APP_STATE_IDLE) {
c0d00880:	4f38      	ldr	r7, [pc, #224]	; (c0d00964 <handleSign+0xfc>)
c0d00882:	7838      	ldrb	r0, [r7, #0]
c0d00884:	2800      	cmp	r0, #0
c0d00886:	d001      	beq.n	c0d0088c <handleSign+0x24>
            reset_app_context();
c0d00888:	f002 fb5a 	bl	c0d02f40 <reset_app_context>
c0d0088c:	9602      	str	r6, [sp, #8]
c0d0088e:	2001      	movs	r0, #1
        }
        appState = APP_STATE_SIGNING_TX;
c0d00890:	7038      	strb	r0, [r7, #0]
        tmpCtx.transactionContext.pathLength = workBuffer[0];
c0d00892:	7820      	ldrb	r0, [r4, #0]
c0d00894:	4934      	ldr	r1, [pc, #208]	; (c0d00968 <handleSign+0x100>)
c0d00896:	7008      	strb	r0, [r1, #0]
        if ((tmpCtx.transactionContext.pathLength < 0x01) ||
c0d00898:	1e42      	subs	r2, r0, #1
c0d0089a:	b2d2      	uxtb	r2, r2
c0d0089c:	2a0a      	cmp	r2, #10
c0d0089e:	d25c      	bcs.n	c0d0095a <handleSign+0xf2>
c0d008a0:	1d09      	adds	r1, r1, #4
            (tmpCtx.transactionContext.pathLength > MAX_BIP32_PATH)) {
            PRINTF("Invalid path\n");
            THROW(0x6a80);
        }
        workBuffer++;
        dataLength--;
c0d008a2:	1e6d      	subs	r5, r5, #1
        workBuffer++;
c0d008a4:	1c64      	adds	r4, r4, #1
c0d008a6:	2200      	movs	r2, #0
        for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
            if (dataLength < 4) {
c0d008a8:	b2ab      	uxth	r3, r5
c0d008aa:	2b03      	cmp	r3, #3
c0d008ac:	d955      	bls.n	c0d0095a <handleSign+0xf2>
                PRINTF("Invalid data\n");
                THROW(0x6a80);
            }
            tmpCtx.transactionContext.bip32Path[i] = U4BE(workBuffer, 0);
c0d008ae:	78e3      	ldrb	r3, [r4, #3]
c0d008b0:	78a7      	ldrb	r7, [r4, #2]
c0d008b2:	023f      	lsls	r7, r7, #8
c0d008b4:	18fb      	adds	r3, r7, r3
c0d008b6:	7867      	ldrb	r7, [r4, #1]
c0d008b8:	7826      	ldrb	r6, [r4, #0]
c0d008ba:	0236      	lsls	r6, r6, #8
c0d008bc:	19f6      	adds	r6, r6, r7
c0d008be:	0436      	lsls	r6, r6, #16
c0d008c0:	199b      	adds	r3, r3, r6
c0d008c2:	c108      	stmia	r1!, {r3}
            workBuffer += 4;
c0d008c4:	1d24      	adds	r4, r4, #4
        for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
c0d008c6:	1c52      	adds	r2, r2, #1
            dataLength -= 4;
c0d008c8:	1f2d      	subs	r5, r5, #4
        for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
c0d008ca:	4282      	cmp	r2, r0
c0d008cc:	d3ec      	bcc.n	c0d008a8 <handleSign+0x40>
        }
        dataPresent = false;
        dataContext.tokenContext.pluginAvailable = 0;
c0d008ce:	4827      	ldr	r0, [pc, #156]	; (c0d0096c <handleSign+0x104>)
c0d008d0:	2100      	movs	r1, #0
c0d008d2:	7781      	strb	r1, [r0, #30]
        dataPresent = false;
c0d008d4:	4826      	ldr	r0, [pc, #152]	; (c0d00970 <handleSign+0x108>)
c0d008d6:	7001      	strb	r1, [r0, #0]
        initTx(&txContext, &global_sha3, &tmpContent.txContent, customProcessor, NULL);
c0d008d8:	4668      	mov	r0, sp
c0d008da:	6001      	str	r1, [r0, #0]
c0d008dc:	4825      	ldr	r0, [pc, #148]	; (c0d00974 <handleSign+0x10c>)
c0d008de:	4926      	ldr	r1, [pc, #152]	; (c0d00978 <handleSign+0x110>)
c0d008e0:	4a26      	ldr	r2, [pc, #152]	; (c0d0097c <handleSign+0x114>)
c0d008e2:	4b28      	ldr	r3, [pc, #160]	; (c0d00984 <handleSign+0x11c>)
c0d008e4:	447b      	add	r3, pc
c0d008e6:	f001 f85b 	bl	c0d019a0 <initTx>
c0d008ea:	9e02      	ldr	r6, [sp, #8]
c0d008ec:	9901      	ldr	r1, [sp, #4]
    } else if (p1 != P1_MORE) {
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0d008ee:	2900      	cmp	r1, #0
c0d008f0:	d129      	bne.n	c0d00946 <handleSign+0xde>
        THROW(0x6B00);
    }
    if ((p1 == P1_MORE) && (appState != APP_STATE_SIGNING_TX)) {
c0d008f2:	2e80      	cmp	r6, #128	; 0x80
c0d008f4:	d103      	bne.n	c0d008fe <handleSign+0x96>
c0d008f6:	481b      	ldr	r0, [pc, #108]	; (c0d00964 <handleSign+0xfc>)
c0d008f8:	7800      	ldrb	r0, [r0, #0]
c0d008fa:	2801      	cmp	r0, #1
c0d008fc:	d127      	bne.n	c0d0094e <handleSign+0xe6>
        PRINTF("Signature not initialized\n");
        THROW(0x6985);
    }
    if (txContext.currentField == TX_RLP_NONE) {
c0d008fe:	481d      	ldr	r0, [pc, #116]	; (c0d00974 <handleSign+0x10c>)
c0d00900:	7800      	ldrb	r0, [r0, #0]
c0d00902:	2800      	cmp	r0, #0
c0d00904:	d023      	beq.n	c0d0094e <handleSign+0xe6>
        THROW(0x6985);
    }
    txResult = processTx(&txContext,
                         workBuffer,
                         dataLength,
                         (chainConfig->kind == CHAIN_KIND_WANCHAIN ? TX_FLAG_TYPE : 0));
c0d00906:	481e      	ldr	r0, [pc, #120]	; (c0d00980 <handleSign+0x118>)
c0d00908:	6800      	ldr	r0, [r0, #0]
c0d0090a:	7c00      	ldrb	r0, [r0, #16]
c0d0090c:	1f80      	subs	r0, r0, #6
c0d0090e:	4243      	negs	r3, r0
c0d00910:	4143      	adcs	r3, r0
                         dataLength,
c0d00912:	b2aa      	uxth	r2, r5
    txResult = processTx(&txContext,
c0d00914:	4817      	ldr	r0, [pc, #92]	; (c0d00974 <handleSign+0x10c>)
c0d00916:	4621      	mov	r1, r4
c0d00918:	f001 f8b5 	bl	c0d01a86 <processTx>
    switch (txResult) {
c0d0091c:	2801      	cmp	r0, #1
c0d0091e:	dc06      	bgt.n	c0d0092e <handleSign+0xc6>
c0d00920:	d00a      	beq.n	c0d00938 <handleSign+0xd0>
c0d00922:	2800      	cmp	r0, #0
c0d00924:	d119      	bne.n	c0d0095a <handleSign+0xf2>
c0d00926:	2009      	movs	r0, #9
c0d00928:	0300      	lsls	r0, r0, #12
        case USTREAM_SUSPENDED:
            break;
        case USTREAM_FINISHED:
            break;
        case USTREAM_PROCESSING:
            THROW(0x9000);
c0d0092a:	f003 f86a 	bl	c0d03a02 <os_longjmp>
    switch (txResult) {
c0d0092e:	2802      	cmp	r0, #2
c0d00930:	d112      	bne.n	c0d00958 <handleSign+0xf0>
c0d00932:	2000      	movs	r0, #0
            PRINTF("Unexpected parser status\n");
            THROW(0x6A80);
    }

    if (txResult == USTREAM_FINISHED) {
        finalizeParsing(false);
c0d00934:	f002 f9a4 	bl	c0d02c80 <finalizeParsing>
c0d00938:	9808      	ldr	r0, [sp, #32]
    }

    *flags |= IO_ASYNCH_REPLY;
c0d0093a:	6801      	ldr	r1, [r0, #0]
c0d0093c:	2210      	movs	r2, #16
c0d0093e:	430a      	orrs	r2, r1
c0d00940:	6002      	str	r2, [r0, #0]
}
c0d00942:	b003      	add	sp, #12
c0d00944:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00946:	206b      	movs	r0, #107	; 0x6b
c0d00948:	0200      	lsls	r0, r0, #8
c0d0094a:	f003 f85a 	bl	c0d03a02 <os_longjmp>
c0d0094e:	20d5      	movs	r0, #213	; 0xd5
c0d00950:	01c0      	lsls	r0, r0, #7
c0d00952:	38fb      	subs	r0, #251	; 0xfb
c0d00954:	f003 f855 	bl	c0d03a02 <os_longjmp>
    switch (txResult) {
c0d00958:	2803      	cmp	r0, #3
c0d0095a:	20d5      	movs	r0, #213	; 0xd5
c0d0095c:	01c0      	lsls	r0, r0, #7
c0d0095e:	f003 f850 	bl	c0d03a02 <os_longjmp>
c0d00962:	46c0      	nop			; (mov r8, r8)
c0d00964:	20001800 	.word	0x20001800
c0d00968:	20001804 	.word	0x20001804
c0d0096c:	20001b40 	.word	0x20001b40
c0d00970:	20001e60 	.word	0x20001e60
c0d00974:	200018a0 	.word	0x200018a0
c0d00978:	20001cb8 	.word	0x20001cb8
c0d0097c:	200018dc 	.word	0x200018dc
c0d00980:	20001b3c 	.word	0x20001b3c
c0d00984:	00002025 	.word	0x00002025

c0d00988 <handleStarkwareGetPublicKey>:
void handleStarkwareGetPublicKey(uint8_t p1,
                                 uint8_t p2,
                                 uint8_t *dataBuffer,
                                 uint16_t dataLength,
                                 unsigned int *flags,
                                 unsigned int *tx) {
c0d00988:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0098a:	b0a1      	sub	sp, #132	; 0x84
c0d0098c:	4616      	mov	r6, r2
c0d0098e:	460c      	mov	r4, r1
c0d00990:	4607      	mov	r7, r0
    UNUSED(dataLength);
    uint8_t privateKeyData[32];
    uint32_t bip32Path[MAX_BIP32_PATH];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer++);
c0d00992:	7815      	ldrb	r5, [r2, #0]
    cx_ecfp_private_key_t privateKey;
    reset_app_context();
c0d00994:	f002 fad4 	bl	c0d02f40 <reset_app_context>
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0d00998:	1e68      	subs	r0, r5, #1
c0d0099a:	b2c0      	uxtb	r0, r0
c0d0099c:	280a      	cmp	r0, #10
c0d0099e:	d25c      	bcs.n	c0d00a5a <handleStarkwareGetPublicKey+0xd2>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0d009a0:	2f02      	cmp	r7, #2
c0d009a2:	d255      	bcs.n	c0d00a50 <handleStarkwareGetPublicKey+0xc8>
        THROW(0x6B00);
    }
    if (p2 != 0) {
c0d009a4:	2c00      	cmp	r4, #0
c0d009a6:	d153      	bne.n	c0d00a50 <handleStarkwareGetPublicKey+0xc8>
c0d009a8:	9703      	str	r7, [sp, #12]
c0d009aa:	1c70      	adds	r0, r6, #1
c0d009ac:	9927      	ldr	r1, [sp, #156]	; 0x9c
c0d009ae:	9101      	str	r1, [sp, #4]
c0d009b0:	9926      	ldr	r1, [sp, #152]	; 0x98
c0d009b2:	9104      	str	r1, [sp, #16]
c0d009b4:	a90f      	add	r1, sp, #60	; 0x3c
c0d009b6:	462a      	mov	r2, r5
        THROW(0x6B00);
    }
    for (i = 0; i < bip32PathLength; i++) {
        bip32Path[i] = U4BE(dataBuffer, 0);
c0d009b8:	78c3      	ldrb	r3, [r0, #3]
c0d009ba:	7884      	ldrb	r4, [r0, #2]
c0d009bc:	0224      	lsls	r4, r4, #8
c0d009be:	18e3      	adds	r3, r4, r3
c0d009c0:	7844      	ldrb	r4, [r0, #1]
c0d009c2:	7806      	ldrb	r6, [r0, #0]
c0d009c4:	0236      	lsls	r6, r6, #8
c0d009c6:	1934      	adds	r4, r6, r4
c0d009c8:	0424      	lsls	r4, r4, #16
c0d009ca:	191b      	adds	r3, r3, r4
c0d009cc:	c108      	stmia	r1!, {r3}
    for (i = 0; i < bip32PathLength; i++) {
c0d009ce:	1d00      	adds	r0, r0, #4
c0d009d0:	1e52      	subs	r2, r2, #1
c0d009d2:	d1f1      	bne.n	c0d009b8 <handleStarkwareGetPublicKey+0x30>
        dataBuffer += 4;
    }
    io_seproxyhal_io_heartbeat();
c0d009d4:	f003 fce8 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d009d8:	a80f      	add	r0, sp, #60	; 0x3c
c0d009da:	ae19      	add	r6, sp, #100	; 0x64
    starkDerivePrivateKey(bip32Path, bip32PathLength, privateKeyData);
c0d009dc:	4629      	mov	r1, r5
c0d009de:	4632      	mov	r2, r6
c0d009e0:	f004 f886 	bl	c0d04af0 <starkDerivePrivateKey>
c0d009e4:	272e      	movs	r7, #46	; 0x2e
c0d009e6:	2220      	movs	r2, #32
c0d009e8:	9202      	str	r2, [sp, #8]
c0d009ea:	ac05      	add	r4, sp, #20
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d009ec:	4638      	mov	r0, r7
c0d009ee:	4631      	mov	r1, r6
c0d009f0:	4623      	mov	r3, r4
c0d009f2:	f004 ff79 	bl	c0d058e8 <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d009f6:	f003 fcd7 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    cx_ecfp_generate_pair(CX_CURVE_Stark256, &tmpCtx.publicKeyContext.publicKey, &privateKey, 1);
c0d009fa:	4d1e      	ldr	r5, [pc, #120]	; (c0d00a74 <handleStarkwareGetPublicKey+0xec>)
c0d009fc:	2301      	movs	r3, #1
c0d009fe:	4638      	mov	r0, r7
c0d00a00:	4629      	mov	r1, r5
c0d00a02:	4622      	mov	r2, r4
c0d00a04:	f004 ff80 	bl	c0d05908 <cx_ecfp_generate_pair>
c0d00a08:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d00a0a:	4620      	mov	r0, r4
c0d00a0c:	f008 fe02 	bl	c0d09614 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d00a10:	4630      	mov	r0, r6
c0d00a12:	9902      	ldr	r1, [sp, #8]
c0d00a14:	f008 fdfe 	bl	c0d09614 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0d00a18:	f003 fcc6 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
#ifndef NO_CONSENT
    if (p1 == P1_NON_CONFIRM)
c0d00a1c:	9803      	ldr	r0, [sp, #12]
c0d00a1e:	2800      	cmp	r0, #0
c0d00a20:	d01f      	beq.n	c0d00a62 <handleStarkwareGetPublicKey+0xda>
        THROW(0x9000);
    }
#ifndef NO_CONSENT
    else {
        // prepare for a UI based reply
        snprintf(strings.tmp.tmp,
c0d00a22:	3509      	adds	r5, #9
c0d00a24:	4668      	mov	r0, sp
c0d00a26:	6005      	str	r5, [r0, #0]
c0d00a28:	4813      	ldr	r0, [pc, #76]	; (c0d00a78 <handleStarkwareGetPublicKey+0xf0>)
c0d00a2a:	2164      	movs	r1, #100	; 0x64
c0d00a2c:	4a13      	ldr	r2, [pc, #76]	; (c0d00a7c <handleStarkwareGetPublicKey+0xf4>)
c0d00a2e:	447a      	add	r2, pc
c0d00a30:	2320      	movs	r3, #32
c0d00a32:	f003 fdfb 	bl	c0d0462c <snprintf>
                 sizeof(strings.tmp.tmp),
                 "0x%.*H",
                 32,
                 tmpCtx.publicKeyContext.publicKey.W + 1);
        ux_flow_init(0, ux_display_stark_public_flow, NULL);
c0d00a36:	4912      	ldr	r1, [pc, #72]	; (c0d00a80 <handleStarkwareGetPublicKey+0xf8>)
c0d00a38:	4479      	add	r1, pc
c0d00a3a:	2000      	movs	r0, #0
c0d00a3c:	4602      	mov	r2, r0
c0d00a3e:	f008 f8a9 	bl	c0d08b94 <ux_flow_init>
c0d00a42:	9a04      	ldr	r2, [sp, #16]

        *flags |= IO_ASYNCH_REPLY;
c0d00a44:	6810      	ldr	r0, [r2, #0]
c0d00a46:	2110      	movs	r1, #16
c0d00a48:	4301      	orrs	r1, r0
c0d00a4a:	6011      	str	r1, [r2, #0]
    }
#endif  // NO_CONSENT
}
c0d00a4c:	b021      	add	sp, #132	; 0x84
c0d00a4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00a50:	20d5      	movs	r0, #213	; 0xd5
c0d00a52:	01c0      	lsls	r0, r0, #7
c0d00a54:	3080      	adds	r0, #128	; 0x80
c0d00a56:	f002 ffd4 	bl	c0d03a02 <os_longjmp>
c0d00a5a:	20d5      	movs	r0, #213	; 0xd5
c0d00a5c:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0d00a5e:	f002 ffd0 	bl	c0d03a02 <os_longjmp>
        *tx = set_result_get_stark_publicKey();
c0d00a62:	f002 fa5f 	bl	c0d02f24 <set_result_get_stark_publicKey>
c0d00a66:	9901      	ldr	r1, [sp, #4]
c0d00a68:	6008      	str	r0, [r1, #0]
c0d00a6a:	2009      	movs	r0, #9
c0d00a6c:	0300      	lsls	r0, r0, #12
        THROW(0x9000);
c0d00a6e:	f002 ffc8 	bl	c0d03a02 <os_longjmp>
c0d00a72:	46c0      	nop			; (mov r8, r8)
c0d00a74:	20001804 	.word	0x20001804
c0d00a78:	20001c26 	.word	0x20001c26
c0d00a7c:	000091c9 	.word	0x000091c9
c0d00a80:	0000a25c 	.word	0x0000a25c

c0d00a84 <handleStarkwareProvideQuantum>:
void handleStarkwareProvideQuantum(uint8_t p1,
                                   uint8_t p2,
                                   uint8_t *dataBuffer,
                                   uint16_t dataLength,
                                   unsigned int *flags,
                                   unsigned int *tx) {
c0d00a84:	b082      	sub	sp, #8
c0d00a86:	461e      	mov	r6, r3
c0d00a88:	4615      	mov	r5, r2
c0d00a8a:	4604      	mov	r4, r0
    size_t i = 0;
    uint8_t expectedDataSize = 20 + 32;
    uint8_t addressZero = 0;
    tokenDefinition_t *currentToken = NULL;
    if (appState != APP_STATE_IDLE) {
c0d00a8c:	482f      	ldr	r0, [pc, #188]	; (c0d00b4c <handleStarkwareProvideQuantum+0xc8>)
c0d00a8e:	7800      	ldrb	r0, [r0, #0]
c0d00a90:	2800      	cmp	r0, #0
c0d00a92:	d001      	beq.n	c0d00a98 <handleStarkwareProvideQuantum+0x14>
        reset_app_context();
c0d00a94:	f002 fa54 	bl	c0d02f40 <reset_app_context>
    }
    switch (p1) {
c0d00a98:	1e60      	subs	r0, r4, #1
c0d00a9a:	2805      	cmp	r0, #5
c0d00a9c:	d248      	bcs.n	c0d00b30 <handleStarkwareProvideQuantum+0xac>
c0d00a9e:	2054      	movs	r0, #84	; 0x54
            expectedDataSize += 32;
            break;
        default:
            THROW(0x6B00);
    }
    if (dataLength != expectedDataSize) {
c0d00aa0:	42b0      	cmp	r0, r6
c0d00aa2:	d149      	bne.n	c0d00b38 <handleStarkwareProvideQuantum+0xb4>
        THROW(0x6700);
    }
    if (p1 == STARK_QUANTUM_LEGACY) {
c0d00aa4:	2c00      	cmp	r4, #0
c0d00aa6:	9401      	str	r4, [sp, #4]
c0d00aa8:	d108      	bne.n	c0d00abc <handleStarkwareProvideQuantum+0x38>
c0d00aaa:	2000      	movs	r0, #0
                    uint32_t targetLength,
                    uint8_t decimals);

__attribute__((no_instrument_function)) inline int allzeroes(uint8_t *buf, int n) {
    for (int i = 0; i < n; ++i) {
        if (buf[i]) {
c0d00aac:	5c29      	ldrb	r1, [r5, r0]
c0d00aae:	2900      	cmp	r1, #0
c0d00ab0:	d104      	bne.n	c0d00abc <handleStarkwareProvideQuantum+0x38>
c0d00ab2:	1c40      	adds	r0, r0, #1
    for (int i = 0; i < n; ++i) {
c0d00ab4:	2813      	cmp	r0, #19
c0d00ab6:	d9f9      	bls.n	c0d00aac <handleStarkwareProvideQuantum+0x28>
c0d00ab8:	2602      	movs	r6, #2
c0d00aba:	e01c      	b.n	c0d00af6 <handleStarkwareProvideQuantum+0x72>
        addressZero = allzeroes(dataBuffer, 20);
    }
    if ((p1 != STARK_QUANTUM_ETH) && !addressZero) {
c0d00abc:	2c01      	cmp	r4, #1
c0d00abe:	d0fb      	beq.n	c0d00ab8 <handleStarkwareProvideQuantum+0x34>
c0d00ac0:	2041      	movs	r0, #65	; 0x41
c0d00ac2:	43c7      	mvns	r7, r0
c0d00ac4:	2600      	movs	r6, #0
c0d00ac6:	4c22      	ldr	r4, [pc, #136]	; (c0d00b50 <handleStarkwareProvideQuantum+0xcc>)
        for (i = 0; i < MAX_TOKEN; i++) {
            currentToken = &tmpCtx.transactionContext.tokens[i];
            if (tmpCtx.transactionContext.tokenSet[i] &&
c0d00ac8:	19a0      	adds	r0, r4, r6
c0d00aca:	218e      	movs	r1, #142	; 0x8e
c0d00acc:	5c40      	ldrb	r0, [r0, r1]
c0d00ace:	2800      	cmp	r0, #0
c0d00ad0:	d007      	beq.n	c0d00ae2 <handleStarkwareProvideQuantum+0x5e>
                (memcmp(currentToken->address, dataBuffer, 20) == 0)) {
c0d00ad2:	19e0      	adds	r0, r4, r7
c0d00ad4:	308e      	adds	r0, #142	; 0x8e
c0d00ad6:	2214      	movs	r2, #20
c0d00ad8:	4629      	mov	r1, r5
c0d00ada:	f008 fd9f 	bl	c0d0961c <memcmp>
            if (tmpCtx.transactionContext.tokenSet[i] &&
c0d00ade:	2800      	cmp	r0, #0
c0d00ae0:	d009      	beq.n	c0d00af6 <handleStarkwareProvideQuantum+0x72>
        for (i = 0; i < MAX_TOKEN; i++) {
c0d00ae2:	3721      	adds	r7, #33	; 0x21
c0d00ae4:	1c76      	adds	r6, r6, #1
c0d00ae6:	2e02      	cmp	r6, #2
c0d00ae8:	d3ee      	bcc.n	c0d00ac8 <handleStarkwareProvideQuantum+0x44>
                break;
            }
        }
        if (i == MAX_TOKEN) {
c0d00aea:	2f00      	cmp	r7, #0
c0d00aec:	d103      	bne.n	c0d00af6 <handleStarkwareProvideQuantum+0x72>
c0d00aee:	20d5      	movs	r0, #213	; 0xd5
c0d00af0:	01c0      	lsls	r0, r0, #7
            PRINTF("Associated token not found\n");
            THROW(0x6A80);
c0d00af2:	f002 ff86 	bl	c0d03a02 <os_longjmp>
        }
    } else {
        i = MAX_TOKEN;
    }
    memmove(dataContext.tokenContext.quantum, dataBuffer + 20, 32);
c0d00af6:	4c17      	ldr	r4, [pc, #92]	; (c0d00b54 <handleStarkwareProvideQuantum+0xd0>)
c0d00af8:	4620      	mov	r0, r4
c0d00afa:	30a4      	adds	r0, #164	; 0xa4
c0d00afc:	4629      	mov	r1, r5
c0d00afe:	3114      	adds	r1, #20
c0d00b00:	2220      	movs	r2, #32
c0d00b02:	f008 fd7b 	bl	c0d095fc <__aeabi_memmove>
c0d00b06:	9f01      	ldr	r7, [sp, #4]
    if (p1 != STARK_QUANTUM_LEGACY) {
c0d00b08:	2f00      	cmp	r7, #0
c0d00b0a:	d006      	beq.n	c0d00b1a <handleStarkwareProvideQuantum+0x96>
        memmove(dataContext.tokenContext.mintingBlob, dataBuffer + 20 + 32, 32);
c0d00b0c:	4620      	mov	r0, r4
c0d00b0e:	30c4      	adds	r0, #196	; 0xc4
c0d00b10:	3534      	adds	r5, #52	; 0x34
c0d00b12:	2220      	movs	r2, #32
c0d00b14:	4629      	mov	r1, r5
c0d00b16:	f008 fd71 	bl	c0d095fc <__aeabi_memmove>
c0d00b1a:	20e5      	movs	r0, #229	; 0xe5
    }
    dataContext.tokenContext.quantumIndex = i;
    dataContext.tokenContext.quantumType = p1;
c0d00b1c:	5427      	strb	r7, [r4, r0]
c0d00b1e:	20e4      	movs	r0, #228	; 0xe4
    dataContext.tokenContext.quantumIndex = i;
c0d00b20:	5426      	strb	r6, [r4, r0]
    quantumSet = true;
c0d00b22:	480d      	ldr	r0, [pc, #52]	; (c0d00b58 <handleStarkwareProvideQuantum+0xd4>)
c0d00b24:	2101      	movs	r1, #1
c0d00b26:	7001      	strb	r1, [r0, #0]
c0d00b28:	2009      	movs	r0, #9
c0d00b2a:	0300      	lsls	r0, r0, #12
    THROW(0x9000);
c0d00b2c:	f002 ff69 	bl	c0d03a02 <os_longjmp>
    switch (p1) {
c0d00b30:	2c00      	cmp	r4, #0
c0d00b32:	d105      	bne.n	c0d00b40 <handleStarkwareProvideQuantum+0xbc>
c0d00b34:	2034      	movs	r0, #52	; 0x34
c0d00b36:	e7b3      	b.n	c0d00aa0 <handleStarkwareProvideQuantum+0x1c>
c0d00b38:	2067      	movs	r0, #103	; 0x67
c0d00b3a:	0200      	lsls	r0, r0, #8
        THROW(0x6700);
c0d00b3c:	f002 ff61 	bl	c0d03a02 <os_longjmp>
c0d00b40:	20d5      	movs	r0, #213	; 0xd5
c0d00b42:	01c0      	lsls	r0, r0, #7
            THROW(0x6B00);
c0d00b44:	3080      	adds	r0, #128	; 0x80
c0d00b46:	f002 ff5c 	bl	c0d03a02 <os_longjmp>
c0d00b4a:	46c0      	nop			; (mov r8, r8)
c0d00b4c:	20001800 	.word	0x20001800
c0d00b50:	20001804 	.word	0x20001804
c0d00b54:	20001b40 	.word	0x20001b40
c0d00b58:	2000189d 	.word	0x2000189d

c0d00b5c <handleStarkwareSignMessage>:
void handleStarkwareSignMessage(uint8_t p1,
                                uint8_t p2,
                                uint8_t *dataBuffer,
                                uint16_t dataLength,
                                unsigned int *flags,
                                unsigned int *tx) {
c0d00b5c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00b5e:	b0c1      	sub	sp, #260	; 0x104
c0d00b60:	461e      	mov	r6, r3
c0d00b62:	4614      	mov	r4, r2
c0d00b64:	910f      	str	r1, [sp, #60]	; 0x3c
c0d00b66:	4607      	mov	r7, r0
    uint8_t privateKeyData[32];
    uint32_t i;
    uint8_t bip32PathLength = *(dataBuffer);
c0d00b68:	7815      	ldrb	r5, [r2, #0]
    uint8_t order = 1;
    uint8_t protocol = 2;
    uint8_t preOffset, postOffset;
    uint8_t zeroTest;
    // Initial checks
    if (appState != APP_STATE_IDLE) {
c0d00b6a:	48cb      	ldr	r0, [pc, #812]	; (c0d00e98 <handleStarkwareSignMessage+0x33c>)
c0d00b6c:	7800      	ldrb	r0, [r0, #0]
c0d00b6e:	2800      	cmp	r0, #0
c0d00b70:	d001      	beq.n	c0d00b76 <handleStarkwareSignMessage+0x1a>
        reset_app_context();
c0d00b72:	f002 f9e5 	bl	c0d02f40 <reset_app_context>
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0d00b76:	1e68      	subs	r0, r5, #1
c0d00b78:	b2c0      	uxtb	r0, r0
c0d00b7a:	280a      	cmp	r0, #10
c0d00b7c:	d300      	bcc.n	c0d00b80 <handleStarkwareSignMessage+0x24>
c0d00b7e:	e0a6      	b.n	c0d00cce <handleStarkwareSignMessage+0x172>
c0d00b80:	2101      	movs	r1, #1
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    switch (p1) {
c0d00b82:	2f03      	cmp	r7, #3
c0d00b84:	9712      	str	r7, [sp, #72]	; 0x48
c0d00b86:	910e      	str	r1, [sp, #56]	; 0x38
c0d00b88:	9611      	str	r6, [sp, #68]	; 0x44
c0d00b8a:	dc0b      	bgt.n	c0d00ba4 <handleStarkwareSignMessage+0x48>
c0d00b8c:	2300      	movs	r3, #0
c0d00b8e:	2f01      	cmp	r7, #1
c0d00b90:	d01d      	beq.n	c0d00bce <handleStarkwareSignMessage+0x72>
c0d00b92:	2f02      	cmp	r7, #2
c0d00b94:	461a      	mov	r2, r3
c0d00b96:	d00b      	beq.n	c0d00bb0 <handleStarkwareSignMessage+0x54>
c0d00b98:	2f03      	cmp	r7, #3
c0d00b9a:	d000      	beq.n	c0d00b9e <handleStarkwareSignMessage+0x42>
c0d00b9c:	e2aa      	b.n	c0d010f4 <handleStarkwareSignMessage+0x598>
c0d00b9e:	2221      	movs	r2, #33	; 0x21
c0d00ba0:	460b      	mov	r3, r1
c0d00ba2:	e015      	b.n	c0d00bd0 <handleStarkwareSignMessage+0x74>
c0d00ba4:	1f38      	subs	r0, r7, #4
c0d00ba6:	2802      	cmp	r0, #2
c0d00ba8:	d300      	bcc.n	c0d00bac <handleStarkwareSignMessage+0x50>
c0d00baa:	e2a3      	b.n	c0d010f4 <handleStarkwareSignMessage+0x598>
c0d00bac:	2221      	movs	r2, #33	; 0x21
c0d00bae:	460b      	mov	r3, r1
        if (dataLength != (20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4 + 1 + 4 * bip32PathLength +
                           2 * postOffset)) {
            THROW(0x6700);
        }
    } else {
        if (dataLength != (20 + 32 + 32 + 4 + 4 + 8 + 4 + 4 + 1 + 4 * bip32PathLength + postOffset +
c0d00bb0:	2f05      	cmp	r7, #5
c0d00bb2:	d001      	beq.n	c0d00bb8 <handleStarkwareSignMessage+0x5c>
c0d00bb4:	206d      	movs	r0, #109	; 0x6d
c0d00bb6:	e000      	b.n	c0d00bba <handleStarkwareSignMessage+0x5e>
c0d00bb8:	20a1      	movs	r0, #161	; 0xa1
c0d00bba:	00a9      	lsls	r1, r5, #2
c0d00bbc:	1840      	adds	r0, r0, r1
c0d00bbe:	1880      	adds	r0, r0, r2
c0d00bc0:	42b0      	cmp	r0, r6
c0d00bc2:	d000      	beq.n	c0d00bc6 <handleStarkwareSignMessage+0x6a>
c0d00bc4:	e29b      	b.n	c0d010fe <handleStarkwareSignMessage+0x5a2>
c0d00bc6:	2000      	movs	r0, #0
c0d00bc8:	2101      	movs	r1, #1
c0d00bca:	9014      	str	r0, [sp, #80]	; 0x50
c0d00bcc:	e00c      	b.n	c0d00be8 <handleStarkwareSignMessage+0x8c>
c0d00bce:	461a      	mov	r2, r3
c0d00bd0:	460e      	mov	r6, r1
                           2 * postOffset)) {
c0d00bd2:	0050      	lsls	r0, r2, #1
c0d00bd4:	00a9      	lsls	r1, r5, #2
        if (dataLength != (20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4 + 1 + 4 * bip32PathLength +
c0d00bd6:	1808      	adds	r0, r1, r0
c0d00bd8:	3089      	adds	r0, #137	; 0x89
c0d00bda:	2100      	movs	r1, #0
c0d00bdc:	9f11      	ldr	r7, [sp, #68]	; 0x44
c0d00bde:	42b8      	cmp	r0, r7
c0d00be0:	9614      	str	r6, [sp, #80]	; 0x50
c0d00be2:	4608      	mov	r0, r1
c0d00be4:	d000      	beq.n	c0d00be8 <handleStarkwareSignMessage+0x8c>
c0d00be6:	e28a      	b.n	c0d010fe <handleStarkwareSignMessage+0x5a2>
c0d00be8:	900b      	str	r0, [sp, #44]	; 0x2c
c0d00bea:	910c      	str	r1, [sp, #48]	; 0x30
c0d00bec:	9310      	str	r3, [sp, #64]	; 0x40
c0d00bee:	9213      	str	r2, [sp, #76]	; 0x4c
                           (p1 == P1_STARK_CONDITIONAL_TRANSFER ? 32 + 20 : 0))) {
            THROW(0x6700);
        }
    }
    if (p2 != 0) {
c0d00bf0:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0d00bf2:	2800      	cmp	r0, #0
c0d00bf4:	d000      	beq.n	c0d00bf8 <handleStarkwareSignMessage+0x9c>
c0d00bf6:	e27d      	b.n	c0d010f4 <handleStarkwareSignMessage+0x598>
c0d00bf8:	9846      	ldr	r0, [sp, #280]	; 0x118
        THROW(0x6B00);
    }
    tmpCtx.transactionContext.pathLength = bip32PathLength;
c0d00bfa:	900d      	str	r0, [sp, #52]	; 0x34
c0d00bfc:	48a7      	ldr	r0, [pc, #668]	; (c0d00e9c <handleStarkwareSignMessage+0x340>)
c0d00bfe:	7005      	strb	r5, [r0, #0]
c0d00c00:	1d00      	adds	r0, r0, #4
c0d00c02:	1c61      	adds	r1, r4, #1
c0d00c04:	2601      	movs	r6, #1
c0d00c06:	9504      	str	r5, [sp, #16]
c0d00c08:	462a      	mov	r2, r5
c0d00c0a:	4633      	mov	r3, r6
    for (i = 0; i < bip32PathLength; i++) {
        tmpCtx.transactionContext.bip32Path[i] = U4BE(dataBuffer, offset);
c0d00c0c:	19a6      	adds	r6, r4, r6
c0d00c0e:	78f7      	ldrb	r7, [r6, #3]
c0d00c10:	78b5      	ldrb	r5, [r6, #2]
c0d00c12:	022d      	lsls	r5, r5, #8
c0d00c14:	19ed      	adds	r5, r5, r7
c0d00c16:	7876      	ldrb	r6, [r6, #1]
c0d00c18:	7809      	ldrb	r1, [r1, #0]
c0d00c1a:	0209      	lsls	r1, r1, #8
c0d00c1c:	1989      	adds	r1, r1, r6
c0d00c1e:	0409      	lsls	r1, r1, #16
c0d00c20:	1869      	adds	r1, r5, r1
c0d00c22:	c002      	stmia	r0!, {r1}
        PRINTF("Storing path %d %d\n", i, tmpCtx.transactionContext.bip32Path[i]);
        offset += 4;
c0d00c24:	1d1b      	adds	r3, r3, #4
c0d00c26:	b2de      	uxtb	r6, r3
c0d00c28:	19a1      	adds	r1, r4, r6
    for (i = 0; i < bip32PathLength; i++) {
c0d00c2a:	1e52      	subs	r2, r2, #1
c0d00c2c:	d1ee      	bne.n	c0d00c0c <handleStarkwareSignMessage+0xb0>
    }
    // Discard the path to use part of dataBuffer as a temporary buffer
    memmove(dataBuffer, dataBuffer + offset, dataLength - offset);
c0d00c2e:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d00c30:	1b82      	subs	r2, r0, r6
c0d00c32:	4620      	mov	r0, r4
c0d00c34:	f008 fce2 	bl	c0d095fc <__aeabi_memmove>
c0d00c38:	9a12      	ldr	r2, [sp, #72]	; 0x48
    dataContext.starkContext.conditional = (p1 == P1_STARK_CONDITIONAL_TRANSFER);
c0d00c3a:	1f50      	subs	r0, r2, #5
c0d00c3c:	4241      	negs	r1, r0
c0d00c3e:	4141      	adcs	r1, r0
c0d00c40:	2080      	movs	r0, #128	; 0x80
c0d00c42:	4d97      	ldr	r5, [pc, #604]	; (c0d00ea0 <handleStarkwareSignMessage+0x344>)
c0d00c44:	900f      	str	r0, [sp, #60]	; 0x3c
c0d00c46:	5429      	strb	r1, [r5, r0]
    if (dataContext.starkContext.conditional) {
c0d00c48:	2a05      	cmp	r2, #5
c0d00c4a:	9e13      	ldr	r6, [sp, #76]	; 0x4c
c0d00c4c:	d10f      	bne.n	c0d00c6e <handleStarkwareSignMessage+0x112>
        memmove(dataContext.starkContext.fact,
                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4 + 8 + 4 + 4,
c0d00c4e:	19a5      	adds	r5, r4, r6
c0d00c50:	4629      	mov	r1, r5
c0d00c52:	316c      	adds	r1, #108	; 0x6c
        memmove(dataContext.starkContext.fact,
c0d00c54:	4892      	ldr	r0, [pc, #584]	; (c0d00ea0 <handleStarkwareSignMessage+0x344>)
c0d00c56:	30a1      	adds	r0, #161	; 0xa1
c0d00c58:	2220      	movs	r2, #32
c0d00c5a:	f008 fccf 	bl	c0d095fc <__aeabi_memmove>
                32);
        memmove(dataContext.starkContext.conditionAddress,
                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4 + 8 + 4 + 4 + 32,
c0d00c5e:	358c      	adds	r5, #140	; 0x8c
        memmove(dataContext.starkContext.conditionAddress,
c0d00c60:	488f      	ldr	r0, [pc, #572]	; (c0d00ea0 <handleStarkwareSignMessage+0x344>)
c0d00c62:	30c1      	adds	r0, #193	; 0xc1
c0d00c64:	2214      	movs	r2, #20
c0d00c66:	4629      	mov	r1, r5
c0d00c68:	4d8d      	ldr	r5, [pc, #564]	; (c0d00ea0 <handleStarkwareSignMessage+0x344>)
c0d00c6a:	f008 fcc7 	bl	c0d095fc <__aeabi_memmove>
c0d00c6e:	9f10      	ldr	r7, [sp, #64]	; 0x40
                20);
        PRINTF("Fact %.*H\n", 32, dataContext.starkContext.fact);
        PRINTF("Address %.*H\n", 20, dataContext.starkContext.conditionAddress);
    }

    zeroTest = allzeroes(dataBuffer + preOffset, 20);
c0d00c70:	19e0      	adds	r0, r4, r7
c0d00c72:	2200      	movs	r2, #0
c0d00c74:	9011      	str	r0, [sp, #68]	; 0x44
        if (buf[i]) {
c0d00c76:	5c81      	ldrb	r1, [r0, r2]
c0d00c78:	2900      	cmp	r1, #0
c0d00c7a:	d10a      	bne.n	c0d00c92 <handleStarkwareSignMessage+0x136>
c0d00c7c:	1c52      	adds	r2, r2, #1
    for (int i = 0; i < n; ++i) {
c0d00c7e:	2a13      	cmp	r2, #19
c0d00c80:	d9f9      	bls.n	c0d00c76 <handleStarkwareSignMessage+0x11a>
    if (zeroTest && (protocol == 2) && (dataBuffer[0] != STARK_QUANTUM_ETH)) {
c0d00c82:	2f00      	cmp	r7, #0
c0d00c84:	990e      	ldr	r1, [sp, #56]	; 0x38
c0d00c86:	d00a      	beq.n	c0d00c9e <handleStarkwareSignMessage+0x142>
c0d00c88:	7820      	ldrb	r0, [r4, #0]
c0d00c8a:	2801      	cmp	r0, #1
c0d00c8c:	d11f      	bne.n	c0d00cce <handleStarkwareSignMessage+0x172>
c0d00c8e:	2100      	movs	r1, #0
c0d00c90:	e005      	b.n	c0d00c9e <handleStarkwareSignMessage+0x142>
        PRINTF("stark - unexpected quantum descriptor type for null first address %d\n",
               dataBuffer[0]);
        THROW(0x6A80);
    }
    if (!zeroTest && getKnownToken(dataBuffer + preOffset) == NULL) {
c0d00c92:	f002 f9e9 	bl	c0d03068 <getKnownToken>
c0d00c96:	2800      	cmp	r0, #0
c0d00c98:	d019      	beq.n	c0d00cce <handleStarkwareSignMessage+0x172>
c0d00c9a:	2101      	movs	r1, #1
c0d00c9c:	4079      	eors	r1, r7
        PRINTF("stark - cannot process unknown token %.*H", 20, dataBuffer + preOffset);
        THROW(0x6A80);
    }
    if (order) {
c0d00c9e:	9814      	ldr	r0, [sp, #80]	; 0x50
c0d00ca0:	2800      	cmp	r0, #0
c0d00ca2:	d01c      	beq.n	c0d00cde <handleStarkwareSignMessage+0x182>
c0d00ca4:	910e      	str	r1, [sp, #56]	; 0x38
c0d00ca6:	19f0      	adds	r0, r6, r7
        zeroTest = allzeroes(dataBuffer + 20 + 32 + postOffset + preOffset, 20);
c0d00ca8:	1821      	adds	r1, r4, r0
c0d00caa:	3134      	adds	r1, #52	; 0x34
c0d00cac:	19a0      	adds	r0, r4, r6
c0d00cae:	19c0      	adds	r0, r0, r7
c0d00cb0:	3034      	adds	r0, #52	; 0x34
c0d00cb2:	2200      	movs	r2, #0
        if (buf[i]) {
c0d00cb4:	5c8b      	ldrb	r3, [r1, r2]
c0d00cb6:	2b00      	cmp	r3, #0
c0d00cb8:	d10d      	bne.n	c0d00cd6 <handleStarkwareSignMessage+0x17a>
c0d00cba:	1c52      	adds	r2, r2, #1
    for (int i = 0; i < n; ++i) {
c0d00cbc:	2a13      	cmp	r2, #19
c0d00cbe:	d9f9      	bls.n	c0d00cb4 <handleStarkwareSignMessage+0x158>
        if (zeroTest && (protocol == 2) && (dataBuffer[1 + 20 + 32 + 32] != STARK_QUANTUM_ETH)) {
c0d00cc0:	980e      	ldr	r0, [sp, #56]	; 0x38
c0d00cc2:	2800      	cmp	r0, #0
c0d00cc4:	d10b      	bne.n	c0d00cde <handleStarkwareSignMessage+0x182>
c0d00cc6:	2055      	movs	r0, #85	; 0x55
c0d00cc8:	5c20      	ldrb	r0, [r4, r0]
c0d00cca:	2801      	cmp	r0, #1
c0d00ccc:	d007      	beq.n	c0d00cde <handleStarkwareSignMessage+0x182>
c0d00cce:	20d5      	movs	r0, #213	; 0xd5
c0d00cd0:	01c0      	lsls	r0, r0, #7
c0d00cd2:	f002 fe96 	bl	c0d03a02 <os_longjmp>
            PRINTF("stark - unexpected quantum descriptor type for null second address %d\n",
                   dataBuffer[1 + 20 + 32 + 32]);
            THROW(0x6A80);
        }
        if (!zeroTest && getKnownToken(dataBuffer + 20 + 32 + postOffset + preOffset) == NULL) {
c0d00cd6:	f002 f9c7 	bl	c0d03068 <getKnownToken>
c0d00cda:	2800      	cmp	r0, #0
c0d00cdc:	d0f7      	beq.n	c0d00cce <handleStarkwareSignMessage+0x172>
                   dataBuffer + 20 + 32 + postOffset + preOffset);
            THROW(0x6A80);
        }
    }
    // Prepare the Stark parameters
    io_seproxyhal_io_heartbeat();
c0d00cde:	f003 fb63 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d00ce2:	2100      	movs	r1, #0
    compute_token_id(&global_sha3,
                     dataBuffer + preOffset,
                     (protocol == 2 ? dataBuffer[0] : STARK_QUANTUM_LEGACY),
c0d00ce4:	2f00      	cmp	r7, #0
c0d00ce6:	460a      	mov	r2, r1
c0d00ce8:	d000      	beq.n	c0d00cec <handleStarkwareSignMessage+0x190>
c0d00cea:	7822      	ldrb	r2, [r4, #0]
    compute_token_id(&global_sha3,
c0d00cec:	4668      	mov	r0, sp
c0d00cee:	6041      	str	r1, [r0, #4]
c0d00cf0:	6085      	str	r5, [r0, #8]
                     dataBuffer + preOffset + 20,
                     (protocol == 2 ? dataBuffer + 1 + 20 + 32 : NULL),
c0d00cf2:	2f00      	cmp	r7, #0
c0d00cf4:	d101      	bne.n	c0d00cfa <handleStarkwareSignMessage+0x19e>
c0d00cf6:	4639      	mov	r1, r7
c0d00cf8:	e001      	b.n	c0d00cfe <handleStarkwareSignMessage+0x1a2>
c0d00cfa:	4621      	mov	r1, r4
c0d00cfc:	3135      	adds	r1, #53	; 0x35
    compute_token_id(&global_sha3,
c0d00cfe:	6001      	str	r1, [r0, #0]
c0d00d00:	9911      	ldr	r1, [sp, #68]	; 0x44
                     dataBuffer + preOffset + 20,
c0d00d02:	460b      	mov	r3, r1
c0d00d04:	3314      	adds	r3, #20
    compute_token_id(&global_sha3,
c0d00d06:	4867      	ldr	r0, [pc, #412]	; (c0d00ea4 <handleStarkwareSignMessage+0x348>)
c0d00d08:	930e      	str	r3, [sp, #56]	; 0x38
c0d00d0a:	f004 f823 	bl	c0d04d54 <compute_token_id>
                     false,
                     dataContext.starkContext.w1);
    if (order) {
c0d00d0e:	9814      	ldr	r0, [sp, #80]	; 0x50
c0d00d10:	2800      	cmp	r0, #0
c0d00d12:	d013      	beq.n	c0d00d3c <handleStarkwareSignMessage+0x1e0>
        io_seproxyhal_io_heartbeat();
        compute_token_id(&global_sha3,
                         dataBuffer + 20 + 32 + postOffset + preOffset,
c0d00d14:	19a0      	adds	r0, r4, r6
c0d00d16:	19c5      	adds	r5, r0, r7
        io_seproxyhal_io_heartbeat();
c0d00d18:	f003 fb46 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d00d1c:	2000      	movs	r0, #0
                         (protocol == 2 ? dataBuffer[1 + 20 + 32 + 32] : STARK_QUANTUM_LEGACY),
c0d00d1e:	2f00      	cmp	r7, #0
c0d00d20:	4602      	mov	r2, r0
c0d00d22:	d001      	beq.n	c0d00d28 <handleStarkwareSignMessage+0x1cc>
c0d00d24:	2155      	movs	r1, #85	; 0x55
c0d00d26:	5c62      	ldrb	r2, [r4, r1]
c0d00d28:	3534      	adds	r5, #52	; 0x34
        compute_token_id(&global_sha3,
c0d00d2a:	4bf8      	ldr	r3, [pc, #992]	; (c0d0110c <handleStarkwareSignMessage+0x5b0>)
c0d00d2c:	3320      	adds	r3, #32
c0d00d2e:	4669      	mov	r1, sp
c0d00d30:	6048      	str	r0, [r1, #4]
c0d00d32:	608b      	str	r3, [r1, #8]
                         dataBuffer + 20 + 32 + postOffset + preOffset + 20,
                         (protocol == 2 ? dataBuffer + 1 + 20 + 32 + 32 + 1 + 20 + 32 : NULL),
c0d00d34:	2f00      	cmp	r7, #0
c0d00d36:	d10c      	bne.n	c0d00d52 <handleStarkwareSignMessage+0x1f6>
c0d00d38:	4638      	mov	r0, r7
c0d00d3a:	e00c      	b.n	c0d00d56 <handleStarkwareSignMessage+0x1fa>
                         false,
                         dataContext.starkContext.w2);
        offset = 20 + 32 + postOffset + 20 + 32 + postOffset;
    } else {
        memmove(dataContext.starkContext.w2, dataBuffer + 20 + 32 + postOffset, 32);
c0d00d3c:	19a1      	adds	r1, r4, r6
c0d00d3e:	3134      	adds	r1, #52	; 0x34
c0d00d40:	4628      	mov	r0, r5
c0d00d42:	3020      	adds	r0, #32
c0d00d44:	2220      	movs	r2, #32
c0d00d46:	f008 fc59 	bl	c0d095fc <__aeabi_memmove>
c0d00d4a:	2054      	movs	r0, #84	; 0x54
        offset = 20 + 32 + postOffset + 32;
c0d00d4c:	4330      	orrs	r0, r6
c0d00d4e:	4606      	mov	r6, r0
c0d00d50:	e00d      	b.n	c0d00d6e <handleStarkwareSignMessage+0x212>
c0d00d52:	4620      	mov	r0, r4
c0d00d54:	308a      	adds	r0, #138	; 0x8a
        compute_token_id(&global_sha3,
c0d00d56:	6008      	str	r0, [r1, #0]
                         dataBuffer + 20 + 32 + postOffset + preOffset + 20,
c0d00d58:	462b      	mov	r3, r5
c0d00d5a:	3314      	adds	r3, #20
        compute_token_id(&global_sha3,
c0d00d5c:	48ec      	ldr	r0, [pc, #944]	; (c0d01110 <handleStarkwareSignMessage+0x5b4>)
c0d00d5e:	4629      	mov	r1, r5
c0d00d60:	f003 fff8 	bl	c0d04d54 <compute_token_id>
c0d00d64:	2048      	movs	r0, #72	; 0x48
        offset = 20 + 32 + postOffset + 20 + 32 + postOffset;
c0d00d66:	4330      	orrs	r0, r6
c0d00d68:	1836      	adds	r6, r6, r0
c0d00d6a:	3620      	adds	r6, #32
c0d00d6c:	4de7      	ldr	r5, [pc, #924]	; (c0d0110c <handleStarkwareSignMessage+0x5b0>)
    }

    poorstream_init(&bitstream, dataContext.starkContext.w3);
c0d00d6e:	4629      	mov	r1, r5
c0d00d70:	3140      	adds	r1, #64	; 0x40
c0d00d72:	ad28      	add	r5, sp, #160	; 0xa0
c0d00d74:	4628      	mov	r0, r5
c0d00d76:	f003 fe43 	bl	c0d04a00 <poorstream_init>
c0d00d7a:	200b      	movs	r0, #11
    poorstream_write_bits(&bitstream, 0, 11);  // padding
c0d00d7c:	4669      	mov	r1, sp
c0d00d7e:	6008      	str	r0, [r1, #0]
c0d00d80:	2700      	movs	r7, #0
c0d00d82:	4628      	mov	r0, r5
c0d00d84:	463a      	mov	r2, r7
c0d00d86:	463b      	mov	r3, r7
c0d00d88:	f003 fe5c 	bl	c0d04a44 <poorstream_write_bits>
c0d00d8c:	2004      	movs	r0, #4
    poorstream_write_bits(
c0d00d8e:	4669      	mov	r1, sp
c0d00d90:	6008      	str	r0, [r1, #0]
        &bitstream,
        (p1 == P1_STARK_CONDITIONAL_TRANSFER ? STARK_CONDITIONAL_TRANSFER_TYPE
c0d00d92:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d00d94:	2805      	cmp	r0, #5
c0d00d96:	d001      	beq.n	c0d00d9c <handleStarkwareSignMessage+0x240>
c0d00d98:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0d00d9a:	e000      	b.n	c0d00d9e <handleStarkwareSignMessage+0x242>
c0d00d9c:	2202      	movs	r2, #2
c0d00d9e:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d00da0:	2805      	cmp	r0, #5
c0d00da2:	9712      	str	r7, [sp, #72]	; 0x48
c0d00da4:	d000      	beq.n	c0d00da8 <handleStarkwareSignMessage+0x24c>
c0d00da6:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    poorstream_write_bits(
c0d00da8:	4628      	mov	r0, r5
c0d00daa:	463b      	mov	r3, r7
c0d00dac:	f003 fe4a 	bl	c0d04a44 <poorstream_write_bits>
c0d00db0:	960c      	str	r6, [sp, #48]	; 0x30
                                             : order ? STARK_ORDER_TYPE : STARK_TRANSFER_TYPE),
        4);
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset), 31);
c0d00db2:	b2f0      	uxtb	r0, r6
c0d00db4:	1826      	adds	r6, r4, r0
c0d00db6:	7871      	ldrb	r1, [r6, #1]
c0d00db8:	910b      	str	r1, [sp, #44]	; 0x2c
c0d00dba:	5c21      	ldrb	r1, [r4, r0]
c0d00dbc:	78f2      	ldrb	r2, [r6, #3]
c0d00dbe:	78b3      	ldrb	r3, [r6, #2]
c0d00dc0:	271f      	movs	r7, #31
c0d00dc2:	4628      	mov	r0, r5
c0d00dc4:	9507      	str	r5, [sp, #28]
c0d00dc6:	466d      	mov	r5, sp
c0d00dc8:	602f      	str	r7, [r5, #0]
c0d00dca:	021b      	lsls	r3, r3, #8
c0d00dcc:	189a      	adds	r2, r3, r2
c0d00dce:	0209      	lsls	r1, r1, #8
c0d00dd0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
c0d00dd2:	18c9      	adds	r1, r1, r3
c0d00dd4:	0409      	lsls	r1, r1, #16
c0d00dd6:	1852      	adds	r2, r2, r1
c0d00dd8:	9b12      	ldr	r3, [sp, #72]	; 0x48
c0d00dda:	f003 fe33 	bl	c0d04a44 <poorstream_write_bits>
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset + 4), 31);
c0d00dde:	7970      	ldrb	r0, [r6, #5]
c0d00de0:	7931      	ldrb	r1, [r6, #4]
c0d00de2:	79f2      	ldrb	r2, [r6, #7]
c0d00de4:	79b3      	ldrb	r3, [r6, #6]
c0d00de6:	466d      	mov	r5, sp
c0d00de8:	970b      	str	r7, [sp, #44]	; 0x2c
c0d00dea:	602f      	str	r7, [r5, #0]
c0d00dec:	021b      	lsls	r3, r3, #8
c0d00dee:	189a      	adds	r2, r3, r2
c0d00df0:	0209      	lsls	r1, r1, #8
c0d00df2:	1808      	adds	r0, r1, r0
c0d00df4:	0400      	lsls	r0, r0, #16
c0d00df6:	1812      	adds	r2, r2, r0
c0d00df8:	9d07      	ldr	r5, [sp, #28]
c0d00dfa:	4628      	mov	r0, r5
c0d00dfc:	9b12      	ldr	r3, [sp, #72]	; 0x48
c0d00dfe:	f003 fe21 	bl	c0d04a44 <poorstream_write_bits>
    poorstream_write_bits(&bitstream, U8BE(dataBuffer, offset + 4 + 4), 63);
c0d00e02:	7a70      	ldrb	r0, [r6, #9]
c0d00e04:	900a      	str	r0, [sp, #40]	; 0x28
c0d00e06:	7a30      	ldrb	r0, [r6, #8]
c0d00e08:	9009      	str	r0, [sp, #36]	; 0x24
c0d00e0a:	7af0      	ldrb	r0, [r6, #11]
c0d00e0c:	9008      	str	r0, [sp, #32]
c0d00e0e:	7ab0      	ldrb	r0, [r6, #10]
c0d00e10:	9006      	str	r0, [sp, #24]
c0d00e12:	7b70      	ldrb	r0, [r6, #13]
c0d00e14:	9005      	str	r0, [sp, #20]
c0d00e16:	7b32      	ldrb	r2, [r6, #12]
c0d00e18:	7bf7      	ldrb	r7, [r6, #15]
c0d00e1a:	7bb1      	ldrb	r1, [r6, #14]
c0d00e1c:	203f      	movs	r0, #63	; 0x3f
c0d00e1e:	466b      	mov	r3, sp
c0d00e20:	9012      	str	r0, [sp, #72]	; 0x48
c0d00e22:	6018      	str	r0, [r3, #0]
c0d00e24:	0208      	lsls	r0, r1, #8
c0d00e26:	19c0      	adds	r0, r0, r7
c0d00e28:	0211      	lsls	r1, r2, #8
c0d00e2a:	9a05      	ldr	r2, [sp, #20]
c0d00e2c:	1889      	adds	r1, r1, r2
c0d00e2e:	0409      	lsls	r1, r1, #16
c0d00e30:	1842      	adds	r2, r0, r1
c0d00e32:	9806      	ldr	r0, [sp, #24]
c0d00e34:	0200      	lsls	r0, r0, #8
c0d00e36:	9908      	ldr	r1, [sp, #32]
c0d00e38:	1840      	adds	r0, r0, r1
c0d00e3a:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d00e3c:	0209      	lsls	r1, r1, #8
c0d00e3e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
c0d00e40:	18c9      	adds	r1, r1, r3
c0d00e42:	0409      	lsls	r1, r1, #16
c0d00e44:	1843      	adds	r3, r0, r1
c0d00e46:	4628      	mov	r0, r5
c0d00e48:	f003 fdfc 	bl	c0d04a44 <poorstream_write_bits>
    if (order) {
c0d00e4c:	9814      	ldr	r0, [sp, #80]	; 0x50
c0d00e4e:	2800      	cmp	r0, #0
c0d00e50:	d02a      	beq.n	c0d00ea8 <handleStarkwareSignMessage+0x34c>
        poorstream_write_bits(&bitstream, U8BE(dataBuffer, offset + 4 + 4 + 8), 63);
c0d00e52:	7c70      	ldrb	r0, [r6, #17]
c0d00e54:	900a      	str	r0, [sp, #40]	; 0x28
c0d00e56:	7c30      	ldrb	r0, [r6, #16]
c0d00e58:	9009      	str	r0, [sp, #36]	; 0x24
c0d00e5a:	7cf0      	ldrb	r0, [r6, #19]
c0d00e5c:	9008      	str	r0, [sp, #32]
c0d00e5e:	7cb5      	ldrb	r5, [r6, #18]
c0d00e60:	7d72      	ldrb	r2, [r6, #21]
c0d00e62:	7d37      	ldrb	r7, [r6, #20]
c0d00e64:	7df0      	ldrb	r0, [r6, #23]
c0d00e66:	7db6      	ldrb	r6, [r6, #22]
c0d00e68:	4669      	mov	r1, sp
c0d00e6a:	9b12      	ldr	r3, [sp, #72]	; 0x48
c0d00e6c:	600b      	str	r3, [r1, #0]
c0d00e6e:	0231      	lsls	r1, r6, #8
c0d00e70:	1808      	adds	r0, r1, r0
c0d00e72:	0239      	lsls	r1, r7, #8
c0d00e74:	1889      	adds	r1, r1, r2
c0d00e76:	0409      	lsls	r1, r1, #16
c0d00e78:	1842      	adds	r2, r0, r1
c0d00e7a:	0228      	lsls	r0, r5, #8
c0d00e7c:	9908      	ldr	r1, [sp, #32]
c0d00e7e:	1840      	adds	r0, r0, r1
c0d00e80:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d00e82:	0209      	lsls	r1, r1, #8
c0d00e84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
c0d00e86:	18c9      	adds	r1, r1, r3
c0d00e88:	0409      	lsls	r1, r1, #16
c0d00e8a:	1843      	adds	r3, r0, r1
c0d00e8c:	a828      	add	r0, sp, #160	; 0xa0
c0d00e8e:	f003 fdd9 	bl	c0d04a44 <poorstream_write_bits>
c0d00e92:	2018      	movs	r0, #24
c0d00e94:	e011      	b.n	c0d00eba <handleStarkwareSignMessage+0x35e>
c0d00e96:	46c0      	nop			; (mov r8, r8)
c0d00e98:	20001800 	.word	0x20001800
c0d00e9c:	20001804 	.word	0x20001804
c0d00ea0:	20001b40 	.word	0x20001b40
c0d00ea4:	20001cb8 	.word	0x20001cb8
        offset += 4 + 4 + 8 + 8;
    } else {
        poorstream_write_bits(&bitstream, 0, 63);
c0d00ea8:	4668      	mov	r0, sp
c0d00eaa:	9912      	ldr	r1, [sp, #72]	; 0x48
c0d00eac:	6001      	str	r1, [r0, #0]
c0d00eae:	a828      	add	r0, sp, #160	; 0xa0
c0d00eb0:	2200      	movs	r2, #0
c0d00eb2:	4613      	mov	r3, r2
c0d00eb4:	f003 fdc6 	bl	c0d04a44 <poorstream_write_bits>
c0d00eb8:	2010      	movs	r0, #16
c0d00eba:	990c      	ldr	r1, [sp, #48]	; 0x30
c0d00ebc:	1808      	adds	r0, r1, r0
        offset += 4 + 4 + 8;
    }
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset), 31);
c0d00ebe:	b2c0      	uxtb	r0, r0
c0d00ec0:	1826      	adds	r6, r4, r0
c0d00ec2:	7871      	ldrb	r1, [r6, #1]
c0d00ec4:	5c20      	ldrb	r0, [r4, r0]
c0d00ec6:	78f2      	ldrb	r2, [r6, #3]
c0d00ec8:	78b3      	ldrb	r3, [r6, #2]
c0d00eca:	466d      	mov	r5, sp
c0d00ecc:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
c0d00ece:	602f      	str	r7, [r5, #0]
c0d00ed0:	021b      	lsls	r3, r3, #8
c0d00ed2:	189a      	adds	r2, r3, r2
c0d00ed4:	0200      	lsls	r0, r0, #8
c0d00ed6:	1840      	adds	r0, r0, r1
c0d00ed8:	0400      	lsls	r0, r0, #16
c0d00eda:	1812      	adds	r2, r2, r0
c0d00edc:	af28      	add	r7, sp, #160	; 0xa0
c0d00ede:	2500      	movs	r5, #0
c0d00ee0:	4638      	mov	r0, r7
c0d00ee2:	462b      	mov	r3, r5
c0d00ee4:	f003 fdae 	bl	c0d04a44 <poorstream_write_bits>
    poorstream_write_bits(&bitstream, U4BE(dataBuffer, offset + 4), 22);
c0d00ee8:	7970      	ldrb	r0, [r6, #5]
c0d00eea:	9012      	str	r0, [sp, #72]	; 0x48
c0d00eec:	7931      	ldrb	r1, [r6, #4]
c0d00eee:	79f2      	ldrb	r2, [r6, #7]
c0d00ef0:	79b3      	ldrb	r3, [r6, #6]
c0d00ef2:	2616      	movs	r6, #22
c0d00ef4:	4668      	mov	r0, sp
c0d00ef6:	6006      	str	r6, [r0, #0]
c0d00ef8:	0218      	lsls	r0, r3, #8
c0d00efa:	1880      	adds	r0, r0, r2
c0d00efc:	0209      	lsls	r1, r1, #8
c0d00efe:	9a12      	ldr	r2, [sp, #72]	; 0x48
c0d00f00:	1889      	adds	r1, r1, r2
c0d00f02:	0409      	lsls	r1, r1, #16
c0d00f04:	1842      	adds	r2, r0, r1
c0d00f06:	4638      	mov	r0, r7
c0d00f08:	462b      	mov	r3, r5
c0d00f0a:	f003 fd9b 	bl	c0d04a44 <poorstream_write_bits>

    PRINTF("stark w1 %.*H\n", 32, dataContext.starkContext.w1);
    PRINTF("stark w2 %.*H\n", 32, dataContext.starkContext.w2);
    PRINTF("stark w3 %.*H\n", 32, dataContext.starkContext.w3);

    if (dataContext.starkContext.conditional) {
c0d00f0e:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0d00f10:	4e7e      	ldr	r6, [pc, #504]	; (c0d0110c <handleStarkwareSignMessage+0x5b0>)
c0d00f12:	5c30      	ldrb	r0, [r6, r0]
c0d00f14:	2800      	cmp	r0, #0
c0d00f16:	d01e      	beq.n	c0d00f56 <handleStarkwareSignMessage+0x3fa>
c0d00f18:	2701      	movs	r7, #1
c0d00f1a:	0239      	lsls	r1, r7, #8
        cx_keccak_init(&global_sha3, 256);
c0d00f1c:	487c      	ldr	r0, [pc, #496]	; (c0d01110 <handleStarkwareSignMessage+0x5b4>)
c0d00f1e:	f004 fca1 	bl	c0d05864 <cx_keccak_init>
        cx_hash((cx_hash_t *) &global_sha3,
c0d00f22:	4668      	mov	r0, sp
c0d00f24:	6005      	str	r5, [r0, #0]
c0d00f26:	6045      	str	r5, [r0, #4]
c0d00f28:	4632      	mov	r2, r6
c0d00f2a:	32c1      	adds	r2, #193	; 0xc1
c0d00f2c:	2314      	movs	r3, #20
c0d00f2e:	4878      	ldr	r0, [pc, #480]	; (c0d01110 <handleStarkwareSignMessage+0x5b4>)
c0d00f30:	4629      	mov	r1, r5
c0d00f32:	f004 fc67 	bl	c0d05804 <cx_hash>
c0d00f36:	2320      	movs	r3, #32
                0,
                dataContext.starkContext.conditionAddress,
                20,
                NULL,
                0);
        cx_hash((cx_hash_t *) &global_sha3,
c0d00f38:	4668      	mov	r0, sp
c0d00f3a:	4631      	mov	r1, r6
c0d00f3c:	3160      	adds	r1, #96	; 0x60
c0d00f3e:	c00a      	stmia	r0!, {r1, r3}
c0d00f40:	4632      	mov	r2, r6
c0d00f42:	32a1      	adds	r2, #161	; 0xa1
c0d00f44:	4872      	ldr	r0, [pc, #456]	; (c0d01110 <handleStarkwareSignMessage+0x5b4>)
c0d00f46:	4639      	mov	r1, r7
c0d00f48:	f004 fc5c 	bl	c0d05804 <cx_hash>
c0d00f4c:	2060      	movs	r0, #96	; 0x60
                CX_LAST,
                dataContext.starkContext.fact,
                32,
                dataContext.starkContext.w4,
                32);
        dataContext.starkContext.w4[0] &= 0x03;
c0d00f4e:	5c31      	ldrb	r1, [r6, r0]
c0d00f50:	2203      	movs	r2, #3
c0d00f52:	400a      	ands	r2, r1
c0d00f54:	5432      	strb	r2, [r6, r0]
        PRINTF("stark w4 %.*H\n", 32, dataContext.starkContext.w4);
    }
    // Prepare the UI
    if (order) {
c0d00f56:	9814      	ldr	r0, [sp, #80]	; 0x50
c0d00f58:	2800      	cmp	r0, #0
c0d00f5a:	d042      	beq.n	c0d00fe2 <handleStarkwareSignMessage+0x486>
        io_seproxyhal_io_heartbeat();
c0d00f5c:	f003 fa24 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
        // amount to sell
        stark_get_amount_string(dataBuffer + preOffset,
c0d00f60:	486d      	ldr	r0, [pc, #436]	; (c0d01118 <handleStarkwareSignMessage+0x5bc>)
c0d00f62:	302b      	adds	r0, #43	; 0x2b
c0d00f64:	4669      	mov	r1, sp
c0d00f66:	6008      	str	r0, [r1, #0]
c0d00f68:	9813      	ldr	r0, [sp, #76]	; 0x4c
                                dataBuffer + preOffset + 20,
                                dataBuffer + 20 + 32 + postOffset + 20 + 32 + postOffset + 4 + 4,
c0d00f6a:	1826      	adds	r6, r4, r0
c0d00f6c:	3634      	adds	r6, #52	; 0x34
c0d00f6e:	1837      	adds	r7, r6, r0
c0d00f70:	463a      	mov	r2, r7
c0d00f72:	323c      	adds	r2, #60	; 0x3c
                                (char *) (dataBuffer + TMP_OFFSET),
c0d00f74:	4625      	mov	r5, r4
c0d00f76:	358c      	adds	r5, #140	; 0x8c
        stark_get_amount_string(dataBuffer + preOffset,
c0d00f78:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d00f7a:	990e      	ldr	r1, [sp, #56]	; 0x38
c0d00f7c:	462b      	mov	r3, r5
c0d00f7e:	f003 fdf9 	bl	c0d04b74 <stark_get_amount_string>
                                strings.common.fullAmount);
        io_seproxyhal_io_heartbeat();
c0d00f82:	f003 fa11 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
        // amount to buy
        stark_get_amount_string(
c0d00f86:	4864      	ldr	r0, [pc, #400]	; (c0d01118 <handleStarkwareSignMessage+0x5bc>)
c0d00f88:	305d      	adds	r0, #93	; 0x5d
c0d00f8a:	4669      	mov	r1, sp
c0d00f8c:	6008      	str	r0, [r1, #0]
            dataBuffer + 20 + 32 + postOffset + preOffset,
c0d00f8e:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d00f90:	1830      	adds	r0, r6, r0
            dataBuffer + 20 + 32 + postOffset + preOffset + 20,
c0d00f92:	4601      	mov	r1, r0
c0d00f94:	3114      	adds	r1, #20
            dataBuffer + 20 + 32 + postOffset + 20 + 32 + postOffset + 4 + 4 + 8,
c0d00f96:	3744      	adds	r7, #68	; 0x44
        stark_get_amount_string(
c0d00f98:	463a      	mov	r2, r7
c0d00f9a:	462b      	mov	r3, r5
c0d00f9c:	f003 fdea 	bl	c0d04b74 <stark_get_amount_string>
c0d00fa0:	2048      	movs	r0, #72	; 0x48
c0d00fa2:	9913      	ldr	r1, [sp, #76]	; 0x4c
            strings.common.maxFee);
        // src vault ID
        snprintf(strings.common.fullAddress,
                 sizeof(strings.common.fullAddress),
                 "%d",
                 U4BE(dataBuffer, 20 + 32 + postOffset + 20 + 32 + postOffset));
c0d00fa4:	4308      	orrs	r0, r1
c0d00fa6:	1808      	adds	r0, r1, r0
                                dataBuffer + 20 + 32 + postOffset + 20 + 32 + postOffset + 4 + 4,
c0d00fa8:	1820      	adds	r0, r4, r0
c0d00faa:	2123      	movs	r1, #35	; 0x23
                 U4BE(dataBuffer, 20 + 32 + postOffset + 20 + 32 + postOffset));
c0d00fac:	5c41      	ldrb	r1, [r0, r1]
c0d00fae:	2222      	movs	r2, #34	; 0x22
c0d00fb0:	5c82      	ldrb	r2, [r0, r2]
c0d00fb2:	0212      	lsls	r2, r2, #8
c0d00fb4:	1851      	adds	r1, r2, r1
c0d00fb6:	2221      	movs	r2, #33	; 0x21
c0d00fb8:	5c82      	ldrb	r2, [r0, r2]
c0d00fba:	2320      	movs	r3, #32
c0d00fbc:	5cc0      	ldrb	r0, [r0, r3]
c0d00fbe:	0200      	lsls	r0, r0, #8
c0d00fc0:	1880      	adds	r0, r0, r2
c0d00fc2:	0400      	lsls	r0, r0, #16
c0d00fc4:	180b      	adds	r3, r1, r0
c0d00fc6:	212b      	movs	r1, #43	; 0x2b
        snprintf(strings.common.fullAddress,
c0d00fc8:	4a5a      	ldr	r2, [pc, #360]	; (c0d01134 <handleStarkwareSignMessage+0x5d8>)
c0d00fca:	447a      	add	r2, pc
c0d00fcc:	4852      	ldr	r0, [pc, #328]	; (c0d01118 <handleStarkwareSignMessage+0x5bc>)
c0d00fce:	f003 fb2d 	bl	c0d0462c <snprintf>
                     32,
                     dataBuffer + 20 + 32 + postOffset);
        }
    }
    if (order) {
        ux_flow_init(0, ux_stark_limit_order_flow, NULL);
c0d00fd2:	4959      	ldr	r1, [pc, #356]	; (c0d01138 <handleStarkwareSignMessage+0x5dc>)
c0d00fd4:	4479      	add	r1, pc
c0d00fd6:	2000      	movs	r0, #0
c0d00fd8:	4602      	mov	r2, r0
c0d00fda:	f007 fddb 	bl	c0d08b94 <ux_flow_init>
c0d00fde:	9c0d      	ldr	r4, [sp, #52]	; 0x34
c0d00fe0:	e082      	b.n	c0d010e8 <handleStarkwareSignMessage+0x58c>
        io_seproxyhal_io_heartbeat();
c0d00fe2:	f003 f9e1 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
        starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path, bip32PathLength, privateKeyData);
c0d00fe6:	4848      	ldr	r0, [pc, #288]	; (c0d01108 <handleStarkwareSignMessage+0x5ac>)
c0d00fe8:	1d00      	adds	r0, r0, #4
c0d00fea:	af39      	add	r7, sp, #228	; 0xe4
c0d00fec:	9712      	str	r7, [sp, #72]	; 0x48
c0d00fee:	9904      	ldr	r1, [sp, #16]
c0d00ff0:	463a      	mov	r2, r7
c0d00ff2:	f003 fd7d 	bl	c0d04af0 <starkDerivePrivateKey>
c0d00ff6:	262e      	movs	r6, #46	; 0x2e
c0d00ff8:	2220      	movs	r2, #32
c0d00ffa:	9210      	str	r2, [sp, #64]	; 0x40
c0d00ffc:	ad2f      	add	r5, sp, #188	; 0xbc
        cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d00ffe:	4630      	mov	r0, r6
c0d01000:	4639      	mov	r1, r7
c0d01002:	462b      	mov	r3, r5
c0d01004:	f004 fc70 	bl	c0d058e8 <cx_ecfp_init_private_key>
        io_seproxyhal_io_heartbeat();
c0d01008:	f003 f9ce 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d0100c:	af15      	add	r7, sp, #84	; 0x54
c0d0100e:	2301      	movs	r3, #1
        cx_ecfp_generate_pair(CX_CURVE_Stark256, &publicKey, &privateKey, 1);
c0d01010:	4630      	mov	r0, r6
c0d01012:	4639      	mov	r1, r7
c0d01014:	462a      	mov	r2, r5
c0d01016:	f004 fc77 	bl	c0d05908 <cx_ecfp_generate_pair>
c0d0101a:	2128      	movs	r1, #40	; 0x28
        explicit_bzero(&privateKey, sizeof(privateKey));
c0d0101c:	9114      	str	r1, [sp, #80]	; 0x50
c0d0101e:	4628      	mov	r0, r5
c0d01020:	f008 faf8 	bl	c0d09614 <explicit_bzero>
        explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d01024:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d01026:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0d01028:	4631      	mov	r1, r6
c0d0102a:	f008 faf3 	bl	c0d09614 <explicit_bzero>
        selfTransfer = (memcmp(publicKey.W + 1, dataBuffer + 20 + 32 + postOffset, 32) == 0);
c0d0102e:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d01030:	1825      	adds	r5, r4, r0
        io_seproxyhal_io_heartbeat();
c0d01032:	f003 f9b9 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
        selfTransfer = (memcmp(publicKey.W + 1, dataBuffer + 20 + 32 + postOffset, 32) == 0);
c0d01036:	4629      	mov	r1, r5
c0d01038:	3134      	adds	r1, #52	; 0x34
c0d0103a:	3709      	adds	r7, #9
c0d0103c:	4638      	mov	r0, r7
c0d0103e:	460f      	mov	r7, r1
c0d01040:	4632      	mov	r2, r6
c0d01042:	f008 faeb 	bl	c0d0961c <memcmp>
c0d01046:	9012      	str	r0, [sp, #72]	; 0x48
        io_seproxyhal_io_heartbeat();
c0d01048:	f003 f9ae 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
        stark_get_amount_string(dataBuffer + preOffset,
c0d0104c:	4831      	ldr	r0, [pc, #196]	; (c0d01114 <handleStarkwareSignMessage+0x5b8>)
c0d0104e:	4669      	mov	r1, sp
c0d01050:	6008      	str	r0, [r1, #0]
                                dataBuffer + 20 + 32 + postOffset + 32 + 4 + 4,
c0d01052:	355c      	adds	r5, #92	; 0x5c
                                (char *) (dataBuffer + TMP_OFFSET),
c0d01054:	4623      	mov	r3, r4
c0d01056:	338c      	adds	r3, #140	; 0x8c
        stark_get_amount_string(dataBuffer + preOffset,
c0d01058:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d0105a:	990e      	ldr	r1, [sp, #56]	; 0x38
c0d0105c:	462a      	mov	r2, r5
c0d0105e:	f003 fd89 	bl	c0d04b74 <stark_get_amount_string>
c0d01062:	2054      	movs	r0, #84	; 0x54
                 U4BE(dataBuffer, 20 + 32 + postOffset + 32 + 4));
c0d01064:	9913      	ldr	r1, [sp, #76]	; 0x4c
c0d01066:	4308      	orrs	r0, r1
        selfTransfer = (memcmp(publicKey.W + 1, dataBuffer + 20 + 32 + postOffset, 32) == 0);
c0d01068:	1820      	adds	r0, r4, r0
                 U4BE(dataBuffer, 20 + 32 + postOffset + 32 + 4));
c0d0106a:	79c1      	ldrb	r1, [r0, #7]
c0d0106c:	7982      	ldrb	r2, [r0, #6]
c0d0106e:	0212      	lsls	r2, r2, #8
c0d01070:	1851      	adds	r1, r2, r1
c0d01072:	7942      	ldrb	r2, [r0, #5]
c0d01074:	7900      	ldrb	r0, [r0, #4]
c0d01076:	0200      	lsls	r0, r0, #8
c0d01078:	1880      	adds	r0, r0, r2
c0d0107a:	0400      	lsls	r0, r0, #16
c0d0107c:	180b      	adds	r3, r1, r0
        snprintf(strings.tmp.tmp2,
c0d0107e:	4826      	ldr	r0, [pc, #152]	; (c0d01118 <handleStarkwareSignMessage+0x5bc>)
c0d01080:	3064      	adds	r0, #100	; 0x64
c0d01082:	4a26      	ldr	r2, [pc, #152]	; (c0d0111c <handleStarkwareSignMessage+0x5c0>)
c0d01084:	447a      	add	r2, pc
c0d01086:	9914      	ldr	r1, [sp, #80]	; 0x50
c0d01088:	f003 fad0 	bl	c0d0462c <snprintf>
        if (!selfTransfer) {
c0d0108c:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d0108e:	2800      	cmp	r0, #0
c0d01090:	d017      	beq.n	c0d010c2 <handleStarkwareSignMessage+0x566>
c0d01092:	4d1e      	ldr	r5, [pc, #120]	; (c0d0110c <handleStarkwareSignMessage+0x5b0>)
            memmove(dataContext.starkContext.transferDestination,
c0d01094:	4628      	mov	r0, r5
c0d01096:	3081      	adds	r0, #129	; 0x81
c0d01098:	2420      	movs	r4, #32
c0d0109a:	4639      	mov	r1, r7
c0d0109c:	4622      	mov	r2, r4
c0d0109e:	f008 faad 	bl	c0d095fc <__aeabi_memmove>
            snprintf(strings.tmp.tmp,
c0d010a2:	4668      	mov	r0, sp
c0d010a4:	6007      	str	r7, [r0, #0]
c0d010a6:	481c      	ldr	r0, [pc, #112]	; (c0d01118 <handleStarkwareSignMessage+0x5bc>)
c0d010a8:	2164      	movs	r1, #100	; 0x64
c0d010aa:	4a1f      	ldr	r2, [pc, #124]	; (c0d01128 <handleStarkwareSignMessage+0x5cc>)
c0d010ac:	447a      	add	r2, pc
c0d010ae:	4623      	mov	r3, r4
c0d010b0:	f003 fabc 	bl	c0d0462c <snprintf>
c0d010b4:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0d010b6:	5c28      	ldrb	r0, [r5, r0]
                (dataContext.starkContext.conditional ? ux_stark_self_transfer_conditional_flow
                                                      : ux_stark_self_transfer_flow),
                NULL);
        } else {
            ux_flow_init(0,
                         (dataContext.starkContext.conditional ? ux_stark_transfer_conditional_flow
c0d010b8:	2800      	cmp	r0, #0
c0d010ba:	d00b      	beq.n	c0d010d4 <handleStarkwareSignMessage+0x578>
c0d010bc:	491c      	ldr	r1, [pc, #112]	; (c0d01130 <handleStarkwareSignMessage+0x5d4>)
c0d010be:	4479      	add	r1, pc
c0d010c0:	e00a      	b.n	c0d010d8 <handleStarkwareSignMessage+0x57c>
c0d010c2:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0d010c4:	4911      	ldr	r1, [pc, #68]	; (c0d0110c <handleStarkwareSignMessage+0x5b0>)
c0d010c6:	5c08      	ldrb	r0, [r1, r0]
                (dataContext.starkContext.conditional ? ux_stark_self_transfer_conditional_flow
c0d010c8:	2800      	cmp	r0, #0
c0d010ca:	9c0d      	ldr	r4, [sp, #52]	; 0x34
c0d010cc:	d006      	beq.n	c0d010dc <handleStarkwareSignMessage+0x580>
c0d010ce:	4915      	ldr	r1, [pc, #84]	; (c0d01124 <handleStarkwareSignMessage+0x5c8>)
c0d010d0:	4479      	add	r1, pc
c0d010d2:	e005      	b.n	c0d010e0 <handleStarkwareSignMessage+0x584>
c0d010d4:	4915      	ldr	r1, [pc, #84]	; (c0d0112c <handleStarkwareSignMessage+0x5d0>)
c0d010d6:	4479      	add	r1, pc
c0d010d8:	9c0d      	ldr	r4, [sp, #52]	; 0x34
c0d010da:	e001      	b.n	c0d010e0 <handleStarkwareSignMessage+0x584>
c0d010dc:	4910      	ldr	r1, [pc, #64]	; (c0d01120 <handleStarkwareSignMessage+0x5c4>)
c0d010de:	4479      	add	r1, pc
c0d010e0:	2000      	movs	r0, #0
c0d010e2:	4602      	mov	r2, r0
c0d010e4:	f007 fd56 	bl	c0d08b94 <ux_flow_init>
                                                               : ux_stark_transfer_flow),
                         NULL);
        }
    }

    *flags |= IO_ASYNCH_REPLY;
c0d010e8:	6820      	ldr	r0, [r4, #0]
c0d010ea:	2110      	movs	r1, #16
c0d010ec:	4301      	orrs	r1, r0
c0d010ee:	6021      	str	r1, [r4, #0]
}
c0d010f0:	b041      	add	sp, #260	; 0x104
c0d010f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d010f4:	20d5      	movs	r0, #213	; 0xd5
c0d010f6:	01c0      	lsls	r0, r0, #7
c0d010f8:	3080      	adds	r0, #128	; 0x80
c0d010fa:	f002 fc82 	bl	c0d03a02 <os_longjmp>
c0d010fe:	2067      	movs	r0, #103	; 0x67
c0d01100:	0200      	lsls	r0, r0, #8
c0d01102:	f002 fc7e 	bl	c0d03a02 <os_longjmp>
c0d01106:	46c0      	nop			; (mov r8, r8)
c0d01108:	20001804 	.word	0x20001804
c0d0110c:	20001b40 	.word	0x20001b40
c0d01110:	20001cb8 	.word	0x20001cb8
c0d01114:	200018dc 	.word	0x200018dc
c0d01118:	20001c26 	.word	0x20001c26
c0d0111c:	0000916a 	.word	0x0000916a
c0d01120:	00009ef2 	.word	0x00009ef2
c0d01124:	00009f44 	.word	0x00009f44
c0d01128:	00008b4b 	.word	0x00008b4b
c0d0112c:	00009eda 	.word	0x00009eda
c0d01130:	00009f2e 	.word	0x00009f2e
c0d01134:	00009224 	.word	0x00009224
c0d01138:	00009e48 	.word	0x00009e48

c0d0113c <handleStarkwareUnsafeSign>:
void handleStarkwareUnsafeSign(uint8_t p1,
                               uint8_t p2,
                               uint8_t *dataBuffer,
                               uint16_t dataLength,
                               unsigned int *flags,
                               unsigned int *tx) {
c0d0113c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0113e:	b0a9      	sub	sp, #164	; 0xa4
c0d01140:	4615      	mov	r5, r2
c0d01142:	460f      	mov	r7, r1
c0d01144:	4606      	mov	r6, r0
    uint32_t i;
    uint8_t privateKeyData[32];
    cx_ecfp_public_key_t publicKey;
    cx_ecfp_private_key_t privateKey;
    uint8_t bip32PathLength = *(dataBuffer);
c0d01146:	7814      	ldrb	r4, [r2, #0]
    uint8_t offset = 1;
    // Initial checks
    if (appState != APP_STATE_IDLE) {
c0d01148:	493c      	ldr	r1, [pc, #240]	; (c0d0123c <handleStarkwareUnsafeSign+0x100>)
c0d0114a:	7809      	ldrb	r1, [r1, #0]
c0d0114c:	2900      	cmp	r1, #0
c0d0114e:	d003      	beq.n	c0d01158 <handleStarkwareUnsafeSign+0x1c>
c0d01150:	9303      	str	r3, [sp, #12]
        reset_app_context();
c0d01152:	f001 fef5 	bl	c0d02f40 <reset_app_context>
c0d01156:	9b03      	ldr	r3, [sp, #12]
    }
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH)) {
c0d01158:	1e61      	subs	r1, r4, #1
c0d0115a:	b2c9      	uxtb	r1, r1
c0d0115c:	290a      	cmp	r1, #10
c0d0115e:	d25f      	bcs.n	c0d01220 <handleStarkwareUnsafeSign+0xe4>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    if ((p1 != 0) || (p2 != 0)) {
c0d01160:	4337      	orrs	r7, r6
c0d01162:	2f00      	cmp	r7, #0
c0d01164:	d160      	bne.n	c0d01228 <handleStarkwareUnsafeSign+0xec>
        THROW(0x6B00);
    }

    if (dataLength != 32 + 4 * bip32PathLength + 1) {
c0d01166:	00a0      	lsls	r0, r4, #2
c0d01168:	3021      	adds	r0, #33	; 0x21
c0d0116a:	4298      	cmp	r0, r3
c0d0116c:	d161      	bne.n	c0d01232 <handleStarkwareUnsafeSign+0xf6>
c0d0116e:	982e      	ldr	r0, [sp, #184]	; 0xb8
        THROW(0x6700);
    }

    tmpCtx.transactionContext.pathLength = bip32PathLength;
c0d01170:	9003      	str	r0, [sp, #12]
c0d01172:	4833      	ldr	r0, [pc, #204]	; (c0d01240 <handleStarkwareUnsafeSign+0x104>)
c0d01174:	7004      	strb	r4, [r0, #0]
c0d01176:	1d00      	adds	r0, r0, #4
c0d01178:	1c69      	adds	r1, r5, #1
c0d0117a:	2201      	movs	r2, #1
c0d0117c:	9402      	str	r4, [sp, #8]
c0d0117e:	4623      	mov	r3, r4
    for (i = 0; i < bip32PathLength; i++) {
        tmpCtx.transactionContext.bip32Path[i] = U4BE(dataBuffer, offset);
c0d01180:	18af      	adds	r7, r5, r2
c0d01182:	78fe      	ldrb	r6, [r7, #3]
c0d01184:	78bc      	ldrb	r4, [r7, #2]
c0d01186:	0224      	lsls	r4, r4, #8
c0d01188:	19a4      	adds	r4, r4, r6
c0d0118a:	787e      	ldrb	r6, [r7, #1]
c0d0118c:	7809      	ldrb	r1, [r1, #0]
c0d0118e:	0209      	lsls	r1, r1, #8
c0d01190:	1989      	adds	r1, r1, r6
c0d01192:	0409      	lsls	r1, r1, #16
c0d01194:	1861      	adds	r1, r4, r1
c0d01196:	c002      	stmia	r0!, {r1}
        PRINTF("Storing path %d %d\n", i, tmpCtx.transactionContext.bip32Path[i]);
        offset += 4;
c0d01198:	1d11      	adds	r1, r2, #4
c0d0119a:	b2ca      	uxtb	r2, r1
c0d0119c:	18a9      	adds	r1, r5, r2
    for (i = 0; i < bip32PathLength; i++) {
c0d0119e:	1e5b      	subs	r3, r3, #1
c0d011a0:	d1ee      	bne.n	c0d01180 <handleStarkwareUnsafeSign+0x44>
    }
    memmove(dataContext.starkContext.w2, dataBuffer + offset, 32);
c0d011a2:	4828      	ldr	r0, [pc, #160]	; (c0d01244 <handleStarkwareUnsafeSign+0x108>)
c0d011a4:	3020      	adds	r0, #32
c0d011a6:	2420      	movs	r4, #32
c0d011a8:	4622      	mov	r2, r4
c0d011aa:	9401      	str	r4, [sp, #4]
c0d011ac:	f008 fa26 	bl	c0d095fc <__aeabi_memmove>
    io_seproxyhal_io_heartbeat();
c0d011b0:	f003 f8fa 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path, bip32PathLength, privateKeyData);
c0d011b4:	4822      	ldr	r0, [pc, #136]	; (c0d01240 <handleStarkwareUnsafeSign+0x104>)
c0d011b6:	1d00      	adds	r0, r0, #4
c0d011b8:	af21      	add	r7, sp, #132	; 0x84
c0d011ba:	9902      	ldr	r1, [sp, #8]
c0d011bc:	463a      	mov	r2, r7
c0d011be:	f003 fc97 	bl	c0d04af0 <starkDerivePrivateKey>
c0d011c2:	262e      	movs	r6, #46	; 0x2e
c0d011c4:	ad04      	add	r5, sp, #16
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d011c6:	4630      	mov	r0, r6
c0d011c8:	4639      	mov	r1, r7
c0d011ca:	4622      	mov	r2, r4
c0d011cc:	462b      	mov	r3, r5
c0d011ce:	f004 fb8b 	bl	c0d058e8 <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d011d2:	f003 f8e9 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d011d6:	ac0e      	add	r4, sp, #56	; 0x38
c0d011d8:	2301      	movs	r3, #1
    cx_ecfp_generate_pair(CX_CURVE_Stark256, &publicKey, &privateKey, 1);
c0d011da:	4630      	mov	r0, r6
c0d011dc:	4621      	mov	r1, r4
c0d011de:	462a      	mov	r2, r5
c0d011e0:	f004 fb92 	bl	c0d05908 <cx_ecfp_generate_pair>
c0d011e4:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d011e6:	4628      	mov	r0, r5
c0d011e8:	f008 fa14 	bl	c0d09614 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d011ec:	4638      	mov	r0, r7
c0d011ee:	9d01      	ldr	r5, [sp, #4]
c0d011f0:	4629      	mov	r1, r5
c0d011f2:	f008 fa0f 	bl	c0d09614 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0d011f6:	f003 f8d7 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    memmove(dataContext.starkContext.w1, publicKey.W + 1, 32);
c0d011fa:	3409      	adds	r4, #9
c0d011fc:	4811      	ldr	r0, [pc, #68]	; (c0d01244 <handleStarkwareUnsafeSign+0x108>)
c0d011fe:	4621      	mov	r1, r4
c0d01200:	462a      	mov	r2, r5
c0d01202:	f008 f9f7 	bl	c0d095f4 <__aeabi_memcpy>
    ux_flow_init(0, ux_stark_unsafe_sign_flow, NULL);
c0d01206:	4910      	ldr	r1, [pc, #64]	; (c0d01248 <handleStarkwareUnsafeSign+0x10c>)
c0d01208:	4479      	add	r1, pc
c0d0120a:	2000      	movs	r0, #0
c0d0120c:	4602      	mov	r2, r0
c0d0120e:	f007 fcc1 	bl	c0d08b94 <ux_flow_init>
c0d01212:	9a03      	ldr	r2, [sp, #12]

    *flags |= IO_ASYNCH_REPLY;
c0d01214:	6810      	ldr	r0, [r2, #0]
c0d01216:	2110      	movs	r1, #16
c0d01218:	4301      	orrs	r1, r0
c0d0121a:	6011      	str	r1, [r2, #0]
}
c0d0121c:	b029      	add	sp, #164	; 0xa4
c0d0121e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01220:	20d5      	movs	r0, #213	; 0xd5
c0d01222:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0d01224:	f002 fbed 	bl	c0d03a02 <os_longjmp>
c0d01228:	20d5      	movs	r0, #213	; 0xd5
c0d0122a:	01c0      	lsls	r0, r0, #7
        THROW(0x6B00);
c0d0122c:	3080      	adds	r0, #128	; 0x80
c0d0122e:	f002 fbe8 	bl	c0d03a02 <os_longjmp>
c0d01232:	2067      	movs	r0, #103	; 0x67
c0d01234:	0200      	lsls	r0, r0, #8
        THROW(0x6700);
c0d01236:	f002 fbe4 	bl	c0d03a02 <os_longjmp>
c0d0123a:	46c0      	nop			; (mov r8, r8)
c0d0123c:	20001800 	.word	0x20001800
c0d01240:	20001804 	.word	0x20001804
c0d01244:	20001b40 	.word	0x20001b40
c0d01248:	00009f04 	.word	0x00009f04

c0d0124c <get_underlying_asset_decimals>:
    {"CBAT", 18},
    {"CREP", 18},
    {"cSAI", 18},
};

bool get_underlying_asset_decimals(char *compound_ticker, uint8_t *out_decimals) {
c0d0124c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0124e:	b081      	sub	sp, #4
c0d01250:	9100      	str	r1, [sp, #0]
c0d01252:	4605      	mov	r5, r0
c0d01254:	2400      	movs	r4, #0
c0d01256:	4e0e      	ldr	r6, [pc, #56]	; (c0d01290 <get_underlying_asset_decimals+0x44>)
c0d01258:	447e      	add	r6, pc
    for (size_t i = 0; i < NUM_COMPOUND_BINDINGS; i++) {
        underlying_asset_decimals_t *binding =
            (underlying_asset_decimals_t *) PIC(&UNDERLYING_ASSET_DECIMALS[i]);
c0d0125a:	4630      	mov	r0, r6
c0d0125c:	f003 fbba 	bl	c0d049d4 <pic>
c0d01260:	4607      	mov	r7, r0
c0d01262:	210c      	movs	r1, #12
        if (strncmp(binding->c_ticker,
                    compound_ticker,
                    strnlen(binding->c_ticker, MAX_TICKER_LEN)) == 0) {
c0d01264:	f008 fc24 	bl	c0d09ab0 <strnlen>
c0d01268:	4602      	mov	r2, r0
        if (strncmp(binding->c_ticker,
c0d0126a:	4638      	mov	r0, r7
c0d0126c:	4629      	mov	r1, r5
c0d0126e:	f008 fbaf 	bl	c0d099d0 <strncmp>
c0d01272:	2800      	cmp	r0, #0
c0d01274:	d005      	beq.n	c0d01282 <get_underlying_asset_decimals+0x36>
c0d01276:	1c64      	adds	r4, r4, #1
    for (size_t i = 0; i < NUM_COMPOUND_BINDINGS; i++) {
c0d01278:	360d      	adds	r6, #13
c0d0127a:	2c08      	cmp	r4, #8
c0d0127c:	d9ed      	bls.n	c0d0125a <get_underlying_asset_decimals+0xe>
c0d0127e:	2000      	movs	r0, #0
c0d01280:	e003      	b.n	c0d0128a <get_underlying_asset_decimals+0x3e>
            *out_decimals = binding->decimals;
c0d01282:	7b38      	ldrb	r0, [r7, #12]
c0d01284:	9900      	ldr	r1, [sp, #0]
c0d01286:	7008      	strb	r0, [r1, #0]
c0d01288:	2001      	movs	r0, #1
            return true;
        }
    }
    return false;
}
c0d0128a:	b001      	add	sp, #4
c0d0128c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0128e:	46c0      	nop			; (mov r8, r8)
c0d01290:	000089a6 	.word	0x000089a6

c0d01294 <compound_plugin_call>:

void compound_plugin_call(int message, void *parameters) {
c0d01294:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01296:	b083      	sub	sp, #12
c0d01298:	460c      	mov	r4, r1
c0d0129a:	21ff      	movs	r1, #255	; 0xff
c0d0129c:	460a      	mov	r2, r1
c0d0129e:	3204      	adds	r2, #4
    switch (message) {
c0d012a0:	4290      	cmp	r0, r2
c0d012a2:	dc12      	bgt.n	c0d012ca <compound_plugin_call+0x36>
c0d012a4:	3102      	adds	r1, #2
c0d012a6:	4288      	cmp	r0, r1
c0d012a8:	d036      	beq.n	c0d01318 <compound_plugin_call+0x84>
c0d012aa:	2181      	movs	r1, #129	; 0x81
c0d012ac:	0049      	lsls	r1, r1, #1
c0d012ae:	4288      	cmp	r0, r1
c0d012b0:	d055      	beq.n	c0d0135e <compound_plugin_call+0xca>
c0d012b2:	4290      	cmp	r0, r2
c0d012b4:	d000      	beq.n	c0d012b8 <compound_plugin_call+0x24>
c0d012b6:	e0f8      	b.n	c0d014aa <compound_plugin_call+0x216>
        } break;

        case ETH_PLUGIN_FINALIZE: {
            ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
            PRINTF("compound plugin finalize\n");
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d012b8:	6860      	ldr	r0, [r4, #4]
c0d012ba:	6800      	ldr	r0, [r0, #0]
c0d012bc:	2101      	movs	r1, #1
            msg->numScreens = 2;
            msg->uiType = ETH_UI_TYPE_GENERIC;
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d012be:	77a1      	strb	r1, [r4, #30]
c0d012c0:	497b      	ldr	r1, [pc, #492]	; (c0d014b0 <compound_plugin_call+0x21c>)
            msg->uiType = ETH_UI_TYPE_GENERIC;
c0d012c2:	83a1      	strh	r1, [r4, #28]
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d012c4:	3063      	adds	r0, #99	; 0x63
c0d012c6:	60e0      	str	r0, [r4, #12]
c0d012c8:	e0ef      	b.n	c0d014aa <compound_plugin_call+0x216>
c0d012ca:	2641      	movs	r6, #65	; 0x41
c0d012cc:	00b2      	lsls	r2, r6, #2
    switch (message) {
c0d012ce:	4290      	cmp	r0, r2
c0d012d0:	d052      	beq.n	c0d01378 <compound_plugin_call+0xe4>
c0d012d2:	3106      	adds	r1, #6
c0d012d4:	4288      	cmp	r0, r1
c0d012d6:	d069      	beq.n	c0d013ac <compound_plugin_call+0x118>
c0d012d8:	2183      	movs	r1, #131	; 0x83
c0d012da:	0049      	lsls	r1, r1, #1
c0d012dc:	4288      	cmp	r0, r1
c0d012de:	d000      	beq.n	c0d012e2 <compound_plugin_call+0x4e>
c0d012e0:	e0e3      	b.n	c0d014aa <compound_plugin_call+0x216>
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0d012e2:	7b20      	ldrb	r0, [r4, #12]
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d012e4:	68a5      	ldr	r5, [r4, #8]
            switch (msg->screenIndex) {
c0d012e6:	2801      	cmp	r0, #1
c0d012e8:	d100      	bne.n	c0d012ec <compound_plugin_call+0x58>
c0d012ea:	e0b9      	b.n	c0d01460 <compound_plugin_call+0x1cc>
c0d012ec:	2800      	cmp	r0, #0
c0d012ee:	d000      	beq.n	c0d012f2 <compound_plugin_call+0x5e>
c0d012f0:	e0db      	b.n	c0d014aa <compound_plugin_call+0x216>
                case 0: {
                    strcpy(msg->title, "Amount");
c0d012f2:	6920      	ldr	r0, [r4, #16]
c0d012f4:	496f      	ldr	r1, [pc, #444]	; (c0d014b4 <compound_plugin_call+0x220>)
c0d012f6:	4479      	add	r1, pc
c0d012f8:	2207      	movs	r2, #7
c0d012fa:	f008 f97b 	bl	c0d095f4 <__aeabi_memcpy>
c0d012fe:	202d      	movs	r0, #45	; 0x2d
                    if (context->selectorIndex != COMPOUND_REDEEM) {
                        ticker_ptr++;
                    }
                    amountToString(context->amount,
                                   sizeof(context->amount),
                                   context->decimals,
c0d01300:	5c2a      	ldrb	r2, [r5, r0]
                    if (context->selectorIndex != COMPOUND_REDEEM) {
c0d01302:	7828      	ldrb	r0, [r5, #0]
                                   ticker_ptr,
                                   msg->msg,
c0d01304:	69a1      	ldr	r1, [r4, #24]
c0d01306:	2364      	movs	r3, #100	; 0x64
                    amountToString(context->amount,
c0d01308:	466e      	mov	r6, sp
c0d0130a:	c60a      	stmia	r6!, {r1, r3}
c0d0130c:	462b      	mov	r3, r5
                    if (context->selectorIndex != COMPOUND_REDEEM) {
c0d0130e:	2801      	cmp	r0, #1
c0d01310:	d100      	bne.n	c0d01314 <compound_plugin_call+0x80>
c0d01312:	e0ba      	b.n	c0d0148a <compound_plugin_call+0x1f6>
c0d01314:	3322      	adds	r3, #34	; 0x22
c0d01316:	e0b9      	b.n	c0d0148c <compound_plugin_call+0x1f8>
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d01318:	68a5      	ldr	r5, [r4, #8]
c0d0131a:	2600      	movs	r6, #0
c0d0131c:	4f66      	ldr	r7, [pc, #408]	; (c0d014b8 <compound_plugin_call+0x224>)
c0d0131e:	447f      	add	r7, pc
                if (memcmp((uint8_t *) PIC(COMPOUND_SELECTORS[i]), msg->selector, SELECTOR_SIZE) ==
c0d01320:	6838      	ldr	r0, [r7, #0]
c0d01322:	f003 fb57 	bl	c0d049d4 <pic>
c0d01326:	7801      	ldrb	r1, [r0, #0]
c0d01328:	7842      	ldrb	r2, [r0, #1]
c0d0132a:	0212      	lsls	r2, r2, #8
c0d0132c:	1851      	adds	r1, r2, r1
c0d0132e:	7882      	ldrb	r2, [r0, #2]
c0d01330:	78c0      	ldrb	r0, [r0, #3]
c0d01332:	0200      	lsls	r0, r0, #8
c0d01334:	1880      	adds	r0, r0, r2
c0d01336:	0400      	lsls	r0, r0, #16
c0d01338:	1840      	adds	r0, r0, r1
c0d0133a:	6921      	ldr	r1, [r4, #16]
c0d0133c:	780a      	ldrb	r2, [r1, #0]
c0d0133e:	784b      	ldrb	r3, [r1, #1]
c0d01340:	021b      	lsls	r3, r3, #8
c0d01342:	189a      	adds	r2, r3, r2
c0d01344:	788b      	ldrb	r3, [r1, #2]
c0d01346:	78c9      	ldrb	r1, [r1, #3]
c0d01348:	0209      	lsls	r1, r1, #8
c0d0134a:	18c9      	adds	r1, r1, r3
c0d0134c:	0409      	lsls	r1, r1, #16
c0d0134e:	1889      	adds	r1, r1, r2
c0d01350:	4288      	cmp	r0, r1
c0d01352:	d03f      	beq.n	c0d013d4 <compound_plugin_call+0x140>
            for (i = 0; i < NUM_COMPOUND_SELECTORS; i++) {
c0d01354:	1d3f      	adds	r7, r7, #4
c0d01356:	1c76      	adds	r6, r6, #1
c0d01358:	2e04      	cmp	r6, #4
c0d0135a:	d3e1      	bcc.n	c0d01320 <compound_plugin_call+0x8c>
c0d0135c:	e03b      	b.n	c0d013d6 <compound_plugin_call+0x142>
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d0135e:	68a0      	ldr	r0, [r4, #8]
            if (context->selectorIndex != CETH_MINT) {
c0d01360:	7801      	ldrb	r1, [r0, #0]
c0d01362:	2903      	cmp	r1, #3
c0d01364:	d034      	beq.n	c0d013d0 <compound_plugin_call+0x13c>
                switch (msg->parameterOffset) {
c0d01366:	6921      	ldr	r1, [r4, #16]
c0d01368:	2904      	cmp	r1, #4
c0d0136a:	d131      	bne.n	c0d013d0 <compound_plugin_call+0x13c>
                        memmove(context->amount, msg->parameter, 32);
c0d0136c:	68e1      	ldr	r1, [r4, #12]
c0d0136e:	1c40      	adds	r0, r0, #1
c0d01370:	2220      	movs	r2, #32
c0d01372:	f008 f943 	bl	c0d095fc <__aeabi_memmove>
c0d01376:	e096      	b.n	c0d014a6 <compound_plugin_call+0x212>
            if (msg->token1 != NULL) {
c0d01378:	68e1      	ldr	r1, [r4, #12]
c0d0137a:	2900      	cmp	r1, #0
c0d0137c:	d014      	beq.n	c0d013a8 <compound_plugin_call+0x114>
c0d0137e:	68a5      	ldr	r5, [r4, #8]
                strcpy((char *) context->ticker_1, (char *) msg->token1->ticker);
c0d01380:	4628      	mov	r0, r5
c0d01382:	3021      	adds	r0, #33	; 0x21
c0d01384:	3114      	adds	r1, #20
c0d01386:	f008 faed 	bl	c0d09964 <strcpy>
                switch (context->selectorIndex) {
c0d0138a:	7829      	ldrb	r1, [r5, #0]
c0d0138c:	1e8a      	subs	r2, r1, #2
c0d0138e:	2a02      	cmp	r2, #2
c0d01390:	d304      	bcc.n	c0d0139c <compound_plugin_call+0x108>
c0d01392:	2901      	cmp	r1, #1
c0d01394:	d100      	bne.n	c0d01398 <compound_plugin_call+0x104>
c0d01396:	e081      	b.n	c0d0149c <compound_plugin_call+0x208>
c0d01398:	2900      	cmp	r1, #0
c0d0139a:	d105      	bne.n	c0d013a8 <compound_plugin_call+0x114>
                            get_underlying_asset_decimals(context->ticker_1, &context->decimals)
c0d0139c:	352d      	adds	r5, #45	; 0x2d
c0d0139e:	4629      	mov	r1, r5
c0d013a0:	f7ff ff54 	bl	c0d0124c <get_underlying_asset_decimals>
c0d013a4:	2800      	cmp	r0, #0
c0d013a6:	d17e      	bne.n	c0d014a6 <compound_plugin_call+0x212>
c0d013a8:	2003      	movs	r0, #3
c0d013aa:	e07d      	b.n	c0d014a8 <compound_plugin_call+0x214>
            compound_parameters_t *context = (compound_parameters_t *) msg->pluginContext;
c0d013ac:	68a5      	ldr	r5, [r4, #8]
            strcpy(msg->name, "Type");
c0d013ae:	68e0      	ldr	r0, [r4, #12]
c0d013b0:	4943      	ldr	r1, [pc, #268]	; (c0d014c0 <compound_plugin_call+0x22c>)
c0d013b2:	4479      	add	r1, pc
c0d013b4:	2205      	movs	r2, #5
c0d013b6:	f008 f91d 	bl	c0d095f4 <__aeabi_memcpy>
            switch (context->selectorIndex) {
c0d013ba:	7828      	ldrb	r0, [r5, #0]
c0d013bc:	1e81      	subs	r1, r0, #2
c0d013be:	2902      	cmp	r1, #2
c0d013c0:	d333      	bcc.n	c0d0142a <compound_plugin_call+0x196>
c0d013c2:	2801      	cmp	r0, #1
c0d013c4:	d837      	bhi.n	c0d01436 <compound_plugin_call+0x1a2>
                    strcpy(msg->version, "Redeem");
c0d013c6:	6960      	ldr	r0, [r4, #20]
c0d013c8:	493e      	ldr	r1, [pc, #248]	; (c0d014c4 <compound_plugin_call+0x230>)
c0d013ca:	4479      	add	r1, pc
c0d013cc:	2207      	movs	r2, #7
c0d013ce:	e030      	b.n	c0d01432 <compound_plugin_call+0x19e>
c0d013d0:	2000      	movs	r0, #0
c0d013d2:	e069      	b.n	c0d014a8 <compound_plugin_call+0x214>
                    context->selectorIndex = i;
c0d013d4:	702e      	strb	r6, [r5, #0]
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d013d6:	6860      	ldr	r0, [r4, #4]
c0d013d8:	6800      	ldr	r0, [r0, #0]
c0d013da:	3042      	adds	r0, #66	; 0x42
c0d013dc:	2100      	movs	r1, #0
        if (buf[i]) {
c0d013de:	5c42      	ldrb	r2, [r0, r1]
c0d013e0:	2a00      	cmp	r2, #0
c0d013e2:	d103      	bne.n	c0d013ec <compound_plugin_call+0x158>
c0d013e4:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d013e6:	291f      	cmp	r1, #31
c0d013e8:	d9f9      	bls.n	c0d013de <compound_plugin_call+0x14a>
c0d013ea:	e002      	b.n	c0d013f2 <compound_plugin_call+0x15e>
                if (context->selectorIndex != CETH_MINT) {
c0d013ec:	7828      	ldrb	r0, [r5, #0]
c0d013ee:	2803      	cmp	r0, #3
c0d013f0:	d119      	bne.n	c0d01426 <compound_plugin_call+0x192>
            if (i == NUM_COMPOUND_SELECTORS) {
c0d013f2:	2e04      	cmp	r6, #4
c0d013f4:	d017      	beq.n	c0d01426 <compound_plugin_call+0x192>
            if (msg->dataSize != COMPOUND_EXPECTED_DATA_SIZE[context->selectorIndex]) {
c0d013f6:	7828      	ldrb	r0, [r5, #0]
c0d013f8:	4930      	ldr	r1, [pc, #192]	; (c0d014bc <compound_plugin_call+0x228>)
c0d013fa:	4479      	add	r1, pc
c0d013fc:	5c09      	ldrb	r1, [r1, r0]
c0d013fe:	6962      	ldr	r2, [r4, #20]
c0d01400:	428a      	cmp	r2, r1
c0d01402:	d110      	bne.n	c0d01426 <compound_plugin_call+0x192>
            if (context->selectorIndex == CETH_MINT) {
c0d01404:	2803      	cmp	r0, #3
c0d01406:	d128      	bne.n	c0d0145a <compound_plugin_call+0x1c6>
                memset(context->amount, 0, sizeof(context->amount));
c0d01408:	1c6d      	adds	r5, r5, #1
c0d0140a:	2120      	movs	r1, #32
c0d0140c:	4628      	mov	r0, r5
c0d0140e:	f008 f8eb 	bl	c0d095e8 <__aeabi_memclr>
                            msg->pluginSharedRO->txContent->value.length,
c0d01412:	6860      	ldr	r0, [r4, #4]
c0d01414:	6801      	ldr	r1, [r0, #0]
c0d01416:	2062      	movs	r0, #98	; 0x62
c0d01418:	5c0a      	ldrb	r2, [r1, r0]
                memmove(context->amount + sizeof(context->amount) -
c0d0141a:	1aa8      	subs	r0, r5, r2
c0d0141c:	3020      	adds	r0, #32
                            msg->pluginSharedRO->txContent->value.length,
c0d0141e:	3142      	adds	r1, #66	; 0x42
                memmove(context->amount + sizeof(context->amount) -
c0d01420:	f008 f8ec 	bl	c0d095fc <__aeabi_memmove>
c0d01424:	e019      	b.n	c0d0145a <compound_plugin_call+0x1c6>
c0d01426:	2000      	movs	r0, #0
c0d01428:	e018      	b.n	c0d0145c <compound_plugin_call+0x1c8>
                    strcpy(msg->version, "Lend");
c0d0142a:	6960      	ldr	r0, [r4, #20]
c0d0142c:	4926      	ldr	r1, [pc, #152]	; (c0d014c8 <compound_plugin_call+0x234>)
c0d0142e:	4479      	add	r1, pc
c0d01430:	2205      	movs	r2, #5
c0d01432:	f008 f8df 	bl	c0d095f4 <__aeabi_memcpy>
            strcat(msg->version, " Assets");
c0d01436:	6965      	ldr	r5, [r4, #20]
c0d01438:	4628      	mov	r0, r5
c0d0143a:	f008 fa9b 	bl	c0d09974 <strlen>
c0d0143e:	2120      	movs	r1, #32
c0d01440:	5429      	strb	r1, [r5, r0]
c0d01442:	1828      	adds	r0, r5, r0
c0d01444:	2100      	movs	r1, #0
c0d01446:	71c1      	strb	r1, [r0, #7]
c0d01448:	2173      	movs	r1, #115	; 0x73
c0d0144a:	7181      	strb	r1, [r0, #6]
c0d0144c:	2274      	movs	r2, #116	; 0x74
c0d0144e:	7142      	strb	r2, [r0, #5]
c0d01450:	2265      	movs	r2, #101	; 0x65
c0d01452:	7102      	strb	r2, [r0, #4]
c0d01454:	70c1      	strb	r1, [r0, #3]
c0d01456:	7081      	strb	r1, [r0, #2]
c0d01458:	7046      	strb	r6, [r0, #1]
c0d0145a:	2001      	movs	r0, #1
c0d0145c:	7720      	strb	r0, [r4, #28]
c0d0145e:	e024      	b.n	c0d014aa <compound_plugin_call+0x216>
                                   100);
                    msg->result = ETH_PLUGIN_RESULT_OK;
                } break;

                case 1:
                    strcpy(msg->title, "Contract");
c0d01460:	6920      	ldr	r0, [r4, #16]
c0d01462:	491a      	ldr	r1, [pc, #104]	; (c0d014cc <compound_plugin_call+0x238>)
c0d01464:	4479      	add	r1, pc
c0d01466:	2209      	movs	r2, #9
c0d01468:	f008 f8c4 	bl	c0d095f4 <__aeabi_memcpy>
                    strcpy(msg->msg, "Compound ");
c0d0146c:	69a0      	ldr	r0, [r4, #24]
c0d0146e:	4918      	ldr	r1, [pc, #96]	; (c0d014d0 <compound_plugin_call+0x23c>)
c0d01470:	4479      	add	r1, pc
c0d01472:	220a      	movs	r2, #10
c0d01474:	f008 f8be 	bl	c0d095f4 <__aeabi_memcpy>
                    strcat(msg->msg,
c0d01478:	69a0      	ldr	r0, [r4, #24]
                           (char *) context->ticker_1 +
c0d0147a:	3522      	adds	r5, #34	; 0x22
                    strcat(msg->msg,
c0d0147c:	4629      	mov	r1, r5
c0d0147e:	f008 fa07 	bl	c0d09890 <strcat>
c0d01482:	2020      	movs	r0, #32
c0d01484:	2101      	movs	r1, #1
                               1);  // remove the 'c' char at beginning of compound ticker
                    msg->result = ETH_PLUGIN_RESULT_OK;
c0d01486:	5421      	strb	r1, [r4, r0]
c0d01488:	e00f      	b.n	c0d014aa <compound_plugin_call+0x216>
c0d0148a:	3321      	adds	r3, #33	; 0x21
                    amountToString(context->amount,
c0d0148c:	1c68      	adds	r0, r5, #1
c0d0148e:	2520      	movs	r5, #32
c0d01490:	4629      	mov	r1, r5
c0d01492:	f007 f9bd 	bl	c0d08810 <amountToString>
c0d01496:	2001      	movs	r0, #1
                    msg->result = ETH_PLUGIN_RESULT_OK;
c0d01498:	5560      	strb	r0, [r4, r5]
c0d0149a:	e006      	b.n	c0d014aa <compound_plugin_call+0x216>
                        context->decimals = msg->token1->decimals;
c0d0149c:	68e0      	ldr	r0, [r4, #12]
c0d0149e:	2120      	movs	r1, #32
c0d014a0:	5c40      	ldrb	r0, [r0, r1]
c0d014a2:	212d      	movs	r1, #45	; 0x2d
c0d014a4:	5468      	strb	r0, [r5, r1]
c0d014a6:	2001      	movs	r0, #1
c0d014a8:	7520      	strb	r0, [r4, #20]
c0d014aa:	b003      	add	sp, #12
c0d014ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d014ae:	46c0      	nop			; (mov r8, r8)
c0d014b0:	00000202 	.word	0x00000202
c0d014b4:	00008992 	.word	0x00008992
c0d014b8:	00008aca 	.word	0x00008aca
c0d014bc:	00008879 	.word	0x00008879
c0d014c0:	000088c5 	.word	0x000088c5
c0d014c4:	000088b2 	.word	0x000088b2
c0d014c8:	00008855 	.word	0x00008855
c0d014cc:	0000893c 	.word	0x0000893c
c0d014d0:	00008820 	.word	0x00008820

c0d014d4 <check_token_binding>:
};

bool check_token_binding(char *ticker1,
                         char *ticker2,
                         const ticker_binding_t *bindings,
                         size_t num_bindings) {
c0d014d4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d014d6:	b083      	sub	sp, #12
c0d014d8:	9101      	str	r1, [sp, #4]
c0d014da:	9002      	str	r0, [sp, #8]
    for (size_t i = 0; i < num_bindings; i++) {
c0d014dc:	2b00      	cmp	r3, #0
c0d014de:	d020      	beq.n	c0d01522 <check_token_binding+0x4e>
c0d014e0:	461c      	mov	r4, r3
c0d014e2:	4615      	mov	r5, r2
c0d014e4:	2700      	movs	r7, #0
        ticker_binding_t *binding = (ticker_binding_t *) PIC(&bindings[i]);
c0d014e6:	4628      	mov	r0, r5
c0d014e8:	f003 fa74 	bl	c0d049d4 <pic>
c0d014ec:	4606      	mov	r6, r0
c0d014ee:	210c      	movs	r1, #12
        if (strncmp(binding->ticker1, ticker1, strnlen(binding->ticker1, MAX_TICKER_LEN)) == 0 &&
c0d014f0:	f008 fade 	bl	c0d09ab0 <strnlen>
c0d014f4:	4602      	mov	r2, r0
c0d014f6:	4630      	mov	r0, r6
c0d014f8:	9902      	ldr	r1, [sp, #8]
c0d014fa:	f008 fa69 	bl	c0d099d0 <strncmp>
c0d014fe:	2800      	cmp	r0, #0
c0d01500:	d10b      	bne.n	c0d0151a <check_token_binding+0x46>
            strncmp(binding->ticker2, ticker2, strnlen(binding->ticker2, MAX_TICKER_LEN)) == 0) {
c0d01502:	360c      	adds	r6, #12
c0d01504:	210c      	movs	r1, #12
c0d01506:	4630      	mov	r0, r6
c0d01508:	f008 fad2 	bl	c0d09ab0 <strnlen>
c0d0150c:	4602      	mov	r2, r0
c0d0150e:	4630      	mov	r0, r6
c0d01510:	9901      	ldr	r1, [sp, #4]
c0d01512:	f008 fa5d 	bl	c0d099d0 <strncmp>
        if (strncmp(binding->ticker1, ticker1, strnlen(binding->ticker1, MAX_TICKER_LEN)) == 0 &&
c0d01516:	2800      	cmp	r0, #0
c0d01518:	d006      	beq.n	c0d01528 <check_token_binding+0x54>
    for (size_t i = 0; i < num_bindings; i++) {
c0d0151a:	3518      	adds	r5, #24
c0d0151c:	1c7f      	adds	r7, r7, #1
c0d0151e:	42a7      	cmp	r7, r4
c0d01520:	d3e1      	bcc.n	c0d014e6 <check_token_binding+0x12>
c0d01522:	2000      	movs	r0, #0
            return true;
        }
    }
    return false;
}
c0d01524:	b003      	add	sp, #12
c0d01526:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01528:	2001      	movs	r0, #1
c0d0152a:	e7fb      	b.n	c0d01524 <check_token_binding+0x50>

c0d0152c <erc20_plugin_available_check>:

bool erc20_plugin_available_check() {
#ifdef HAVE_STARKWARE
    if (quantumSet) {
c0d0152c:	4807      	ldr	r0, [pc, #28]	; (c0d0154c <erc20_plugin_available_check+0x20>)
c0d0152e:	7801      	ldrb	r1, [r0, #0]
c0d01530:	2001      	movs	r0, #1
c0d01532:	2900      	cmp	r1, #0
c0d01534:	d006      	beq.n	c0d01544 <erc20_plugin_available_check+0x18>
c0d01536:	21e5      	movs	r1, #229	; 0xe5
        switch (dataContext.tokenContext.quantumType) {
c0d01538:	4a05      	ldr	r2, [pc, #20]	; (c0d01550 <erc20_plugin_available_check+0x24>)
c0d0153a:	5c51      	ldrb	r1, [r2, r1]
c0d0153c:	2904      	cmp	r1, #4
c0d0153e:	d802      	bhi.n	c0d01546 <erc20_plugin_available_check+0x1a>
c0d01540:	2903      	cmp	r1, #3
c0d01542:	d000      	beq.n	c0d01546 <erc20_plugin_available_check+0x1a>
                return false;
        }
    }
#endif
    return true;
}
c0d01544:	4770      	bx	lr
c0d01546:	2000      	movs	r0, #0
c0d01548:	4770      	bx	lr
c0d0154a:	46c0      	nop			; (mov r8, r8)
c0d0154c:	2000189d 	.word	0x2000189d
c0d01550:	20001b40 	.word	0x20001b40

c0d01554 <erc20_plugin_call>:

void erc20_plugin_call(int message, void *parameters) {
c0d01554:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01556:	b083      	sub	sp, #12
c0d01558:	460c      	mov	r4, r1
c0d0155a:	21ff      	movs	r1, #255	; 0xff
c0d0155c:	460a      	mov	r2, r1
c0d0155e:	3204      	adds	r2, #4
    switch (message) {
c0d01560:	4290      	cmp	r0, r2
c0d01562:	dc1d      	bgt.n	c0d015a0 <erc20_plugin_call+0x4c>
c0d01564:	3102      	adds	r1, #2
c0d01566:	4288      	cmp	r0, r1
c0d01568:	d048      	beq.n	c0d015fc <erc20_plugin_call+0xa8>
c0d0156a:	2181      	movs	r1, #129	; 0x81
c0d0156c:	0049      	lsls	r1, r1, #1
c0d0156e:	4288      	cmp	r0, r1
c0d01570:	d072      	beq.n	c0d01658 <erc20_plugin_call+0x104>
c0d01572:	4290      	cmp	r0, r2
c0d01574:	d000      	beq.n	c0d01578 <erc20_plugin_call+0x24>
c0d01576:	e129      	b.n	c0d017cc <erc20_plugin_call+0x278>
            }
        } break;

        case ETH_PLUGIN_FINALIZE: {
            ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d01578:	68a0      	ldr	r0, [r4, #8]
            PRINTF("erc20 plugin finalize\n");
            if (context->selectorIndex == ERC20_TRANSFER) {
c0d0157a:	7801      	ldrb	r1, [r0, #0]
c0d0157c:	2901      	cmp	r1, #1
c0d0157e:	d100      	bne.n	c0d01582 <erc20_plugin_call+0x2e>
c0d01580:	e0be      	b.n	c0d01700 <erc20_plugin_call+0x1ac>
c0d01582:	2900      	cmp	r1, #0
c0d01584:	d000      	beq.n	c0d01588 <erc20_plugin_call+0x34>
c0d01586:	e121      	b.n	c0d017cc <erc20_plugin_call+0x278>
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d01588:	6861      	ldr	r1, [r4, #4]
c0d0158a:	6809      	ldr	r1, [r1, #0]
c0d0158c:	2201      	movs	r2, #1
                msg->amount = context->amount;
                msg->address = context->destinationAddress;
                msg->uiType = ETH_UI_TYPE_AMOUNT_ADDRESS;
                msg->result = ETH_PLUGIN_RESULT_OK;
c0d0158e:	77a2      	strb	r2, [r4, #30]
                msg->uiType = ETH_UI_TYPE_AMOUNT_ADDRESS;
c0d01590:	7722      	strb	r2, [r4, #28]
                msg->address = context->destinationAddress;
c0d01592:	1c42      	adds	r2, r0, #1
                msg->amount = context->amount;
c0d01594:	3016      	adds	r0, #22
c0d01596:	6160      	str	r0, [r4, #20]
                msg->address = context->destinationAddress;
c0d01598:	61a2      	str	r2, [r4, #24]
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d0159a:	3163      	adds	r1, #99	; 0x63
c0d0159c:	60e1      	str	r1, [r4, #12]
c0d0159e:	e115      	b.n	c0d017cc <erc20_plugin_call+0x278>
c0d015a0:	2641      	movs	r6, #65	; 0x41
c0d015a2:	00b2      	lsls	r2, r6, #2
    switch (message) {
c0d015a4:	4290      	cmp	r0, r2
c0d015a6:	d062      	beq.n	c0d0166e <erc20_plugin_call+0x11a>
c0d015a8:	3106      	adds	r1, #6
c0d015aa:	4288      	cmp	r0, r1
c0d015ac:	d100      	bne.n	c0d015b0 <erc20_plugin_call+0x5c>
c0d015ae:	e08c      	b.n	c0d016ca <erc20_plugin_call+0x176>
c0d015b0:	2183      	movs	r1, #131	; 0x83
c0d015b2:	0049      	lsls	r1, r1, #1
c0d015b4:	4288      	cmp	r0, r1
c0d015b6:	d000      	beq.n	c0d015ba <erc20_plugin_call+0x66>
c0d015b8:	e108      	b.n	c0d017cc <erc20_plugin_call+0x278>
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0d015ba:	7b20      	ldrb	r0, [r4, #12]
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d015bc:	68a5      	ldr	r5, [r4, #8]
            switch (msg->screenIndex) {
c0d015be:	2801      	cmp	r0, #1
c0d015c0:	d100      	bne.n	c0d015c4 <erc20_plugin_call+0x70>
c0d015c2:	e0a8      	b.n	c0d01716 <erc20_plugin_call+0x1c2>
c0d015c4:	2800      	cmp	r0, #0
c0d015c6:	d000      	beq.n	c0d015ca <erc20_plugin_call+0x76>
c0d015c8:	e100      	b.n	c0d017cc <erc20_plugin_call+0x278>
                case 0:
                    strcpy(msg->title, "Amount");
c0d015ca:	6920      	ldr	r0, [r4, #16]
c0d015cc:	4982      	ldr	r1, [pc, #520]	; (c0d017d8 <erc20_plugin_call+0x284>)
c0d015ce:	4479      	add	r1, pc
c0d015d0:	2207      	movs	r2, #7
c0d015d2:	f008 f80f 	bl	c0d095f4 <__aeabi_memcpy>
                    if (ismaxint(context->amount, sizeof(context->amount))) {
c0d015d6:	4628      	mov	r0, r5
c0d015d8:	3016      	adds	r0, #22
c0d015da:	2100      	movs	r1, #0
    }
    return 1;
}
__attribute__((no_instrument_function)) inline int ismaxint(uint8_t *buf, int n) {
    for (int i = 0; i < n; ++i) {
        if (buf[i] != 0xff) {
c0d015dc:	5c42      	ldrb	r2, [r0, r1]
c0d015de:	2aff      	cmp	r2, #255	; 0xff
c0d015e0:	d000      	beq.n	c0d015e4 <erc20_plugin_call+0x90>
c0d015e2:	e0c3      	b.n	c0d0176c <erc20_plugin_call+0x218>
c0d015e4:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d015e6:	291f      	cmp	r1, #31
c0d015e8:	d9f8      	bls.n	c0d015dc <erc20_plugin_call+0x88>
                        strcpy(msg->msg, "Unlimited ");
c0d015ea:	69a0      	ldr	r0, [r4, #24]
c0d015ec:	4980      	ldr	r1, [pc, #512]	; (c0d017f0 <erc20_plugin_call+0x29c>)
c0d015ee:	4479      	add	r1, pc
c0d015f0:	220b      	movs	r2, #11
c0d015f2:	f007 ffff 	bl	c0d095f4 <__aeabi_memcpy>
                        strcat(msg->msg, (char *) context->ticker_1);
c0d015f6:	69a0      	ldr	r0, [r4, #24]
c0d015f8:	3536      	adds	r5, #54	; 0x36
c0d015fa:	e0a3      	b.n	c0d01744 <erc20_plugin_call+0x1f0>
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d015fc:	6860      	ldr	r0, [r4, #4]
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d015fe:	68a5      	ldr	r5, [r4, #8]
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d01600:	6800      	ldr	r0, [r0, #0]
c0d01602:	3042      	adds	r0, #66	; 0x42
c0d01604:	2100      	movs	r1, #0
        if (buf[i]) {
c0d01606:	5c42      	ldrb	r2, [r0, r1]
c0d01608:	2a00      	cmp	r2, #0
c0d0160a:	d175      	bne.n	c0d016f8 <erc20_plugin_call+0x1a4>
c0d0160c:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d0160e:	2920      	cmp	r1, #32
c0d01610:	d3f9      	bcc.n	c0d01606 <erc20_plugin_call+0xb2>
c0d01612:	2600      	movs	r6, #0
c0d01614:	4f71      	ldr	r7, [pc, #452]	; (c0d017dc <erc20_plugin_call+0x288>)
c0d01616:	447f      	add	r7, pc
                    if (memcmp((uint8_t *) PIC(ERC20_SELECTORS[i]), msg->selector, SELECTOR_SIZE) ==
c0d01618:	6838      	ldr	r0, [r7, #0]
c0d0161a:	f003 f9db 	bl	c0d049d4 <pic>
c0d0161e:	7801      	ldrb	r1, [r0, #0]
c0d01620:	7842      	ldrb	r2, [r0, #1]
c0d01622:	0212      	lsls	r2, r2, #8
c0d01624:	1851      	adds	r1, r2, r1
c0d01626:	7882      	ldrb	r2, [r0, #2]
c0d01628:	78c0      	ldrb	r0, [r0, #3]
c0d0162a:	0200      	lsls	r0, r0, #8
c0d0162c:	1880      	adds	r0, r0, r2
c0d0162e:	0400      	lsls	r0, r0, #16
c0d01630:	1840      	adds	r0, r0, r1
c0d01632:	6921      	ldr	r1, [r4, #16]
c0d01634:	780a      	ldrb	r2, [r1, #0]
c0d01636:	784b      	ldrb	r3, [r1, #1]
c0d01638:	021b      	lsls	r3, r3, #8
c0d0163a:	189a      	adds	r2, r3, r2
c0d0163c:	788b      	ldrb	r3, [r1, #2]
c0d0163e:	78c9      	ldrb	r1, [r1, #3]
c0d01640:	0209      	lsls	r1, r1, #8
c0d01642:	18c9      	adds	r1, r1, r3
c0d01644:	0409      	lsls	r1, r1, #16
c0d01646:	1889      	adds	r1, r1, r2
c0d01648:	4288      	cmp	r0, r1
c0d0164a:	d100      	bne.n	c0d0164e <erc20_plugin_call+0xfa>
c0d0164c:	e088      	b.n	c0d01760 <erc20_plugin_call+0x20c>
                for (i = 0; i < NUM_ERC20_SELECTORS; i++) {
c0d0164e:	1d3f      	adds	r7, r7, #4
c0d01650:	1c76      	adds	r6, r6, #1
c0d01652:	2e02      	cmp	r6, #2
c0d01654:	d3e0      	bcc.n	c0d01618 <erc20_plugin_call+0xc4>
c0d01656:	e084      	b.n	c0d01762 <erc20_plugin_call+0x20e>
            switch (msg->parameterOffset) {
c0d01658:	6921      	ldr	r1, [r4, #16]
            erc20_parameters_t *context = (erc20_parameters_t *) msg->pluginContext;
c0d0165a:	68a0      	ldr	r0, [r4, #8]
            switch (msg->parameterOffset) {
c0d0165c:	2924      	cmp	r1, #36	; 0x24
c0d0165e:	d075      	beq.n	c0d0174c <erc20_plugin_call+0x1f8>
c0d01660:	2904      	cmp	r1, #4
c0d01662:	d17a      	bne.n	c0d0175a <erc20_plugin_call+0x206>
                    memmove(context->destinationAddress, msg->parameter + 12, 20);
c0d01664:	68e1      	ldr	r1, [r4, #12]
c0d01666:	1c40      	adds	r0, r0, #1
c0d01668:	310c      	adds	r1, #12
c0d0166a:	2214      	movs	r2, #20
c0d0166c:	e071      	b.n	c0d01752 <erc20_plugin_call+0x1fe>
            if (msg->token1 != NULL) {
c0d0166e:	68e1      	ldr	r1, [r4, #12]
c0d01670:	2900      	cmp	r1, #0
c0d01672:	d043      	beq.n	c0d016fc <erc20_plugin_call+0x1a8>
c0d01674:	68a5      	ldr	r5, [r4, #8]
c0d01676:	204f      	movs	r0, #79	; 0x4f
c0d01678:	2200      	movs	r2, #0
                context->target = TARGET_ADDRESS;
c0d0167a:	542a      	strb	r2, [r5, r0]
                strcpy((char *) context->ticker_1, (char *) msg->token1->ticker);
c0d0167c:	4628      	mov	r0, r5
c0d0167e:	3036      	adds	r0, #54	; 0x36
c0d01680:	3114      	adds	r1, #20
c0d01682:	f008 f96f 	bl	c0d09964 <strcpy>
                context->decimals = msg->token1->decimals;
c0d01686:	68e0      	ldr	r0, [r4, #12]
c0d01688:	2120      	movs	r1, #32
c0d0168a:	5c40      	ldrb	r0, [r0, r1]
c0d0168c:	214e      	movs	r1, #78	; 0x4e
c0d0168e:	5468      	strb	r0, [r5, r1]
                if (context->selectorIndex == ERC20_APPROVE) {
c0d01690:	7828      	ldrb	r0, [r5, #0]
c0d01692:	2801      	cmp	r0, #1
c0d01694:	d15f      	bne.n	c0d01756 <erc20_plugin_call+0x202>
                    if (msg->token2 != NULL) {
c0d01696:	6921      	ldr	r1, [r4, #16]
c0d01698:	2900      	cmp	r1, #0
c0d0169a:	d05c      	beq.n	c0d01756 <erc20_plugin_call+0x202>
c0d0169c:	462e      	mov	r6, r5
c0d0169e:	364f      	adds	r6, #79	; 0x4f
c0d016a0:	2001      	movs	r0, #1
                        context->target = TARGET_CONTRACT;
c0d016a2:	7030      	strb	r0, [r6, #0]
                        strcpy((char *) context->ticker_2, (char *) msg->token2->ticker);
c0d016a4:	3542      	adds	r5, #66	; 0x42
c0d016a6:	3114      	adds	r1, #20
c0d016a8:	4628      	mov	r0, r5
c0d016aa:	f008 f95b 	bl	c0d09964 <strcpy>
                        if (check_token_binding((char *) msg->token1->ticker,
c0d016ae:	68e0      	ldr	r0, [r4, #12]
                                                (char *) msg->token2->ticker,
c0d016b0:	6921      	ldr	r1, [r4, #16]
                        if (check_token_binding((char *) msg->token1->ticker,
c0d016b2:	3014      	adds	r0, #20
                                                (char *) msg->token2->ticker,
c0d016b4:	3114      	adds	r1, #20
                        if (check_token_binding((char *) msg->token1->ticker,
c0d016b6:	4a4a      	ldr	r2, [pc, #296]	; (c0d017e0 <erc20_plugin_call+0x28c>)
c0d016b8:	447a      	add	r2, pc
c0d016ba:	2309      	movs	r3, #9
c0d016bc:	f7ff ff0a 	bl	c0d014d4 <check_token_binding>
c0d016c0:	2800      	cmp	r0, #0
c0d016c2:	d048      	beq.n	c0d01756 <erc20_plugin_call+0x202>
c0d016c4:	2002      	movs	r0, #2
                            context->target = TARGET_COMPOUND;
c0d016c6:	7030      	strb	r0, [r6, #0]
c0d016c8:	e045      	b.n	c0d01756 <erc20_plugin_call+0x202>
            strcpy(msg->name, "Type");
c0d016ca:	68e0      	ldr	r0, [r4, #12]
c0d016cc:	4945      	ldr	r1, [pc, #276]	; (c0d017e4 <erc20_plugin_call+0x290>)
c0d016ce:	4479      	add	r1, pc
c0d016d0:	2205      	movs	r2, #5
c0d016d2:	f007 ff8f 	bl	c0d095f4 <__aeabi_memcpy>
            strcpy(msg->version, "Approve");
c0d016d6:	6960      	ldr	r0, [r4, #20]
c0d016d8:	2100      	movs	r1, #0
c0d016da:	71c1      	strb	r1, [r0, #7]
c0d016dc:	2165      	movs	r1, #101	; 0x65
c0d016de:	7181      	strb	r1, [r0, #6]
c0d016e0:	2176      	movs	r1, #118	; 0x76
c0d016e2:	7141      	strb	r1, [r0, #5]
c0d016e4:	216f      	movs	r1, #111	; 0x6f
c0d016e6:	7101      	strb	r1, [r0, #4]
c0d016e8:	2172      	movs	r1, #114	; 0x72
c0d016ea:	70c1      	strb	r1, [r0, #3]
c0d016ec:	2170      	movs	r1, #112	; 0x70
c0d016ee:	7081      	strb	r1, [r0, #2]
c0d016f0:	7041      	strb	r1, [r0, #1]
c0d016f2:	7006      	strb	r6, [r0, #0]
c0d016f4:	2001      	movs	r0, #1
c0d016f6:	e037      	b.n	c0d01768 <erc20_plugin_call+0x214>
c0d016f8:	2000      	movs	r0, #0
c0d016fa:	e035      	b.n	c0d01768 <erc20_plugin_call+0x214>
c0d016fc:	2003      	movs	r0, #3
c0d016fe:	e02d      	b.n	c0d0175c <erc20_plugin_call+0x208>
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d01700:	6861      	ldr	r1, [r4, #4]
c0d01702:	6809      	ldr	r1, [r1, #0]
                msg->tokenLookup2 = context->destinationAddress;
c0d01704:	1c40      	adds	r0, r0, #1
c0d01706:	2201      	movs	r2, #1
                msg->result = ETH_PLUGIN_RESULT_OK;
c0d01708:	77a2      	strb	r2, [r4, #30]
c0d0170a:	4a32      	ldr	r2, [pc, #200]	; (c0d017d4 <erc20_plugin_call+0x280>)
                msg->uiType = ETH_UI_TYPE_GENERIC;
c0d0170c:	83a2      	strh	r2, [r4, #28]
                msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d0170e:	3163      	adds	r1, #99	; 0x63
c0d01710:	60e1      	str	r1, [r4, #12]
                msg->tokenLookup2 = context->destinationAddress;
c0d01712:	6120      	str	r0, [r4, #16]
c0d01714:	e05a      	b.n	c0d017cc <erc20_plugin_call+0x278>
c0d01716:	204f      	movs	r0, #79	; 0x4f
                                       100);
                    }
                    msg->result = ETH_PLUGIN_RESULT_OK;
                    break;
                case 1:
                    if (context->target >= TARGET_CONTRACT) {
c0d01718:	5c29      	ldrb	r1, [r5, r0]
c0d0171a:	6920      	ldr	r0, [r4, #16]
c0d0171c:	2900      	cmp	r1, #0
c0d0171e:	d031      	beq.n	c0d01784 <erc20_plugin_call+0x230>
c0d01720:	462e      	mov	r6, r5
c0d01722:	364f      	adds	r6, #79	; 0x4f
                        strcpy(msg->title, "Contract");
c0d01724:	4930      	ldr	r1, [pc, #192]	; (c0d017e8 <erc20_plugin_call+0x294>)
c0d01726:	4479      	add	r1, pc
c0d01728:	2209      	movs	r2, #9
c0d0172a:	f007 ff63 	bl	c0d095f4 <__aeabi_memcpy>
c0d0172e:	69a0      	ldr	r0, [r4, #24]
                        if (context->target == TARGET_COMPOUND) {
c0d01730:	7831      	ldrb	r1, [r6, #0]
c0d01732:	2902      	cmp	r1, #2
c0d01734:	d143      	bne.n	c0d017be <erc20_plugin_call+0x26a>
                            strcpy(msg->msg, "Compound ");
c0d01736:	492d      	ldr	r1, [pc, #180]	; (c0d017ec <erc20_plugin_call+0x298>)
c0d01738:	4479      	add	r1, pc
c0d0173a:	220a      	movs	r2, #10
c0d0173c:	f007 ff5a 	bl	c0d095f4 <__aeabi_memcpy>
                            strcat(msg->msg,
c0d01740:	69a0      	ldr	r0, [r4, #24]
                                   (char *) context->ticker_2 +
c0d01742:	3543      	adds	r5, #67	; 0x43
c0d01744:	4629      	mov	r1, r5
c0d01746:	f008 f8a3 	bl	c0d09890 <strcat>
c0d0174a:	e03c      	b.n	c0d017c6 <erc20_plugin_call+0x272>
                    memmove(context->amount, msg->parameter, 32);
c0d0174c:	68e1      	ldr	r1, [r4, #12]
c0d0174e:	3016      	adds	r0, #22
c0d01750:	2220      	movs	r2, #32
c0d01752:	f007 ff53 	bl	c0d095fc <__aeabi_memmove>
c0d01756:	2001      	movs	r0, #1
c0d01758:	e000      	b.n	c0d0175c <erc20_plugin_call+0x208>
c0d0175a:	2000      	movs	r0, #0
c0d0175c:	7520      	strb	r0, [r4, #20]
c0d0175e:	e035      	b.n	c0d017cc <erc20_plugin_call+0x278>
                        context->selectorIndex = i;
c0d01760:	702e      	strb	r6, [r5, #0]
                if (i == NUM_ERC20_SELECTORS) {
c0d01762:	1eb0      	subs	r0, r6, #2
c0d01764:	1e41      	subs	r1, r0, #1
c0d01766:	4188      	sbcs	r0, r1
c0d01768:	7720      	strb	r0, [r4, #28]
c0d0176a:	e02f      	b.n	c0d017cc <erc20_plugin_call+0x278>
c0d0176c:	214e      	movs	r1, #78	; 0x4e
                                       context->decimals,
c0d0176e:	5c6a      	ldrb	r2, [r5, r1]
                                       msg->msg,
c0d01770:	69a1      	ldr	r1, [r4, #24]
c0d01772:	2364      	movs	r3, #100	; 0x64
                        amountToString(context->amount,
c0d01774:	466e      	mov	r6, sp
c0d01776:	c60a      	stmia	r6!, {r1, r3}
                                       (char *) context->ticker_1,
c0d01778:	3536      	adds	r5, #54	; 0x36
c0d0177a:	2120      	movs	r1, #32
                        amountToString(context->amount,
c0d0177c:	462b      	mov	r3, r5
c0d0177e:	f007 f847 	bl	c0d08810 <amountToString>
c0d01782:	e020      	b.n	c0d017c6 <erc20_plugin_call+0x272>
c0d01784:	2100      	movs	r1, #0
                                       1);  // remove the 'c' char at beginning of compound ticker
                        } else {
                            strcpy(msg->msg, (char *) context->ticker_2);
                        }
                    } else {
                        strcpy(msg->title, "Address");
c0d01786:	71c1      	strb	r1, [r0, #7]
c0d01788:	2173      	movs	r1, #115	; 0x73
c0d0178a:	7181      	strb	r1, [r0, #6]
c0d0178c:	7141      	strb	r1, [r0, #5]
c0d0178e:	2165      	movs	r1, #101	; 0x65
c0d01790:	7101      	strb	r1, [r0, #4]
c0d01792:	2172      	movs	r1, #114	; 0x72
c0d01794:	70c1      	strb	r1, [r0, #3]
c0d01796:	2164      	movs	r1, #100	; 0x64
c0d01798:	7081      	strb	r1, [r0, #2]
c0d0179a:	7041      	strb	r1, [r0, #1]
c0d0179c:	7006      	strb	r6, [r0, #0]
                        msg->msg[0] = '0';
c0d0179e:	69a0      	ldr	r0, [r4, #24]
c0d017a0:	2130      	movs	r1, #48	; 0x30
c0d017a2:	7001      	strb	r1, [r0, #0]
                        msg->msg[1] = 'x';
c0d017a4:	69a0      	ldr	r0, [r4, #24]
c0d017a6:	2178      	movs	r1, #120	; 0x78
c0d017a8:	7041      	strb	r1, [r0, #1]
                        getEthAddressStringFromBinary(context->destinationAddress,
                                                      (uint8_t *) msg->msg + 2,
                                                      msg->pluginSharedRW->sha3,
                                                      chainConfig);
c0d017aa:	4809      	ldr	r0, [pc, #36]	; (c0d017d0 <erc20_plugin_call+0x27c>)
c0d017ac:	6803      	ldr	r3, [r0, #0]
                                                      msg->pluginSharedRW->sha3,
c0d017ae:	6820      	ldr	r0, [r4, #0]
c0d017b0:	6802      	ldr	r2, [r0, #0]
                        getEthAddressStringFromBinary(context->destinationAddress,
c0d017b2:	1c68      	adds	r0, r5, #1
                                                      (uint8_t *) msg->msg + 2,
c0d017b4:	69a1      	ldr	r1, [r4, #24]
c0d017b6:	1c89      	adds	r1, r1, #2
                        getEthAddressStringFromBinary(context->destinationAddress,
c0d017b8:	f000 fbdc 	bl	c0d01f74 <getEthAddressStringFromBinary>
c0d017bc:	e003      	b.n	c0d017c6 <erc20_plugin_call+0x272>
                            strcpy(msg->msg, (char *) context->ticker_2);
c0d017be:	3542      	adds	r5, #66	; 0x42
c0d017c0:	4629      	mov	r1, r5
c0d017c2:	f008 f8cf 	bl	c0d09964 <strcpy>
c0d017c6:	2020      	movs	r0, #32
c0d017c8:	2101      	movs	r1, #1
c0d017ca:	5421      	strb	r1, [r4, r0]
c0d017cc:	b003      	add	sp, #12
c0d017ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d017d0:	20001b3c 	.word	0x20001b3c
c0d017d4:	00000202 	.word	0x00000202
c0d017d8:	000086ba 	.word	0x000086ba
c0d017dc:	000087b2 	.word	0x000087b2
c0d017e0:	000085e2 	.word	0x000085e2
c0d017e4:	000085a9 	.word	0x000085a9
c0d017e8:	0000867a 	.word	0x0000867a
c0d017ec:	00008558 	.word	0x00008558
c0d017f0:	00008786 	.word	0x00008786

c0d017f4 <erc721_plugin_available_check>:
    // tokenDefinition_t *tokenAddress;
} erc721_parameters_t;

bool erc721_plugin_available_check() {
#ifdef HAVE_STARKWARE
    if (quantumSet) {
c0d017f4:	4807      	ldr	r0, [pc, #28]	; (c0d01814 <erc721_plugin_available_check+0x20>)
c0d017f6:	7800      	ldrb	r0, [r0, #0]
c0d017f8:	2100      	movs	r1, #0
c0d017fa:	2800      	cmp	r0, #0
c0d017fc:	d008      	beq.n	c0d01810 <erc721_plugin_available_check+0x1c>
c0d017fe:	20e5      	movs	r0, #229	; 0xe5
        switch (dataContext.tokenContext.quantumType) {
c0d01800:	4a05      	ldr	r2, [pc, #20]	; (c0d01818 <erc721_plugin_available_check+0x24>)
c0d01802:	5c12      	ldrb	r2, [r2, r0]
c0d01804:	2001      	movs	r0, #1
c0d01806:	2a03      	cmp	r2, #3
c0d01808:	d001      	beq.n	c0d0180e <erc721_plugin_available_check+0x1a>
c0d0180a:	2a05      	cmp	r2, #5
c0d0180c:	d100      	bne.n	c0d01810 <erc721_plugin_available_check+0x1c>
                return false;
        }
    }
    return false;
#endif
}
c0d0180e:	4770      	bx	lr
c0d01810:	4608      	mov	r0, r1
c0d01812:	4770      	bx	lr
c0d01814:	2000189d 	.word	0x2000189d
c0d01818:	20001b40 	.word	0x20001b40

c0d0181c <erc721_plugin_call>:

void erc721_plugin_call(int message, void *parameters) {
c0d0181c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0181e:	b081      	sub	sp, #4
c0d01820:	460c      	mov	r4, r1
c0d01822:	21ff      	movs	r1, #255	; 0xff
c0d01824:	460a      	mov	r2, r1
c0d01826:	3204      	adds	r2, #4
    switch (message) {
c0d01828:	4290      	cmp	r0, r2
c0d0182a:	dc15      	bgt.n	c0d01858 <erc721_plugin_call+0x3c>
c0d0182c:	3102      	adds	r1, #2
c0d0182e:	4288      	cmp	r0, r1
c0d01830:	d031      	beq.n	c0d01896 <erc721_plugin_call+0x7a>
c0d01832:	2181      	movs	r1, #129	; 0x81
c0d01834:	0049      	lsls	r1, r1, #1
c0d01836:	4288      	cmp	r0, r1
c0d01838:	d05f      	beq.n	c0d018fa <erc721_plugin_call+0xde>
c0d0183a:	4290      	cmp	r0, r2
c0d0183c:	d000      	beq.n	c0d01840 <erc721_plugin_call+0x24>
c0d0183e:	e0a1      	b.n	c0d01984 <erc721_plugin_call+0x168>

        case ETH_PLUGIN_FINALIZE: {
            ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
            PRINTF("erc721 plugin finalize\n");
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d01840:	6860      	ldr	r0, [r4, #4]
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
c0d01842:	68a1      	ldr	r1, [r4, #8]
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d01844:	6800      	ldr	r0, [r0, #0]
            msg->tokenLookup2 = context->address;
c0d01846:	1c49      	adds	r1, r1, #1
c0d01848:	2201      	movs	r2, #1
            msg->numScreens = 3;
            msg->uiType = ETH_UI_TYPE_GENERIC;
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d0184a:	77a2      	strb	r2, [r4, #30]
c0d0184c:	4a4f      	ldr	r2, [pc, #316]	; (c0d0198c <erc721_plugin_call+0x170>)
            msg->uiType = ETH_UI_TYPE_GENERIC;
c0d0184e:	83a2      	strh	r2, [r4, #28]
            msg->tokenLookup1 = msg->pluginSharedRO->txContent->destination;
c0d01850:	3063      	adds	r0, #99	; 0x63
c0d01852:	60e0      	str	r0, [r4, #12]
            msg->tokenLookup2 = context->address;
c0d01854:	6121      	str	r1, [r4, #16]
c0d01856:	e095      	b.n	c0d01984 <erc721_plugin_call+0x168>
c0d01858:	2241      	movs	r2, #65	; 0x41
c0d0185a:	0092      	lsls	r2, r2, #2
    switch (message) {
c0d0185c:	4290      	cmp	r0, r2
c0d0185e:	d06a      	beq.n	c0d01936 <erc721_plugin_call+0x11a>
c0d01860:	3106      	adds	r1, #6
c0d01862:	4288      	cmp	r0, r1
c0d01864:	d054      	beq.n	c0d01910 <erc721_plugin_call+0xf4>
c0d01866:	2183      	movs	r1, #131	; 0x83
c0d01868:	0049      	lsls	r1, r1, #1
c0d0186a:	4288      	cmp	r0, r1
c0d0186c:	d000      	beq.n	c0d01870 <erc721_plugin_call+0x54>
c0d0186e:	e089      	b.n	c0d01984 <erc721_plugin_call+0x168>
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0d01870:	7b20      	ldrb	r0, [r4, #12]
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
c0d01872:	68a5      	ldr	r5, [r4, #8]
            switch (msg->screenIndex) {
c0d01874:	2802      	cmp	r0, #2
c0d01876:	d061      	beq.n	c0d0193c <erc721_plugin_call+0x120>
c0d01878:	2801      	cmp	r0, #1
c0d0187a:	d076      	beq.n	c0d0196a <erc721_plugin_call+0x14e>
c0d0187c:	2800      	cmp	r0, #0
c0d0187e:	d000      	beq.n	c0d01882 <erc721_plugin_call+0x66>
c0d01880:	e080      	b.n	c0d01984 <erc721_plugin_call+0x168>
                case 0:
                    strcpy(msg->title, "Contract Name");
c0d01882:	6920      	ldr	r0, [r4, #16]
c0d01884:	4942      	ldr	r1, [pc, #264]	; (c0d01990 <erc721_plugin_call+0x174>)
c0d01886:	4479      	add	r1, pc
c0d01888:	220e      	movs	r2, #14
c0d0188a:	f007 feb3 	bl	c0d095f4 <__aeabi_memcpy>
                    starkware_print_eth_address(tmpContent.txContent.destination, msg->msg);
c0d0188e:	69a1      	ldr	r1, [r4, #24]
c0d01890:	483d      	ldr	r0, [pc, #244]	; (c0d01988 <erc721_plugin_call+0x16c>)
c0d01892:	3063      	adds	r0, #99	; 0x63
c0d01894:	e071      	b.n	c0d0197a <erc721_plugin_call+0x15e>
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d01896:	6860      	ldr	r0, [r4, #4]
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
c0d01898:	68a5      	ldr	r5, [r4, #8]
            if (!allzeroes(msg->pluginSharedRO->txContent->value.value, 32)) {
c0d0189a:	6800      	ldr	r0, [r0, #0]
c0d0189c:	3042      	adds	r0, #66	; 0x42
c0d0189e:	2100      	movs	r1, #0
        if (buf[i]) {
c0d018a0:	5c42      	ldrb	r2, [r0, r1]
c0d018a2:	2a00      	cmp	r2, #0
c0d018a4:	d13f      	bne.n	c0d01926 <erc721_plugin_call+0x10a>
c0d018a6:	1c49      	adds	r1, r1, #1
    for (int i = 0; i < n; ++i) {
c0d018a8:	2920      	cmp	r1, #32
c0d018aa:	d3f9      	bcc.n	c0d018a0 <erc721_plugin_call+0x84>
c0d018ac:	2000      	movs	r0, #0
c0d018ae:	4e39      	ldr	r6, [pc, #228]	; (c0d01994 <erc721_plugin_call+0x178>)
c0d018b0:	447e      	add	r6, pc
                for (i = 0; i < NUM_ERC721_SELECTORS; i++) {
c0d018b2:	2801      	cmp	r0, #1
c0d018b4:	d066      	beq.n	c0d01984 <erc721_plugin_call+0x168>
c0d018b6:	4607      	mov	r7, r0
                    if (memcmp((uint8_t *) PIC(ERC721_SELECTORS[i]),
c0d018b8:	0080      	lsls	r0, r0, #2
c0d018ba:	5830      	ldr	r0, [r6, r0]
c0d018bc:	f003 f88a 	bl	c0d049d4 <pic>
c0d018c0:	7801      	ldrb	r1, [r0, #0]
c0d018c2:	7842      	ldrb	r2, [r0, #1]
c0d018c4:	0212      	lsls	r2, r2, #8
c0d018c6:	1851      	adds	r1, r2, r1
c0d018c8:	7882      	ldrb	r2, [r0, #2]
c0d018ca:	78c0      	ldrb	r0, [r0, #3]
c0d018cc:	0200      	lsls	r0, r0, #8
c0d018ce:	1880      	adds	r0, r0, r2
c0d018d0:	0400      	lsls	r0, r0, #16
c0d018d2:	1841      	adds	r1, r0, r1
                               msg->selector,
c0d018d4:	6920      	ldr	r0, [r4, #16]
                    if (memcmp((uint8_t *) PIC(ERC721_SELECTORS[i]),
c0d018d6:	7802      	ldrb	r2, [r0, #0]
c0d018d8:	7843      	ldrb	r3, [r0, #1]
c0d018da:	021b      	lsls	r3, r3, #8
c0d018dc:	189a      	adds	r2, r3, r2
c0d018de:	7883      	ldrb	r3, [r0, #2]
c0d018e0:	78c0      	ldrb	r0, [r0, #3]
c0d018e2:	0200      	lsls	r0, r0, #8
c0d018e4:	18c0      	adds	r0, r0, r3
c0d018e6:	0400      	lsls	r0, r0, #16
c0d018e8:	1882      	adds	r2, r0, r2
c0d018ea:	2001      	movs	r0, #1
c0d018ec:	4291      	cmp	r1, r2
c0d018ee:	d1e0      	bne.n	c0d018b2 <erc721_plugin_call+0x96>
                        context->selectorIndex = i;
c0d018f0:	702f      	strb	r7, [r5, #0]
                if (msg->dataSize != 4 + 32 + 32) {
c0d018f2:	6960      	ldr	r0, [r4, #20]
c0d018f4:	2844      	cmp	r0, #68	; 0x44
c0d018f6:	d014      	beq.n	c0d01922 <erc721_plugin_call+0x106>
c0d018f8:	e044      	b.n	c0d01984 <erc721_plugin_call+0x168>
            switch (msg->parameterOffset) {
c0d018fa:	6921      	ldr	r1, [r4, #16]
            erc721_parameters_t *context = (erc721_parameters_t *) msg->pluginContext;
c0d018fc:	68a0      	ldr	r0, [r4, #8]
            switch (msg->parameterOffset) {
c0d018fe:	2924      	cmp	r1, #36	; 0x24
c0d01900:	d014      	beq.n	c0d0192c <erc721_plugin_call+0x110>
c0d01902:	2904      	cmp	r1, #4
c0d01904:	d13e      	bne.n	c0d01984 <erc721_plugin_call+0x168>
                    memmove(context->address, msg->parameter + 32 - 20, 20);
c0d01906:	68e1      	ldr	r1, [r4, #12]
c0d01908:	1c40      	adds	r0, r0, #1
c0d0190a:	310c      	adds	r1, #12
c0d0190c:	2214      	movs	r2, #20
c0d0190e:	e010      	b.n	c0d01932 <erc721_plugin_call+0x116>
            strcpy(msg->name, "Allowance");
c0d01910:	68e0      	ldr	r0, [r4, #12]
c0d01912:	4921      	ldr	r1, [pc, #132]	; (c0d01998 <erc721_plugin_call+0x17c>)
c0d01914:	4479      	add	r1, pc
c0d01916:	220a      	movs	r2, #10
c0d01918:	f007 fe6c 	bl	c0d095f4 <__aeabi_memcpy>
            strcpy(msg->version, "");
c0d0191c:	6960      	ldr	r0, [r4, #20]
c0d0191e:	2100      	movs	r1, #0
c0d01920:	7001      	strb	r1, [r0, #0]
c0d01922:	2001      	movs	r0, #1
c0d01924:	e000      	b.n	c0d01928 <erc721_plugin_call+0x10c>
c0d01926:	2000      	movs	r0, #0
c0d01928:	7720      	strb	r0, [r4, #28]
c0d0192a:	e02b      	b.n	c0d01984 <erc721_plugin_call+0x168>
                    memmove(context->tokenId, msg->parameter, 32);
c0d0192c:	68e1      	ldr	r1, [r4, #12]
c0d0192e:	3015      	adds	r0, #21
c0d01930:	2220      	movs	r2, #32
c0d01932:	f007 fe63 	bl	c0d095fc <__aeabi_memmove>
c0d01936:	2001      	movs	r0, #1
c0d01938:	7520      	strb	r0, [r4, #20]
c0d0193a:	e023      	b.n	c0d01984 <erc721_plugin_call+0x168>
                    starkware_print_eth_address(context->address, msg->msg);
                    msg->result = ETH_PLUGIN_RESULT_OK;
                    break;

                case 2:
                    strcpy(msg->title, "TokenID");
c0d0193c:	6920      	ldr	r0, [r4, #16]
c0d0193e:	2100      	movs	r1, #0
c0d01940:	71c1      	strb	r1, [r0, #7]
c0d01942:	2144      	movs	r1, #68	; 0x44
c0d01944:	7181      	strb	r1, [r0, #6]
c0d01946:	2149      	movs	r1, #73	; 0x49
c0d01948:	7141      	strb	r1, [r0, #5]
c0d0194a:	216e      	movs	r1, #110	; 0x6e
c0d0194c:	7101      	strb	r1, [r0, #4]
c0d0194e:	2165      	movs	r1, #101	; 0x65
c0d01950:	70c1      	strb	r1, [r0, #3]
c0d01952:	216b      	movs	r1, #107	; 0x6b
c0d01954:	7081      	strb	r1, [r0, #2]
c0d01956:	216f      	movs	r1, #111	; 0x6f
c0d01958:	7041      	strb	r1, [r0, #1]
c0d0195a:	2154      	movs	r1, #84	; 0x54
c0d0195c:	7001      	strb	r1, [r0, #0]
                    starkware_print_stark_key(context->tokenId, msg->msg);
c0d0195e:	69a1      	ldr	r1, [r4, #24]
c0d01960:	3515      	adds	r5, #21
c0d01962:	4628      	mov	r0, r5
c0d01964:	f003 fb1c 	bl	c0d04fa0 <starkware_print_stark_key>
c0d01968:	e009      	b.n	c0d0197e <erc721_plugin_call+0x162>
                    strcpy(msg->title, "NFT Contract");
c0d0196a:	6920      	ldr	r0, [r4, #16]
c0d0196c:	490b      	ldr	r1, [pc, #44]	; (c0d0199c <erc721_plugin_call+0x180>)
c0d0196e:	4479      	add	r1, pc
c0d01970:	220d      	movs	r2, #13
c0d01972:	f007 fe3f 	bl	c0d095f4 <__aeabi_memcpy>
                    starkware_print_eth_address(context->address, msg->msg);
c0d01976:	69a1      	ldr	r1, [r4, #24]
c0d01978:	1c68      	adds	r0, r5, #1
c0d0197a:	f003 fb21 	bl	c0d04fc0 <starkware_print_eth_address>
c0d0197e:	2020      	movs	r0, #32
c0d01980:	2101      	movs	r1, #1
c0d01982:	5421      	strb	r1, [r4, r0]
c0d01984:	b001      	add	sp, #4
c0d01986:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01988:	200018dc 	.word	0x200018dc
c0d0198c:	00000302 	.word	0x00000302
c0d01990:	00008506 	.word	0x00008506
c0d01994:	00008524 	.word	0x00008524
c0d01998:	0000846c 	.word	0x0000846c
c0d0199c:	0000842e 	.word	0x0000842e

c0d019a0 <initTx>:

void initTx(txContext_t *context,
            cx_sha3_t *sha3,
            txContent_t *content,
            ustreamProcess_t customProcessor,
            void *extra) {
c0d019a0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d019a2:	b081      	sub	sp, #4
c0d019a4:	461d      	mov	r5, r3
c0d019a6:	4616      	mov	r6, r2
c0d019a8:	460c      	mov	r4, r1
c0d019aa:	4607      	mov	r7, r0
c0d019ac:	2130      	movs	r1, #48	; 0x30
    memset(context, 0, sizeof(txContext_t));
c0d019ae:	f007 fe1b 	bl	c0d095e8 <__aeabi_memclr>
    context->sha3 = sha3;
    context->content = content;
c0d019b2:	637e      	str	r6, [r7, #52]	; 0x34
    context->sha3 = sha3;
c0d019b4:	607c      	str	r4, [r7, #4]
c0d019b6:	9806      	ldr	r0, [sp, #24]
    context->customProcessor = customProcessor;
    context->extra = extra;
c0d019b8:	63b8      	str	r0, [r7, #56]	; 0x38
    context->customProcessor = customProcessor;
c0d019ba:	633d      	str	r5, [r7, #48]	; 0x30
c0d019bc:	2001      	movs	r0, #1
    context->currentField = TX_RLP_CONTENT;
c0d019be:	7038      	strb	r0, [r7, #0]
c0d019c0:	0201      	lsls	r1, r0, #8
    cx_keccak_init(context->sha3, 256);
c0d019c2:	4620      	mov	r0, r4
c0d019c4:	f003 ff4e 	bl	c0d05864 <cx_keccak_init>
}
c0d019c8:	b001      	add	sp, #4
c0d019ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d019cc <readTxByte>:

uint8_t readTxByte(txContext_t *context) {
c0d019cc:	b510      	push	{r4, lr}
c0d019ce:	b084      	sub	sp, #16
    uint8_t data;
    if (context->commandLength < 1) {
c0d019d0:	6a82      	ldr	r2, [r0, #40]	; 0x28
c0d019d2:	2a00      	cmp	r2, #0
c0d019d4:	d01e      	beq.n	c0d01a14 <readTxByte+0x48>
        PRINTF("readTxByte Underflow\n");
        THROW(EXCEPTION);
    }
    data = *context->workBuffer;
c0d019d6:	6a43      	ldr	r3, [r0, #36]	; 0x24
c0d019d8:	7819      	ldrb	r1, [r3, #0]
c0d019da:	ac03      	add	r4, sp, #12
c0d019dc:	7021      	strb	r1, [r4, #0]
    context->workBuffer++;
    context->commandLength--;
c0d019de:	1e52      	subs	r2, r2, #1
    context->workBuffer++;
c0d019e0:	1c5b      	adds	r3, r3, #1
c0d019e2:	6243      	str	r3, [r0, #36]	; 0x24
    context->commandLength--;
c0d019e4:	6282      	str	r2, [r0, #40]	; 0x28
    if (context->processingField) {
c0d019e6:	7c42      	ldrb	r2, [r0, #17]
c0d019e8:	2a00      	cmp	r2, #0
c0d019ea:	d005      	beq.n	c0d019f8 <readTxByte+0x2c>
        context->currentFieldPos++;
c0d019ec:	68c2      	ldr	r2, [r0, #12]
c0d019ee:	1c52      	adds	r2, r2, #1
c0d019f0:	60c2      	str	r2, [r0, #12]
    }
    if (!(context->processingField && context->fieldSingleByte)) {
c0d019f2:	7c82      	ldrb	r2, [r0, #18]
c0d019f4:	2a00      	cmp	r2, #0
c0d019f6:	d10a      	bne.n	c0d01a0e <readTxByte+0x42>
        cx_hash((cx_hash_t *) context->sha3, 0, &data, 1, NULL, 0);
c0d019f8:	6840      	ldr	r0, [r0, #4]
c0d019fa:	2100      	movs	r1, #0
c0d019fc:	466a      	mov	r2, sp
c0d019fe:	6011      	str	r1, [r2, #0]
c0d01a00:	6051      	str	r1, [r2, #4]
c0d01a02:	ac03      	add	r4, sp, #12
c0d01a04:	2301      	movs	r3, #1
c0d01a06:	4622      	mov	r2, r4
c0d01a08:	f003 fefc 	bl	c0d05804 <cx_hash>
    }
    return data;
c0d01a0c:	7821      	ldrb	r1, [r4, #0]
c0d01a0e:	4608      	mov	r0, r1
c0d01a10:	b004      	add	sp, #16
c0d01a12:	bd10      	pop	{r4, pc}
c0d01a14:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0d01a16:	f001 fff4 	bl	c0d03a02 <os_longjmp>

c0d01a1a <copyTxData>:
}

void copyTxData(txContext_t *context, uint8_t *out, uint32_t length) {
c0d01a1a:	b5b0      	push	{r4, r5, r7, lr}
c0d01a1c:	b082      	sub	sp, #8
c0d01a1e:	4605      	mov	r5, r0
    if (context->commandLength < length) {
c0d01a20:	6a80      	ldr	r0, [r0, #40]	; 0x28
c0d01a22:	4290      	cmp	r0, r2
c0d01a24:	d32c      	bcc.n	c0d01a80 <copyTxData+0x66>
c0d01a26:	4614      	mov	r4, r2
        PRINTF("copyTxData Underflow\n");
        THROW(EXCEPTION);
    }
    if (out != NULL) {
c0d01a28:	2900      	cmp	r1, #0
c0d01a2a:	d005      	beq.n	c0d01a38 <copyTxData+0x1e>
        memmove(out, context->workBuffer, length);
c0d01a2c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
c0d01a2e:	4608      	mov	r0, r1
c0d01a30:	4611      	mov	r1, r2
c0d01a32:	4622      	mov	r2, r4
c0d01a34:	f007 fde2 	bl	c0d095fc <__aeabi_memmove>
    }
    if (!(context->processingField && context->fieldSingleByte)) {
c0d01a38:	7c68      	ldrb	r0, [r5, #17]
c0d01a3a:	2800      	cmp	r0, #0
c0d01a3c:	d009      	beq.n	c0d01a52 <copyTxData+0x38>
c0d01a3e:	7ca8      	ldrb	r0, [r5, #18]
c0d01a40:	2800      	cmp	r0, #0
c0d01a42:	d006      	beq.n	c0d01a52 <copyTxData+0x38>
        cx_hash((cx_hash_t *) context->sha3, 0, context->workBuffer, length, NULL, 0);
    }
    context->workBuffer += length;
c0d01a44:	6a68      	ldr	r0, [r5, #36]	; 0x24
c0d01a46:	1900      	adds	r0, r0, r4
c0d01a48:	6268      	str	r0, [r5, #36]	; 0x24
    context->commandLength -= length;
c0d01a4a:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0d01a4c:	1b00      	subs	r0, r0, r4
c0d01a4e:	62a8      	str	r0, [r5, #40]	; 0x28
c0d01a50:	e011      	b.n	c0d01a76 <copyTxData+0x5c>
        cx_hash((cx_hash_t *) context->sha3, 0, context->workBuffer, length, NULL, 0);
c0d01a52:	6a6a      	ldr	r2, [r5, #36]	; 0x24
c0d01a54:	6868      	ldr	r0, [r5, #4]
c0d01a56:	2100      	movs	r1, #0
c0d01a58:	466b      	mov	r3, sp
c0d01a5a:	6019      	str	r1, [r3, #0]
c0d01a5c:	6059      	str	r1, [r3, #4]
c0d01a5e:	4623      	mov	r3, r4
c0d01a60:	f003 fed0 	bl	c0d05804 <cx_hash>
    context->workBuffer += length;
c0d01a64:	6a68      	ldr	r0, [r5, #36]	; 0x24
c0d01a66:	1900      	adds	r0, r0, r4
c0d01a68:	6268      	str	r0, [r5, #36]	; 0x24
    context->commandLength -= length;
c0d01a6a:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0d01a6c:	1b00      	subs	r0, r0, r4
c0d01a6e:	62a8      	str	r0, [r5, #40]	; 0x28
    if (context->processingField) {
c0d01a70:	7c68      	ldrb	r0, [r5, #17]
c0d01a72:	2800      	cmp	r0, #0
c0d01a74:	d002      	beq.n	c0d01a7c <copyTxData+0x62>
        context->currentFieldPos += length;
c0d01a76:	68e8      	ldr	r0, [r5, #12]
c0d01a78:	1900      	adds	r0, r0, r4
c0d01a7a:	60e8      	str	r0, [r5, #12]
    }
}
c0d01a7c:	b002      	add	sp, #8
c0d01a7e:	bdb0      	pop	{r4, r5, r7, pc}
c0d01a80:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0d01a82:	f001 ffbe 	bl	c0d03a02 <os_longjmp>

c0d01a86 <processTx>:
}

parserStatus_e processTx(txContext_t *context,
                         uint8_t *buffer,
                         uint32_t length,
                         uint32_t processingFlags) {
c0d01a86:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01a88:	b08d      	sub	sp, #52	; 0x34
c0d01a8a:	9300      	str	r3, [sp, #0]
c0d01a8c:	4616      	mov	r6, r2
c0d01a8e:	460f      	mov	r7, r1
c0d01a90:	4605      	mov	r5, r0
c0d01a92:	ac01      	add	r4, sp, #4
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0d01a94:	4620      	mov	r0, r4
c0d01a96:	f007 fee1 	bl	c0d0985c <setjmp>
c0d01a9a:	85a0      	strh	r0, [r4, #44]	; 0x2c
c0d01a9c:	0400      	lsls	r0, r0, #16
c0d01a9e:	d007      	beq.n	c0d01ab0 <processTx+0x2a>
c0d01aa0:	a801      	add	r0, sp, #4
c0d01aa2:	2100      	movs	r1, #0
            context->workBuffer = buffer;
            context->commandLength = length;
            context->processingFlags = processingFlags;
            result = processTxInternal(context);
        }
        CATCH_OTHER(e) {
c0d01aa4:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d01aa6:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d01aa8:	f004 f858 	bl	c0d05b5c <try_context_set>
c0d01aac:	2403      	movs	r4, #3
c0d01aae:	e00b      	b.n	c0d01ac8 <processTx+0x42>
c0d01ab0:	a801      	add	r0, sp, #4
        TRY {
c0d01ab2:	f004 f853 	bl	c0d05b5c <try_context_set>
c0d01ab6:	900b      	str	r0, [sp, #44]	; 0x2c
            context->workBuffer = buffer;
c0d01ab8:	626f      	str	r7, [r5, #36]	; 0x24
            context->commandLength = length;
c0d01aba:	62ae      	str	r6, [r5, #40]	; 0x28
            context->processingFlags = processingFlags;
c0d01abc:	9800      	ldr	r0, [sp, #0]
c0d01abe:	62e8      	str	r0, [r5, #44]	; 0x2c
            result = processTxInternal(context);
c0d01ac0:	4628      	mov	r0, r5
c0d01ac2:	f000 f812 	bl	c0d01aea <processTxInternal>
c0d01ac6:	4604      	mov	r4, r0
            result = USTREAM_FAULT;
        }
        FINALLY {
c0d01ac8:	f004 f83c 	bl	c0d05b44 <try_context_get>
c0d01acc:	a901      	add	r1, sp, #4
c0d01ace:	4288      	cmp	r0, r1
c0d01ad0:	d102      	bne.n	c0d01ad8 <processTx+0x52>
c0d01ad2:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d01ad4:	f004 f842 	bl	c0d05b5c <try_context_set>
c0d01ad8:	a801      	add	r0, sp, #4
        }
    }
    END_TRY;
c0d01ada:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d01adc:	2800      	cmp	r0, #0
c0d01ade:	d102      	bne.n	c0d01ae6 <processTx+0x60>
    return result;
c0d01ae0:	4620      	mov	r0, r4
c0d01ae2:	b00d      	add	sp, #52	; 0x34
c0d01ae4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    END_TRY;
c0d01ae6:	f001 ff8c 	bl	c0d03a02 <os_longjmp>

c0d01aea <processTxInternal>:
static parserStatus_e processTxInternal(txContext_t *context) {
c0d01aea:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01aec:	b085      	sub	sp, #20
c0d01aee:	4604      	mov	r4, r0
c0d01af0:	4605      	mov	r5, r0
c0d01af2:	3510      	adds	r5, #16
c0d01af4:	3008      	adds	r0, #8
c0d01af6:	9002      	str	r0, [sp, #8]
c0d01af8:	4626      	mov	r6, r4
c0d01afa:	3618      	adds	r6, #24
c0d01afc:	e13a      	b.n	c0d01d74 <processTxInternal+0x28a>
        if (context->commandLength == 0) {
c0d01afe:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d01b00:	2800      	cmp	r0, #0
c0d01b02:	d104      	bne.n	c0d01b0e <processTxInternal+0x24>
c0d01b04:	e13e      	b.n	c0d01d84 <processTxInternal+0x29a>
        if ((context->currentField == TX_RLP_V) && (context->commandLength == 0)) {
c0d01b06:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d01b08:	2800      	cmp	r0, #0
c0d01b0a:	d100      	bne.n	c0d01b0e <processTxInternal+0x24>
c0d01b0c:	e13c      	b.n	c0d01d88 <processTxInternal+0x29e>
        if (!context->processingField) {
c0d01b0e:	7c61      	ldrb	r1, [r4, #17]
c0d01b10:	2900      	cmp	r1, #0
c0d01b12:	d022      	beq.n	c0d01b5a <processTxInternal+0x70>
        if (context->customProcessor != NULL) {
c0d01b14:	6b21      	ldr	r1, [r4, #48]	; 0x30
c0d01b16:	2900      	cmp	r1, #0
c0d01b18:	d007      	beq.n	c0d01b2a <processTxInternal+0x40>
            customStatus = context->customProcessor(context);
c0d01b1a:	4620      	mov	r0, r4
c0d01b1c:	4788      	blx	r1
            switch (customStatus) {
c0d01b1e:	2800      	cmp	r0, #0
c0d01b20:	d003      	beq.n	c0d01b2a <processTxInternal+0x40>
c0d01b22:	2801      	cmp	r0, #1
c0d01b24:	d100      	bne.n	c0d01b28 <processTxInternal+0x3e>
c0d01b26:	e125      	b.n	c0d01d74 <processTxInternal+0x28a>
c0d01b28:	e133      	b.n	c0d01d92 <processTxInternal+0x2a8>
            switch (context->currentField) {
c0d01b2a:	7820      	ldrb	r0, [r4, #0]
c0d01b2c:	2703      	movs	r7, #3
c0d01b2e:	2806      	cmp	r0, #6
c0d01b30:	dc4f      	bgt.n	c0d01bd2 <processTxInternal+0xe8>
c0d01b32:	2803      	cmp	r0, #3
c0d01b34:	dc75      	bgt.n	c0d01c22 <processTxInternal+0x138>
c0d01b36:	2801      	cmp	r0, #1
c0d01b38:	d100      	bne.n	c0d01b3c <processTxInternal+0x52>
c0d01b3a:	e0b3      	b.n	c0d01ca4 <processTxInternal+0x1ba>
c0d01b3c:	2802      	cmp	r0, #2
c0d01b3e:	d002      	beq.n	c0d01b46 <processTxInternal+0x5c>
c0d01b40:	2803      	cmp	r0, #3
c0d01b42:	d000      	beq.n	c0d01b46 <processTxInternal+0x5c>
c0d01b44:	e12a      	b.n	c0d01d9c <processTxInternal+0x2b2>
c0d01b46:	7828      	ldrb	r0, [r5, #0]
c0d01b48:	2800      	cmp	r0, #0
c0d01b4a:	d000      	beq.n	c0d01b4e <processTxInternal+0x64>
c0d01b4c:	e129      	b.n	c0d01da2 <processTxInternal+0x2b8>
c0d01b4e:	9802      	ldr	r0, [sp, #8]
c0d01b50:	6800      	ldr	r0, [r0, #0]
c0d01b52:	2821      	cmp	r0, #33	; 0x21
c0d01b54:	d200      	bcs.n	c0d01b58 <processTxInternal+0x6e>
c0d01b56:	e094      	b.n	c0d01c82 <processTxInternal+0x198>
c0d01b58:	e123      	b.n	c0d01da2 <processTxInternal+0x2b8>
c0d01b5a:	2700      	movs	r7, #0
c0d01b5c:	e004      	b.n	c0d01b68 <processTxInternal+0x7e>
                if (context->rlpBufferPos == sizeof(context->rlpBuffer)) {
c0d01b5e:	6a20      	ldr	r0, [r4, #32]
c0d01b60:	2805      	cmp	r0, #5
c0d01b62:	d100      	bne.n	c0d01b66 <processTxInternal+0x7c>
c0d01b64:	e119      	b.n	c0d01d9a <processTxInternal+0x2b0>
            while (context->commandLength != 0) {
c0d01b66:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d01b68:	2800      	cmp	r0, #0
c0d01b6a:	d100      	bne.n	c0d01b6e <processTxInternal+0x84>
c0d01b6c:	e116      	b.n	c0d01d9c <processTxInternal+0x2b2>
                context->rlpBuffer[context->rlpBufferPos++] = readTxByte(context);
c0d01b6e:	4620      	mov	r0, r4
c0d01b70:	f7ff ff2c 	bl	c0d019cc <readTxByte>
c0d01b74:	6a21      	ldr	r1, [r4, #32]
c0d01b76:	1c4a      	adds	r2, r1, #1
c0d01b78:	6222      	str	r2, [r4, #32]
c0d01b7a:	1861      	adds	r1, r4, r1
c0d01b7c:	7608      	strb	r0, [r1, #24]
                if (rlpCanDecode(context->rlpBuffer, context->rlpBufferPos, &valid)) {
c0d01b7e:	6a21      	ldr	r1, [r4, #32]
c0d01b80:	aa03      	add	r2, sp, #12
c0d01b82:	4630      	mov	r0, r6
c0d01b84:	f000 f93b 	bl	c0d01dfe <rlpCanDecode>
c0d01b88:	2800      	cmp	r0, #0
c0d01b8a:	d0e8      	beq.n	c0d01b5e <processTxInternal+0x74>
c0d01b8c:	a803      	add	r0, sp, #12
                    if (!valid) {
c0d01b8e:	7800      	ldrb	r0, [r0, #0]
c0d01b90:	2703      	movs	r7, #3
c0d01b92:	2800      	cmp	r0, #0
c0d01b94:	d100      	bne.n	c0d01b98 <processTxInternal+0xae>
c0d01b96:	e101      	b.n	c0d01d9c <processTxInternal+0x2b2>
                                 context->rlpBufferPos,
c0d01b98:	6a21      	ldr	r1, [r4, #32]
            if (!rlpDecodeLength(context->rlpBuffer,
c0d01b9a:	4668      	mov	r0, sp
c0d01b9c:	6005      	str	r5, [r0, #0]
c0d01b9e:	ab04      	add	r3, sp, #16
c0d01ba0:	4630      	mov	r0, r6
c0d01ba2:	9a02      	ldr	r2, [sp, #8]
c0d01ba4:	f000 f94d 	bl	c0d01e42 <rlpDecodeLength>
c0d01ba8:	2800      	cmp	r0, #0
c0d01baa:	d100      	bne.n	c0d01bae <processTxInternal+0xc4>
c0d01bac:	e0f6      	b.n	c0d01d9c <processTxInternal+0x2b2>
c0d01bae:	2000      	movs	r0, #0
            if (offset == 0) {
c0d01bb0:	9904      	ldr	r1, [sp, #16]
c0d01bb2:	2900      	cmp	r1, #0
c0d01bb4:	4601      	mov	r1, r0
c0d01bb6:	d106      	bne.n	c0d01bc6 <processTxInternal+0xdc>
                context->workBuffer--;
c0d01bb8:	6a61      	ldr	r1, [r4, #36]	; 0x24
c0d01bba:	1e49      	subs	r1, r1, #1
c0d01bbc:	6261      	str	r1, [r4, #36]	; 0x24
                context->commandLength++;
c0d01bbe:	6aa1      	ldr	r1, [r4, #40]	; 0x28
c0d01bc0:	1c49      	adds	r1, r1, #1
c0d01bc2:	62a1      	str	r1, [r4, #40]	; 0x28
c0d01bc4:	2101      	movs	r1, #1
            context->rlpBufferPos = 0;
c0d01bc6:	6220      	str	r0, [r4, #32]
            context->currentFieldPos = 0;
c0d01bc8:	60e0      	str	r0, [r4, #12]
c0d01bca:	74a1      	strb	r1, [r4, #18]
c0d01bcc:	2001      	movs	r0, #1
            context->processingField = true;
c0d01bce:	7460      	strb	r0, [r4, #17]
c0d01bd0:	e7a0      	b.n	c0d01b14 <processTxInternal+0x2a>
            switch (context->currentField) {
c0d01bd2:	2809      	cmp	r0, #9
c0d01bd4:	dc4c      	bgt.n	c0d01c70 <processTxInternal+0x186>
c0d01bd6:	2807      	cmp	r0, #7
c0d01bd8:	d074      	beq.n	c0d01cc4 <processTxInternal+0x1da>
c0d01bda:	2808      	cmp	r0, #8
c0d01bdc:	d04c      	beq.n	c0d01c78 <processTxInternal+0x18e>
c0d01bde:	2809      	cmp	r0, #9
c0d01be0:	d000      	beq.n	c0d01be4 <processTxInternal+0xfa>
c0d01be2:	e0db      	b.n	c0d01d9c <processTxInternal+0x2b2>
    if (context->currentFieldIsList) {
c0d01be4:	7828      	ldrb	r0, [r5, #0]
c0d01be6:	2800      	cmp	r0, #0
c0d01be8:	d000      	beq.n	c0d01bec <processTxInternal+0x102>
c0d01bea:	e0da      	b.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldLength > MAX_V) {
c0d01bec:	9802      	ldr	r0, [sp, #8]
c0d01bee:	6800      	ldr	r0, [r0, #0]
c0d01bf0:	2805      	cmp	r0, #5
c0d01bf2:	d300      	bcc.n	c0d01bf6 <processTxInternal+0x10c>
c0d01bf4:	e0d5      	b.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d01bf6:	68e1      	ldr	r1, [r4, #12]
c0d01bf8:	4288      	cmp	r0, r1
c0d01bfa:	d90c      	bls.n	c0d01c16 <processTxInternal+0x12c>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d01bfc:	1a40      	subs	r0, r0, r1
c0d01bfe:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d01c00:	4282      	cmp	r2, r0
c0d01c02:	d300      	bcc.n	c0d01c06 <processTxInternal+0x11c>
c0d01c04:	4602      	mov	r2, r0
        copyTxData(context, context->content->v + context->currentFieldPos, copySize);
c0d01c06:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d01c08:	1841      	adds	r1, r0, r1
c0d01c0a:	3178      	adds	r1, #120	; 0x78
c0d01c0c:	4620      	mov	r0, r4
c0d01c0e:	f7ff ff04 	bl	c0d01a1a <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d01c12:	68a0      	ldr	r0, [r4, #8]
c0d01c14:	68e1      	ldr	r1, [r4, #12]
c0d01c16:	4281      	cmp	r1, r0
c0d01c18:	d000      	beq.n	c0d01c1c <processTxInternal+0x132>
c0d01c1a:	e0ab      	b.n	c0d01d74 <processTxInternal+0x28a>
        context->content->vLength = context->currentFieldLength;
c0d01c1c:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d01c1e:	227c      	movs	r2, #124	; 0x7c
c0d01c20:	e0a2      	b.n	c0d01d68 <processTxInternal+0x27e>
            switch (context->currentField) {
c0d01c22:	2804      	cmp	r0, #4
c0d01c24:	d06a      	beq.n	c0d01cfc <processTxInternal+0x212>
c0d01c26:	2805      	cmp	r0, #5
c0d01c28:	d100      	bne.n	c0d01c2c <processTxInternal+0x142>
c0d01c2a:	e082      	b.n	c0d01d32 <processTxInternal+0x248>
c0d01c2c:	2806      	cmp	r0, #6
c0d01c2e:	d000      	beq.n	c0d01c32 <processTxInternal+0x148>
c0d01c30:	e0b4      	b.n	c0d01d9c <processTxInternal+0x2b2>
    if (context->currentFieldIsList) {
c0d01c32:	7828      	ldrb	r0, [r5, #0]
c0d01c34:	2800      	cmp	r0, #0
c0d01c36:	d000      	beq.n	c0d01c3a <processTxInternal+0x150>
c0d01c38:	e0b3      	b.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldLength > MAX_ADDRESS) {
c0d01c3a:	9802      	ldr	r0, [sp, #8]
c0d01c3c:	6800      	ldr	r0, [r0, #0]
c0d01c3e:	2815      	cmp	r0, #21
c0d01c40:	d300      	bcc.n	c0d01c44 <processTxInternal+0x15a>
c0d01c42:	e0ae      	b.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d01c44:	68e1      	ldr	r1, [r4, #12]
c0d01c46:	4288      	cmp	r0, r1
c0d01c48:	d90c      	bls.n	c0d01c64 <processTxInternal+0x17a>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d01c4a:	1a40      	subs	r0, r0, r1
c0d01c4c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d01c4e:	4282      	cmp	r2, r0
c0d01c50:	d300      	bcc.n	c0d01c54 <processTxInternal+0x16a>
c0d01c52:	4602      	mov	r2, r0
        copyTxData(context, context->content->destination + context->currentFieldPos, copySize);
c0d01c54:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d01c56:	1841      	adds	r1, r0, r1
c0d01c58:	3163      	adds	r1, #99	; 0x63
c0d01c5a:	4620      	mov	r0, r4
c0d01c5c:	f7ff fedd 	bl	c0d01a1a <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d01c60:	68a0      	ldr	r0, [r4, #8]
c0d01c62:	68e1      	ldr	r1, [r4, #12]
c0d01c64:	4281      	cmp	r1, r0
c0d01c66:	d000      	beq.n	c0d01c6a <processTxInternal+0x180>
c0d01c68:	e084      	b.n	c0d01d74 <processTxInternal+0x28a>
        context->content->destinationLength = context->currentFieldLength;
c0d01c6a:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d01c6c:	2277      	movs	r2, #119	; 0x77
c0d01c6e:	e07b      	b.n	c0d01d68 <processTxInternal+0x27e>
            switch (context->currentField) {
c0d01c70:	380a      	subs	r0, #10
c0d01c72:	2802      	cmp	r0, #2
c0d01c74:	d300      	bcc.n	c0d01c78 <processTxInternal+0x18e>
c0d01c76:	e091      	b.n	c0d01d9c <processTxInternal+0x2b2>
    if (context->currentFieldIsList) {
c0d01c78:	7828      	ldrb	r0, [r5, #0]
c0d01c7a:	2800      	cmp	r0, #0
c0d01c7c:	d000      	beq.n	c0d01c80 <processTxInternal+0x196>
c0d01c7e:	e090      	b.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d01c80:	68a0      	ldr	r0, [r4, #8]
c0d01c82:	68e1      	ldr	r1, [r4, #12]
c0d01c84:	4288      	cmp	r0, r1
c0d01c86:	d90a      	bls.n	c0d01c9e <processTxInternal+0x1b4>
c0d01c88:	1a40      	subs	r0, r0, r1
c0d01c8a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d01c8c:	4282      	cmp	r2, r0
c0d01c8e:	d300      	bcc.n	c0d01c92 <processTxInternal+0x1a8>
c0d01c90:	4602      	mov	r2, r0
c0d01c92:	2100      	movs	r1, #0
c0d01c94:	4620      	mov	r0, r4
c0d01c96:	f7ff fec0 	bl	c0d01a1a <copyTxData>
c0d01c9a:	68a0      	ldr	r0, [r4, #8]
c0d01c9c:	68e1      	ldr	r1, [r4, #12]
c0d01c9e:	4281      	cmp	r1, r0
c0d01ca0:	d168      	bne.n	c0d01d74 <processTxInternal+0x28a>
c0d01ca2:	e062      	b.n	c0d01d6a <processTxInternal+0x280>
    if (!context->currentFieldIsList) {
c0d01ca4:	7828      	ldrb	r0, [r5, #0]
c0d01ca6:	2800      	cmp	r0, #0
c0d01ca8:	d07b      	beq.n	c0d01da2 <processTxInternal+0x2b8>
c0d01caa:	2000      	movs	r0, #0
    context->processingField = false;
c0d01cac:	7460      	strb	r0, [r4, #17]
c0d01cae:	2002      	movs	r0, #2
    context->currentField++;
c0d01cb0:	7020      	strb	r0, [r4, #0]
    context->dataLength = context->currentFieldLength;
c0d01cb2:	68a0      	ldr	r0, [r4, #8]
c0d01cb4:	6160      	str	r0, [r4, #20]
c0d01cb6:	202c      	movs	r0, #44	; 0x2c
                    if ((context->processingFlags & TX_FLAG_TYPE) == 0) {
c0d01cb8:	5c20      	ldrb	r0, [r4, r0]
c0d01cba:	07c0      	lsls	r0, r0, #31
c0d01cbc:	d15a      	bne.n	c0d01d74 <processTxInternal+0x28a>
c0d01cbe:	2003      	movs	r0, #3
                        context->currentField++;
c0d01cc0:	7020      	strb	r0, [r4, #0]
c0d01cc2:	e057      	b.n	c0d01d74 <processTxInternal+0x28a>
    if (context->currentFieldIsList) {
c0d01cc4:	7828      	ldrb	r0, [r5, #0]
c0d01cc6:	2800      	cmp	r0, #0
c0d01cc8:	d16b      	bne.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldLength > MAX_INT256) {
c0d01cca:	9802      	ldr	r0, [sp, #8]
c0d01ccc:	6800      	ldr	r0, [r0, #0]
c0d01cce:	2821      	cmp	r0, #33	; 0x21
c0d01cd0:	d267      	bcs.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d01cd2:	68e1      	ldr	r1, [r4, #12]
c0d01cd4:	4288      	cmp	r0, r1
c0d01cd6:	d90c      	bls.n	c0d01cf2 <processTxInternal+0x208>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d01cd8:	1a40      	subs	r0, r0, r1
c0d01cda:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d01cdc:	4282      	cmp	r2, r0
c0d01cde:	d300      	bcc.n	c0d01ce2 <processTxInternal+0x1f8>
c0d01ce0:	4602      	mov	r2, r0
        copyTxData(context, context->content->value.value + context->currentFieldPos, copySize);
c0d01ce2:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d01ce4:	1841      	adds	r1, r0, r1
c0d01ce6:	3142      	adds	r1, #66	; 0x42
c0d01ce8:	4620      	mov	r0, r4
c0d01cea:	f7ff fe96 	bl	c0d01a1a <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d01cee:	68a0      	ldr	r0, [r4, #8]
c0d01cf0:	68e1      	ldr	r1, [r4, #12]
c0d01cf2:	4281      	cmp	r1, r0
c0d01cf4:	d13e      	bne.n	c0d01d74 <processTxInternal+0x28a>
        context->content->value.length = context->currentFieldLength;
c0d01cf6:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d01cf8:	2262      	movs	r2, #98	; 0x62
c0d01cfa:	e035      	b.n	c0d01d68 <processTxInternal+0x27e>
    if (context->currentFieldIsList) {
c0d01cfc:	7828      	ldrb	r0, [r5, #0]
c0d01cfe:	2800      	cmp	r0, #0
c0d01d00:	d14f      	bne.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldLength > MAX_INT256) {
c0d01d02:	9802      	ldr	r0, [sp, #8]
c0d01d04:	6800      	ldr	r0, [r0, #0]
c0d01d06:	2821      	cmp	r0, #33	; 0x21
c0d01d08:	d24b      	bcs.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d01d0a:	68e2      	ldr	r2, [r4, #12]
c0d01d0c:	4290      	cmp	r0, r2
c0d01d0e:	d90b      	bls.n	c0d01d28 <processTxInternal+0x23e>
        copyTxData(context, context->content->gasprice.value + context->currentFieldPos, copySize);
c0d01d10:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d01d12:	1889      	adds	r1, r1, r2
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d01d14:	1a80      	subs	r0, r0, r2
c0d01d16:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d01d18:	4282      	cmp	r2, r0
c0d01d1a:	d300      	bcc.n	c0d01d1e <processTxInternal+0x234>
c0d01d1c:	4602      	mov	r2, r0
        copyTxData(context, context->content->gasprice.value + context->currentFieldPos, copySize);
c0d01d1e:	4620      	mov	r0, r4
c0d01d20:	f7ff fe7b 	bl	c0d01a1a <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d01d24:	68a0      	ldr	r0, [r4, #8]
c0d01d26:	68e2      	ldr	r2, [r4, #12]
c0d01d28:	4282      	cmp	r2, r0
c0d01d2a:	d123      	bne.n	c0d01d74 <processTxInternal+0x28a>
        context->content->gasprice.length = context->currentFieldLength;
c0d01d2c:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d01d2e:	2220      	movs	r2, #32
c0d01d30:	e01a      	b.n	c0d01d68 <processTxInternal+0x27e>
    if (context->currentFieldIsList) {
c0d01d32:	7828      	ldrb	r0, [r5, #0]
c0d01d34:	2800      	cmp	r0, #0
c0d01d36:	d134      	bne.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldLength > MAX_INT256) {
c0d01d38:	9802      	ldr	r0, [sp, #8]
c0d01d3a:	6800      	ldr	r0, [r0, #0]
c0d01d3c:	2821      	cmp	r0, #33	; 0x21
c0d01d3e:	d230      	bcs.n	c0d01da2 <processTxInternal+0x2b8>
    if (context->currentFieldPos < context->currentFieldLength) {
c0d01d40:	68e1      	ldr	r1, [r4, #12]
c0d01d42:	4288      	cmp	r0, r1
c0d01d44:	d90c      	bls.n	c0d01d60 <processTxInternal+0x276>
            MIN(context->commandLength, context->currentFieldLength - context->currentFieldPos);
c0d01d46:	1a40      	subs	r0, r0, r1
c0d01d48:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d01d4a:	4282      	cmp	r2, r0
c0d01d4c:	d300      	bcc.n	c0d01d50 <processTxInternal+0x266>
c0d01d4e:	4602      	mov	r2, r0
        copyTxData(context, context->content->startgas.value + context->currentFieldPos, copySize);
c0d01d50:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d01d52:	1841      	adds	r1, r0, r1
c0d01d54:	3121      	adds	r1, #33	; 0x21
c0d01d56:	4620      	mov	r0, r4
c0d01d58:	f7ff fe5f 	bl	c0d01a1a <copyTxData>
    if (context->currentFieldPos == context->currentFieldLength) {
c0d01d5c:	68a0      	ldr	r0, [r4, #8]
c0d01d5e:	68e1      	ldr	r1, [r4, #12]
c0d01d60:	4281      	cmp	r1, r0
c0d01d62:	d107      	bne.n	c0d01d74 <processTxInternal+0x28a>
        context->content->startgas.length = context->currentFieldLength;
c0d01d64:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d01d66:	2241      	movs	r2, #65	; 0x41
c0d01d68:	5488      	strb	r0, [r1, r2]
c0d01d6a:	2000      	movs	r0, #0
c0d01d6c:	7460      	strb	r0, [r4, #17]
c0d01d6e:	7820      	ldrb	r0, [r4, #0]
c0d01d70:	1c40      	adds	r0, r0, #1
c0d01d72:	7020      	strb	r0, [r4, #0]
        if (context->currentField == TX_RLP_DONE) {
c0d01d74:	7820      	ldrb	r0, [r4, #0]
c0d01d76:	2702      	movs	r7, #2
c0d01d78:	2809      	cmp	r0, #9
c0d01d7a:	d100      	bne.n	c0d01d7e <processTxInternal+0x294>
c0d01d7c:	e6c3      	b.n	c0d01b06 <processTxInternal+0x1c>
c0d01d7e:	280c      	cmp	r0, #12
c0d01d80:	d00c      	beq.n	c0d01d9c <processTxInternal+0x2b2>
c0d01d82:	e6bc      	b.n	c0d01afe <processTxInternal+0x14>
c0d01d84:	2700      	movs	r7, #0
c0d01d86:	e009      	b.n	c0d01d9c <processTxInternal+0x2b2>
            context->content->vLength = 0;
c0d01d88:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d01d8a:	217c      	movs	r1, #124	; 0x7c
c0d01d8c:	2200      	movs	r2, #0
c0d01d8e:	5442      	strb	r2, [r0, r1]
c0d01d90:	e004      	b.n	c0d01d9c <processTxInternal+0x2b2>
            switch (customStatus) {
c0d01d92:	2802      	cmp	r0, #2
c0d01d94:	d101      	bne.n	c0d01d9a <processTxInternal+0x2b0>
c0d01d96:	2701      	movs	r7, #1
c0d01d98:	e000      	b.n	c0d01d9c <processTxInternal+0x2b2>
c0d01d9a:	2703      	movs	r7, #3
}
c0d01d9c:	4638      	mov	r0, r7
c0d01d9e:	b005      	add	sp, #20
c0d01da0:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01da2:	2001      	movs	r0, #1
c0d01da4:	f001 fe2d 	bl	c0d03a02 <os_longjmp>

c0d01da8 <continueTx>:
}

parserStatus_e continueTx(txContext_t *context) {
c0d01da8:	b5b0      	push	{r4, r5, r7, lr}
c0d01daa:	b08c      	sub	sp, #48	; 0x30
c0d01dac:	4604      	mov	r4, r0
c0d01dae:	466d      	mov	r5, sp
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0d01db0:	4628      	mov	r0, r5
c0d01db2:	f007 fd53 	bl	c0d0985c <setjmp>
c0d01db6:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0d01db8:	0400      	lsls	r0, r0, #16
c0d01dba:	d007      	beq.n	c0d01dcc <continueTx+0x24>
c0d01dbc:	4668      	mov	r0, sp
c0d01dbe:	2100      	movs	r1, #0
            result = processTxInternal(context);
        }
        CATCH_OTHER(e) {
c0d01dc0:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d01dc2:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d01dc4:	f003 feca 	bl	c0d05b5c <try_context_set>
c0d01dc8:	2403      	movs	r4, #3
c0d01dca:	e007      	b.n	c0d01ddc <continueTx+0x34>
c0d01dcc:	4668      	mov	r0, sp
        TRY {
c0d01dce:	f003 fec5 	bl	c0d05b5c <try_context_set>
c0d01dd2:	900a      	str	r0, [sp, #40]	; 0x28
            result = processTxInternal(context);
c0d01dd4:	4620      	mov	r0, r4
c0d01dd6:	f7ff fe88 	bl	c0d01aea <processTxInternal>
c0d01dda:	4604      	mov	r4, r0
            result = USTREAM_FAULT;
        }
        FINALLY {
c0d01ddc:	f003 feb2 	bl	c0d05b44 <try_context_get>
c0d01de0:	4669      	mov	r1, sp
c0d01de2:	4288      	cmp	r0, r1
c0d01de4:	d102      	bne.n	c0d01dec <continueTx+0x44>
c0d01de6:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d01de8:	f003 feb8 	bl	c0d05b5c <try_context_set>
c0d01dec:	4668      	mov	r0, sp
        }
    }
    END_TRY;
c0d01dee:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d01df0:	2800      	cmp	r0, #0
c0d01df2:	d102      	bne.n	c0d01dfa <continueTx+0x52>
    return result;
c0d01df4:	4620      	mov	r0, r4
c0d01df6:	b00c      	add	sp, #48	; 0x30
c0d01df8:	bdb0      	pop	{r4, r5, r7, pc}
    END_TRY;
c0d01dfa:	f001 fe02 	bl	c0d03a02 <os_longjmp>

c0d01dfe <rlpCanDecode>:
#include "os.h"
#include "cx.h"
#include "ethUtils.h"
#include "chainConfig.h"

bool rlpCanDecode(uint8_t *buffer, uint32_t bufferLength, bool *valid) {
c0d01dfe:	b510      	push	{r4, lr}
    if (*buffer <= 0x7f) {
c0d01e00:	7800      	ldrb	r0, [r0, #0]
    } else if (*buffer <= 0xb7) {
c0d01e02:	08c3      	lsrs	r3, r0, #3
    if (*buffer <= 0x7f) {
c0d01e04:	2b17      	cmp	r3, #23
c0d01e06:	d319      	bcc.n	c0d01e3c <rlpCanDecode+0x3e>
    } else if (*buffer <= 0xbf) {
c0d01e08:	0984      	lsrs	r4, r0, #6
c0d01e0a:	2c02      	cmp	r4, #2
c0d01e0c:	d807      	bhi.n	c0d01e1e <rlpCanDecode+0x20>
        if (bufferLength < (1 + (*buffer - 0xb7))) {
c0d01e0e:	4603      	mov	r3, r0
c0d01e10:	3bb6      	subs	r3, #182	; 0xb6
c0d01e12:	428b      	cmp	r3, r1
c0d01e14:	d809      	bhi.n	c0d01e2a <rlpCanDecode+0x2c>
            return false;
        }
        if (*buffer > 0xbb) {
c0d01e16:	0880      	lsrs	r0, r0, #2
c0d01e18:	282f      	cmp	r0, #47	; 0x2f
c0d01e1a:	d20b      	bcs.n	c0d01e34 <rlpCanDecode+0x36>
c0d01e1c:	e00e      	b.n	c0d01e3c <rlpCanDecode+0x3e>
            *valid = false;  // arbitrary 32 bits length limitation
            return true;
        }
    } else if (*buffer <= 0xf7) {
c0d01e1e:	2b1f      	cmp	r3, #31
c0d01e20:	d30c      	bcc.n	c0d01e3c <rlpCanDecode+0x3e>
    } else {
        if (bufferLength < (1 + (*buffer - 0xf7))) {
c0d01e22:	4603      	mov	r3, r0
c0d01e24:	3bf6      	subs	r3, #246	; 0xf6
c0d01e26:	428b      	cmp	r3, r1
c0d01e28:	d901      	bls.n	c0d01e2e <rlpCanDecode+0x30>
c0d01e2a:	2000      	movs	r0, #0
            return true;
        }
    }
    *valid = true;
    return true;
}
c0d01e2c:	bd10      	pop	{r4, pc}
        if (*buffer > 0xfb) {
c0d01e2e:	0880      	lsrs	r0, r0, #2
c0d01e30:	283f      	cmp	r0, #63	; 0x3f
c0d01e32:	d303      	bcc.n	c0d01e3c <rlpCanDecode+0x3e>
c0d01e34:	2000      	movs	r0, #0
c0d01e36:	7010      	strb	r0, [r2, #0]
c0d01e38:	2001      	movs	r0, #1
}
c0d01e3a:	bd10      	pop	{r4, pc}
c0d01e3c:	2001      	movs	r0, #1
    *valid = true;
c0d01e3e:	7010      	strb	r0, [r2, #0]
}
c0d01e40:	bd10      	pop	{r4, pc}

c0d01e42 <rlpDecodeLength>:

bool rlpDecodeLength(uint8_t *buffer,
                     uint32_t bufferLength,
                     uint32_t *fieldLength,
                     uint32_t *offset,
                     bool *list) {
c0d01e42:	b570      	push	{r4, r5, r6, lr}
    if (*buffer <= 0x7f) {
c0d01e44:	7801      	ldrb	r1, [r0, #0]
c0d01e46:	b249      	sxtb	r1, r1
c0d01e48:	9c04      	ldr	r4, [sp, #16]
c0d01e4a:	2900      	cmp	r1, #0
c0d01e4c:	db04      	blt.n	c0d01e58 <rlpDecodeLength+0x16>
c0d01e4e:	2000      	movs	r0, #0
        *offset = 0;
c0d01e50:	6018      	str	r0, [r3, #0]
c0d01e52:	2101      	movs	r1, #1
        *fieldLength = 1;
c0d01e54:	6011      	str	r1, [r2, #0]
c0d01e56:	e009      	b.n	c0d01e6c <rlpDecodeLength+0x2a>
c0d01e58:	b2c9      	uxtb	r1, r1
        *list = false;
    } else if (*buffer <= 0xb7) {
c0d01e5a:	08cd      	lsrs	r5, r1, #3
c0d01e5c:	2d16      	cmp	r5, #22
c0d01e5e:	d808      	bhi.n	c0d01e72 <rlpDecodeLength+0x30>
c0d01e60:	2101      	movs	r1, #1
        *offset = 1;
c0d01e62:	6019      	str	r1, [r3, #0]
        *fieldLength = *buffer - 0x80;
c0d01e64:	7800      	ldrb	r0, [r0, #0]
c0d01e66:	3880      	subs	r0, #128	; 0x80
c0d01e68:	6010      	str	r0, [r2, #0]
c0d01e6a:	2000      	movs	r0, #0
c0d01e6c:	7020      	strb	r0, [r4, #0]
                return false;  // arbitrary 32 bits length limitation
        }
    }

    return true;
}
c0d01e6e:	4608      	mov	r0, r1
c0d01e70:	bd70      	pop	{r4, r5, r6, pc}
    } else if (*buffer <= 0xbf) {
c0d01e72:	098e      	lsrs	r6, r1, #6
c0d01e74:	2e02      	cmp	r6, #2
c0d01e76:	d80f      	bhi.n	c0d01e98 <rlpDecodeLength+0x56>
        *offset = 1 + (*buffer - 0xb7);
c0d01e78:	39b6      	subs	r1, #182	; 0xb6
c0d01e7a:	6019      	str	r1, [r3, #0]
c0d01e7c:	2100      	movs	r1, #0
        *list = false;
c0d01e7e:	7021      	strb	r1, [r4, #0]
        switch (*buffer) {
c0d01e80:	7803      	ldrb	r3, [r0, #0]
c0d01e82:	2bb9      	cmp	r3, #185	; 0xb9
c0d01e84:	dc11      	bgt.n	c0d01eaa <rlpDecodeLength+0x68>
c0d01e86:	2bb8      	cmp	r3, #184	; 0xb8
c0d01e88:	d03c      	beq.n	c0d01f04 <rlpDecodeLength+0xc2>
c0d01e8a:	2bb9      	cmp	r3, #185	; 0xb9
c0d01e8c:	d1ef      	bne.n	c0d01e6e <rlpDecodeLength+0x2c>
                *fieldLength = (*(buffer + 1) << 8) + *(buffer + 2);
c0d01e8e:	7881      	ldrb	r1, [r0, #2]
c0d01e90:	7840      	ldrb	r0, [r0, #1]
c0d01e92:	0200      	lsls	r0, r0, #8
c0d01e94:	1840      	adds	r0, r0, r1
c0d01e96:	e03e      	b.n	c0d01f16 <rlpDecodeLength+0xd4>
    } else if (*buffer <= 0xf7) {
c0d01e98:	2d1e      	cmp	r5, #30
c0d01e9a:	d814      	bhi.n	c0d01ec6 <rlpDecodeLength+0x84>
c0d01e9c:	2101      	movs	r1, #1
        *offset = 1;
c0d01e9e:	6019      	str	r1, [r3, #0]
        *fieldLength = *buffer - 0xc0;
c0d01ea0:	7800      	ldrb	r0, [r0, #0]
c0d01ea2:	38c0      	subs	r0, #192	; 0xc0
c0d01ea4:	6010      	str	r0, [r2, #0]
        *list = true;
c0d01ea6:	7021      	strb	r1, [r4, #0]
c0d01ea8:	e7e1      	b.n	c0d01e6e <rlpDecodeLength+0x2c>
        switch (*buffer) {
c0d01eaa:	2bba      	cmp	r3, #186	; 0xba
c0d01eac:	d02c      	beq.n	c0d01f08 <rlpDecodeLength+0xc6>
c0d01eae:	2bbb      	cmp	r3, #187	; 0xbb
c0d01eb0:	d1dd      	bne.n	c0d01e6e <rlpDecodeLength+0x2c>
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0d01eb2:	7841      	ldrb	r1, [r0, #1]
c0d01eb4:	0609      	lsls	r1, r1, #24
c0d01eb6:	7883      	ldrb	r3, [r0, #2]
c0d01eb8:	041b      	lsls	r3, r3, #16
c0d01eba:	1859      	adds	r1, r3, r1
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0d01ebc:	78c3      	ldrb	r3, [r0, #3]
c0d01ebe:	021b      	lsls	r3, r3, #8
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0d01ec0:	18c9      	adds	r1, r1, r3
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0d01ec2:	7900      	ldrb	r0, [r0, #4]
c0d01ec4:	e026      	b.n	c0d01f14 <rlpDecodeLength+0xd2>
        *offset = 1 + (*buffer - 0xf7);
c0d01ec6:	39f6      	subs	r1, #246	; 0xf6
c0d01ec8:	6019      	str	r1, [r3, #0]
c0d01eca:	2301      	movs	r3, #1
        *list = true;
c0d01ecc:	7023      	strb	r3, [r4, #0]
        switch (*buffer) {
c0d01ece:	7804      	ldrb	r4, [r0, #0]
c0d01ed0:	2100      	movs	r1, #0
c0d01ed2:	2cf9      	cmp	r4, #249	; 0xf9
c0d01ed4:	dc08      	bgt.n	c0d01ee8 <rlpDecodeLength+0xa6>
c0d01ed6:	2cf8      	cmp	r4, #248	; 0xf8
c0d01ed8:	d020      	beq.n	c0d01f1c <rlpDecodeLength+0xda>
c0d01eda:	2cf9      	cmp	r4, #249	; 0xf9
c0d01edc:	d1c7      	bne.n	c0d01e6e <rlpDecodeLength+0x2c>
                *fieldLength = (*(buffer + 1) << 8) + *(buffer + 2);
c0d01ede:	7881      	ldrb	r1, [r0, #2]
c0d01ee0:	7840      	ldrb	r0, [r0, #1]
c0d01ee2:	0200      	lsls	r0, r0, #8
c0d01ee4:	1840      	adds	r0, r0, r1
c0d01ee6:	e022      	b.n	c0d01f2e <rlpDecodeLength+0xec>
        switch (*buffer) {
c0d01ee8:	2cfa      	cmp	r4, #250	; 0xfa
c0d01eea:	d019      	beq.n	c0d01f20 <rlpDecodeLength+0xde>
c0d01eec:	2cfb      	cmp	r4, #251	; 0xfb
c0d01eee:	d1be      	bne.n	c0d01e6e <rlpDecodeLength+0x2c>
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0d01ef0:	7841      	ldrb	r1, [r0, #1]
c0d01ef2:	0609      	lsls	r1, r1, #24
c0d01ef4:	7884      	ldrb	r4, [r0, #2]
c0d01ef6:	0424      	lsls	r4, r4, #16
c0d01ef8:	1861      	adds	r1, r4, r1
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0d01efa:	78c4      	ldrb	r4, [r0, #3]
c0d01efc:	0224      	lsls	r4, r4, #8
                *fieldLength = (*(buffer + 1) << 24) + (*(buffer + 2) << 16) +
c0d01efe:	1909      	adds	r1, r1, r4
                               (*(buffer + 3) << 8) + *(buffer + 4);
c0d01f00:	7900      	ldrb	r0, [r0, #4]
c0d01f02:	e013      	b.n	c0d01f2c <rlpDecodeLength+0xea>
                *fieldLength = *(buffer + 1);
c0d01f04:	7840      	ldrb	r0, [r0, #1]
c0d01f06:	e006      	b.n	c0d01f16 <rlpDecodeLength+0xd4>
                *fieldLength = (*(buffer + 1) << 16) + (*(buffer + 2) << 8) + *(buffer + 3);
c0d01f08:	7841      	ldrb	r1, [r0, #1]
c0d01f0a:	0409      	lsls	r1, r1, #16
c0d01f0c:	7883      	ldrb	r3, [r0, #2]
c0d01f0e:	021b      	lsls	r3, r3, #8
c0d01f10:	1859      	adds	r1, r3, r1
c0d01f12:	78c0      	ldrb	r0, [r0, #3]
c0d01f14:	1808      	adds	r0, r1, r0
c0d01f16:	6010      	str	r0, [r2, #0]
c0d01f18:	2101      	movs	r1, #1
c0d01f1a:	e7a8      	b.n	c0d01e6e <rlpDecodeLength+0x2c>
                *fieldLength = *(buffer + 1);
c0d01f1c:	7840      	ldrb	r0, [r0, #1]
c0d01f1e:	e006      	b.n	c0d01f2e <rlpDecodeLength+0xec>
                *fieldLength = (*(buffer + 1) << 16) + (*(buffer + 2) << 8) + *(buffer + 3);
c0d01f20:	7841      	ldrb	r1, [r0, #1]
c0d01f22:	0409      	lsls	r1, r1, #16
c0d01f24:	7884      	ldrb	r4, [r0, #2]
c0d01f26:	0224      	lsls	r4, r4, #8
c0d01f28:	1861      	adds	r1, r4, r1
c0d01f2a:	78c0      	ldrb	r0, [r0, #3]
c0d01f2c:	1808      	adds	r0, r1, r0
c0d01f2e:	6010      	str	r0, [r2, #0]
c0d01f30:	4619      	mov	r1, r3
c0d01f32:	e79c      	b.n	c0d01e6e <rlpDecodeLength+0x2c>

c0d01f34 <getEthAddressStringFromKey>:
static const uint8_t const HEXDIGITS[] = "0123456789abcdef";

void getEthAddressStringFromKey(cx_ecfp_public_key_t *publicKey,
                                uint8_t *out,
                                cx_sha3_t *sha3Context,
                                chain_config_t *chain_config) {
c0d01f34:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01f36:	b08d      	sub	sp, #52	; 0x34
c0d01f38:	9304      	str	r3, [sp, #16]
c0d01f3a:	4615      	mov	r5, r2
c0d01f3c:	9103      	str	r1, [sp, #12]
c0d01f3e:	4607      	mov	r7, r0
c0d01f40:	2401      	movs	r4, #1
c0d01f42:	0221      	lsls	r1, r4, #8
    uint8_t hashAddress[32];
    cx_keccak_init(sha3Context, 256);
c0d01f44:	4610      	mov	r0, r2
c0d01f46:	f003 fc8d 	bl	c0d05864 <cx_keccak_init>
c0d01f4a:	2020      	movs	r0, #32
    cx_hash((cx_hash_t *) sha3Context, CX_LAST, publicKey->W + 1, 64, hashAddress, 32);
c0d01f4c:	4669      	mov	r1, sp
c0d01f4e:	6048      	str	r0, [r1, #4]
c0d01f50:	ae05      	add	r6, sp, #20
c0d01f52:	600e      	str	r6, [r1, #0]
c0d01f54:	3709      	adds	r7, #9
c0d01f56:	2340      	movs	r3, #64	; 0x40
c0d01f58:	4628      	mov	r0, r5
c0d01f5a:	4621      	mov	r1, r4
c0d01f5c:	463a      	mov	r2, r7
c0d01f5e:	f003 fc51 	bl	c0d05804 <cx_hash>
    getEthAddressStringFromBinary(hashAddress + 12, out, sha3Context, chain_config);
c0d01f62:	360c      	adds	r6, #12
c0d01f64:	4630      	mov	r0, r6
c0d01f66:	9903      	ldr	r1, [sp, #12]
c0d01f68:	462a      	mov	r2, r5
c0d01f6a:	9b04      	ldr	r3, [sp, #16]
c0d01f6c:	f000 f802 	bl	c0d01f74 <getEthAddressStringFromBinary>
}
c0d01f70:	b00d      	add	sp, #52	; 0x34
c0d01f72:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d01f74 <getEthAddressStringFromBinary>:

void getEthAddressStringFromBinary(uint8_t *address,
                                   uint8_t *out,
                                   cx_sha3_t *sha3Context,
                                   chain_config_t *chain_config) {
c0d01f74:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01f76:	b093      	sub	sp, #76	; 0x4c
c0d01f78:	9203      	str	r2, [sp, #12]
c0d01f7a:	9104      	str	r1, [sp, #16]
c0d01f7c:	4605      	mov	r5, r0
    } locals_union;

    uint8_t i;
    bool eip1191 = false;
    uint32_t offset = 0;
    switch (chain_config->chainId) {
c0d01f7e:	68db      	ldr	r3, [r3, #12]
c0d01f80:	2101      	movs	r1, #1
c0d01f82:	4618      	mov	r0, r3
c0d01f84:	9105      	str	r1, [sp, #20]
c0d01f86:	4388      	bics	r0, r1
c0d01f88:	2600      	movs	r6, #0
        case 30:
        case 31:
            eip1191 = true;
            break;
    }
    if (eip1191) {
c0d01f8a:	281e      	cmp	r0, #30
c0d01f8c:	4630      	mov	r0, r6
c0d01f8e:	d109      	bne.n	c0d01fa4 <getEthAddressStringFromBinary+0x30>
c0d01f90:	af06      	add	r7, sp, #24
c0d01f92:	2133      	movs	r1, #51	; 0x33
        snprintf((char *) locals_union.tmp,
c0d01f94:	4a27      	ldr	r2, [pc, #156]	; (c0d02034 <getEthAddressStringFromBinary+0xc0>)
c0d01f96:	447a      	add	r2, pc
c0d01f98:	4638      	mov	r0, r7
c0d01f9a:	f002 fb47 	bl	c0d0462c <snprintf>
                 sizeof(locals_union.tmp),
                 "%d0x",
                 chain_config->chainId);
        offset = strlen((char *) locals_union.tmp);
c0d01f9e:	4638      	mov	r0, r7
c0d01fa0:	f007 fce8 	bl	c0d09974 <strlen>
c0d01fa4:	a906      	add	r1, sp, #24
c0d01fa6:	9002      	str	r0, [sp, #8]
    }
    for (i = 0; i < 20; i++) {
c0d01fa8:	1808      	adds	r0, r1, r0
c0d01faa:	4f23      	ldr	r7, [pc, #140]	; (c0d02038 <getEthAddressStringFromBinary+0xc4>)
c0d01fac:	447f      	add	r7, pc
        uint8_t digit = address[i];
c0d01fae:	5da9      	ldrb	r1, [r5, r6]
c0d01fb0:	240f      	movs	r4, #15
        locals_union.tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
c0d01fb2:	090a      	lsrs	r2, r1, #4
        locals_union.tmp[offset + 2 * i + 1] = HEXDIGITS[digit & 0x0f];
c0d01fb4:	4021      	ands	r1, r4
c0d01fb6:	5c79      	ldrb	r1, [r7, r1]
c0d01fb8:	7041      	strb	r1, [r0, #1]
        locals_union.tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
c0d01fba:	5cb9      	ldrb	r1, [r7, r2]
c0d01fbc:	7001      	strb	r1, [r0, #0]
    for (i = 0; i < 20; i++) {
c0d01fbe:	1c80      	adds	r0, r0, #2
c0d01fc0:	1c76      	adds	r6, r6, #1
c0d01fc2:	2e14      	cmp	r6, #20
c0d01fc4:	d1f3      	bne.n	c0d01fae <getEthAddressStringFromBinary+0x3a>
c0d01fc6:	9805      	ldr	r0, [sp, #20]
c0d01fc8:	0201      	lsls	r1, r0, #8
c0d01fca:	9e03      	ldr	r6, [sp, #12]
    }
    cx_keccak_init(sha3Context, 256);
c0d01fcc:	4630      	mov	r0, r6
c0d01fce:	f003 fc49 	bl	c0d05864 <cx_keccak_init>
c0d01fd2:	2020      	movs	r0, #32
    cx_hash((cx_hash_t *) sha3Context,
c0d01fd4:	4669      	mov	r1, sp
c0d01fd6:	6048      	str	r0, [r1, #4]
c0d01fd8:	aa06      	add	r2, sp, #24
c0d01fda:	600a      	str	r2, [r1, #0]
c0d01fdc:	9b02      	ldr	r3, [sp, #8]
            CX_LAST,
            locals_union.tmp,
            offset + 40,
c0d01fde:	3328      	adds	r3, #40	; 0x28
    cx_hash((cx_hash_t *) sha3Context,
c0d01fe0:	4630      	mov	r0, r6
c0d01fe2:	9905      	ldr	r1, [sp, #20]
c0d01fe4:	f003 fc0e 	bl	c0d05804 <cx_hash>
c0d01fe8:	2000      	movs	r0, #0
c0d01fea:	9e04      	ldr	r6, [sp, #16]
            locals_union.hashChecksum,
            32);
    for (i = 0; i < 40; i++) {
        uint8_t digit = address[i / 2];
        if ((i % 2) == 0) {
c0d01fec:	4602      	mov	r2, r0
c0d01fee:	9905      	ldr	r1, [sp, #20]
c0d01ff0:	400a      	ands	r2, r1
        uint8_t digit = address[i / 2];
c0d01ff2:	0843      	lsrs	r3, r0, #1
c0d01ff4:	5ce9      	ldrb	r1, [r5, r3]
        if ((i % 2) == 0) {
c0d01ff6:	2a00      	cmp	r2, #0
c0d01ff8:	d001      	beq.n	c0d01ffe <getEthAddressStringFromBinary+0x8a>
c0d01ffa:	4021      	ands	r1, r4
c0d01ffc:	e000      	b.n	c0d02000 <getEthAddressStringFromBinary+0x8c>
c0d01ffe:	0909      	lsrs	r1, r1, #4
            digit = (digit >> 4) & 0x0f;
        } else {
            digit = digit & 0x0f;
        }
        if (digit < 10) {
c0d02000:	2909      	cmp	r1, #9
c0d02002:	d801      	bhi.n	c0d02008 <getEthAddressStringFromBinary+0x94>
            out[i] = HEXDIGITS[digit];
c0d02004:	5c79      	ldrb	r1, [r7, r1]
c0d02006:	e00b      	b.n	c0d02020 <getEthAddressStringFromBinary+0xac>
c0d02008:	ae06      	add	r6, sp, #24
        } else {
            int v = (locals_union.hashChecksum[i / 2] >> (4 * (1 - i % 2))) & 0x0f;
c0d0200a:	5cf3      	ldrb	r3, [r6, r3]
c0d0200c:	0092      	lsls	r2, r2, #2
c0d0200e:	2604      	movs	r6, #4
c0d02010:	4056      	eors	r6, r2
c0d02012:	2208      	movs	r2, #8
            if (v >= 8) {
c0d02014:	40b2      	lsls	r2, r6
c0d02016:	5c79      	ldrb	r1, [r7, r1]
c0d02018:	421a      	tst	r2, r3
c0d0201a:	d000      	beq.n	c0d0201e <getEthAddressStringFromBinary+0xaa>
c0d0201c:	3920      	subs	r1, #32
c0d0201e:	9e04      	ldr	r6, [sp, #16]
c0d02020:	5431      	strb	r1, [r6, r0]
    for (i = 0; i < 40; i++) {
c0d02022:	1c40      	adds	r0, r0, #1
c0d02024:	2828      	cmp	r0, #40	; 0x28
c0d02026:	d1e1      	bne.n	c0d01fec <getEthAddressStringFromBinary+0x78>
c0d02028:	2028      	movs	r0, #40	; 0x28
c0d0202a:	2100      	movs	r1, #0
            } else {
                out[i] = HEXDIGITS[digit];
            }
        }
    }
    out[40] = '\0';
c0d0202c:	5431      	strb	r1, [r6, r0]
}
c0d0202e:	b013      	add	sp, #76	; 0x4c
c0d02030:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02032:	46c0      	nop			; (mov r8, r8)
c0d02034:	00007e13 	.word	0x00007e13
c0d02038:	00007e02 	.word	0x00007e02

c0d0203c <adjustDecimals>:

bool adjustDecimals(char *src,
                    uint32_t srcLength,
                    char *target,
                    uint32_t targetLength,
                    uint8_t decimals) {
c0d0203c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0203e:	b081      	sub	sp, #4
c0d02040:	460e      	mov	r6, r1
c0d02042:	4605      	mov	r5, r0
    uint32_t startOffset;
    uint32_t lastZeroOffset = 0;
    uint32_t offset = 0;
    if ((srcLength == 1) && (*src == '0')) {
c0d02044:	2901      	cmp	r1, #1
c0d02046:	d10a      	bne.n	c0d0205e <adjustDecimals+0x22>
c0d02048:	7828      	ldrb	r0, [r5, #0]
c0d0204a:	2830      	cmp	r0, #48	; 0x30
c0d0204c:	d107      	bne.n	c0d0205e <adjustDecimals+0x22>
        if (targetLength < 2) {
c0d0204e:	2b02      	cmp	r3, #2
c0d02050:	d32d      	bcc.n	c0d020ae <adjustDecimals+0x72>
c0d02052:	2000      	movs	r0, #0
            return false;
        }
        target[0] = '0';
        target[1] = '\0';
c0d02054:	7050      	strb	r0, [r2, #1]
c0d02056:	2030      	movs	r0, #48	; 0x30
        target[0] = '0';
c0d02058:	7010      	strb	r0, [r2, #0]
c0d0205a:	2001      	movs	r0, #1
c0d0205c:	e064      	b.n	c0d02128 <adjustDecimals+0xec>
c0d0205e:	9c06      	ldr	r4, [sp, #24]
        return true;
    }
    if (srcLength <= decimals) {
c0d02060:	42b4      	cmp	r4, r6
c0d02062:	d221      	bcs.n	c0d020a8 <adjustDecimals+0x6c>
        }
        target[offset] = '\0';
    } else {
        uint32_t sourceOffset = 0;
        uint32_t delta = srcLength - decimals;
        if (targetLength < srcLength + 1 + 1) {
c0d02064:	1cb0      	adds	r0, r6, #2
c0d02066:	4298      	cmp	r0, r3
c0d02068:	d821      	bhi.n	c0d020ae <adjustDecimals+0x72>
c0d0206a:	9200      	str	r2, [sp, #0]
c0d0206c:	1b30      	subs	r0, r6, r4
            return false;
        }
        while (offset < delta) {
c0d0206e:	d009      	beq.n	c0d02084 <adjustDecimals+0x48>
c0d02070:	4629      	mov	r1, r5
c0d02072:	4602      	mov	r2, r0
c0d02074:	9b00      	ldr	r3, [sp, #0]
            target[offset++] = src[sourceOffset++];
c0d02076:	780f      	ldrb	r7, [r1, #0]
c0d02078:	701f      	strb	r7, [r3, #0]
        while (offset < delta) {
c0d0207a:	1c49      	adds	r1, r1, #1
c0d0207c:	1e52      	subs	r2, r2, #1
c0d0207e:	1c5b      	adds	r3, r3, #1
c0d02080:	2a00      	cmp	r2, #0
c0d02082:	d1f8      	bne.n	c0d02076 <adjustDecimals+0x3a>
        }
        if (decimals != 0) {
c0d02084:	2c00      	cmp	r4, #0
c0d02086:	4601      	mov	r1, r0
c0d02088:	9f00      	ldr	r7, [sp, #0]
c0d0208a:	d002      	beq.n	c0d02092 <adjustDecimals+0x56>
c0d0208c:	212e      	movs	r1, #46	; 0x2e
            target[offset++] = '.';
c0d0208e:	5439      	strb	r1, [r7, r0]
c0d02090:	1c41      	adds	r1, r0, #1
        }
        startOffset = offset;
        while (sourceOffset < srcLength) {
c0d02092:	42b0      	cmp	r0, r6
c0d02094:	d22d      	bcs.n	c0d020f2 <adjustDecimals+0xb6>
            target[offset++] = src[sourceOffset++];
c0d02096:	187a      	adds	r2, r7, r1
c0d02098:	182b      	adds	r3, r5, r0
c0d0209a:	2000      	movs	r0, #0
c0d0209c:	5c1d      	ldrb	r5, [r3, r0]
c0d0209e:	5415      	strb	r5, [r2, r0]
        while (sourceOffset < srcLength) {
c0d020a0:	1c40      	adds	r0, r0, #1
c0d020a2:	4284      	cmp	r4, r0
c0d020a4:	d1fa      	bne.n	c0d0209c <adjustDecimals+0x60>
c0d020a6:	e022      	b.n	c0d020ee <adjustDecimals+0xb2>
        if (targetLength < srcLength + 1 + 2 + delta) {
c0d020a8:	1ce0      	adds	r0, r4, #3
c0d020aa:	4298      	cmp	r0, r3
c0d020ac:	d901      	bls.n	c0d020b2 <adjustDecimals+0x76>
c0d020ae:	2000      	movs	r0, #0
c0d020b0:	e03a      	b.n	c0d02128 <adjustDecimals+0xec>
c0d020b2:	1ba7      	subs	r7, r4, r6
c0d020b4:	202e      	movs	r0, #46	; 0x2e
        target[offset++] = '.';
c0d020b6:	7050      	strb	r0, [r2, #1]
c0d020b8:	2030      	movs	r0, #48	; 0x30
        target[offset++] = '0';
c0d020ba:	7010      	strb	r0, [r2, #0]
        for (uint32_t i = 0; i < delta; i++) {
c0d020bc:	2f00      	cmp	r7, #0
c0d020be:	d00b      	beq.n	c0d020d8 <adjustDecimals+0x9c>
c0d020c0:	9200      	str	r2, [sp, #0]
            target[offset++] = '0';
c0d020c2:	1c90      	adds	r0, r2, #2
c0d020c4:	2230      	movs	r2, #48	; 0x30
c0d020c6:	4639      	mov	r1, r7
c0d020c8:	f007 fa9c 	bl	c0d09604 <__aeabi_memset>
c0d020cc:	1ca0      	adds	r0, r4, #2
c0d020ce:	1b81      	subs	r1, r0, r6
        for (uint32_t i = 0; i < delta; i++) {
c0d020d0:	1e7f      	subs	r7, r7, #1
c0d020d2:	d1fd      	bne.n	c0d020d0 <adjustDecimals+0x94>
c0d020d4:	9f00      	ldr	r7, [sp, #0]
c0d020d6:	e001      	b.n	c0d020dc <adjustDecimals+0xa0>
c0d020d8:	2102      	movs	r1, #2
c0d020da:	4617      	mov	r7, r2
        for (uint32_t i = 0; i < srcLength; i++) {
c0d020dc:	2e00      	cmp	r6, #0
c0d020de:	d008      	beq.n	c0d020f2 <adjustDecimals+0xb6>
            target[offset++] = src[i];
c0d020e0:	187a      	adds	r2, r7, r1
c0d020e2:	2000      	movs	r0, #0
c0d020e4:	5c2b      	ldrb	r3, [r5, r0]
c0d020e6:	5413      	strb	r3, [r2, r0]
        for (uint32_t i = 0; i < srcLength; i++) {
c0d020e8:	1c40      	adds	r0, r0, #1
c0d020ea:	4286      	cmp	r6, r0
c0d020ec:	d1fa      	bne.n	c0d020e4 <adjustDecimals+0xa8>
c0d020ee:	180a      	adds	r2, r1, r0
c0d020f0:	e000      	b.n	c0d020f4 <adjustDecimals+0xb8>
c0d020f2:	460a      	mov	r2, r1
c0d020f4:	2400      	movs	r4, #0
c0d020f6:	54bc      	strb	r4, [r7, r2]
c0d020f8:	2001      	movs	r0, #1
        }
        target[offset] = '\0';
    }
    for (uint32_t i = startOffset; i < offset; i++) {
c0d020fa:	4291      	cmp	r1, r2
c0d020fc:	d214      	bcs.n	c0d02128 <adjustDecimals+0xec>
        if (target[i] == '0') {
c0d020fe:	5c7d      	ldrb	r5, [r7, r1]
c0d02100:	2c00      	cmp	r4, #0
c0d02102:	460b      	mov	r3, r1
c0d02104:	d000      	beq.n	c0d02108 <adjustDecimals+0xcc>
c0d02106:	4623      	mov	r3, r4
c0d02108:	2d30      	cmp	r5, #48	; 0x30
c0d0210a:	d000      	beq.n	c0d0210e <adjustDecimals+0xd2>
c0d0210c:	2300      	movs	r3, #0
    for (uint32_t i = startOffset; i < offset; i++) {
c0d0210e:	1c49      	adds	r1, r1, #1
c0d02110:	428a      	cmp	r2, r1
c0d02112:	461c      	mov	r4, r3
c0d02114:	d1f3      	bne.n	c0d020fe <adjustDecimals+0xc2>
            }
        } else {
            lastZeroOffset = 0;
        }
    }
    if (lastZeroOffset != 0) {
c0d02116:	2b00      	cmp	r3, #0
c0d02118:	d006      	beq.n	c0d02128 <adjustDecimals+0xec>
c0d0211a:	2100      	movs	r1, #0
        target[lastZeroOffset] = '\0';
c0d0211c:	54f9      	strb	r1, [r7, r3]
        if (target[lastZeroOffset - 1] == '.') {
c0d0211e:	1e5a      	subs	r2, r3, #1
c0d02120:	5cbb      	ldrb	r3, [r7, r2]
c0d02122:	2b2e      	cmp	r3, #46	; 0x2e
c0d02124:	d100      	bne.n	c0d02128 <adjustDecimals+0xec>
            target[lastZeroOffset - 1] = '\0';
c0d02126:	54b9      	strb	r1, [r7, r2]
        }
    }
    return true;
}
c0d02128:	b001      	add	sp, #4
c0d0212a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d0212c <eth_plugin_prepare_init>:
#include "eth_plugin_handler.h"
#include "eth_plugin_internal.h"
#include "shared_context.h"
#include "base64.h"

void eth_plugin_prepare_init(ethPluginInitContract_t *init, uint8_t *selector, uint32_t dataSize) {
c0d0212c:	b570      	push	{r4, r5, r6, lr}
c0d0212e:	4614      	mov	r4, r2
c0d02130:	460d      	mov	r5, r1
c0d02132:	4606      	mov	r6, r0
c0d02134:	2120      	movs	r1, #32
    memset((uint8_t *) init, 0, sizeof(ethPluginInitContract_t));
c0d02136:	f007 fa57 	bl	c0d095e8 <__aeabi_memclr>
    init->selector = selector;
c0d0213a:	6135      	str	r5, [r6, #16]
    init->dataSize = dataSize;
c0d0213c:	6174      	str	r4, [r6, #20]
}
c0d0213e:	bd70      	pop	{r4, r5, r6, pc}

c0d02140 <eth_plugin_prepare_provide_parameter>:

void eth_plugin_prepare_provide_parameter(ethPluginProvideParameter_t *provideParameter,
                                          uint8_t *parameter,
                                          uint32_t parameterOffset) {
c0d02140:	b570      	push	{r4, r5, r6, lr}
c0d02142:	4614      	mov	r4, r2
c0d02144:	460d      	mov	r5, r1
c0d02146:	4606      	mov	r6, r0
c0d02148:	2118      	movs	r1, #24
    memset((uint8_t *) provideParameter, 0, sizeof(ethPluginProvideParameter_t));
c0d0214a:	f007 fa4d 	bl	c0d095e8 <__aeabi_memclr>
    provideParameter->parameter = parameter;
c0d0214e:	60f5      	str	r5, [r6, #12]
    provideParameter->parameterOffset = parameterOffset;
c0d02150:	6134      	str	r4, [r6, #16]
}
c0d02152:	bd70      	pop	{r4, r5, r6, pc}

c0d02154 <eth_plugin_prepare_finalize>:

void eth_plugin_prepare_finalize(ethPluginFinalize_t *finalize) {
c0d02154:	b580      	push	{r7, lr}
c0d02156:	2120      	movs	r1, #32
    memset((uint8_t *) finalize, 0, sizeof(ethPluginFinalize_t));
c0d02158:	f007 fa46 	bl	c0d095e8 <__aeabi_memclr>
}
c0d0215c:	bd80      	pop	{r7, pc}

c0d0215e <eth_plugin_prepare_provide_token>:

void eth_plugin_prepare_provide_token(ethPluginProvideToken_t *provideToken,
                                      tokenDefinition_t *token1,
                                      tokenDefinition_t *token2) {
c0d0215e:	b570      	push	{r4, r5, r6, lr}
c0d02160:	4614      	mov	r4, r2
c0d02162:	460d      	mov	r5, r1
c0d02164:	4606      	mov	r6, r0
c0d02166:	2118      	movs	r1, #24
    memset((uint8_t *) provideToken, 0, sizeof(ethPluginProvideToken_t));
c0d02168:	f007 fa3e 	bl	c0d095e8 <__aeabi_memclr>
    provideToken->token1 = token1;
c0d0216c:	60f5      	str	r5, [r6, #12]
    provideToken->token2 = token2;
c0d0216e:	6134      	str	r4, [r6, #16]
}
c0d02170:	bd70      	pop	{r4, r5, r6, pc}

c0d02172 <eth_plugin_prepare_query_contract_ID>:

void eth_plugin_prepare_query_contract_ID(ethQueryContractID_t *queryContractID,
                                          char *name,
                                          uint32_t nameLength,
                                          char *version,
                                          uint32_t versionLength) {
c0d02172:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02174:	b081      	sub	sp, #4
c0d02176:	461c      	mov	r4, r3
c0d02178:	4615      	mov	r5, r2
c0d0217a:	460e      	mov	r6, r1
c0d0217c:	4607      	mov	r7, r0
c0d0217e:	2120      	movs	r1, #32
    memset((uint8_t *) queryContractID, 0, sizeof(ethQueryContractID_t));
c0d02180:	f007 fa32 	bl	c0d095e8 <__aeabi_memclr>
c0d02184:	9806      	ldr	r0, [sp, #24]
    queryContractID->name = name;
c0d02186:	60fe      	str	r6, [r7, #12]
    queryContractID->nameLength = nameLength;
c0d02188:	613d      	str	r5, [r7, #16]
    queryContractID->version = version;
c0d0218a:	617c      	str	r4, [r7, #20]
    queryContractID->versionLength = versionLength;
c0d0218c:	61b8      	str	r0, [r7, #24]
}
c0d0218e:	b001      	add	sp, #4
c0d02190:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d02192 <eth_plugin_prepare_query_contract_UI>:
void eth_plugin_prepare_query_contract_UI(ethQueryContractUI_t *queryContractUI,
                                          uint8_t screenIndex,
                                          char *title,
                                          uint32_t titleLength,
                                          char *msg,
                                          uint32_t msgLength) {
c0d02192:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02194:	b081      	sub	sp, #4
c0d02196:	461c      	mov	r4, r3
c0d02198:	4615      	mov	r5, r2
c0d0219a:	460e      	mov	r6, r1
c0d0219c:	4607      	mov	r7, r0
c0d0219e:	2124      	movs	r1, #36	; 0x24
    memset((uint8_t *) queryContractUI, 0, sizeof(ethQueryContractUI_t));
c0d021a0:	f007 fa22 	bl	c0d095e8 <__aeabi_memclr>
c0d021a4:	9807      	ldr	r0, [sp, #28]
    queryContractUI->screenIndex = screenIndex;
    queryContractUI->title = title;
    queryContractUI->titleLength = titleLength;
    queryContractUI->msg = msg;
    queryContractUI->msgLength = msgLength;
c0d021a6:	61f8      	str	r0, [r7, #28]
c0d021a8:	9806      	ldr	r0, [sp, #24]
    queryContractUI->msg = msg;
c0d021aa:	61b8      	str	r0, [r7, #24]
    queryContractUI->titleLength = titleLength;
c0d021ac:	617c      	str	r4, [r7, #20]
    queryContractUI->title = title;
c0d021ae:	613d      	str	r5, [r7, #16]
    queryContractUI->screenIndex = screenIndex;
c0d021b0:	733e      	strb	r6, [r7, #12]
}
c0d021b2:	b001      	add	sp, #4
c0d021b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d021b8 <eth_plugin_perform_init>:

int eth_plugin_perform_init(uint8_t *contractAddress, ethPluginInitContract_t *init) {
c0d021b8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d021ba:	b087      	sub	sp, #28
c0d021bc:	9106      	str	r1, [sp, #24]
c0d021be:	4605      	mov	r5, r0
    uint8_t i;
    const uint8_t **selectors;
    dataContext.tokenContext.pluginAvailable = 0;
c0d021c0:	483a      	ldr	r0, [pc, #232]	; (c0d022ac <eth_plugin_perform_init+0xf4>)
c0d021c2:	2400      	movs	r4, #0
c0d021c4:	7784      	strb	r4, [r0, #30]
    // Handle hardcoded plugin list
    PRINTF("Selector %.*H\n", 4, init->selector);
    for (i = 0;; i++) {
        uint8_t j;
        selectors = PIC(INTERNAL_ETH_PLUGINS[i].selectors);
c0d021c6:	4e3b      	ldr	r6, [pc, #236]	; (c0d022b4 <eth_plugin_perform_init+0xfc>)
c0d021c8:	447e      	add	r6, pc
c0d021ca:	6870      	ldr	r0, [r6, #4]
c0d021cc:	f002 fc02 	bl	c0d049d4 <pic>
        if (selectors == NULL) {
c0d021d0:	2800      	cmp	r0, #0
c0d021d2:	d051      	beq.n	c0d02278 <eth_plugin_perform_init+0xc0>
c0d021d4:	4607      	mov	r7, r0
c0d021d6:	9404      	str	r4, [sp, #16]
c0d021d8:	9601      	str	r6, [sp, #4]
c0d021da:	2114      	movs	r1, #20
            break;
        }
        for (j = 0; ((j < INTERNAL_ETH_PLUGINS[i].num_selectors) && (contractAddress != NULL));
c0d021dc:	2d00      	cmp	r5, #0
c0d021de:	d033      	beq.n	c0d02248 <eth_plugin_perform_init+0x90>
c0d021e0:	434c      	muls	r4, r1
c0d021e2:	1930      	adds	r0, r6, r4
c0d021e4:	9005      	str	r0, [sp, #20]
c0d021e6:	7a06      	ldrb	r6, [r0, #8]
c0d021e8:	2e00      	cmp	r6, #0
c0d021ea:	d02c      	beq.n	c0d02246 <eth_plugin_perform_init+0x8e>
c0d021ec:	9103      	str	r1, [sp, #12]
c0d021ee:	9502      	str	r5, [sp, #8]
c0d021f0:	2500      	movs	r5, #0
             j++) {
            if (memcmp(init->selector, PIC(selectors[j]), SELECTOR_SIZE) == 0) {
c0d021f2:	9806      	ldr	r0, [sp, #24]
c0d021f4:	6904      	ldr	r4, [r0, #16]
c0d021f6:	6838      	ldr	r0, [r7, #0]
c0d021f8:	f002 fbec 	bl	c0d049d4 <pic>
c0d021fc:	7801      	ldrb	r1, [r0, #0]
c0d021fe:	7842      	ldrb	r2, [r0, #1]
c0d02200:	0212      	lsls	r2, r2, #8
c0d02202:	1851      	adds	r1, r2, r1
c0d02204:	7882      	ldrb	r2, [r0, #2]
c0d02206:	78c0      	ldrb	r0, [r0, #3]
c0d02208:	0200      	lsls	r0, r0, #8
c0d0220a:	1880      	adds	r0, r0, r2
c0d0220c:	0400      	lsls	r0, r0, #16
c0d0220e:	1840      	adds	r0, r0, r1
c0d02210:	7821      	ldrb	r1, [r4, #0]
c0d02212:	7862      	ldrb	r2, [r4, #1]
c0d02214:	0212      	lsls	r2, r2, #8
c0d02216:	1851      	adds	r1, r2, r1
c0d02218:	78a2      	ldrb	r2, [r4, #2]
c0d0221a:	78e3      	ldrb	r3, [r4, #3]
c0d0221c:	021b      	lsls	r3, r3, #8
c0d0221e:	189a      	adds	r2, r3, r2
c0d02220:	0412      	lsls	r2, r2, #16
c0d02222:	1851      	adds	r1, r2, r1
c0d02224:	4281      	cmp	r1, r0
c0d02226:	d108      	bne.n	c0d0223a <eth_plugin_perform_init+0x82>
                if ((INTERNAL_ETH_PLUGINS[i].availableCheck == NULL) ||
c0d02228:	9805      	ldr	r0, [sp, #20]
c0d0222a:	6800      	ldr	r0, [r0, #0]
c0d0222c:	2800      	cmp	r0, #0
c0d0222e:	d00d      	beq.n	c0d0224c <eth_plugin_perform_init+0x94>
                    ((PluginAvailableCheck) PIC(INTERNAL_ETH_PLUGINS[i].availableCheck))()) {
c0d02230:	f002 fbd0 	bl	c0d049d4 <pic>
c0d02234:	4780      	blx	r0
                if ((INTERNAL_ETH_PLUGINS[i].availableCheck == NULL) ||
c0d02236:	2800      	cmp	r0, #0
c0d02238:	d108      	bne.n	c0d0224c <eth_plugin_perform_init+0x94>
        for (j = 0; ((j < INTERNAL_ETH_PLUGINS[i].num_selectors) && (contractAddress != NULL));
c0d0223a:	1d3f      	adds	r7, r7, #4
             j++) {
c0d0223c:	1c6d      	adds	r5, r5, #1
        for (j = 0; ((j < INTERNAL_ETH_PLUGINS[i].num_selectors) && (contractAddress != NULL));
c0d0223e:	42b5      	cmp	r5, r6
c0d02240:	d3d7      	bcc.n	c0d021f2 <eth_plugin_perform_init+0x3a>
c0d02242:	9d02      	ldr	r5, [sp, #8]
c0d02244:	e00a      	b.n	c0d0225c <eth_plugin_perform_init+0xa4>
c0d02246:	9e01      	ldr	r6, [sp, #4]
c0d02248:	9804      	ldr	r0, [sp, #16]
c0d0224a:	e00a      	b.n	c0d02262 <eth_plugin_perform_init+0xaa>
c0d0224c:	9905      	ldr	r1, [sp, #20]
                    strcpy(dataContext.tokenContext.pluginName, INTERNAL_ETH_PLUGINS[i].alias);
c0d0224e:	3109      	adds	r1, #9
c0d02250:	4816      	ldr	r0, [pc, #88]	; (c0d022ac <eth_plugin_perform_init+0xf4>)
c0d02252:	f007 fb87 	bl	c0d09964 <strcpy>
c0d02256:	2101      	movs	r1, #1
                    dataContext.tokenContext.pluginAvailable = 1;
c0d02258:	7781      	strb	r1, [r0, #30]
c0d0225a:	2500      	movs	r5, #0
c0d0225c:	9e01      	ldr	r6, [sp, #4]
c0d0225e:	9804      	ldr	r0, [sp, #16]
c0d02260:	9903      	ldr	r1, [sp, #12]
    for (i = 0;; i++) {
c0d02262:	1c40      	adds	r0, r0, #1
c0d02264:	9004      	str	r0, [sp, #16]
        selectors = PIC(INTERNAL_ETH_PLUGINS[i].selectors);
c0d02266:	b2c4      	uxtb	r4, r0
c0d02268:	4361      	muls	r1, r4
c0d0226a:	1870      	adds	r0, r6, r1
c0d0226c:	6840      	ldr	r0, [r0, #4]
c0d0226e:	f002 fbb1 	bl	c0d049d4 <pic>
c0d02272:	4607      	mov	r7, r0
        if (selectors == NULL) {
c0d02274:	2800      	cmp	r0, #0
c0d02276:	d1b0      	bne.n	c0d021da <eth_plugin_perform_init+0x22>
            }
        }
    }

    // Do not handle a plugin if running in swap mode
    if (called_from_swap && (contractAddress != NULL)) {
c0d02278:	2d00      	cmp	r5, #0
c0d0227a:	d006      	beq.n	c0d0228a <eth_plugin_perform_init+0xd2>
c0d0227c:	480c      	ldr	r0, [pc, #48]	; (c0d022b0 <eth_plugin_perform_init+0xf8>)
c0d0227e:	7800      	ldrb	r0, [r0, #0]
c0d02280:	2800      	cmp	r0, #0
c0d02282:	d002      	beq.n	c0d0228a <eth_plugin_perform_init+0xd2>
c0d02284:	2000      	movs	r0, #0
c0d02286:	e00f      	b.n	c0d022a8 <eth_plugin_perform_init+0xf0>
c0d02288:	2500      	movs	r5, #0
c0d0228a:	21ff      	movs	r1, #255	; 0xff
c0d0228c:	3102      	adds	r1, #2
        if (contractAddress != NULL) {
            PRINTF("Trying address %.*H\n", 20, contractAddress);
        } else {
            PRINTF("Trying alias %s\n", dataContext.tokenContext.pluginName);
        }
        int status = eth_plugin_call(contractAddress, ETH_PLUGIN_INIT_CONTRACT, (void *) init);
c0d0228e:	4628      	mov	r0, r5
c0d02290:	9a06      	ldr	r2, [sp, #24]
c0d02292:	f000 f811 	bl	c0d022b8 <eth_plugin_call>
        if (!status) {
c0d02296:	2800      	cmp	r0, #0
c0d02298:	d006      	beq.n	c0d022a8 <eth_plugin_perform_init+0xf0>
c0d0229a:	2802      	cmp	r0, #2
c0d0229c:	d0f4      	beq.n	c0d02288 <eth_plugin_perform_init+0xd0>
c0d0229e:	2801      	cmp	r0, #1
c0d022a0:	d1f3      	bne.n	c0d0228a <eth_plugin_perform_init+0xd2>
c0d022a2:	2001      	movs	r0, #1
        if (status == ETH_PLUGIN_RESULT_OK_ALIAS) {
            contractAddress = NULL;
        }
    }
    PRINTF("eth_plugin_init ok %s\n", dataContext.tokenContext.pluginName);
    dataContext.tokenContext.pluginAvailable = 1;
c0d022a4:	4901      	ldr	r1, [pc, #4]	; (c0d022ac <eth_plugin_perform_init+0xf4>)
c0d022a6:	7788      	strb	r0, [r1, #30]
    return 1;
}
c0d022a8:	b007      	add	sp, #28
c0d022aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d022ac:	20001b40 	.word	0x20001b40
c0d022b0:	2000189c 	.word	0x2000189c
c0d022b4:	00007cb0 	.word	0x00007cb0

c0d022b8 <eth_plugin_call>:

int eth_plugin_call(uint8_t *contractAddress, int method, void *parameter) {
c0d022b8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d022ba:	b09f      	sub	sp, #124	; 0x7c
c0d022bc:	4615      	mov	r5, r2
c0d022be:	460e      	mov	r6, r1
c0d022c0:	4607      	mov	r7, r0
    char *alias;
    uint8_t i;
    uint8_t internalPlugin = 0;

    pluginRW.sha3 = &global_sha3;
    pluginRO.txContent = &tmpContent.txContent;
c0d022c2:	486f      	ldr	r0, [pc, #444]	; (c0d02480 <eth_plugin_call+0x1c8>)
c0d022c4:	901d      	str	r0, [sp, #116]	; 0x74
    pluginRW.sha3 = &global_sha3;
c0d022c6:	486f      	ldr	r0, [pc, #444]	; (c0d02484 <eth_plugin_call+0x1cc>)
c0d022c8:	901e      	str	r0, [sp, #120]	; 0x78

    if (contractAddress == NULL) {
c0d022ca:	2f00      	cmp	r7, #0
c0d022cc:	d006      	beq.n	c0d022dc <eth_plugin_call+0x24>
c0d022ce:	ac15      	add	r4, sp, #84	; 0x54
c0d022d0:	2214      	movs	r2, #20
            PRINTF("Cached plugin call but no plugin available\n");
            return 0;
        }
        alias = dataContext.tokenContext.pluginName;
    } else {
        Base64encode(tmp, (char *) contractAddress, 20);
c0d022d2:	4620      	mov	r0, r4
c0d022d4:	4639      	mov	r1, r7
c0d022d6:	f7fd feb1 	bl	c0d0003c <Base64encode>
c0d022da:	e004      	b.n	c0d022e6 <eth_plugin_call+0x2e>
        if (!dataContext.tokenContext.pluginAvailable) {
c0d022dc:	4c6a      	ldr	r4, [pc, #424]	; (c0d02488 <eth_plugin_call+0x1d0>)
c0d022de:	7fa0      	ldrb	r0, [r4, #30]
c0d022e0:	2800      	cmp	r0, #0
c0d022e2:	d100      	bne.n	c0d022e6 <eth_plugin_call+0x2e>
c0d022e4:	e0a3      	b.n	c0d0242e <eth_plugin_call+0x176>
c0d022e6:	21ff      	movs	r1, #255	; 0xff
c0d022e8:	460b      	mov	r3, r1
c0d022ea:	3304      	adds	r3, #4
c0d022ec:	2200      	movs	r2, #0
        alias = tmp;
    }

    // Prepare the call

    switch (method) {
c0d022ee:	429e      	cmp	r6, r3
c0d022f0:	dc0b      	bgt.n	c0d0230a <eth_plugin_call+0x52>
c0d022f2:	4608      	mov	r0, r1
c0d022f4:	3002      	adds	r0, #2
c0d022f6:	4286      	cmp	r6, r0
c0d022f8:	d100      	bne.n	c0d022fc <eth_plugin_call+0x44>
c0d022fa:	e09a      	b.n	c0d02432 <eth_plugin_call+0x17a>
c0d022fc:	2081      	movs	r0, #129	; 0x81
c0d022fe:	0040      	lsls	r0, r0, #1
c0d02300:	4286      	cmp	r6, r0
c0d02302:	d00f      	beq.n	c0d02324 <eth_plugin_call+0x6c>
c0d02304:	429e      	cmp	r6, r3
c0d02306:	d00d      	beq.n	c0d02324 <eth_plugin_call+0x6c>
c0d02308:	e0b4      	b.n	c0d02474 <eth_plugin_call+0x1bc>
c0d0230a:	2041      	movs	r0, #65	; 0x41
c0d0230c:	0080      	lsls	r0, r0, #2
c0d0230e:	4286      	cmp	r6, r0
c0d02310:	d008      	beq.n	c0d02324 <eth_plugin_call+0x6c>
c0d02312:	4608      	mov	r0, r1
c0d02314:	3006      	adds	r0, #6
c0d02316:	4286      	cmp	r6, r0
c0d02318:	d004      	beq.n	c0d02324 <eth_plugin_call+0x6c>
c0d0231a:	2083      	movs	r0, #131	; 0x83
c0d0231c:	0040      	lsls	r0, r0, #1
c0d0231e:	4286      	cmp	r6, r0
c0d02320:	d000      	beq.n	c0d02324 <eth_plugin_call+0x6c>
c0d02322:	e0a7      	b.n	c0d02474 <eth_plugin_call+0x1bc>
c0d02324:	9300      	str	r3, [sp, #0]
c0d02326:	9101      	str	r1, [sp, #4]
c0d02328:	9702      	str	r7, [sp, #8]
c0d0232a:	9603      	str	r6, [sp, #12]
c0d0232c:	9205      	str	r2, [sp, #20]
c0d0232e:	a81d      	add	r0, sp, #116	; 0x74
c0d02330:	6068      	str	r0, [r5, #4]
c0d02332:	a81e      	add	r0, sp, #120	; 0x78
c0d02334:	6028      	str	r0, [r5, #0]
c0d02336:	4854      	ldr	r0, [pc, #336]	; (c0d02488 <eth_plugin_call+0x1d0>)
c0d02338:	3044      	adds	r0, #68	; 0x44
c0d0233a:	2108      	movs	r1, #8
c0d0233c:	9504      	str	r5, [sp, #16]
c0d0233e:	5068      	str	r0, [r5, r1]
    }

    // Perform the call

    for (i = 0;; i++) {
        if (INTERNAL_ETH_PLUGINS[i].alias[0] == 0) {
c0d02340:	4f52      	ldr	r7, [pc, #328]	; (c0d0248c <eth_plugin_call+0x1d4>)
c0d02342:	447f      	add	r7, pc
c0d02344:	7a78      	ldrb	r0, [r7, #9]
c0d02346:	2800      	cmp	r0, #0
c0d02348:	d016      	beq.n	c0d02378 <eth_plugin_call+0xc0>
            break;
        }
        if (strcmp(alias, INTERNAL_ETH_PLUGINS[i].alias) == 0) {
c0d0234a:	4639      	mov	r1, r7
c0d0234c:	3109      	adds	r1, #9
c0d0234e:	4620      	mov	r0, r4
c0d02350:	f007 fac4 	bl	c0d098dc <strcmp>
c0d02354:	2800      	cmp	r0, #0
c0d02356:	d022      	beq.n	c0d0239e <eth_plugin_call+0xe6>
c0d02358:	2601      	movs	r6, #1
        if (INTERNAL_ETH_PLUGINS[i].alias[0] == 0) {
c0d0235a:	b2f5      	uxtb	r5, r6
c0d0235c:	2014      	movs	r0, #20
c0d0235e:	4368      	muls	r0, r5
c0d02360:	1839      	adds	r1, r7, r0
c0d02362:	7a48      	ldrb	r0, [r1, #9]
c0d02364:	2800      	cmp	r0, #0
c0d02366:	d007      	beq.n	c0d02378 <eth_plugin_call+0xc0>
c0d02368:	3109      	adds	r1, #9
        if (strcmp(alias, INTERNAL_ETH_PLUGINS[i].alias) == 0) {
c0d0236a:	4620      	mov	r0, r4
c0d0236c:	f007 fab6 	bl	c0d098dc <strcmp>
    for (i = 0;; i++) {
c0d02370:	1c76      	adds	r6, r6, #1
        if (strcmp(alias, INTERNAL_ETH_PLUGINS[i].alias) == 0) {
c0d02372:	2800      	cmp	r0, #0
c0d02374:	d1f1      	bne.n	c0d0235a <eth_plugin_call+0xa2>
c0d02376:	e013      	b.n	c0d023a0 <eth_plugin_call+0xe8>
c0d02378:	9d04      	ldr	r5, [sp, #16]

    if (!internalPlugin) {
        uint32_t params[3];
        params[0] = (uint32_t) alias;
        params[1] = method;
        params[2] = (uint32_t) parameter;
c0d0237a:	9514      	str	r5, [sp, #80]	; 0x50
c0d0237c:	9e03      	ldr	r6, [sp, #12]
        params[1] = method;
c0d0237e:	9613      	str	r6, [sp, #76]	; 0x4c
        params[0] = (uint32_t) alias;
c0d02380:	9412      	str	r4, [sp, #72]	; 0x48
c0d02382:	af06      	add	r7, sp, #24
        BEGIN_TRY {
            TRY {
c0d02384:	4638      	mov	r0, r7
c0d02386:	f007 fa69 	bl	c0d0985c <setjmp>
c0d0238a:	85b8      	strh	r0, [r7, #44]	; 0x2c
c0d0238c:	0400      	lsls	r0, r0, #16
c0d0238e:	d016      	beq.n	c0d023be <eth_plugin_call+0x106>
c0d02390:	a806      	add	r0, sp, #24
c0d02392:	2100      	movs	r1, #0
                os_lib_call(params);
            }
            CATCH_OTHER(e) {
c0d02394:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d02396:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d02398:	f003 fbe0 	bl	c0d05b5c <try_context_set>
c0d0239c:	e016      	b.n	c0d023cc <eth_plugin_call+0x114>
c0d0239e:	2500      	movs	r5, #0
c0d023a0:	2014      	movs	r0, #20
            ((PluginCall) PIC(INTERNAL_ETH_PLUGINS[i].impl))(method, parameter);
c0d023a2:	4368      	muls	r0, r5
c0d023a4:	1838      	adds	r0, r7, r0
c0d023a6:	6900      	ldr	r0, [r0, #16]
c0d023a8:	f002 fb14 	bl	c0d049d4 <pic>
c0d023ac:	4602      	mov	r2, r0
c0d023ae:	9e03      	ldr	r6, [sp, #12]
c0d023b0:	4630      	mov	r0, r6
c0d023b2:	9d04      	ldr	r5, [sp, #16]
c0d023b4:	4629      	mov	r1, r5
c0d023b6:	4790      	blx	r2
c0d023b8:	9a05      	ldr	r2, [sp, #20]
c0d023ba:	9f02      	ldr	r7, [sp, #8]
c0d023bc:	e014      	b.n	c0d023e8 <eth_plugin_call+0x130>
c0d023be:	a806      	add	r0, sp, #24
            TRY {
c0d023c0:	f003 fbcc 	bl	c0d05b5c <try_context_set>
c0d023c4:	9010      	str	r0, [sp, #64]	; 0x40
c0d023c6:	a812      	add	r0, sp, #72	; 0x48
                os_lib_call(params);
c0d023c8:	f003 fb58 	bl	c0d05a7c <os_lib_call>
c0d023cc:	9f02      	ldr	r7, [sp, #8]
                PRINTF("Plugin call exception for %s\n", alias);
            }
            FINALLY {
c0d023ce:	f003 fbb9 	bl	c0d05b44 <try_context_get>
c0d023d2:	a906      	add	r1, sp, #24
c0d023d4:	4288      	cmp	r0, r1
c0d023d6:	d102      	bne.n	c0d023de <eth_plugin_call+0x126>
c0d023d8:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d023da:	f003 fbbf 	bl	c0d05b5c <try_context_set>
c0d023de:	a806      	add	r0, sp, #24
            }
        }
        END_TRY;
c0d023e0:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d023e2:	2800      	cmp	r0, #0
c0d023e4:	d149      	bne.n	c0d0247a <eth_plugin_call+0x1c2>
c0d023e6:	9a05      	ldr	r2, [sp, #20]
c0d023e8:	9901      	ldr	r1, [sp, #4]
c0d023ea:	9b00      	ldr	r3, [sp, #0]
    }

    // Check the call result

    switch (method) {
c0d023ec:	429e      	cmp	r6, r3
c0d023ee:	dc0a      	bgt.n	c0d02406 <eth_plugin_call+0x14e>
c0d023f0:	3102      	adds	r1, #2
c0d023f2:	428e      	cmp	r6, r1
c0d023f4:	d02e      	beq.n	c0d02454 <eth_plugin_call+0x19c>
c0d023f6:	2081      	movs	r0, #129	; 0x81
c0d023f8:	0040      	lsls	r0, r0, #1
c0d023fa:	4286      	cmp	r6, r0
c0d023fc:	d011      	beq.n	c0d02422 <eth_plugin_call+0x16a>
c0d023fe:	429e      	cmp	r6, r3
c0d02400:	d138      	bne.n	c0d02474 <eth_plugin_call+0x1bc>
                default:
                    return 0;
            }
            break;
        case ETH_PLUGIN_FINALIZE:
            switch (((ethPluginFinalize_t *) parameter)->result) {
c0d02402:	7fa8      	ldrb	r0, [r5, #30]
c0d02404:	e00e      	b.n	c0d02424 <eth_plugin_call+0x16c>
c0d02406:	2041      	movs	r0, #65	; 0x41
c0d02408:	0080      	lsls	r0, r0, #2
    switch (method) {
c0d0240a:	4286      	cmp	r6, r0
c0d0240c:	d009      	beq.n	c0d02422 <eth_plugin_call+0x16a>
c0d0240e:	3106      	adds	r1, #6
c0d02410:	428e      	cmp	r6, r1
c0d02412:	d02b      	beq.n	c0d0246c <eth_plugin_call+0x1b4>
c0d02414:	2083      	movs	r0, #131	; 0x83
c0d02416:	0040      	lsls	r0, r0, #1
c0d02418:	4286      	cmp	r6, r0
c0d0241a:	d12b      	bne.n	c0d02474 <eth_plugin_call+0x1bc>
c0d0241c:	2020      	movs	r0, #32
            if (((ethQueryContractID_t *) parameter)->result != ETH_PLUGIN_RESULT_OK) {
                return 0;
            }
            break;
        case ETH_PLUGIN_QUERY_CONTRACT_UI:
            if (((ethQueryContractUI_t *) parameter)->result != ETH_PLUGIN_RESULT_OK) {
c0d0241e:	5c28      	ldrb	r0, [r5, r0]
c0d02420:	e025      	b.n	c0d0246e <eth_plugin_call+0x1b6>
c0d02422:	7d28      	ldrb	r0, [r5, #20]
c0d02424:	2102      	movs	r1, #2
c0d02426:	4301      	orrs	r1, r0
c0d02428:	2903      	cmp	r1, #3
c0d0242a:	d022      	beq.n	c0d02472 <eth_plugin_call+0x1ba>
c0d0242c:	e022      	b.n	c0d02474 <eth_plugin_call+0x1bc>
c0d0242e:	2200      	movs	r2, #0
c0d02430:	e020      	b.n	c0d02474 <eth_plugin_call+0x1bc>
c0d02432:	9300      	str	r3, [sp, #0]
c0d02434:	9101      	str	r1, [sp, #4]
c0d02436:	9702      	str	r7, [sp, #8]
c0d02438:	9603      	str	r6, [sp, #12]
c0d0243a:	9205      	str	r2, [sp, #20]
c0d0243c:	2060      	movs	r0, #96	; 0x60
            ((ethPluginInitContract_t *) parameter)->pluginContextLength =
c0d0243e:	60e8      	str	r0, [r5, #12]
c0d02440:	a81d      	add	r0, sp, #116	; 0x74
            ((ethPluginInitContract_t *) parameter)->pluginSharedRO = &pluginRO;
c0d02442:	6068      	str	r0, [r5, #4]
c0d02444:	a81e      	add	r0, sp, #120	; 0x78
            ((ethPluginInitContract_t *) parameter)->pluginSharedRW = &pluginRW;
c0d02446:	6028      	str	r0, [r5, #0]
            ((ethPluginInitContract_t *) parameter)->pluginContext =
c0d02448:	480f      	ldr	r0, [pc, #60]	; (c0d02488 <eth_plugin_call+0x1d0>)
c0d0244a:	4601      	mov	r1, r0
c0d0244c:	3144      	adds	r1, #68	; 0x44
c0d0244e:	60a9      	str	r1, [r5, #8]
c0d02450:	2118      	movs	r1, #24
c0d02452:	e773      	b.n	c0d0233c <eth_plugin_call+0x84>
            switch (((ethPluginInitContract_t *) parameter)->result) {
c0d02454:	7f28      	ldrb	r0, [r5, #28]
c0d02456:	2802      	cmp	r0, #2
c0d02458:	d00b      	beq.n	c0d02472 <eth_plugin_call+0x1ba>
c0d0245a:	2801      	cmp	r0, #1
c0d0245c:	d10a      	bne.n	c0d02474 <eth_plugin_call+0x1bc>
                    if (contractAddress != NULL) {
c0d0245e:	2f00      	cmp	r7, #0
c0d02460:	d007      	beq.n	c0d02472 <eth_plugin_call+0x1ba>
                        strcpy(dataContext.tokenContext.pluginName, alias);
c0d02462:	4809      	ldr	r0, [pc, #36]	; (c0d02488 <eth_plugin_call+0x1d0>)
c0d02464:	4621      	mov	r1, r4
c0d02466:	f007 fa7d 	bl	c0d09964 <strcpy>
c0d0246a:	e002      	b.n	c0d02472 <eth_plugin_call+0x1ba>
            if (((ethQueryContractID_t *) parameter)->result != ETH_PLUGIN_RESULT_OK) {
c0d0246c:	7f28      	ldrb	r0, [r5, #28]
c0d0246e:	2801      	cmp	r0, #1
c0d02470:	d100      	bne.n	c0d02474 <eth_plugin_call+0x1bc>
c0d02472:	2201      	movs	r2, #1
        default:
            return 0;
    }

    return 1;
}
c0d02474:	4610      	mov	r0, r2
c0d02476:	b01f      	add	sp, #124	; 0x7c
c0d02478:	bdf0      	pop	{r4, r5, r6, r7, pc}
        END_TRY;
c0d0247a:	f001 fac2 	bl	c0d03a02 <os_longjmp>
c0d0247e:	46c0      	nop			; (mov r8, r8)
c0d02480:	200018dc 	.word	0x200018dc
c0d02484:	20001cb8 	.word	0x20001cb8
c0d02488:	20001b40 	.word	0x20001b40
c0d0248c:	00007b36 	.word	0x00007b36

c0d02490 <plugin_ui_get_id>:

} plugin_ui_state_t;

void computeFees(char *displayBuffer, uint32_t displayBufferSize);

void plugin_ui_get_id() {
c0d02490:	b510      	push	{r4, lr}
c0d02492:	b08a      	sub	sp, #40	; 0x28
c0d02494:	2028      	movs	r0, #40	; 0x28
    ethQueryContractID_t pluginQueryContractID;
    eth_plugin_prepare_query_contract_ID(&pluginQueryContractID,
c0d02496:	4669      	mov	r1, sp
c0d02498:	6008      	str	r0, [r1, #0]
c0d0249a:	490e      	ldr	r1, [pc, #56]	; (c0d024d4 <plugin_ui_get_id+0x44>)
c0d0249c:	460b      	mov	r3, r1
c0d0249e:	3364      	adds	r3, #100	; 0x64
c0d024a0:	ac02      	add	r4, sp, #8
c0d024a2:	2264      	movs	r2, #100	; 0x64
c0d024a4:	4620      	mov	r0, r4
c0d024a6:	f7ff fe64 	bl	c0d02172 <eth_plugin_prepare_query_contract_ID>
                                         sizeof(strings.tmp.tmp),
                                         strings.tmp.tmp2,
                                         sizeof(strings.tmp.tmp2));
    // Query the original contract for ID if it's not an internal alias
    if (!eth_plugin_call(
            (dataContext.tokenContext.pluginName[0] == '-' ? NULL
c0d024aa:	480c      	ldr	r0, [pc, #48]	; (c0d024dc <plugin_ui_get_id+0x4c>)
c0d024ac:	7800      	ldrb	r0, [r0, #0]
c0d024ae:	282d      	cmp	r0, #45	; 0x2d
c0d024b0:	d002      	beq.n	c0d024b8 <plugin_ui_get_id+0x28>
c0d024b2:	4809      	ldr	r0, [pc, #36]	; (c0d024d8 <plugin_ui_get_id+0x48>)
c0d024b4:	3063      	adds	r0, #99	; 0x63
c0d024b6:	e000      	b.n	c0d024ba <plugin_ui_get_id+0x2a>
c0d024b8:	2000      	movs	r0, #0
c0d024ba:	21ff      	movs	r1, #255	; 0xff
c0d024bc:	3106      	adds	r1, #6
    if (!eth_plugin_call(
c0d024be:	4622      	mov	r2, r4
c0d024c0:	f7ff fefa 	bl	c0d022b8 <eth_plugin_call>
c0d024c4:	2800      	cmp	r0, #0
c0d024c6:	d102      	bne.n	c0d024ce <plugin_ui_get_id+0x3e>
c0d024c8:	2000      	movs	r0, #0
                                                           : tmpContent.txContent.destination),
            ETH_PLUGIN_QUERY_CONTRACT_ID,
            (void *) &pluginQueryContractID)) {
        PRINTF("Plugin query contract ID call failed\n");
        io_seproxyhal_touch_tx_cancel(NULL);
c0d024ca:	f004 f9ab 	bl	c0d06824 <io_seproxyhal_touch_tx_cancel>
    }
}
c0d024ce:	b00a      	add	sp, #40	; 0x28
c0d024d0:	bd10      	pop	{r4, pc}
c0d024d2:	46c0      	nop			; (mov r8, r8)
c0d024d4:	20001c26 	.word	0x20001c26
c0d024d8:	200018dc 	.word	0x200018dc
c0d024dc:	20001b40 	.word	0x20001b40

c0d024e0 <plugin_ui_get_item>:

void plugin_ui_get_item() {
c0d024e0:	b510      	push	{r4, lr}
c0d024e2:	b08c      	sub	sp, #48	; 0x30
c0d024e4:	2042      	movs	r0, #66	; 0x42
    ethQueryContractUI_t pluginQueryContractUI;
    eth_plugin_prepare_query_contract_UI(&pluginQueryContractUI,
                                         dataContext.tokenContext.pluginUiCurrentItem,
c0d024e6:	490d      	ldr	r1, [pc, #52]	; (c0d0251c <plugin_ui_get_item+0x3c>)
c0d024e8:	5c09      	ldrb	r1, [r1, r0]
c0d024ea:	2028      	movs	r0, #40	; 0x28
    eth_plugin_prepare_query_contract_UI(&pluginQueryContractUI,
c0d024ec:	466b      	mov	r3, sp
c0d024ee:	6058      	str	r0, [r3, #4]
c0d024f0:	4a0b      	ldr	r2, [pc, #44]	; (c0d02520 <plugin_ui_get_item+0x40>)
c0d024f2:	4610      	mov	r0, r2
c0d024f4:	3064      	adds	r0, #100	; 0x64
c0d024f6:	6018      	str	r0, [r3, #0]
c0d024f8:	ac03      	add	r4, sp, #12
c0d024fa:	2364      	movs	r3, #100	; 0x64
c0d024fc:	4620      	mov	r0, r4
c0d024fe:	f7ff fe48 	bl	c0d02192 <eth_plugin_prepare_query_contract_UI>
c0d02502:	2083      	movs	r0, #131	; 0x83
c0d02504:	0041      	lsls	r1, r0, #1
c0d02506:	2000      	movs	r0, #0
                                         strings.tmp.tmp,
                                         sizeof(strings.tmp.tmp),
                                         strings.tmp.tmp2,
                                         sizeof(strings.tmp.tmp2));
    if (!eth_plugin_call(NULL, ETH_PLUGIN_QUERY_CONTRACT_UI, (void *) &pluginQueryContractUI)) {
c0d02508:	4622      	mov	r2, r4
c0d0250a:	f7ff fed5 	bl	c0d022b8 <eth_plugin_call>
c0d0250e:	2800      	cmp	r0, #0
c0d02510:	d102      	bne.n	c0d02518 <plugin_ui_get_item+0x38>
c0d02512:	2000      	movs	r0, #0
        PRINTF("Plugin query contract UI call failed\n");
        io_seproxyhal_touch_tx_cancel(NULL);
c0d02514:	f004 f986 	bl	c0d06824 <io_seproxyhal_touch_tx_cancel>
    }
}
c0d02518:	b00c      	add	sp, #48	; 0x30
c0d0251a:	bd10      	pop	{r4, pc}
c0d0251c:	20001b40 	.word	0x20001b40
c0d02520:	20001c26 	.word	0x20001c26

c0d02524 <display_next_plugin_item>:

void display_next_plugin_item(bool entering) {
c0d02524:	b510      	push	{r4, lr}
c0d02526:	2243      	movs	r2, #67	; 0x43
c0d02528:	491e      	ldr	r1, [pc, #120]	; (c0d025a4 <display_next_plugin_item+0x80>)
c0d0252a:	5c8b      	ldrb	r3, [r1, r2]
    if (entering) {
c0d0252c:	2800      	cmp	r0, #0
c0d0252e:	d006      	beq.n	c0d0253e <display_next_plugin_item+0x1a>
c0d02530:	2042      	movs	r0, #66	; 0x42
        if (dataContext.tokenContext.pluginUiState == PLUGIN_UI_OUTSIDE) {
c0d02532:	2b01      	cmp	r3, #1
c0d02534:	d10c      	bne.n	c0d02550 <display_next_plugin_item+0x2c>
c0d02536:	2300      	movs	r3, #0
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
            dataContext.tokenContext.pluginUiCurrentItem = 0;
c0d02538:	540b      	strb	r3, [r1, r0]
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
c0d0253a:	548b      	strb	r3, [r1, r2]
c0d0253c:	e00d      	b.n	c0d0255a <display_next_plugin_item+0x36>
                dataContext.tokenContext.pluginUiCurrentItem = 0;
                ux_flow_prev();
            }
        }
    } else {
        if (dataContext.tokenContext.pluginUiState == PLUGIN_UI_OUTSIDE) {
c0d0253e:	2b01      	cmp	r3, #1
c0d02540:	d10e      	bne.n	c0d02560 <display_next_plugin_item+0x3c>
c0d02542:	2000      	movs	r0, #0
            dataContext.tokenContext.pluginUiState = PLUGIN_UI_INSIDE;
c0d02544:	5488      	strb	r0, [r1, r2]
            plugin_ui_get_item();
c0d02546:	f7ff ffcb 	bl	c0d024e0 <plugin_ui_get_item>
            ux_flow_prev();
c0d0254a:	f006 fa5d 	bl	c0d08a08 <ux_flow_prev>
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
                ux_flow_next();
            }
        }
    }
}
c0d0254e:	bd10      	pop	{r4, pc}
            if (dataContext.tokenContext.pluginUiCurrentItem > 0) {
c0d02550:	5c0b      	ldrb	r3, [r1, r0]
c0d02552:	2b00      	cmp	r3, #0
c0d02554:	d01e      	beq.n	c0d02594 <display_next_plugin_item+0x70>
                dataContext.tokenContext.pluginUiCurrentItem--;
c0d02556:	1e5a      	subs	r2, r3, #1
c0d02558:	540a      	strb	r2, [r1, r0]
c0d0255a:	f7ff ffc1 	bl	c0d024e0 <plugin_ui_get_item>
c0d0255e:	e016      	b.n	c0d0258e <display_next_plugin_item+0x6a>
c0d02560:	2042      	movs	r0, #66	; 0x42
            if (dataContext.tokenContext.pluginUiCurrentItem <
c0d02562:	5c0b      	ldrb	r3, [r1, r0]
c0d02564:	2441      	movs	r4, #65	; 0x41
                dataContext.tokenContext.pluginUiMaxItems - 1) {
c0d02566:	5d0c      	ldrb	r4, [r1, r4]
c0d02568:	1e64      	subs	r4, r4, #1
            if (dataContext.tokenContext.pluginUiCurrentItem <
c0d0256a:	429c      	cmp	r4, r3
c0d0256c:	dd0d      	ble.n	c0d0258a <display_next_plugin_item+0x66>
                dataContext.tokenContext.pluginUiCurrentItem++;
c0d0256e:	1c5a      	adds	r2, r3, #1
c0d02570:	540a      	strb	r2, [r1, r0]
                plugin_ui_get_item();
c0d02572:	f7ff ffb5 	bl	c0d024e0 <plugin_ui_get_item>
                ux_flow_prev();
c0d02576:	f006 fa47 	bl	c0d08a08 <ux_flow_prev>
                G_ux.layout_paging.current = 0;
c0d0257a:	480b      	ldr	r0, [pc, #44]	; (c0d025a8 <display_next_plugin_item+0x84>)
c0d0257c:	2100      	movs	r1, #0
c0d0257e:	6041      	str	r1, [r0, #4]
                ux_layout_paging_redisplay(G_ux.stack_count - 1);
c0d02580:	7800      	ldrb	r0, [r0, #0]
c0d02582:	1e40      	subs	r0, r0, #1
c0d02584:	f006 fc8e 	bl	c0d08ea4 <ux_layout_paging_redisplay>
}
c0d02588:	bd10      	pop	{r4, pc}
c0d0258a:	2001      	movs	r0, #1
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0d0258c:	5488      	strb	r0, [r1, r2]
c0d0258e:	f006 fa35 	bl	c0d089fc <ux_flow_next>
}
c0d02592:	bd10      	pop	{r4, pc}
c0d02594:	2300      	movs	r3, #0
                dataContext.tokenContext.pluginUiCurrentItem = 0;
c0d02596:	540b      	strb	r3, [r1, r0]
c0d02598:	2001      	movs	r0, #1
                dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0d0259a:	5488      	strb	r0, [r1, r2]
                ux_flow_prev();
c0d0259c:	f006 fa34 	bl	c0d08a08 <ux_flow_prev>
}
c0d025a0:	bd10      	pop	{r4, pc}
c0d025a2:	46c0      	nop			; (mov r8, r8)
c0d025a4:	20001b40 	.word	0x20001b40
c0d025a8:	2000195c 	.word	0x2000195c

c0d025ac <ux_plugin_approval_id_step_init>:
      &C_icon_eye,
      "Review",
      "contract call",
    });

UX_STEP_NOCB_INIT(
c0d025ac:	b510      	push	{r4, lr}
c0d025ae:	4604      	mov	r4, r0
c0d025b0:	f7ff ff6e 	bl	c0d02490 <plugin_ui_get_id>
c0d025b4:	4620      	mov	r0, r4
c0d025b6:	f006 fd4b 	bl	c0d09050 <ux_layout_paging_init>
c0d025ba:	bd10      	pop	{r4, pc}

c0d025bc <ux_plugin_approval_before_step_init>:
  {
    .title = strings.tmp.tmp,
    .text = strings.tmp.tmp2
  });

UX_STEP_INIT(
c0d025bc:	b580      	push	{r7, lr}
c0d025be:	2001      	movs	r0, #1
c0d025c0:	f7ff ffb0 	bl	c0d02524 <display_next_plugin_item>
c0d025c4:	bd80      	pop	{r7, pc}

c0d025c6 <ux_plugin_approval_after_step_init>:
  {
    .title = strings.tmp.tmp,
    .text = strings.tmp.tmp2
  });

UX_STEP_INIT(
c0d025c6:	b580      	push	{r7, lr}
c0d025c8:	2000      	movs	r0, #0
c0d025ca:	f7ff ffab 	bl	c0d02524 <display_next_plugin_item>
c0d025ce:	bd80      	pop	{r7, pc}

c0d025d0 <ux_plugin_approval_fees_step_init>:
  NULL,
  {
    display_next_plugin_item(false);
  });

UX_STEP_NOCB_INIT(
c0d025d0:	b510      	push	{r4, lr}
c0d025d2:	4604      	mov	r4, r0
    computeFees(strings.common.maxFee, sizeof(strings.common.maxFee));
c0d025d4:	4804      	ldr	r0, [pc, #16]	; (c0d025e8 <ux_plugin_approval_fees_step_init+0x18>)
c0d025d6:	305d      	adds	r0, #93	; 0x5d
c0d025d8:	2132      	movs	r1, #50	; 0x32
c0d025da:	f000 faf5 	bl	c0d02bc8 <computeFees>
UX_STEP_NOCB_INIT(
c0d025de:	4620      	mov	r0, r4
c0d025e0:	f006 fd36 	bl	c0d09050 <ux_layout_paging_init>
c0d025e4:	bd10      	pop	{r4, pc}
c0d025e6:	46c0      	nop			; (mov r8, r8)
c0d025e8:	20001c26 	.word	0x20001c26

c0d025ec <ux_plugin_approval_ok_step_validateinit>:
  {
    .title = "Max Fees",
    .text = strings.common.maxFee
  });

UX_FLOW_DEF_VALID(
c0d025ec:	b580      	push	{r7, lr}
c0d025ee:	2000      	movs	r0, #0
c0d025f0:	f004 f8a4 	bl	c0d0673c <io_seproxyhal_touch_tx_ok>
c0d025f4:	bd80      	pop	{r7, pc}

c0d025f6 <ux_plugin_approval_cancel_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_FLOW_DEF_VALID(
c0d025f6:	b580      	push	{r7, lr}
c0d025f8:	2000      	movs	r0, #0
c0d025fa:	f004 f913 	bl	c0d06824 <io_seproxyhal_touch_tx_cancel>
c0d025fe:	bd80      	pop	{r7, pc}

c0d02600 <plugin_ui_start>:
        &ux_plugin_approval_after_step,
        &ux_plugin_approval_fees_step,
        &ux_plugin_approval_ok_step,
        &ux_plugin_approval_cancel_step);

void plugin_ui_start() {
c0d02600:	b580      	push	{r7, lr}
c0d02602:	2142      	movs	r1, #66	; 0x42
    dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0d02604:	4a05      	ldr	r2, [pc, #20]	; (c0d0261c <plugin_ui_start+0x1c>)
c0d02606:	2000      	movs	r0, #0
    dataContext.tokenContext.pluginUiCurrentItem = 0;
c0d02608:	5450      	strb	r0, [r2, r1]
c0d0260a:	2143      	movs	r1, #67	; 0x43
c0d0260c:	2301      	movs	r3, #1
    dataContext.tokenContext.pluginUiState = PLUGIN_UI_OUTSIDE;
c0d0260e:	5453      	strb	r3, [r2, r1]
    ux_flow_init(0, ux_plugin_approval_flow, NULL);
c0d02610:	4903      	ldr	r1, [pc, #12]	; (c0d02620 <plugin_ui_start+0x20>)
c0d02612:	4479      	add	r1, pc
c0d02614:	4602      	mov	r2, r0
c0d02616:	f006 fabd 	bl	c0d08b94 <ux_flow_init>
}
c0d0261a:	bd80      	pop	{r7, pc}
c0d0261c:	20001b40 	.word	0x20001b40
c0d02620:	000079ea 	.word	0x000079ea

c0d02624 <handle_check_address>:
static int os_strcmp(const char* s1, const char* s2) {
    size_t size = strlen(s1) + 1;
    return memcmp(s1, s2, size);
}

int handle_check_address(check_address_parameters_t* params, chain_config_t* chain_config) {
c0d02624:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02626:	b0ff      	sub	sp, #508	; 0x1fc
c0d02628:	b090      	sub	sp, #64	; 0x40
c0d0262a:	4604      	mov	r4, r0
    PRINTF("Params on the address %d\n", (unsigned int) params);
    PRINTF("Address to check %s\n", params->address_to_check);
    PRINTF("Inside handle_check_address\n");
    if (params->address_to_check == 0) {
c0d0262c:	6900      	ldr	r0, [r0, #16]
c0d0262e:	2800      	cmp	r0, #0
c0d02630:	d061      	beq.n	c0d026f6 <handle_check_address+0xd2>
        PRINTF("Address to check == 0\n");
        return 0;
    }

    uint8_t i;
    uint8_t* bip32_path_ptr = params->address_parameters;
c0d02632:	68a6      	ldr	r6, [r4, #8]
    uint8_t bip32PathLength = *(bip32_path_ptr++);
c0d02634:	7832      	ldrb	r2, [r6, #0]
    union group2 {
        uint8_t privateKeyData[32];
        cx_ecfp_public_key_t publicKey;
    } locals_union2;

    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH) ||
c0d02636:	1e50      	subs	r0, r2, #1
c0d02638:	b2c3      	uxtb	r3, r0
c0d0263a:	2000      	movs	r0, #0
c0d0263c:	2b09      	cmp	r3, #9
c0d0263e:	d85b      	bhi.n	c0d026f8 <handle_check_address+0xd4>
        (bip32PathLength * 4 != params->address_parameters_length - 1)) {
c0d02640:	0093      	lsls	r3, r2, #2
c0d02642:	7b25      	ldrb	r5, [r4, #12]
c0d02644:	1e6d      	subs	r5, r5, #1
    if ((bip32PathLength < 0x01) || (bip32PathLength > MAX_BIP32_PATH) ||
c0d02646:	429d      	cmp	r5, r3
c0d02648:	d156      	bne.n	c0d026f8 <handle_check_address+0xd4>
c0d0264a:	9103      	str	r1, [sp, #12]
    uint8_t bip32PathLength = *(bip32_path_ptr++);
c0d0264c:	1c70      	adds	r0, r6, #1
c0d0264e:	a917      	add	r1, sp, #92	; 0x5c
c0d02650:	4613      	mov	r3, r2
        PRINTF("Invalid path\n");
        return 0;
    }
    for (i = 0; i < bip32PathLength; i++) {
        locals_union1.bip32Path[i] = U4BE(bip32_path_ptr, 0);
c0d02652:	78c5      	ldrb	r5, [r0, #3]
c0d02654:	7886      	ldrb	r6, [r0, #2]
c0d02656:	0236      	lsls	r6, r6, #8
c0d02658:	1975      	adds	r5, r6, r5
c0d0265a:	7846      	ldrb	r6, [r0, #1]
c0d0265c:	7807      	ldrb	r7, [r0, #0]
c0d0265e:	023f      	lsls	r7, r7, #8
c0d02660:	19be      	adds	r6, r7, r6
c0d02662:	0436      	lsls	r6, r6, #16
c0d02664:	19ad      	adds	r5, r5, r6
c0d02666:	c120      	stmia	r1!, {r5}
    for (i = 0; i < bip32PathLength; i++) {
c0d02668:	1d00      	adds	r0, r0, #4
c0d0266a:	1e5b      	subs	r3, r3, #1
c0d0266c:	d1f1      	bne.n	c0d02652 <handle_check_address+0x2e>
c0d0266e:	2000      	movs	r0, #0
        bip32_path_ptr += 4;
    }
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d02670:	4669      	mov	r1, sp
c0d02672:	6008      	str	r0, [r1, #0]
c0d02674:	2521      	movs	r5, #33	; 0x21
c0d02676:	ae17      	add	r6, sp, #92	; 0x5c
c0d02678:	af04      	add	r7, sp, #16
c0d0267a:	4628      	mov	r0, r5
c0d0267c:	4631      	mov	r1, r6
c0d0267e:	463b      	mov	r3, r7
c0d02680:	f003 f9c6 	bl	c0d05a10 <os_perso_derive_node_bip32>
c0d02684:	2134      	movs	r1, #52	; 0x34
                               locals_union1.bip32Path,
                               bip32PathLength,
                               locals_union2.privateKeyData,
                               NULL);
    ZERO(locals_union1);
c0d02686:	9102      	str	r1, [sp, #8]
c0d02688:	4630      	mov	r0, r6
c0d0268a:	f006 ffad 	bl	c0d095e8 <__aeabi_memclr>
c0d0268e:	2220      	movs	r2, #32
    cx_ecfp_init_private_key(CX_CURVE_256K1,
c0d02690:	4628      	mov	r0, r5
c0d02692:	4639      	mov	r1, r7
c0d02694:	4633      	mov	r3, r6
c0d02696:	f003 f927 	bl	c0d058e8 <cx_ecfp_init_private_key>
c0d0269a:	214c      	movs	r1, #76	; 0x4c
                             locals_union2.privateKeyData,
                             32,
                             &locals_union1.privateKey);
    ZERO(locals_union2);
c0d0269c:	9101      	str	r1, [sp, #4]
c0d0269e:	4638      	mov	r0, r7
c0d026a0:	f006 ffa2 	bl	c0d095e8 <__aeabi_memclr>
c0d026a4:	2301      	movs	r3, #1
    cx_ecfp_generate_pair(CX_CURVE_256K1, &locals_union2.publicKey, &locals_union1.privateKey, 1);
c0d026a6:	4628      	mov	r0, r5
c0d026a8:	4639      	mov	r1, r7
c0d026aa:	4632      	mov	r2, r6
c0d026ac:	f003 f92c 	bl	c0d05908 <cx_ecfp_generate_pair>
    ZERO(locals_union1);
c0d026b0:	4630      	mov	r0, r6
c0d026b2:	9902      	ldr	r1, [sp, #8]
c0d026b4:	f006 ff98 	bl	c0d095e8 <__aeabi_memclr>
c0d026b8:	aa24      	add	r2, sp, #144	; 0x90
    getEthAddressStringFromKey(&locals_union2.publicKey,
c0d026ba:	4638      	mov	r0, r7
c0d026bc:	4631      	mov	r1, r6
c0d026be:	9b03      	ldr	r3, [sp, #12]
c0d026c0:	f7ff fc38 	bl	c0d01f34 <getEthAddressStringFromKey>
                               (uint8_t*) locals_union1.address,
                               &local_sha3,
                               chain_config);
    ZERO(locals_union2);
c0d026c4:	4638      	mov	r0, r7
c0d026c6:	9901      	ldr	r1, [sp, #4]
c0d026c8:	f006 ff8e 	bl	c0d095e8 <__aeabi_memclr>

    uint8_t offset_0x = 0;
    if (memcmp(params->address_to_check, "0x", 2) == 0) {
c0d026cc:	6924      	ldr	r4, [r4, #16]
c0d026ce:	7820      	ldrb	r0, [r4, #0]
c0d026d0:	7861      	ldrb	r1, [r4, #1]
c0d026d2:	0209      	lsls	r1, r1, #8
c0d026d4:	1808      	adds	r0, r1, r0
c0d026d6:	490a      	ldr	r1, [pc, #40]	; (c0d02700 <handle_check_address+0xdc>)
        offset_0x = 2;
    }

    if (os_strcmp(locals_union1.address, params->address_to_check + offset_0x) != 0) {
c0d026d8:	4288      	cmp	r0, r1
c0d026da:	d100      	bne.n	c0d026de <handle_check_address+0xba>
c0d026dc:	1ca4      	adds	r4, r4, #2
    size_t size = strlen(s1) + 1;
c0d026de:	4630      	mov	r0, r6
c0d026e0:	f007 f948 	bl	c0d09974 <strlen>
c0d026e4:	1c42      	adds	r2, r0, #1
    return memcmp(s1, s2, size);
c0d026e6:	4630      	mov	r0, r6
c0d026e8:	4621      	mov	r1, r4
c0d026ea:	f006 ff97 	bl	c0d0961c <memcmp>
c0d026ee:	4601      	mov	r1, r0
    if (os_strcmp(locals_union1.address, params->address_to_check + offset_0x) != 0) {
c0d026f0:	4240      	negs	r0, r0
c0d026f2:	4148      	adcs	r0, r1
c0d026f4:	e000      	b.n	c0d026f8 <handle_check_address+0xd4>
c0d026f6:	2000      	movs	r0, #0
        PRINTF("Addresses don't match\n");
        return 0;
    }
    PRINTF("Addresses  match\n");
    return 1;
}
c0d026f8:	b07f      	add	sp, #508	; 0x1fc
c0d026fa:	b010      	add	sp, #64	; 0x40
c0d026fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d026fe:	46c0      	nop			; (mov r8, r8)
c0d02700:	00007830 	.word	0x00007830

c0d02704 <handle_get_printable_amount>:
#include "utils.h"
#include "uint256.h"
#include "string.h"
#include <stdint.h>

int handle_get_printable_amount(get_printable_amount_parameters_t* params, chain_config_t* config) {
c0d02704:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02706:	b089      	sub	sp, #36	; 0x24
c0d02708:	9104      	str	r1, [sp, #16]
c0d0270a:	4605      	mov	r5, r0
    uint8_t decimals;
    char ticker[MAX_TICKER_LEN];
    memset(params->printable_amount, 0, sizeof(params->printable_amount));
c0d0270c:	4604      	mov	r4, r0
c0d0270e:	340e      	adds	r4, #14
c0d02710:	261e      	movs	r6, #30
c0d02712:	4620      	mov	r0, r4
c0d02714:	4631      	mov	r1, r6
c0d02716:	f006 ff67 	bl	c0d095e8 <__aeabi_memclr>
    if (params->amount_length > 32) {
c0d0271a:	7b28      	ldrb	r0, [r5, #12]
c0d0271c:	2700      	movs	r7, #0
c0d0271e:	2820      	cmp	r0, #32
c0d02720:	d82c      	bhi.n	c0d0277c <handle_get_printable_amount+0x78>
c0d02722:	9603      	str	r6, [sp, #12]
c0d02724:	9e04      	ldr	r6, [sp, #16]
        PRINTF("Amount is too big, 32 bytes max but buffer has %u bytes", params->amount_length);
        return 0;
    }
    if (!parse_swap_config(params->coin_configuration,
                           params->coin_configuration_length,
c0d02726:	7929      	ldrb	r1, [r5, #4]
    if (!parse_swap_config(params->coin_configuration,
c0d02728:	6828      	ldr	r0, [r5, #0]
c0d0272a:	aa05      	add	r2, sp, #20
c0d0272c:	ab08      	add	r3, sp, #32
c0d0272e:	f006 f8b3 	bl	c0d08898 <parse_swap_config>
c0d02732:	2800      	cmp	r0, #0
c0d02734:	d022      	beq.n	c0d0277c <handle_get_printable_amount+0x78>
        PRINTF("Error while parsing config\n");
        return 0;
    }

    // If the amount is a fee, its value is nominated in ETH even if we're doing an ERC20 swap
    if (params->is_fee) {
c0d02736:	7b68      	ldrb	r0, [r5, #13]
c0d02738:	2800      	cmp	r0, #0
c0d0273a:	d013      	beq.n	c0d02764 <handle_get_printable_amount+0x60>
c0d0273c:	210a      	movs	r1, #10
c0d0273e:	4630      	mov	r0, r6
        uint8_t ticker_len = strnlen(config->coinName, sizeof(config->coinName));
c0d02740:	f007 f9b6 	bl	c0d09ab0 <strnlen>
        memcpy(ticker, config->coinName, ticker_len);
c0d02744:	b2c6      	uxtb	r6, r0
c0d02746:	af05      	add	r7, sp, #20
c0d02748:	4638      	mov	r0, r7
c0d0274a:	9904      	ldr	r1, [sp, #16]
c0d0274c:	4632      	mov	r2, r6
c0d0274e:	f006 ff51 	bl	c0d095f4 <__aeabi_memcpy>
c0d02752:	2020      	movs	r0, #32
        ticker[ticker_len] = ' ';
c0d02754:	55b8      	strb	r0, [r7, r6]
c0d02756:	19b8      	adds	r0, r7, r6
c0d02758:	2100      	movs	r1, #0
        ticker[ticker_len + 1] = '\0';
c0d0275a:	7041      	strb	r1, [r0, #1]
c0d0275c:	a808      	add	r0, sp, #32
c0d0275e:	2212      	movs	r2, #18
        decimals = WEI_TO_ETHER;
c0d02760:	7002      	strb	r2, [r0, #0]
c0d02762:	e001      	b.n	c0d02768 <handle_get_printable_amount+0x64>
c0d02764:	a808      	add	r0, sp, #32
    }

    amountToString(params->amount,
                   params->amount_length,
                   decimals,
c0d02766:	7802      	ldrb	r2, [r0, #0]
                   params->amount_length,
c0d02768:	7b29      	ldrb	r1, [r5, #12]
    amountToString(params->amount,
c0d0276a:	68a8      	ldr	r0, [r5, #8]
c0d0276c:	466b      	mov	r3, sp
c0d0276e:	601c      	str	r4, [r3, #0]
c0d02770:	9c03      	ldr	r4, [sp, #12]
c0d02772:	605c      	str	r4, [r3, #4]
c0d02774:	ab05      	add	r3, sp, #20
c0d02776:	f006 f84b 	bl	c0d08810 <amountToString>
c0d0277a:	2701      	movs	r7, #1
                   ticker,
                   params->printable_amount,
                   sizeof(params->printable_amount));
    return 1;
}
c0d0277c:	4638      	mov	r0, r7
c0d0277e:	b009      	add	sp, #36	; 0x24
c0d02780:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d02784 <copy_transaction_parameters>:
#include "ux.h"
#include "shared_context.h"
#include "utils.h"

bool copy_transaction_parameters(create_transaction_parameters_t* sign_transaction_params,
                                 chain_config_t* config) {
c0d02784:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02786:	b0ad      	sub	sp, #180	; 0xb4
c0d02788:	460d      	mov	r5, r1
c0d0278a:	4604      	mov	r4, r0
c0d0278c:	ae09      	add	r6, sp, #36	; 0x24
c0d0278e:	218f      	movs	r1, #143	; 0x8f
    // first copy parameters to stack, and then to global data.
    // We need this "trick" as the input data position can overlap with app-ethereum globals
    txStringProperties_t stack_data;
    memset(&stack_data, 0, sizeof(stack_data));
c0d02790:	4630      	mov	r0, r6
c0d02792:	f006 ff29 	bl	c0d095e8 <__aeabi_memclr>
    strncpy(stack_data.fullAddress,
            sign_transaction_params->destination_address,
c0d02796:	69a1      	ldr	r1, [r4, #24]
c0d02798:	222b      	movs	r2, #43	; 0x2b
    strncpy(stack_data.fullAddress,
c0d0279a:	4630      	mov	r0, r6
c0d0279c:	f007 f952 	bl	c0d09a44 <strncpy>
c0d027a0:	202a      	movs	r0, #42	; 0x2a
            sizeof(stack_data.fullAddress));
    if ((stack_data.fullAddress[sizeof(stack_data.fullAddress) - 1] != '\0') ||
c0d027a2:	5c31      	ldrb	r1, [r6, r0]
c0d027a4:	2000      	movs	r0, #0
c0d027a6:	2900      	cmp	r1, #0
c0d027a8:	d138      	bne.n	c0d0281c <copy_transaction_parameters+0x98>
        (sign_transaction_params->amount_length > 32) ||
c0d027aa:	7b21      	ldrb	r1, [r4, #12]
c0d027ac:	2920      	cmp	r1, #32
c0d027ae:	d835      	bhi.n	c0d0281c <copy_transaction_parameters+0x98>
        (sign_transaction_params->fee_amount_length > 8)) {
c0d027b0:	7d21      	ldrb	r1, [r4, #20]
    if ((stack_data.fullAddress[sizeof(stack_data.fullAddress) - 1] != '\0') ||
c0d027b2:	2908      	cmp	r1, #8
c0d027b4:	d832      	bhi.n	c0d0281c <copy_transaction_parameters+0x98>
    }

    uint8_t decimals;
    char ticker[MAX_TICKER_LEN];
    if (!parse_swap_config(sign_transaction_params->coin_configuration,
                           sign_transaction_params->coin_configuration_length,
c0d027b6:	7921      	ldrb	r1, [r4, #4]
    if (!parse_swap_config(sign_transaction_params->coin_configuration,
c0d027b8:	6820      	ldr	r0, [r4, #0]
c0d027ba:	aa05      	add	r2, sp, #20
c0d027bc:	ab08      	add	r3, sp, #32
c0d027be:	f006 f86b 	bl	c0d08898 <parse_swap_config>
c0d027c2:	2800      	cmp	r0, #0
c0d027c4:	d029      	beq.n	c0d0281a <copy_transaction_parameters+0x96>
c0d027c6:	a808      	add	r0, sp, #32
        PRINTF("Error while parsing config\n");
        return false;
    }
    amountToString(sign_transaction_params->amount,
                   sign_transaction_params->amount_length,
                   decimals,
c0d027c8:	9003      	str	r0, [sp, #12]
c0d027ca:	7802      	ldrb	r2, [r0, #0]
                   sign_transaction_params->amount_length,
c0d027cc:	7b21      	ldrb	r1, [r4, #12]
    amountToString(sign_transaction_params->amount,
c0d027ce:	68a0      	ldr	r0, [r4, #8]
c0d027d0:	2632      	movs	r6, #50	; 0x32
c0d027d2:	9604      	str	r6, [sp, #16]
c0d027d4:	466b      	mov	r3, sp
c0d027d6:	605e      	str	r6, [r3, #4]
c0d027d8:	ae09      	add	r6, sp, #36	; 0x24
                   ticker,
                   stack_data.fullAmount,
c0d027da:	4637      	mov	r7, r6
c0d027dc:	372b      	adds	r7, #43	; 0x2b
    amountToString(sign_transaction_params->amount,
c0d027de:	601f      	str	r7, [r3, #0]
c0d027e0:	af05      	add	r7, sp, #20
c0d027e2:	463b      	mov	r3, r7
c0d027e4:	f006 f814 	bl	c0d08810 <amountToString>
                   sizeof(stack_data.fullAmount));

    // If the amount is a fee, its value is nominated in ETH even if we're doing an ERC20 swap
    strcpy(ticker, config->coinName);
c0d027e8:	4638      	mov	r0, r7
c0d027ea:	4629      	mov	r1, r5
c0d027ec:	f007 f8ba 	bl	c0d09964 <strcpy>
c0d027f0:	2212      	movs	r2, #18
    decimals = WEI_TO_ETHER;
c0d027f2:	9803      	ldr	r0, [sp, #12]
c0d027f4:	7002      	strb	r2, [r0, #0]
    amountToString(sign_transaction_params->fee_amount,
                   sign_transaction_params->fee_amount_length,
c0d027f6:	7d21      	ldrb	r1, [r4, #20]
    amountToString(sign_transaction_params->fee_amount,
c0d027f8:	6920      	ldr	r0, [r4, #16]
c0d027fa:	466b      	mov	r3, sp
                   decimals,
                   ticker,
                   stack_data.maxFee,
c0d027fc:	4634      	mov	r4, r6
c0d027fe:	345d      	adds	r4, #93	; 0x5d
    amountToString(sign_transaction_params->fee_amount,
c0d02800:	601c      	str	r4, [r3, #0]
c0d02802:	9c04      	ldr	r4, [sp, #16]
c0d02804:	605c      	str	r4, [r3, #4]
c0d02806:	463b      	mov	r3, r7
c0d02808:	f006 f802 	bl	c0d08810 <amountToString>
                   sizeof(stack_data.maxFee));

    memcpy(&strings.common, &stack_data, sizeof(stack_data));
c0d0280c:	4804      	ldr	r0, [pc, #16]	; (c0d02820 <copy_transaction_parameters+0x9c>)
c0d0280e:	228f      	movs	r2, #143	; 0x8f
c0d02810:	4631      	mov	r1, r6
c0d02812:	f006 feef 	bl	c0d095f4 <__aeabi_memcpy>
c0d02816:	2001      	movs	r0, #1
c0d02818:	e000      	b.n	c0d0281c <copy_transaction_parameters+0x98>
c0d0281a:	2000      	movs	r0, #0
    return true;
}
c0d0281c:	b02d      	add	sp, #180	; 0xb4
c0d0281e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02820:	20001c26 	.word	0x20001c26

c0d02824 <handle_swap_sign_transaction>:

void handle_swap_sign_transaction(chain_config_t* config) {
c0d02824:	b5b0      	push	{r4, r5, r7, lr}
c0d02826:	b082      	sub	sp, #8
    chainConfig = config;
c0d02828:	4914      	ldr	r1, [pc, #80]	; (c0d0287c <handle_swap_sign_transaction+0x58>)
c0d0282a:	6008      	str	r0, [r1, #0]
    reset_app_context();
c0d0282c:	f000 fb88 	bl	c0d02f40 <reset_app_context>
    called_from_swap = true;
c0d02830:	4813      	ldr	r0, [pc, #76]	; (c0d02880 <handle_swap_sign_transaction+0x5c>)
c0d02832:	2401      	movs	r4, #1
c0d02834:	7004      	strb	r4, [r0, #0]
    io_seproxyhal_init();
c0d02836:	f001 fb1f 	bl	c0d03e78 <io_seproxyhal_init>

    if (N_storage.initialized != 0x01) {
c0d0283a:	4813      	ldr	r0, [pc, #76]	; (c0d02888 <handle_swap_sign_transaction+0x64>)
c0d0283c:	4478      	add	r0, pc
c0d0283e:	f002 f8c9 	bl	c0d049d4 <pic>
c0d02842:	7880      	ldrb	r0, [r0, #2]
c0d02844:	2801      	cmp	r0, #1
c0d02846:	d00b      	beq.n	c0d02860 <handle_swap_sign_transaction+0x3c>
c0d02848:	ad01      	add	r5, sp, #4
        internalStorage_t storage;
        storage.dataAllowed = 0x00;
        storage.contractDetails = 0x00;
        storage.initialized = 0x01;
c0d0284a:	70ac      	strb	r4, [r5, #2]
c0d0284c:	2000      	movs	r0, #0
        storage.dataAllowed = 0x00;
c0d0284e:	8028      	strh	r0, [r5, #0]
        nvm_write((void*) &N_storage, (void*) &storage, sizeof(internalStorage_t));
c0d02850:	480e      	ldr	r0, [pc, #56]	; (c0d0288c <handle_swap_sign_transaction+0x68>)
c0d02852:	4478      	add	r0, pc
c0d02854:	f002 f8be 	bl	c0d049d4 <pic>
c0d02858:	2203      	movs	r2, #3
c0d0285a:	4629      	mov	r1, r5
c0d0285c:	f002 ffb6 	bl	c0d057cc <nvm_write>
c0d02860:	0221      	lsls	r1, r4, #8
    }

    UX_INIT();
c0d02862:	4808      	ldr	r0, [pc, #32]	; (c0d02884 <handle_swap_sign_transaction+0x60>)
c0d02864:	f006 fec0 	bl	c0d095e8 <__aeabi_memclr>
c0d02868:	2000      	movs	r0, #0
    USB_power(0);
c0d0286a:	f005 fec1 	bl	c0d085f0 <USB_power>
    USB_power(1);
c0d0286e:	4620      	mov	r0, r4
c0d02870:	f005 febe 	bl	c0d085f0 <USB_power>
#endif  // TARGET_NANOX
#ifdef HAVE_BLE
    BLE_power(0, NULL);
    BLE_power(1, "Nano X");
#endif  // HAVE_BLE
    app_main();
c0d02874:	f000 fd2e 	bl	c0d032d4 <app_main>
c0d02878:	b002      	add	sp, #8
c0d0287a:	bdb0      	pop	{r4, r5, r7, pc}
c0d0287c:	20001b3c 	.word	0x20001b3c
c0d02880:	2000189c 	.word	0x2000189c
c0d02884:	2000195c 	.word	0x2000195c
c0d02888:	00008ec0 	.word	0x00008ec0
c0d0288c:	00008eaa 	.word	0x00008eaa

c0d02890 <set_result_get_publicKey>:
#include "shared_context.h"

uint32_t set_result_get_publicKey() {
c0d02890:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = 0;
    G_io_apdu_buffer[tx++] = 65;
c0d02892:	4c10      	ldr	r4, [pc, #64]	; (c0d028d4 <set_result_get_publicKey+0x44>)
c0d02894:	2241      	movs	r2, #65	; 0x41
c0d02896:	7022      	strb	r2, [r4, #0]
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.publicKey.W, 65);
c0d02898:	1c60      	adds	r0, r4, #1
c0d0289a:	4d0f      	ldr	r5, [pc, #60]	; (c0d028d8 <set_result_get_publicKey+0x48>)
c0d0289c:	4629      	mov	r1, r5
c0d0289e:	3108      	adds	r1, #8
c0d028a0:	f006 fea8 	bl	c0d095f4 <__aeabi_memcpy>
c0d028a4:	2042      	movs	r0, #66	; 0x42
c0d028a6:	2228      	movs	r2, #40	; 0x28
    tx += 65;
    G_io_apdu_buffer[tx++] = 40;
c0d028a8:	5422      	strb	r2, [r4, r0]
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.address, 40);
c0d028aa:	4620      	mov	r0, r4
c0d028ac:	3043      	adds	r0, #67	; 0x43
c0d028ae:	4629      	mov	r1, r5
c0d028b0:	314c      	adds	r1, #76	; 0x4c
c0d028b2:	f006 fe9f 	bl	c0d095f4 <__aeabi_memcpy>
c0d028b6:	2095      	movs	r0, #149	; 0x95
    tx += 40;
    if (tmpCtx.publicKeyContext.getChaincode) {
c0d028b8:	5c28      	ldrb	r0, [r5, r0]
c0d028ba:	2800      	cmp	r0, #0
c0d028bc:	d008      	beq.n	c0d028d0 <set_result_get_publicKey+0x40>
        memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.chainCode, 32);
c0d028be:	346b      	adds	r4, #107	; 0x6b
c0d028c0:	3575      	adds	r5, #117	; 0x75
c0d028c2:	2220      	movs	r2, #32
c0d028c4:	4620      	mov	r0, r4
c0d028c6:	4629      	mov	r1, r5
c0d028c8:	f006 fe94 	bl	c0d095f4 <__aeabi_memcpy>
c0d028cc:	208b      	movs	r0, #139	; 0x8b
        tx += 32;
    }
    return tx;
c0d028ce:	bdb0      	pop	{r4, r5, r7, pc}
c0d028d0:	206b      	movs	r0, #107	; 0x6b
c0d028d2:	bdb0      	pop	{r4, r5, r7, pc}
c0d028d4:	20001e61 	.word	0x20001e61
c0d028d8:	20001804 	.word	0x20001804

c0d028dc <splitBinaryParameterPart>:
#endif
#include "eth_plugin_handler.h"

#define ERR_SILENT_MODE_CHECK_FAILED 0x6001

uint32_t splitBinaryParameterPart(char *result, uint8_t *parameter) {
c0d028dc:	b510      	push	{r4, lr}
c0d028de:	2200      	movs	r2, #0
    uint32_t i;
    for (i = 0; i < 8; i++) {
        if (parameter[i] != 0x00) {
c0d028e0:	5c8b      	ldrb	r3, [r1, r2]
c0d028e2:	2b00      	cmp	r3, #0
c0d028e4:	d10a      	bne.n	c0d028fc <splitBinaryParameterPart+0x20>
    for (i = 0; i < 8; i++) {
c0d028e6:	1c52      	adds	r2, r2, #1
c0d028e8:	2a08      	cmp	r2, #8
c0d028ea:	d3f9      	bcc.n	c0d028e0 <splitBinaryParameterPart+0x4>
            break;
        }
    }
    if (i == 8) {
c0d028ec:	d106      	bne.n	c0d028fc <splitBinaryParameterPart+0x20>
c0d028ee:	2100      	movs	r1, #0
        result[0] = '0';
        result[1] = '0';
        result[2] = '\0';
c0d028f0:	7081      	strb	r1, [r0, #2]
c0d028f2:	2130      	movs	r1, #48	; 0x30
        result[1] = '0';
c0d028f4:	7041      	strb	r1, [r0, #1]
        result[0] = '0';
c0d028f6:	7001      	strb	r1, [r0, #0]
c0d028f8:	2002      	movs	r0, #2
        return 2;
    } else {
        array_hexstr(result, parameter + i, 8 - i);
        return ((8 - i) * 2);
    }
}
c0d028fa:	bd10      	pop	{r4, pc}
        array_hexstr(result, parameter + i, 8 - i);
c0d028fc:	1889      	adds	r1, r1, r2
c0d028fe:	2308      	movs	r3, #8
c0d02900:	1a9c      	subs	r4, r3, r2
c0d02902:	4622      	mov	r2, r4
c0d02904:	f005 ff20 	bl	c0d08748 <array_hexstr>
        return ((8 - i) * 2);
c0d02908:	0060      	lsls	r0, r4, #1
}
c0d0290a:	bd10      	pop	{r4, pc}

c0d0290c <customProcessor>:

customStatus_e customProcessor(txContext_t *context) {
c0d0290c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0290e:	b08b      	sub	sp, #44	; 0x2c
c0d02910:	4604      	mov	r4, r0
    if ((context->currentField == TX_RLP_DATA) && (context->currentFieldLength != 0)) {
c0d02912:	7800      	ldrb	r0, [r0, #0]
c0d02914:	2500      	movs	r5, #0
c0d02916:	2808      	cmp	r0, #8
c0d02918:	d000      	beq.n	c0d0291c <customProcessor+0x10>
c0d0291a:	e098      	b.n	c0d02a4e <customProcessor+0x142>
c0d0291c:	68a0      	ldr	r0, [r4, #8]
c0d0291e:	2800      	cmp	r0, #0
c0d02920:	d100      	bne.n	c0d02924 <customProcessor+0x18>
c0d02922:	e094      	b.n	c0d02a4e <customProcessor+0x142>
        dataPresent = true;
c0d02924:	4877      	ldr	r0, [pc, #476]	; (c0d02b04 <customProcessor+0x1f8>)
c0d02926:	2101      	movs	r1, #1
c0d02928:	7001      	strb	r1, [r0, #0]
c0d0292a:	2077      	movs	r0, #119	; 0x77
        // If handling a new contract rather than a function call, abort immediately
        if (tmpContent.txContent.destinationLength == 0) {
c0d0292c:	4f76      	ldr	r7, [pc, #472]	; (c0d02b08 <customProcessor+0x1fc>)
c0d0292e:	5c38      	ldrb	r0, [r7, r0]
c0d02930:	2800      	cmp	r0, #0
c0d02932:	d100      	bne.n	c0d02936 <customProcessor+0x2a>
c0d02934:	e08b      	b.n	c0d02a4e <customProcessor+0x142>
            return CUSTOM_NOT_HANDLED;
        }
        if (context->currentFieldPos == 0) {
c0d02936:	68e6      	ldr	r6, [r4, #12]
c0d02938:	2e00      	cmp	r6, #0
c0d0293a:	d017      	beq.n	c0d0296c <customProcessor+0x60>
c0d0293c:	9102      	str	r1, [sp, #8]
c0d0293e:	4875      	ldr	r0, [pc, #468]	; (c0d02b14 <customProcessor+0x208>)
c0d02940:	4478      	add	r0, pc
c0d02942:	f002 f847 	bl	c0d049d4 <pic>
            }
            dataContext.tokenContext.fieldIndex = 0;
            dataContext.tokenContext.fieldOffset = 0;
            blockSize = 4;
        } else {
            if (!N_storage.contractDetails && !dataContext.tokenContext.pluginAvailable) {
c0d02946:	7841      	ldrb	r1, [r0, #1]
c0d02948:	4870      	ldr	r0, [pc, #448]	; (c0d02b0c <customProcessor+0x200>)
c0d0294a:	7f82      	ldrb	r2, [r0, #30]
c0d0294c:	430a      	orrs	r2, r1
c0d0294e:	0611      	lsls	r1, r2, #24
c0d02950:	d07d      	beq.n	c0d02a4e <customProcessor+0x142>
c0d02952:	2140      	movs	r1, #64	; 0x40
                return CUSTOM_NOT_HANDLED;
            }
            blockSize = 32 - (dataContext.tokenContext.fieldOffset % 32);
c0d02954:	5c40      	ldrb	r0, [r0, r1]
c0d02956:	211f      	movs	r1, #31
c0d02958:	4001      	ands	r1, r0
c0d0295a:	2220      	movs	r2, #32
c0d0295c:	1a55      	subs	r5, r2, r1
c0d0295e:	2200      	movs	r2, #0
        }

        // Sanity check
        if ((context->currentFieldLength - fieldPos) < blockSize) {
c0d02960:	68a1      	ldr	r1, [r4, #8]
c0d02962:	1b89      	subs	r1, r1, r6
c0d02964:	42a9      	cmp	r1, r5
c0d02966:	d206      	bcs.n	c0d02976 <customProcessor+0x6a>
c0d02968:	2503      	movs	r5, #3
c0d0296a:	e070      	b.n	c0d02a4e <customProcessor+0x142>
            if (context->commandLength < 4) {
c0d0296c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d0296e:	2804      	cmp	r0, #4
c0d02970:	d23f      	bcs.n	c0d029f2 <customProcessor+0xe6>
c0d02972:	2703      	movs	r7, #3
c0d02974:	e06a      	b.n	c0d02a4c <customProcessor+0x140>
c0d02976:	9201      	str	r2, [sp, #4]
            PRINTF("Unconsistent data\n");
            return CUSTOM_FAULT;
        }

        copySize = (context->commandLength < blockSize ? context->commandLength : blockSize);
c0d02978:	6aa6      	ldr	r6, [r4, #40]	; 0x28
c0d0297a:	42ae      	cmp	r6, r5
c0d0297c:	4637      	mov	r7, r6
c0d0297e:	d300      	bcc.n	c0d02982 <customProcessor+0x76>
c0d02980:	462f      	mov	r7, r5

        PRINTF("currentFieldPos %d copySize %d\n", context->currentFieldPos, copySize);

        copyTxData(context,
                   dataContext.tokenContext.data + dataContext.tokenContext.fieldOffset,
c0d02982:	4962      	ldr	r1, [pc, #392]	; (c0d02b0c <customProcessor+0x200>)
c0d02984:	1809      	adds	r1, r1, r0
c0d02986:	311f      	adds	r1, #31
        copyTxData(context,
c0d02988:	4620      	mov	r0, r4
c0d0298a:	463a      	mov	r2, r7
c0d0298c:	f7ff f845 	bl	c0d01a1a <copyTxData>
                   copySize);

        if (context->currentFieldPos == context->currentFieldLength) {
c0d02990:	68a0      	ldr	r0, [r4, #8]
c0d02992:	68e1      	ldr	r1, [r4, #12]
c0d02994:	4281      	cmp	r1, r0
c0d02996:	d104      	bne.n	c0d029a2 <customProcessor+0x96>
c0d02998:	2000      	movs	r0, #0
            context->currentField++;
            context->processingField = false;
c0d0299a:	7460      	strb	r0, [r4, #17]
            context->currentField++;
c0d0299c:	7820      	ldrb	r0, [r4, #0]
c0d0299e:	1c40      	adds	r0, r0, #1
c0d029a0:	7020      	strb	r0, [r4, #0]
c0d029a2:	2440      	movs	r4, #64	; 0x40
c0d029a4:	4859      	ldr	r0, [pc, #356]	; (c0d02b0c <customProcessor+0x200>)
c0d029a6:	4601      	mov	r1, r0
        }

        dataContext.tokenContext.fieldOffset += copySize;
c0d029a8:	5d00      	ldrb	r0, [r0, r4]
c0d029aa:	19c0      	adds	r0, r0, r7
c0d029ac:	5508      	strb	r0, [r1, r4]

        if (copySize == blockSize) {
c0d029ae:	42ae      	cmp	r6, r5
c0d029b0:	9d02      	ldr	r5, [sp, #8]
c0d029b2:	d34c      	bcc.n	c0d02a4e <customProcessor+0x142>
c0d029b4:	460f      	mov	r7, r1
            // Can process or display
            if (dataContext.tokenContext.pluginAvailable) {
c0d029b6:	7f88      	ldrb	r0, [r1, #30]
c0d029b8:	2800      	cmp	r0, #0
c0d029ba:	d068      	beq.n	c0d02a8e <customProcessor+0x182>
c0d029bc:	4639      	mov	r1, r7
c0d029be:	273f      	movs	r7, #63	; 0x3f
                ethPluginProvideParameter_t pluginProvideParameter;
                eth_plugin_prepare_provide_parameter(&pluginProvideParameter,
                                                     dataContext.tokenContext.data,
                                                     dataContext.tokenContext.fieldIndex * 32 + 4);
c0d029c0:	5dc8      	ldrb	r0, [r1, r7]
c0d029c2:	0140      	lsls	r0, r0, #5
c0d029c4:	1d02      	adds	r2, r0, #4
                eth_plugin_prepare_provide_parameter(&pluginProvideParameter,
c0d029c6:	311f      	adds	r1, #31
c0d029c8:	ad03      	add	r5, sp, #12
c0d029ca:	4628      	mov	r0, r5
c0d029cc:	f7ff fbb8 	bl	c0d02140 <eth_plugin_prepare_provide_parameter>
c0d029d0:	2081      	movs	r0, #129	; 0x81
c0d029d2:	0041      	lsls	r1, r0, #1
c0d029d4:	2600      	movs	r6, #0
                if (!eth_plugin_call(NULL,
c0d029d6:	4630      	mov	r0, r6
c0d029d8:	462a      	mov	r2, r5
c0d029da:	f7ff fc6d 	bl	c0d022b8 <eth_plugin_call>
c0d029de:	2800      	cmp	r0, #0
c0d029e0:	d0c2      	beq.n	c0d02968 <customProcessor+0x5c>
c0d029e2:	484a      	ldr	r0, [pc, #296]	; (c0d02b0c <customProcessor+0x200>)
c0d029e4:	4601      	mov	r1, r0
                                     (void *) &pluginProvideParameter)) {
                    PRINTF("Plugin parameter call failed\n");
                    return CUSTOM_FAULT;
                }
                dataContext.tokenContext.fieldIndex++;
                dataContext.tokenContext.fieldOffset = 0;
c0d029e6:	5506      	strb	r6, [r0, r4]
                dataContext.tokenContext.fieldIndex++;
c0d029e8:	5dc0      	ldrb	r0, [r0, r7]
c0d029ea:	1c40      	adds	r0, r0, #1
c0d029ec:	55c8      	strb	r0, [r1, r7]
c0d029ee:	2501      	movs	r5, #1
c0d029f0:	e02d      	b.n	c0d02a4e <customProcessor+0x142>
c0d029f2:	9102      	str	r1, [sp, #8]
            dataContext.tokenContext.pluginAvailable = 0;
c0d029f4:	4945      	ldr	r1, [pc, #276]	; (c0d02b0c <customProcessor+0x200>)
c0d029f6:	2000      	movs	r0, #0
c0d029f8:	4606      	mov	r6, r0
c0d029fa:	7788      	strb	r0, [r1, #30]
            if (!N_storage.contractDetails) {
c0d029fc:	4846      	ldr	r0, [pc, #280]	; (c0d02b18 <customProcessor+0x20c>)
c0d029fe:	4478      	add	r0, pc
c0d02a00:	f001 ffe8 	bl	c0d049d4 <pic>
c0d02a04:	7840      	ldrb	r0, [r0, #1]
c0d02a06:	2800      	cmp	r0, #0
c0d02a08:	d002      	beq.n	c0d02a10 <customProcessor+0x104>
c0d02a0a:	4940      	ldr	r1, [pc, #256]	; (c0d02b0c <customProcessor+0x200>)
            if (dataContext.tokenContext.pluginAvailable) {
c0d02a0c:	7f88      	ldrb	r0, [r1, #30]
c0d02a0e:	e00c      	b.n	c0d02a2a <customProcessor+0x11e>
                                        context->currentFieldLength);
c0d02a10:	68a2      	ldr	r2, [r4, #8]
                                        context->workBuffer,
c0d02a12:	6a61      	ldr	r1, [r4, #36]	; 0x24
c0d02a14:	a803      	add	r0, sp, #12
                eth_plugin_prepare_init(&pluginInit,
c0d02a16:	9001      	str	r0, [sp, #4]
c0d02a18:	f7ff fb88 	bl	c0d0212c <eth_plugin_prepare_init>
                    eth_plugin_perform_init(tmpContent.txContent.destination, &pluginInit);
c0d02a1c:	3763      	adds	r7, #99	; 0x63
c0d02a1e:	4638      	mov	r0, r7
c0d02a20:	9901      	ldr	r1, [sp, #4]
c0d02a22:	f7ff fbc9 	bl	c0d021b8 <eth_plugin_perform_init>
c0d02a26:	4939      	ldr	r1, [pc, #228]	; (c0d02b0c <customProcessor+0x200>)
                dataContext.tokenContext.pluginAvailable =
c0d02a28:	7788      	strb	r0, [r1, #30]
c0d02a2a:	4637      	mov	r7, r6
            if (dataContext.tokenContext.pluginAvailable) {
c0d02a2c:	0600      	lsls	r0, r0, #24
c0d02a2e:	d011      	beq.n	c0d02a54 <customProcessor+0x148>
c0d02a30:	2040      	movs	r0, #64	; 0x40
                dataContext.tokenContext.fieldOffset = 0;
c0d02a32:	540f      	strb	r7, [r1, r0]
c0d02a34:	203f      	movs	r0, #63	; 0x3f
                dataContext.tokenContext.fieldIndex = 0;
c0d02a36:	540f      	strb	r7, [r1, r0]
c0d02a38:	2204      	movs	r2, #4
                copyTxData(context, NULL, 4);
c0d02a3a:	4620      	mov	r0, r4
c0d02a3c:	460e      	mov	r6, r1
c0d02a3e:	4639      	mov	r1, r7
c0d02a40:	f7fe ffeb 	bl	c0d01a1a <copyTxData>
c0d02a44:	4631      	mov	r1, r6
                if (context->currentFieldLength == 4) {
c0d02a46:	68a0      	ldr	r0, [r4, #8]
c0d02a48:	2804      	cmp	r0, #4
c0d02a4a:	d103      	bne.n	c0d02a54 <customProcessor+0x148>
c0d02a4c:	463d      	mov	r5, r7
        }

        return CUSTOM_SUSPENDED;
    }
    return CUSTOM_NOT_HANDLED;
}
c0d02a4e:	4628      	mov	r0, r5
c0d02a50:	b00b      	add	sp, #44	; 0x2c
c0d02a52:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02a54:	460f      	mov	r7, r1
        uint32_t fieldPos = context->currentFieldPos;
c0d02a56:	68e6      	ldr	r6, [r4, #12]
c0d02a58:	4830      	ldr	r0, [pc, #192]	; (c0d02b1c <customProcessor+0x210>)
c0d02a5a:	4478      	add	r0, pc
c0d02a5c:	f001 ffba 	bl	c0d049d4 <pic>
        if (fieldPos == 0) {  // not reached if a plugin is available
c0d02a60:	2e00      	cmp	r6, #0
c0d02a62:	d000      	beq.n	c0d02a66 <customProcessor+0x15a>
c0d02a64:	e76f      	b.n	c0d02946 <customProcessor+0x3a>
            if (!N_storage.dataAllowed) {
c0d02a66:	7800      	ldrb	r0, [r0, #0]
c0d02a68:	2800      	cmp	r0, #0
c0d02a6a:	d100      	bne.n	c0d02a6e <customProcessor+0x162>
c0d02a6c:	e77c      	b.n	c0d02968 <customProcessor+0x5c>
            if (!N_storage.contractDetails) {
c0d02a6e:	482c      	ldr	r0, [pc, #176]	; (c0d02b20 <customProcessor+0x214>)
c0d02a70:	4478      	add	r0, pc
c0d02a72:	f001 ffaf 	bl	c0d049d4 <pic>
c0d02a76:	7840      	ldrb	r0, [r0, #1]
c0d02a78:	2800      	cmp	r0, #0
c0d02a7a:	d040      	beq.n	c0d02afe <customProcessor+0x1f2>
c0d02a7c:	2140      	movs	r1, #64	; 0x40
c0d02a7e:	2000      	movs	r0, #0
            dataContext.tokenContext.fieldOffset = 0;
c0d02a80:	5478      	strb	r0, [r7, r1]
c0d02a82:	213f      	movs	r1, #63	; 0x3f
            dataContext.tokenContext.fieldIndex = 0;
c0d02a84:	5478      	strb	r0, [r7, r1]
c0d02a86:	2504      	movs	r5, #4
c0d02a88:	2201      	movs	r2, #1
c0d02a8a:	4606      	mov	r6, r0
c0d02a8c:	e768      	b.n	c0d02960 <customProcessor+0x54>
            if (fieldPos != 0) {
c0d02a8e:	9801      	ldr	r0, [sp, #4]
c0d02a90:	2800      	cmp	r0, #0
c0d02a92:	d00c      	beq.n	c0d02aae <customProcessor+0x1a2>
c0d02a94:	2500      	movs	r5, #0
            dataContext.tokenContext.fieldOffset = 0;
c0d02a96:	553d      	strb	r5, [r7, r4]
                array_hexstr(strings.tmp.tmp, dataContext.tokenContext.data, 4);
c0d02a98:	371f      	adds	r7, #31
c0d02a9a:	481d      	ldr	r0, [pc, #116]	; (c0d02b10 <customProcessor+0x204>)
c0d02a9c:	2204      	movs	r2, #4
c0d02a9e:	4639      	mov	r1, r7
c0d02aa0:	f005 fe52 	bl	c0d08748 <array_hexstr>
                ux_flow_init(0, ux_confirm_selector_flow, NULL);
c0d02aa4:	491f      	ldr	r1, [pc, #124]	; (c0d02b24 <customProcessor+0x218>)
c0d02aa6:	4479      	add	r1, pc
c0d02aa8:	4628      	mov	r0, r5
c0d02aaa:	462a      	mov	r2, r5
c0d02aac:	e023      	b.n	c0d02af6 <customProcessor+0x1ea>
c0d02aae:	2000      	movs	r0, #0
            dataContext.tokenContext.fieldOffset = 0;
c0d02ab0:	5538      	strb	r0, [r7, r4]
c0d02ab2:	203f      	movs	r0, #63	; 0x3f
                dataContext.tokenContext.fieldIndex++;
c0d02ab4:	5c39      	ldrb	r1, [r7, r0]
c0d02ab6:	1c49      	adds	r1, r1, #1
c0d02ab8:	5439      	strb	r1, [r7, r0]
                         dataContext.tokenContext.fieldIndex);
c0d02aba:	b2cb      	uxtb	r3, r1
                snprintf(strings.tmp.tmp2,
c0d02abc:	4c14      	ldr	r4, [pc, #80]	; (c0d02b10 <customProcessor+0x204>)
c0d02abe:	4620      	mov	r0, r4
c0d02ac0:	3064      	adds	r0, #100	; 0x64
c0d02ac2:	2128      	movs	r1, #40	; 0x28
c0d02ac4:	4a18      	ldr	r2, [pc, #96]	; (c0d02b28 <customProcessor+0x21c>)
c0d02ac6:	447a      	add	r2, pc
c0d02ac8:	f001 fdb0 	bl	c0d0462c <snprintf>
                    offset += splitBinaryParameterPart(strings.tmp.tmp + offset,
c0d02acc:	4639      	mov	r1, r7
c0d02ace:	311f      	adds	r1, #31
c0d02ad0:	4620      	mov	r0, r4
c0d02ad2:	f7ff ff03 	bl	c0d028dc <splitBinaryParameterPart>
c0d02ad6:	2527      	movs	r5, #39	; 0x27
c0d02ad8:	213a      	movs	r1, #58	; 0x3a
                        strings.tmp.tmp[offset++] = ':';
c0d02ada:	5421      	strb	r1, [r4, r0]
                    offset += splitBinaryParameterPart(strings.tmp.tmp + offset,
c0d02adc:	1979      	adds	r1, r7, r5
                        strings.tmp.tmp[offset++] = ':';
c0d02ade:	1c46      	adds	r6, r0, #1
                    offset += splitBinaryParameterPart(strings.tmp.tmp + offset,
c0d02ae0:	19a0      	adds	r0, r4, r6
c0d02ae2:	f7ff fefb 	bl	c0d028dc <splitBinaryParameterPart>
c0d02ae6:	1980      	adds	r0, r0, r6
                    if (i != 3) {
c0d02ae8:	3508      	adds	r5, #8
c0d02aea:	2d3f      	cmp	r5, #63	; 0x3f
c0d02aec:	d1f4      	bne.n	c0d02ad8 <customProcessor+0x1cc>
                ux_flow_init(0, ux_confirm_parameter_flow, NULL);
c0d02aee:	490f      	ldr	r1, [pc, #60]	; (c0d02b2c <customProcessor+0x220>)
c0d02af0:	4479      	add	r1, pc
c0d02af2:	2000      	movs	r0, #0
c0d02af4:	4602      	mov	r2, r0
c0d02af6:	f006 f84d 	bl	c0d08b94 <ux_flow_init>
c0d02afa:	2502      	movs	r5, #2
c0d02afc:	e7a7      	b.n	c0d02a4e <customProcessor+0x142>
c0d02afe:	2500      	movs	r5, #0
c0d02b00:	e7a5      	b.n	c0d02a4e <customProcessor+0x142>
c0d02b02:	46c0      	nop			; (mov r8, r8)
c0d02b04:	20001e60 	.word	0x20001e60
c0d02b08:	200018dc 	.word	0x200018dc
c0d02b0c:	20001b40 	.word	0x20001b40
c0d02b10:	20001c26 	.word	0x20001c26
c0d02b14:	00008dbc 	.word	0x00008dbc
c0d02b18:	00008cfe 	.word	0x00008cfe
c0d02b1c:	00008ca2 	.word	0x00008ca2
c0d02b20:	00008c8c 	.word	0x00008c8c
c0d02b24:	00007f6a 	.word	0x00007f6a
c0d02b28:	00007722 	.word	0x00007722
c0d02b2c:	00007fc8 	.word	0x00007fc8

c0d02b30 <compareOrCopy>:
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
        str[i] = str[i] >= 'a' ? str[i] - ('a' - 'A') : str[i];
    }
}

void compareOrCopy(char *preapproved_string, char *parsed_string, bool silent_mode) {
c0d02b30:	b5b0      	push	{r4, r5, r7, lr}
c0d02b32:	460c      	mov	r4, r1
c0d02b34:	4605      	mov	r5, r0
    if (silent_mode) {
c0d02b36:	2a00      	cmp	r2, #0
c0d02b38:	d02c      	beq.n	c0d02b94 <compareOrCopy+0x64>
        /* ETH address are not fundamentally case sensitive but might
        have some for checksum purpose, so let's get rid of these diffs */
        to_uppercase(preapproved_string, strlen(preapproved_string));
c0d02b3a:	4628      	mov	r0, r5
c0d02b3c:	f006 ff1a 	bl	c0d09974 <strlen>
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0d02b40:	0601      	lsls	r1, r0, #24
c0d02b42:	d00b      	beq.n	c0d02b5c <compareOrCopy+0x2c>
c0d02b44:	b2c0      	uxtb	r0, r0
c0d02b46:	2100      	movs	r1, #0
c0d02b48:	5c6a      	ldrb	r2, [r5, r1]
c0d02b4a:	2a00      	cmp	r2, #0
c0d02b4c:	d006      	beq.n	c0d02b5c <compareOrCopy+0x2c>
        str[i] = str[i] >= 'a' ? str[i] - ('a' - 'A') : str[i];
c0d02b4e:	2a60      	cmp	r2, #96	; 0x60
c0d02b50:	d900      	bls.n	c0d02b54 <compareOrCopy+0x24>
c0d02b52:	3a20      	subs	r2, #32
c0d02b54:	546a      	strb	r2, [r5, r1]
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0d02b56:	1c49      	adds	r1, r1, #1
c0d02b58:	4281      	cmp	r1, r0
c0d02b5a:	d3f5      	bcc.n	c0d02b48 <compareOrCopy+0x18>
        to_uppercase(parsed_string, strlen(parsed_string));
c0d02b5c:	4620      	mov	r0, r4
c0d02b5e:	f006 ff09 	bl	c0d09974 <strlen>
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0d02b62:	0601      	lsls	r1, r0, #24
c0d02b64:	d00b      	beq.n	c0d02b7e <compareOrCopy+0x4e>
c0d02b66:	b2c0      	uxtb	r0, r0
c0d02b68:	2100      	movs	r1, #0
c0d02b6a:	5c62      	ldrb	r2, [r4, r1]
c0d02b6c:	2a00      	cmp	r2, #0
c0d02b6e:	d006      	beq.n	c0d02b7e <compareOrCopy+0x4e>
        str[i] = str[i] >= 'a' ? str[i] - ('a' - 'A') : str[i];
c0d02b70:	2a60      	cmp	r2, #96	; 0x60
c0d02b72:	d900      	bls.n	c0d02b76 <compareOrCopy+0x46>
c0d02b74:	3a20      	subs	r2, #32
c0d02b76:	5462      	strb	r2, [r4, r1]
    for (unsigned char i = 0; i < size && str[i] != 0; i++) {
c0d02b78:	1c49      	adds	r1, r1, #1
c0d02b7a:	4281      	cmp	r1, r0
c0d02b7c:	d3f5      	bcc.n	c0d02b6a <compareOrCopy+0x3a>
        if (memcmp(preapproved_string, parsed_string, strlen(preapproved_string))) {
c0d02b7e:	4628      	mov	r0, r5
c0d02b80:	f006 fef8 	bl	c0d09974 <strlen>
c0d02b84:	4602      	mov	r2, r0
c0d02b86:	4628      	mov	r0, r5
c0d02b88:	4621      	mov	r1, r4
c0d02b8a:	f006 fd47 	bl	c0d0961c <memcmp>
c0d02b8e:	2800      	cmp	r0, #0
c0d02b90:	d105      	bne.n	c0d02b9e <compareOrCopy+0x6e>
            THROW(ERR_SILENT_MODE_CHECK_FAILED);
        }
    } else {
        strcpy(preapproved_string, parsed_string);
    }
}
c0d02b92:	bdb0      	pop	{r4, r5, r7, pc}
        strcpy(preapproved_string, parsed_string);
c0d02b94:	4628      	mov	r0, r5
c0d02b96:	4621      	mov	r1, r4
c0d02b98:	f006 fee4 	bl	c0d09964 <strcpy>
}
c0d02b9c:	bdb0      	pop	{r4, r5, r7, pc}
c0d02b9e:	4801      	ldr	r0, [pc, #4]	; (c0d02ba4 <compareOrCopy+0x74>)
            THROW(ERR_SILENT_MODE_CHECK_FAILED);
c0d02ba0:	f000 ff2f 	bl	c0d03a02 <os_longjmp>
c0d02ba4:	00006001 	.word	0x00006001

c0d02ba8 <reportFinalizeError>:

void reportFinalizeError(bool direct) {
c0d02ba8:	b510      	push	{r4, lr}
c0d02baa:	4604      	mov	r4, r0
    reset_app_context();
c0d02bac:	f000 f9c8 	bl	c0d02f40 <reset_app_context>
c0d02bb0:	20d5      	movs	r0, #213	; 0xd5
c0d02bb2:	01c0      	lsls	r0, r0, #7
    if (direct) {
c0d02bb4:	2c00      	cmp	r4, #0
c0d02bb6:	d104      	bne.n	c0d02bc2 <reportFinalizeError+0x1a>
        THROW(0x6A80);
    } else {
        io_seproxyhal_send_status(0x6A80);
c0d02bb8:	f000 f9f4 	bl	c0d02fa4 <io_seproxyhal_send_status>
        ui_idle();
c0d02bbc:	f000 f9e0 	bl	c0d02f80 <ui_idle>
    }
}
c0d02bc0:	bd10      	pop	{r4, pc}
        THROW(0x6A80);
c0d02bc2:	f000 ff1e 	bl	c0d03a02 <os_longjmp>
	...

c0d02bc8 <computeFees>:

void computeFees(char *displayBuffer, uint32_t displayBufferSize) {
c0d02bc8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02bca:	b09d      	sub	sp, #116	; 0x74
c0d02bcc:	9103      	str	r1, [sp, #12]
c0d02bce:	4604      	mov	r4, r0
    uint256_t gasPrice, startGas, uint256;
    uint8_t *feeTicker = (uint8_t *) PIC(chainConfig->coinName);
c0d02bd0:	4828      	ldr	r0, [pc, #160]	; (c0d02c74 <computeFees+0xac>)
c0d02bd2:	6800      	ldr	r0, [r0, #0]
c0d02bd4:	f001 fefe 	bl	c0d049d4 <pic>
c0d02bd8:	4605      	mov	r5, r0
c0d02bda:	2020      	movs	r0, #32
           tmpContent.txContent.gasprice.value);
    PRINTF("Startgas %.*H\n",
           tmpContent.txContent.startgas.length,
           tmpContent.txContent.startgas.value);
    convertUint256BE(tmpContent.txContent.gasprice.value,
                     tmpContent.txContent.gasprice.length,
c0d02bdc:	4f26      	ldr	r7, [pc, #152]	; (c0d02c78 <computeFees+0xb0>)
c0d02bde:	5c39      	ldrb	r1, [r7, r0]
c0d02be0:	aa14      	add	r2, sp, #80	; 0x50
    convertUint256BE(tmpContent.txContent.gasprice.value,
c0d02be2:	9202      	str	r2, [sp, #8]
c0d02be4:	4638      	mov	r0, r7
c0d02be6:	f005 fdc7 	bl	c0d08778 <convertUint256BE>
c0d02bea:	2041      	movs	r0, #65	; 0x41
                     &gasPrice);
    convertUint256BE(tmpContent.txContent.startgas.value,
                     tmpContent.txContent.startgas.length,
c0d02bec:	5c39      	ldrb	r1, [r7, r0]
    convertUint256BE(tmpContent.txContent.startgas.value,
c0d02bee:	3721      	adds	r7, #33	; 0x21
c0d02bf0:	ae0c      	add	r6, sp, #48	; 0x30
c0d02bf2:	4638      	mov	r0, r7
c0d02bf4:	4632      	mov	r2, r6
c0d02bf6:	f005 fdbf 	bl	c0d08778 <convertUint256BE>
c0d02bfa:	aa04      	add	r2, sp, #16
                     &startGas);
    mul256(&gasPrice, &startGas, &uint256);
c0d02bfc:	9201      	str	r2, [sp, #4]
c0d02bfe:	9802      	ldr	r0, [sp, #8]
c0d02c00:	4631      	mov	r1, r6
c0d02c02:	f004 fbb7 	bl	c0d07374 <mul256>
    tostring256(&uint256, 10, (char *) (G_io_apdu_buffer + 100), 100);
c0d02c06:	4e1d      	ldr	r6, [pc, #116]	; (c0d02c7c <computeFees+0xb4>)
c0d02c08:	4632      	mov	r2, r6
c0d02c0a:	3264      	adds	r2, #100	; 0x64
c0d02c0c:	210a      	movs	r1, #10
c0d02c0e:	2764      	movs	r7, #100	; 0x64
c0d02c10:	9801      	ldr	r0, [sp, #4]
c0d02c12:	9202      	str	r2, [sp, #8]
c0d02c14:	463b      	mov	r3, r7
c0d02c16:	f004 fd45 	bl	c0d076a4 <tostring256>
    i = 0;
    while (G_io_apdu_buffer[100 + i]) {
c0d02c1a:	5df0      	ldrb	r0, [r6, r7]
c0d02c1c:	1c7f      	adds	r7, r7, #1
c0d02c1e:	2800      	cmp	r0, #0
c0d02c20:	d1fb      	bne.n	c0d02c1a <computeFees+0x52>
c0d02c22:	2012      	movs	r0, #18
        i++;
    }
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
c0d02c24:	4669      	mov	r1, sp
c0d02c26:	6008      	str	r0, [r1, #0]
c0d02c28:	3f65      	subs	r7, #101	; 0x65
c0d02c2a:	2364      	movs	r3, #100	; 0x64
c0d02c2c:	9802      	ldr	r0, [sp, #8]
c0d02c2e:	4639      	mov	r1, r7
c0d02c30:	4632      	mov	r2, r6
c0d02c32:	f7ff fa03 	bl	c0d0203c <adjustDecimals>
                   (char *) G_io_apdu_buffer,
                   100,
                   WEI_TO_ETHER);
    i = 0;
    tickerOffset = 0;
    memset(displayBuffer, 0, displayBufferSize);
c0d02c36:	4620      	mov	r0, r4
c0d02c38:	9903      	ldr	r1, [sp, #12]
c0d02c3a:	f006 fcd5 	bl	c0d095e8 <__aeabi_memclr>
    while (feeTicker[tickerOffset]) {
c0d02c3e:	7829      	ldrb	r1, [r5, #0]
c0d02c40:	2000      	movs	r0, #0
c0d02c42:	2900      	cmp	r1, #0
c0d02c44:	d006      	beq.n	c0d02c54 <computeFees+0x8c>
c0d02c46:	4602      	mov	r2, r0
        displayBuffer[tickerOffset] = feeTicker[tickerOffset];
c0d02c48:	5421      	strb	r1, [r4, r0]
        tickerOffset++;
c0d02c4a:	1c52      	adds	r2, r2, #1
    while (feeTicker[tickerOffset]) {
c0d02c4c:	b2d0      	uxtb	r0, r2
c0d02c4e:	5c29      	ldrb	r1, [r5, r0]
c0d02c50:	2900      	cmp	r1, #0
c0d02c52:	d1f9      	bne.n	c0d02c48 <computeFees+0x80>
c0d02c54:	1820      	adds	r0, r4, r0
    }
    while (G_io_apdu_buffer[i]) {
c0d02c56:	7831      	ldrb	r1, [r6, #0]
c0d02c58:	2900      	cmp	r1, #0
c0d02c5a:	d007      	beq.n	c0d02c6c <computeFees+0xa4>
c0d02c5c:	1c72      	adds	r2, r6, #1
        displayBuffer[tickerOffset + i] = G_io_apdu_buffer[i];
c0d02c5e:	7001      	strb	r1, [r0, #0]
    while (G_io_apdu_buffer[i]) {
c0d02c60:	1c53      	adds	r3, r2, #1
c0d02c62:	1c40      	adds	r0, r0, #1
c0d02c64:	7811      	ldrb	r1, [r2, #0]
c0d02c66:	2900      	cmp	r1, #0
c0d02c68:	461a      	mov	r2, r3
c0d02c6a:	d1f8      	bne.n	c0d02c5e <computeFees+0x96>
c0d02c6c:	2100      	movs	r1, #0
        i++;
    }
    displayBuffer[tickerOffset + i] = '\0';
c0d02c6e:	7001      	strb	r1, [r0, #0]
}
c0d02c70:	b01d      	add	sp, #116	; 0x74
c0d02c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02c74:	20001b3c 	.word	0x20001b3c
c0d02c78:	200018dc 	.word	0x200018dc
c0d02c7c:	20001e61 	.word	0x20001e61

c0d02c80 <finalizeParsing>:

void finalizeParsing(bool direct) {
c0d02c80:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02c82:	b09d      	sub	sp, #116	; 0x74
c0d02c84:	9007      	str	r0, [sp, #28]
    char displayBuffer[50];
    uint8_t decimals = WEI_TO_ETHER;
    uint8_t *ticker = (uint8_t *) PIC(chainConfig->coinName);
c0d02c86:	4f9a      	ldr	r7, [pc, #616]	; (c0d02ef0 <finalizeParsing+0x270>)
c0d02c88:	6838      	ldr	r0, [r7, #0]
c0d02c8a:	f001 fea3 	bl	c0d049d4 <pic>
c0d02c8e:	9005      	str	r0, [sp, #20]
    ethPluginFinalize_t pluginFinalize;
    tokenDefinition_t *token1 = NULL, *token2 = NULL;
    bool genericUI = true;

    // Verify the chain
    if (chainConfig->chainId != 0) {
c0d02c90:	6838      	ldr	r0, [r7, #0]
c0d02c92:	68c0      	ldr	r0, [r0, #12]
c0d02c94:	2800      	cmp	r0, #0
c0d02c96:	d00f      	beq.n	c0d02cb8 <finalizeParsing+0x38>
        uint32_t v = getV(&tmpContent.txContent);
c0d02c98:	4896      	ldr	r0, [pc, #600]	; (c0d02ef4 <finalizeParsing+0x274>)
c0d02c9a:	f005 fd83 	bl	c0d087a4 <getV>
        if (chainConfig->chainId != v) {
c0d02c9e:	6839      	ldr	r1, [r7, #0]
c0d02ca0:	68c9      	ldr	r1, [r1, #12]
c0d02ca2:	4281      	cmp	r1, r0
c0d02ca4:	d008      	beq.n	c0d02cb8 <finalizeParsing+0x38>
            reset_app_context();
c0d02ca6:	f000 f94b 	bl	c0d02f40 <reset_app_context>
c0d02caa:	9c07      	ldr	r4, [sp, #28]
            PRINTF("Invalid chainId %d expected %d\n", v, chainConfig->chainId);
            reportFinalizeError(direct);
c0d02cac:	4620      	mov	r0, r4
c0d02cae:	f7ff ff7b 	bl	c0d02ba8 <reportFinalizeError>
            if (!direct) {
c0d02cb2:	2c00      	cmp	r4, #0
c0d02cb4:	d100      	bne.n	c0d02cb8 <finalizeParsing+0x38>
c0d02cb6:	e116      	b.n	c0d02ee6 <finalizeParsing+0x266>
c0d02cb8:	2520      	movs	r5, #32
                return;
            }
        }
    }
    // Store the hash
    cx_hash((cx_hash_t *) &global_sha3,
c0d02cba:	4668      	mov	r0, sp
c0d02cbc:	6045      	str	r5, [r0, #4]
c0d02cbe:	4a8e      	ldr	r2, [pc, #568]	; (c0d02ef8 <finalizeParsing+0x278>)
c0d02cc0:	322c      	adds	r2, #44	; 0x2c
c0d02cc2:	6002      	str	r2, [r0, #0]
c0d02cc4:	488d      	ldr	r0, [pc, #564]	; (c0d02efc <finalizeParsing+0x27c>)
c0d02cc6:	2401      	movs	r4, #1
c0d02cc8:	2600      	movs	r6, #0
c0d02cca:	4621      	mov	r1, r4
c0d02ccc:	4633      	mov	r3, r6
c0d02cce:	f002 fd99 	bl	c0d05804 <cx_hash>
            0,
            tmpCtx.transactionContext.hash,
            32);

    // Finalize the plugin handling
    if (dataContext.tokenContext.pluginAvailable) {
c0d02cd2:	488b      	ldr	r0, [pc, #556]	; (c0d02f00 <finalizeParsing+0x280>)
c0d02cd4:	7f80      	ldrb	r0, [r0, #30]
c0d02cd6:	2112      	movs	r1, #18
c0d02cd8:	2800      	cmp	r0, #0
c0d02cda:	9406      	str	r4, [sp, #24]
c0d02cdc:	9104      	str	r1, [sp, #16]
c0d02cde:	d04b      	beq.n	c0d02d78 <finalizeParsing+0xf8>
c0d02ce0:	9503      	str	r5, [sp, #12]
c0d02ce2:	af08      	add	r7, sp, #32
        genericUI = false;
        eth_plugin_prepare_finalize(&pluginFinalize);
c0d02ce4:	4638      	mov	r0, r7
c0d02ce6:	f7ff fa35 	bl	c0d02154 <eth_plugin_prepare_finalize>
c0d02cea:	24ff      	movs	r4, #255	; 0xff
c0d02cec:	3404      	adds	r4, #4
c0d02cee:	2500      	movs	r5, #0
        if (!eth_plugin_call(NULL, ETH_PLUGIN_FINALIZE, (void *) &pluginFinalize)) {
c0d02cf0:	4628      	mov	r0, r5
c0d02cf2:	4621      	mov	r1, r4
c0d02cf4:	463a      	mov	r2, r7
c0d02cf6:	4f7e      	ldr	r7, [pc, #504]	; (c0d02ef0 <finalizeParsing+0x270>)
c0d02cf8:	f7ff fade 	bl	c0d022b8 <eth_plugin_call>
c0d02cfc:	2800      	cmp	r0, #0
c0d02cfe:	d108      	bne.n	c0d02d12 <finalizeParsing+0x92>
c0d02d00:	9602      	str	r6, [sp, #8]
c0d02d02:	9e07      	ldr	r6, [sp, #28]
            PRINTF("Plugin finalize call failed\n");
            reportFinalizeError(direct);
c0d02d04:	4630      	mov	r0, r6
c0d02d06:	f7ff ff4f 	bl	c0d02ba8 <reportFinalizeError>
            if (!direct) {
c0d02d0a:	2e00      	cmp	r6, #0
c0d02d0c:	9e02      	ldr	r6, [sp, #8]
c0d02d0e:	d100      	bne.n	c0d02d12 <finalizeParsing+0x92>
c0d02d10:	e0e9      	b.n	c0d02ee6 <finalizeParsing+0x266>
                return;
            }
        }
        // Lookup tokens if requested
        if (pluginFinalize.tokenLookup1 != NULL) {
c0d02d12:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d02d14:	2800      	cmp	r0, #0
c0d02d16:	d027      	beq.n	c0d02d68 <finalizeParsing+0xe8>
            ethPluginProvideToken_t pluginProvideToken;
            token1 = getKnownToken(pluginFinalize.tokenLookup1);
c0d02d18:	f000 f9a6 	bl	c0d03068 <getKnownToken>
c0d02d1c:	4601      	mov	r1, r0
            if (pluginFinalize.tokenLookup2 != NULL) {
c0d02d1e:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d02d20:	2800      	cmp	r0, #0
c0d02d22:	d004      	beq.n	c0d02d2e <finalizeParsing+0xae>
c0d02d24:	460d      	mov	r5, r1
                token2 = getKnownToken(pluginFinalize.tokenLookup2);
c0d02d26:	f000 f99f 	bl	c0d03068 <getKnownToken>
c0d02d2a:	4629      	mov	r1, r5
c0d02d2c:	4605      	mov	r5, r0
c0d02d2e:	af10      	add	r7, sp, #64	; 0x40
            }
            eth_plugin_prepare_provide_token(&pluginProvideToken, token1, token2);
c0d02d30:	4638      	mov	r0, r7
c0d02d32:	9102      	str	r1, [sp, #8]
c0d02d34:	462a      	mov	r2, r5
c0d02d36:	f7ff fa12 	bl	c0d0215e <eth_plugin_prepare_provide_token>
            if (!eth_plugin_call(NULL, ETH_PLUGIN_PROVIDE_TOKEN, (void *) &pluginProvideToken)) {
c0d02d3a:	1c61      	adds	r1, r4, #1
c0d02d3c:	2000      	movs	r0, #0
c0d02d3e:	463a      	mov	r2, r7
c0d02d40:	f7ff faba 	bl	c0d022b8 <eth_plugin_call>
c0d02d44:	2800      	cmp	r0, #0
c0d02d46:	d106      	bne.n	c0d02d56 <finalizeParsing+0xd6>
c0d02d48:	9c07      	ldr	r4, [sp, #28]
                PRINTF("Plugin provide token call failed\n");
                reportFinalizeError(direct);
c0d02d4a:	4620      	mov	r0, r4
c0d02d4c:	f7ff ff2c 	bl	c0d02ba8 <reportFinalizeError>
                if (!direct) {
c0d02d50:	2c00      	cmp	r4, #0
c0d02d52:	d100      	bne.n	c0d02d56 <finalizeParsing+0xd6>
c0d02d54:	e0c7      	b.n	c0d02ee6 <finalizeParsing+0x266>
c0d02d56:	a810      	add	r0, sp, #64	; 0x40
                    return;
                }
            }
            pluginFinalize.result = pluginProvideToken.result;
c0d02d58:	7d00      	ldrb	r0, [r0, #20]
c0d02d5a:	a908      	add	r1, sp, #32
c0d02d5c:	7788      	strb	r0, [r1, #30]
c0d02d5e:	9c06      	ldr	r4, [sp, #24]
c0d02d60:	4f63      	ldr	r7, [pc, #396]	; (c0d02ef0 <finalizeParsing+0x270>)
c0d02d62:	9d03      	ldr	r5, [sp, #12]
c0d02d64:	9902      	ldr	r1, [sp, #8]
c0d02d66:	e004      	b.n	c0d02d72 <finalizeParsing+0xf2>
c0d02d68:	a808      	add	r0, sp, #32
        }
        if (pluginFinalize.result != ETH_PLUGIN_RESULT_FALLBACK) {
c0d02d6a:	7f80      	ldrb	r0, [r0, #30]
c0d02d6c:	2100      	movs	r1, #0
c0d02d6e:	9c06      	ldr	r4, [sp, #24]
c0d02d70:	9d03      	ldr	r5, [sp, #12]
c0d02d72:	4a63      	ldr	r2, [pc, #396]	; (c0d02f00 <finalizeParsing+0x280>)
c0d02d74:	2803      	cmp	r0, #3
c0d02d76:	d12b      	bne.n	c0d02dd0 <finalizeParsing+0x150>
        } else {
            genericUI = true;
        }
    }

    if (dataPresent && !N_storage.dataAllowed) {
c0d02d78:	4862      	ldr	r0, [pc, #392]	; (c0d02f04 <finalizeParsing+0x284>)
c0d02d7a:	7800      	ldrb	r0, [r0, #0]
c0d02d7c:	2800      	cmp	r0, #0
c0d02d7e:	d00d      	beq.n	c0d02d9c <finalizeParsing+0x11c>
c0d02d80:	4863      	ldr	r0, [pc, #396]	; (c0d02f10 <finalizeParsing+0x290>)
c0d02d82:	4478      	add	r0, pc
c0d02d84:	f001 fe26 	bl	c0d049d4 <pic>
c0d02d88:	7800      	ldrb	r0, [r0, #0]
c0d02d8a:	2800      	cmp	r0, #0
c0d02d8c:	d106      	bne.n	c0d02d9c <finalizeParsing+0x11c>
c0d02d8e:	9d07      	ldr	r5, [sp, #28]
        PRINTF("Data field forbidden\n");
        reportFinalizeError(direct);
c0d02d90:	4628      	mov	r0, r5
c0d02d92:	f7ff ff09 	bl	c0d02ba8 <reportFinalizeError>
        if (!direct) {
c0d02d96:	2d00      	cmp	r5, #0
c0d02d98:	d100      	bne.n	c0d02d9c <finalizeParsing+0x11c>
c0d02d9a:	e0a4      	b.n	c0d02ee6 <finalizeParsing+0x266>
            return;
        }
    }
    // Prepare destination address to display
    if (genericUI) {
c0d02d9c:	2c00      	cmp	r4, #0
c0d02d9e:	d04b      	beq.n	c0d02e38 <finalizeParsing+0x1b8>
c0d02da0:	2077      	movs	r0, #119	; 0x77
        if (tmpContent.txContent.destinationLength != 0) {
c0d02da2:	4c54      	ldr	r4, [pc, #336]	; (c0d02ef4 <finalizeParsing+0x274>)
c0d02da4:	5c20      	ldrb	r0, [r4, r0]
c0d02da6:	2800      	cmp	r0, #0
c0d02da8:	d020      	beq.n	c0d02dec <finalizeParsing+0x16c>
c0d02daa:	ad10      	add	r5, sp, #64	; 0x40
c0d02dac:	2078      	movs	r0, #120	; 0x78
            displayBuffer[0] = '0';
            displayBuffer[1] = 'x';
c0d02dae:	7068      	strb	r0, [r5, #1]
c0d02db0:	2030      	movs	r0, #48	; 0x30
            displayBuffer[0] = '0';
c0d02db2:	7028      	strb	r0, [r5, #0]
            getEthAddressStringFromBinary(tmpContent.txContent.destination,
                                          (uint8_t *) displayBuffer + 2,
                                          &global_sha3,
                                          chainConfig);
c0d02db4:	683b      	ldr	r3, [r7, #0]
            getEthAddressStringFromBinary(tmpContent.txContent.destination,
c0d02db6:	4620      	mov	r0, r4
c0d02db8:	3063      	adds	r0, #99	; 0x63
                                          (uint8_t *) displayBuffer + 2,
c0d02dba:	1ca9      	adds	r1, r5, #2
            getEthAddressStringFromBinary(tmpContent.txContent.destination,
c0d02dbc:	4a4f      	ldr	r2, [pc, #316]	; (c0d02efc <finalizeParsing+0x27c>)
c0d02dbe:	f7ff f8d9 	bl	c0d01f74 <getEthAddressStringFromBinary>
            compareOrCopy(strings.common.fullAddress, displayBuffer, called_from_swap);
c0d02dc2:	4851      	ldr	r0, [pc, #324]	; (c0d02f08 <finalizeParsing+0x288>)
c0d02dc4:	7802      	ldrb	r2, [r0, #0]
c0d02dc6:	4851      	ldr	r0, [pc, #324]	; (c0d02f0c <finalizeParsing+0x28c>)
c0d02dc8:	4629      	mov	r1, r5
c0d02dca:	f7ff feb1 	bl	c0d02b30 <compareOrCopy>
c0d02dce:	e013      	b.n	c0d02df8 <finalizeParsing+0x178>
c0d02dd0:	a808      	add	r0, sp, #32
            switch (pluginFinalize.uiType) {
c0d02dd2:	7f00      	ldrb	r0, [r0, #28]
c0d02dd4:	2801      	cmp	r0, #1
c0d02dd6:	d04a      	beq.n	c0d02e6e <finalizeParsing+0x1ee>
c0d02dd8:	2802      	cmp	r0, #2
c0d02dda:	d176      	bne.n	c0d02eca <finalizeParsing+0x24a>
c0d02ddc:	a808      	add	r0, sp, #32
                    dataContext.tokenContext.pluginUiMaxItems = pluginFinalize.numScreens;
c0d02dde:	7f40      	ldrb	r0, [r0, #29]
c0d02de0:	2141      	movs	r1, #65	; 0x41
c0d02de2:	5450      	strb	r0, [r2, r1]
                    dataPresent = false;
c0d02de4:	4847      	ldr	r0, [pc, #284]	; (c0d02f04 <finalizeParsing+0x284>)
c0d02de6:	2600      	movs	r6, #0
c0d02de8:	7006      	strb	r6, [r0, #0]
c0d02dea:	e025      	b.n	c0d02e38 <finalizeParsing+0x1b8>
        } else {
            strcpy(strings.common.fullAddress, "Contract");
c0d02dec:	4847      	ldr	r0, [pc, #284]	; (c0d02f0c <finalizeParsing+0x28c>)
c0d02dee:	4949      	ldr	r1, [pc, #292]	; (c0d02f14 <finalizeParsing+0x294>)
c0d02df0:	4479      	add	r1, pc
c0d02df2:	2209      	movs	r2, #9
c0d02df4:	f006 fbfe 	bl	c0d095f4 <__aeabi_memcpy>
c0d02df8:	9b05      	ldr	r3, [sp, #20]
c0d02dfa:	2062      	movs	r0, #98	; 0x62
        }
    }
    // Prepare amount to display
    if (genericUI) {
        amountToString(tmpContent.txContent.value.value,
                       tmpContent.txContent.value.length,
c0d02dfc:	5c21      	ldrb	r1, [r4, r0]
c0d02dfe:	2632      	movs	r6, #50	; 0x32
        amountToString(tmpContent.txContent.value.value,
c0d02e00:	4668      	mov	r0, sp
c0d02e02:	6046      	str	r6, [r0, #4]
c0d02e04:	ad10      	add	r5, sp, #64	; 0x40
c0d02e06:	6005      	str	r5, [r0, #0]
c0d02e08:	3442      	adds	r4, #66	; 0x42
c0d02e0a:	4620      	mov	r0, r4
c0d02e0c:	9a04      	ldr	r2, [sp, #16]
c0d02e0e:	f005 fcff 	bl	c0d08810 <amountToString>
                       decimals,
                       (char *) ticker,
                       displayBuffer,
                       sizeof(displayBuffer));
        compareOrCopy(strings.common.fullAmount, displayBuffer, called_from_swap);
c0d02e12:	4f3d      	ldr	r7, [pc, #244]	; (c0d02f08 <finalizeParsing+0x288>)
c0d02e14:	783a      	ldrb	r2, [r7, #0]
c0d02e16:	4c3d      	ldr	r4, [pc, #244]	; (c0d02f0c <finalizeParsing+0x28c>)
c0d02e18:	4620      	mov	r0, r4
c0d02e1a:	302b      	adds	r0, #43	; 0x2b
c0d02e1c:	4629      	mov	r1, r5
c0d02e1e:	f7ff fe87 	bl	c0d02b30 <compareOrCopy>
    }
    // Compute maximum fee
    if (genericUI) {
        computeFees(displayBuffer, sizeof(displayBuffer));
c0d02e22:	4628      	mov	r0, r5
c0d02e24:	4631      	mov	r1, r6
c0d02e26:	f7ff fecf 	bl	c0d02bc8 <computeFees>
        compareOrCopy(strings.common.maxFee, displayBuffer, called_from_swap);
c0d02e2a:	783a      	ldrb	r2, [r7, #0]
c0d02e2c:	345d      	adds	r4, #93	; 0x5d
c0d02e2e:	4620      	mov	r0, r4
c0d02e30:	4629      	mov	r1, r5
c0d02e32:	f7ff fe7d 	bl	c0d02b30 <compareOrCopy>
c0d02e36:	9e06      	ldr	r6, [sp, #24]
    }

    bool no_consent = false;

    no_consent = called_from_swap;
c0d02e38:	4833      	ldr	r0, [pc, #204]	; (c0d02f08 <finalizeParsing+0x288>)
c0d02e3a:	7800      	ldrb	r0, [r0, #0]

#ifdef NO_CONSENT
    no_consent = true;
#endif  // NO_CONSENT

    if (no_consent) {
c0d02e3c:	2800      	cmp	r0, #0
c0d02e3e:	d003      	beq.n	c0d02e48 <finalizeParsing+0x1c8>
c0d02e40:	2000      	movs	r0, #0
        io_seproxyhal_touch_tx_ok(NULL);
c0d02e42:	f003 fc7b 	bl	c0d0673c <io_seproxyhal_touch_tx_ok>
c0d02e46:	e04e      	b.n	c0d02ee6 <finalizeParsing+0x266>
    } else {
        if (genericUI) {
c0d02e48:	2e00      	cmp	r6, #0
c0d02e4a:	d00d      	beq.n	c0d02e68 <finalizeParsing+0x1e8>
            ux_flow_init(
                0,
                ((dataPresent && !N_storage.contractDetails) ? ux_approval_tx_data_warning_flow
c0d02e4c:	482d      	ldr	r0, [pc, #180]	; (c0d02f04 <finalizeParsing+0x284>)
c0d02e4e:	7800      	ldrb	r0, [r0, #0]
c0d02e50:	2800      	cmp	r0, #0
c0d02e52:	d006      	beq.n	c0d02e62 <finalizeParsing+0x1e2>
c0d02e54:	4830      	ldr	r0, [pc, #192]	; (c0d02f18 <finalizeParsing+0x298>)
c0d02e56:	4478      	add	r0, pc
c0d02e58:	f001 fdbc 	bl	c0d049d4 <pic>
c0d02e5c:	7840      	ldrb	r0, [r0, #1]
c0d02e5e:	2800      	cmp	r0, #0
c0d02e60:	d03b      	beq.n	c0d02eda <finalizeParsing+0x25a>
c0d02e62:	492f      	ldr	r1, [pc, #188]	; (c0d02f20 <finalizeParsing+0x2a0>)
c0d02e64:	4479      	add	r1, pc
c0d02e66:	e03a      	b.n	c0d02ede <finalizeParsing+0x25e>
                                                             : ux_approval_tx_flow),
                NULL);
        } else {
            plugin_ui_start();
c0d02e68:	f7ff fbca 	bl	c0d02600 <plugin_ui_start>
c0d02e6c:	e03b      	b.n	c0d02ee6 <finalizeParsing+0x266>
c0d02e6e:	9102      	str	r1, [sp, #8]
                    dataPresent = false;
c0d02e70:	4824      	ldr	r0, [pc, #144]	; (c0d02f04 <finalizeParsing+0x284>)
c0d02e72:	2100      	movs	r1, #0
c0d02e74:	7001      	strb	r1, [r0, #0]
                    if ((pluginFinalize.amount == NULL) || (pluginFinalize.address == NULL)) {
c0d02e76:	990d      	ldr	r1, [sp, #52]	; 0x34
c0d02e78:	2900      	cmp	r1, #0
c0d02e7a:	d002      	beq.n	c0d02e82 <finalizeParsing+0x202>
c0d02e7c:	9c0e      	ldr	r4, [sp, #56]	; 0x38
c0d02e7e:	2c00      	cmp	r4, #0
c0d02e80:	d108      	bne.n	c0d02e94 <finalizeParsing+0x214>
c0d02e82:	9c07      	ldr	r4, [sp, #28]
                        reportFinalizeError(direct);
c0d02e84:	4620      	mov	r0, r4
c0d02e86:	f7ff fe8f 	bl	c0d02ba8 <reportFinalizeError>
                        if (!direct) {
c0d02e8a:	2c00      	cmp	r4, #0
c0d02e8c:	d02b      	beq.n	c0d02ee6 <finalizeParsing+0x266>
                    memmove(tmpContent.txContent.destination, pluginFinalize.address, 20);
c0d02e8e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
                    memmove(tmpContent.txContent.value.value, pluginFinalize.amount, 32);
c0d02e90:	990d      	ldr	r1, [sp, #52]	; 0x34
c0d02e92:	9d03      	ldr	r5, [sp, #12]
c0d02e94:	4f17      	ldr	r7, [pc, #92]	; (c0d02ef4 <finalizeParsing+0x274>)
c0d02e96:	4638      	mov	r0, r7
c0d02e98:	3042      	adds	r0, #66	; 0x42
c0d02e9a:	462a      	mov	r2, r5
c0d02e9c:	f006 fbae 	bl	c0d095fc <__aeabi_memmove>
c0d02ea0:	2062      	movs	r0, #98	; 0x62
                    tmpContent.txContent.value.length = 32;
c0d02ea2:	543d      	strb	r5, [r7, r0]
                    memmove(tmpContent.txContent.destination, pluginFinalize.address, 20);
c0d02ea4:	4638      	mov	r0, r7
c0d02ea6:	3063      	adds	r0, #99	; 0x63
c0d02ea8:	2514      	movs	r5, #20
c0d02eaa:	4621      	mov	r1, r4
c0d02eac:	462a      	mov	r2, r5
c0d02eae:	f006 fba5 	bl	c0d095fc <__aeabi_memmove>
c0d02eb2:	2077      	movs	r0, #119	; 0x77
                    tmpContent.txContent.destinationLength = 20;
c0d02eb4:	543d      	strb	r5, [r7, r0]
c0d02eb6:	9902      	ldr	r1, [sp, #8]
                    if (token1 != NULL) {
c0d02eb8:	2900      	cmp	r1, #0
c0d02eba:	d016      	beq.n	c0d02eea <finalizeParsing+0x26a>
                        decimals = token1->decimals;
c0d02ebc:	9803      	ldr	r0, [sp, #12]
c0d02ebe:	5c08      	ldrb	r0, [r1, r0]
                        ticker = token1->ticker;
c0d02ec0:	9004      	str	r0, [sp, #16]
c0d02ec2:	3114      	adds	r1, #20
c0d02ec4:	9c06      	ldr	r4, [sp, #24]
c0d02ec6:	9105      	str	r1, [sp, #20]
c0d02ec8:	e010      	b.n	c0d02eec <finalizeParsing+0x26c>
c0d02eca:	9c07      	ldr	r4, [sp, #28]
                    reportFinalizeError(direct);
c0d02ecc:	4620      	mov	r0, r4
c0d02ece:	f7ff fe6b 	bl	c0d02ba8 <reportFinalizeError>
                    if (!direct) {
c0d02ed2:	2c00      	cmp	r4, #0
c0d02ed4:	d007      	beq.n	c0d02ee6 <finalizeParsing+0x266>
c0d02ed6:	2400      	movs	r4, #0
c0d02ed8:	e74e      	b.n	c0d02d78 <finalizeParsing+0xf8>
c0d02eda:	4910      	ldr	r1, [pc, #64]	; (c0d02f1c <finalizeParsing+0x29c>)
c0d02edc:	4479      	add	r1, pc
c0d02ede:	2000      	movs	r0, #0
            ux_flow_init(
c0d02ee0:	4602      	mov	r2, r0
c0d02ee2:	f005 fe57 	bl	c0d08b94 <ux_flow_init>
        }
    }
}
c0d02ee6:	b01d      	add	sp, #116	; 0x74
c0d02ee8:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02eea:	9c06      	ldr	r4, [sp, #24]
c0d02eec:	4f00      	ldr	r7, [pc, #0]	; (c0d02ef0 <finalizeParsing+0x270>)
c0d02eee:	e743      	b.n	c0d02d78 <finalizeParsing+0xf8>
c0d02ef0:	20001b3c 	.word	0x20001b3c
c0d02ef4:	200018dc 	.word	0x200018dc
c0d02ef8:	20001804 	.word	0x20001804
c0d02efc:	20001cb8 	.word	0x20001cb8
c0d02f00:	20001b40 	.word	0x20001b40
c0d02f04:	20001e60 	.word	0x20001e60
c0d02f08:	2000189c 	.word	0x2000189c
c0d02f0c:	20001c26 	.word	0x20001c26
c0d02f10:	0000897a 	.word	0x0000897a
c0d02f14:	00006fb0 	.word	0x00006fb0
c0d02f18:	000088a6 	.word	0x000088a6
c0d02f1c:	00007cf0 	.word	0x00007cf0
c0d02f20:	00007d4c 	.word	0x00007d4c

c0d02f24 <set_result_get_stark_publicKey>:
#ifdef HAVE_STARKWARE

#include "shared_context.h"
#include "feature_stark_getPublicKey.h"

uint32_t set_result_get_stark_publicKey() {
c0d02f24:	b510      	push	{r4, lr}
    uint32_t tx = 0;
    memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.publicKey.W, 65);
c0d02f26:	4904      	ldr	r1, [pc, #16]	; (c0d02f38 <set_result_get_stark_publicKey+0x14>)
c0d02f28:	3108      	adds	r1, #8
c0d02f2a:	4804      	ldr	r0, [pc, #16]	; (c0d02f3c <set_result_get_stark_publicKey+0x18>)
c0d02f2c:	2441      	movs	r4, #65	; 0x41
c0d02f2e:	4622      	mov	r2, r4
c0d02f30:	f006 fb60 	bl	c0d095f4 <__aeabi_memcpy>
    tx += 65;
    return tx;
c0d02f34:	4620      	mov	r0, r4
c0d02f36:	bd10      	pop	{r4, pc}
c0d02f38:	20001804 	.word	0x20001804
c0d02f3c:	20001e61 	.word	0x20001e61

c0d02f40 <reset_app_context>:
void reset_app_context() {
c0d02f40:	b580      	push	{r7, lr}
c0d02f42:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d02f44:	4908      	ldr	r1, [pc, #32]	; (c0d02f68 <reset_app_context+0x28>)
c0d02f46:	2200      	movs	r2, #0
c0d02f48:	520a      	strh	r2, [r1, r0]
    appState = APP_STATE_IDLE;
c0d02f4a:	4808      	ldr	r0, [pc, #32]	; (c0d02f6c <reset_app_context+0x2c>)
c0d02f4c:	7002      	strb	r2, [r0, #0]
    called_from_swap = false;
c0d02f4e:	4808      	ldr	r0, [pc, #32]	; (c0d02f70 <reset_app_context+0x30>)
c0d02f50:	7002      	strb	r2, [r0, #0]
    quantumSet = false;
c0d02f52:	4808      	ldr	r0, [pc, #32]	; (c0d02f74 <reset_app_context+0x34>)
c0d02f54:	7002      	strb	r2, [r0, #0]
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d02f56:	4808      	ldr	r0, [pc, #32]	; (c0d02f78 <reset_app_context+0x38>)
c0d02f58:	213c      	movs	r1, #60	; 0x3c
c0d02f5a:	f006 fb45 	bl	c0d095e8 <__aeabi_memclr>
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d02f5e:	4807      	ldr	r0, [pc, #28]	; (c0d02f7c <reset_app_context+0x3c>)
c0d02f60:	2180      	movs	r1, #128	; 0x80
c0d02f62:	f006 fb41 	bl	c0d095e8 <__aeabi_memclr>
}
c0d02f66:	bd80      	pop	{r7, pc}
c0d02f68:	20001804 	.word	0x20001804
c0d02f6c:	20001800 	.word	0x20001800
c0d02f70:	2000189c 	.word	0x2000189c
c0d02f74:	2000189d 	.word	0x2000189d
c0d02f78:	200018a0 	.word	0x200018a0
c0d02f7c:	200018dc 	.word	0x200018dc

c0d02f80 <ui_idle>:
void ui_idle(void) {
c0d02f80:	b580      	push	{r7, lr}
    if (G_ux.stack_count == 0) {
c0d02f82:	4806      	ldr	r0, [pc, #24]	; (c0d02f9c <ui_idle+0x1c>)
c0d02f84:	7800      	ldrb	r0, [r0, #0]
c0d02f86:	2800      	cmp	r0, #0
c0d02f88:	d101      	bne.n	c0d02f8e <ui_idle+0xe>
        ux_stack_push();
c0d02f8a:	f006 f9bf 	bl	c0d0930c <ux_stack_push>
    ux_flow_init(0, ux_idle_flow, NULL);
c0d02f8e:	4904      	ldr	r1, [pc, #16]	; (c0d02fa0 <ui_idle+0x20>)
c0d02f90:	4479      	add	r1, pc
c0d02f92:	2000      	movs	r0, #0
c0d02f94:	4602      	mov	r2, r0
c0d02f96:	f005 fdfd 	bl	c0d08b94 <ux_flow_init>
}
c0d02f9a:	bd80      	pop	{r7, pc}
c0d02f9c:	2000195c 	.word	0x2000195c
c0d02fa0:	00007684 	.word	0x00007684

c0d02fa4 <io_seproxyhal_send_status>:
void io_seproxyhal_send_status(uint32_t sw) {
c0d02fa4:	b580      	push	{r7, lr}
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0d02fa6:	4904      	ldr	r1, [pc, #16]	; (c0d02fb8 <io_seproxyhal_send_status+0x14>)
    G_io_apdu_buffer[1] = (sw & 0xff);
c0d02fa8:	7048      	strb	r0, [r1, #1]
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0d02faa:	0a00      	lsrs	r0, r0, #8
c0d02fac:	7008      	strb	r0, [r1, #0]
c0d02fae:	2020      	movs	r0, #32
c0d02fb0:	2102      	movs	r1, #2
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d02fb2:	f001 f86f 	bl	c0d04094 <io_exchange>
}
c0d02fb6:	bd80      	pop	{r7, pc}
c0d02fb8:	20001e61 	.word	0x20001e61

c0d02fbc <format_signature_out>:
void format_signature_out(const uint8_t *signature) {
c0d02fbc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02fbe:	b081      	sub	sp, #4
c0d02fc0:	4604      	mov	r4, r0
    memset(G_io_apdu_buffer + 1, 0x00, 64);
c0d02fc2:	4817      	ldr	r0, [pc, #92]	; (c0d03020 <format_signature_out+0x64>)
c0d02fc4:	1c40      	adds	r0, r0, #1
c0d02fc6:	2140      	movs	r1, #64	; 0x40
c0d02fc8:	f006 fb0e 	bl	c0d095e8 <__aeabi_memclr>
    uint8_t xlength = signature[xoffset - 1];
c0d02fcc:	78e0      	ldrb	r0, [r4, #3]
    if (xlength == 33) {
c0d02fce:	2821      	cmp	r0, #33	; 0x21
c0d02fd0:	d001      	beq.n	c0d02fd6 <format_signature_out+0x1a>
c0d02fd2:	2704      	movs	r7, #4
c0d02fd4:	e000      	b.n	c0d02fd8 <format_signature_out+0x1c>
c0d02fd6:	2705      	movs	r7, #5
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0d02fd8:	19e1      	adds	r1, r4, r7
c0d02fda:	2520      	movs	r5, #32
    if (xlength == 33) {
c0d02fdc:	2821      	cmp	r0, #33	; 0x21
c0d02fde:	462e      	mov	r6, r5
c0d02fe0:	d000      	beq.n	c0d02fe4 <format_signature_out+0x28>
c0d02fe2:	4606      	mov	r6, r0
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0d02fe4:	480e      	ldr	r0, [pc, #56]	; (c0d03020 <format_signature_out+0x64>)
c0d02fe6:	1b80      	subs	r0, r0, r6
c0d02fe8:	3021      	adds	r0, #33	; 0x21
c0d02fea:	4632      	mov	r2, r6
c0d02fec:	f006 fb06 	bl	c0d095fc <__aeabi_memmove>
    xoffset += xlength + 2;  // move over rvalue and TagLEn
c0d02ff0:	1cb8      	adds	r0, r7, #2
c0d02ff2:	1981      	adds	r1, r0, r6
    xlength = signature[xoffset - 1];
c0d02ff4:	b2c8      	uxtb	r0, r1
c0d02ff6:	1820      	adds	r0, r4, r0
c0d02ff8:	2200      	movs	r2, #0
c0d02ffa:	43d2      	mvns	r2, r2
c0d02ffc:	5c80      	ldrb	r0, [r0, r2]
    if (xlength == 33) {
c0d02ffe:	2821      	cmp	r0, #33	; 0x21
c0d03000:	d100      	bne.n	c0d03004 <format_signature_out+0x48>
c0d03002:	1c49      	adds	r1, r1, #1
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0d03004:	b2c9      	uxtb	r1, r1
c0d03006:	1861      	adds	r1, r4, r1
    if (xlength == 33) {
c0d03008:	2821      	cmp	r0, #33	; 0x21
c0d0300a:	d000      	beq.n	c0d0300e <format_signature_out+0x52>
c0d0300c:	4605      	mov	r5, r0
    memmove(G_io_apdu_buffer + offset + 32 - xlength, signature + xoffset, xlength);
c0d0300e:	4804      	ldr	r0, [pc, #16]	; (c0d03020 <format_signature_out+0x64>)
c0d03010:	1b40      	subs	r0, r0, r5
c0d03012:	3041      	adds	r0, #65	; 0x41
c0d03014:	462a      	mov	r2, r5
c0d03016:	f006 faf1 	bl	c0d095fc <__aeabi_memmove>
}
c0d0301a:	b001      	add	sp, #4
c0d0301c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0301e:	46c0      	nop			; (mov r8, r8)
c0d03020:	20001e61 	.word	0x20001e61

c0d03024 <io_exchange_al>:
unsigned short io_exchange_al(unsigned char channel, unsigned short tx_len) {
c0d03024:	b5b0      	push	{r4, r5, r7, lr}
c0d03026:	4605      	mov	r5, r0
c0d03028:	2007      	movs	r0, #7
    switch (channel & ~(IO_FLAGS)) {
c0d0302a:	4028      	ands	r0, r5
c0d0302c:	2400      	movs	r4, #0
c0d0302e:	2801      	cmp	r0, #1
c0d03030:	d012      	beq.n	c0d03058 <io_exchange_al+0x34>
c0d03032:	2802      	cmp	r0, #2
c0d03034:	d112      	bne.n	c0d0305c <io_exchange_al+0x38>
            if (tx_len) {
c0d03036:	2900      	cmp	r1, #0
c0d03038:	d007      	beq.n	c0d0304a <io_exchange_al+0x26>
                io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);
c0d0303a:	480a      	ldr	r0, [pc, #40]	; (c0d03064 <io_exchange_al+0x40>)
c0d0303c:	f002 fd5a 	bl	c0d05af4 <io_seph_send>
                if (channel & IO_RESET_AFTER_REPLIED) {
c0d03040:	0628      	lsls	r0, r5, #24
c0d03042:	d509      	bpl.n	c0d03058 <io_exchange_al+0x34>
                    reset();
c0d03044:	f002 fbb8 	bl	c0d057b8 <halt>
c0d03048:	e006      	b.n	c0d03058 <io_exchange_al+0x34>
c0d0304a:	21ff      	movs	r1, #255	; 0xff
c0d0304c:	3152      	adds	r1, #82	; 0x52
                return io_seproxyhal_spi_recv(G_io_apdu_buffer, sizeof(G_io_apdu_buffer), 0);
c0d0304e:	4805      	ldr	r0, [pc, #20]	; (c0d03064 <io_exchange_al+0x40>)
c0d03050:	2200      	movs	r2, #0
c0d03052:	f002 fd67 	bl	c0d05b24 <io_seph_recv>
c0d03056:	4604      	mov	r4, r0
}
c0d03058:	4620      	mov	r0, r4
c0d0305a:	bdb0      	pop	{r4, r5, r7, pc}
c0d0305c:	2002      	movs	r0, #2
            THROW(INVALID_PARAMETER);
c0d0305e:	f000 fcd0 	bl	c0d03a02 <os_longjmp>
c0d03062:	46c0      	nop			; (mov r8, r8)
c0d03064:	20001e61 	.word	0x20001e61

c0d03068 <getKnownToken>:
tokenDefinition_t *getKnownToken(uint8_t *contractAddress) {
c0d03068:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0306a:	b081      	sub	sp, #4
c0d0306c:	4605      	mov	r5, r0
c0d0306e:	4e0c      	ldr	r6, [pc, #48]	; (c0d030a0 <getKnownToken+0x38>)
c0d03070:	4634      	mov	r4, r6
c0d03072:	344c      	adds	r4, #76	; 0x4c
c0d03074:	2700      	movs	r7, #0
        if (tmpCtx.transactionContext.tokenSet[i] &&
c0d03076:	19f0      	adds	r0, r6, r7
c0d03078:	218e      	movs	r1, #142	; 0x8e
c0d0307a:	5c40      	ldrb	r0, [r0, r1]
c0d0307c:	2800      	cmp	r0, #0
c0d0307e:	d006      	beq.n	c0d0308e <getKnownToken+0x26>
c0d03080:	2214      	movs	r2, #20
            (memcmp(currentToken->address, contractAddress, 20) == 0)) {
c0d03082:	4620      	mov	r0, r4
c0d03084:	4629      	mov	r1, r5
c0d03086:	f006 fac9 	bl	c0d0961c <memcmp>
        if (tmpCtx.transactionContext.tokenSet[i] &&
c0d0308a:	2800      	cmp	r0, #0
c0d0308c:	d004      	beq.n	c0d03098 <getKnownToken+0x30>
    for (size_t i = 0; i < MAX_TOKEN; i++) {
c0d0308e:	3421      	adds	r4, #33	; 0x21
c0d03090:	1c7f      	adds	r7, r7, #1
c0d03092:	2f02      	cmp	r7, #2
c0d03094:	d3ef      	bcc.n	c0d03076 <getKnownToken+0xe>
c0d03096:	2400      	movs	r4, #0
}
c0d03098:	4620      	mov	r0, r4
c0d0309a:	b001      	add	sp, #4
c0d0309c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0309e:	46c0      	nop			; (mov r8, r8)
c0d030a0:	20001804 	.word	0x20001804

c0d030a4 <handleApdu>:
void handleApdu(unsigned int *flags, unsigned int *tx) {
c0d030a4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d030a6:	b08f      	sub	sp, #60	; 0x3c
c0d030a8:	460c      	mov	r4, r1
c0d030aa:	4605      	mov	r5, r0
c0d030ac:	af03      	add	r7, sp, #12
        TRY {
c0d030ae:	4638      	mov	r0, r7
c0d030b0:	f006 fbd4 	bl	c0d0985c <setjmp>
c0d030b4:	85b8      	strh	r0, [r7, #44]	; 0x2c
c0d030b6:	b287      	uxth	r7, r0
c0d030b8:	2f00      	cmp	r7, #0
c0d030ba:	d027      	beq.n	c0d0310c <handleApdu+0x68>
c0d030bc:	2f10      	cmp	r7, #16
c0d030be:	d100      	bne.n	c0d030c2 <handleApdu+0x1e>
c0d030c0:	e0e9      	b.n	c0d03296 <handleApdu+0x1f2>
c0d030c2:	4606      	mov	r6, r0
c0d030c4:	a803      	add	r0, sp, #12
c0d030c6:	2500      	movs	r5, #0
        CATCH_OTHER(e) {
c0d030c8:	8585      	strh	r5, [r0, #44]	; 0x2c
c0d030ca:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d030cc:	f002 fd46 	bl	c0d05b5c <try_context_set>
c0d030d0:	200f      	movs	r0, #15
c0d030d2:	0300      	lsls	r0, r0, #12
            switch (e & 0xF000) {
c0d030d4:	4030      	ands	r0, r6
c0d030d6:	2109      	movs	r1, #9
c0d030d8:	0309      	lsls	r1, r1, #12
c0d030da:	4288      	cmp	r0, r1
c0d030dc:	d014      	beq.n	c0d03108 <handleApdu+0x64>
c0d030de:	2103      	movs	r1, #3
c0d030e0:	0349      	lsls	r1, r1, #13
c0d030e2:	4288      	cmp	r0, r1
c0d030e4:	d13e      	bne.n	c0d03164 <handleApdu+0xc0>
c0d030e6:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d030e8:	4974      	ldr	r1, [pc, #464]	; (c0d032bc <handleApdu+0x218>)
c0d030ea:	520d      	strh	r5, [r1, r0]
    appState = APP_STATE_IDLE;
c0d030ec:	4874      	ldr	r0, [pc, #464]	; (c0d032c0 <handleApdu+0x21c>)
c0d030ee:	7005      	strb	r5, [r0, #0]
    called_from_swap = false;
c0d030f0:	4874      	ldr	r0, [pc, #464]	; (c0d032c4 <handleApdu+0x220>)
c0d030f2:	7005      	strb	r5, [r0, #0]
    quantumSet = false;
c0d030f4:	4874      	ldr	r0, [pc, #464]	; (c0d032c8 <handleApdu+0x224>)
c0d030f6:	7005      	strb	r5, [r0, #0]
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d030f8:	4874      	ldr	r0, [pc, #464]	; (c0d032cc <handleApdu+0x228>)
c0d030fa:	213c      	movs	r1, #60	; 0x3c
c0d030fc:	f006 fa74 	bl	c0d095e8 <__aeabi_memclr>
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d03100:	4873      	ldr	r0, [pc, #460]	; (c0d032d0 <handleApdu+0x22c>)
c0d03102:	2180      	movs	r1, #128	; 0x80
c0d03104:	f006 fa70 	bl	c0d095e8 <__aeabi_memclr>
c0d03108:	0a38      	lsrs	r0, r7, #8
c0d0310a:	e03f      	b.n	c0d0318c <handleApdu+0xe8>
c0d0310c:	a803      	add	r0, sp, #12
        TRY {
c0d0310e:	f002 fd25 	bl	c0d05b5c <try_context_set>
c0d03112:	900d      	str	r0, [sp, #52]	; 0x34
            if (G_io_apdu_buffer[OFFSET_CLA] == STARKWARE_CLA) {
c0d03114:	4a68      	ldr	r2, [pc, #416]	; (c0d032b8 <handleApdu+0x214>)
c0d03116:	7810      	ldrb	r0, [r2, #0]
c0d03118:	28e0      	cmp	r0, #224	; 0xe0
c0d0311a:	d011      	beq.n	c0d03140 <handleApdu+0x9c>
c0d0311c:	28f0      	cmp	r0, #240	; 0xf0
c0d0311e:	d000      	beq.n	c0d03122 <handleApdu+0x7e>
c0d03120:	e0c2      	b.n	c0d032a8 <handleApdu+0x204>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03122:	7850      	ldrb	r0, [r2, #1]
c0d03124:	2807      	cmp	r0, #7
c0d03126:	dc48      	bgt.n	c0d031ba <handleApdu+0x116>
c0d03128:	2802      	cmp	r0, #2
c0d0312a:	d160      	bne.n	c0d031ee <handleApdu+0x14a>
                                                    G_io_apdu_buffer[OFFSET_LC],
c0d0312c:	7913      	ldrb	r3, [r2, #4]
                                                    G_io_apdu_buffer[OFFSET_P2],
c0d0312e:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareGetPublicKey(G_io_apdu_buffer[OFFSET_P1],
c0d03130:	7890      	ldrb	r0, [r2, #2]
c0d03132:	466e      	mov	r6, sp
c0d03134:	6035      	str	r5, [r6, #0]
c0d03136:	6074      	str	r4, [r6, #4]
c0d03138:	1d52      	adds	r2, r2, #5
c0d0313a:	f7fd fc25 	bl	c0d00988 <handleStarkwareGetPublicKey>
c0d0313e:	e06d      	b.n	c0d0321c <handleApdu+0x178>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03140:	7850      	ldrb	r0, [r2, #1]
c0d03142:	2807      	cmp	r0, #7
c0d03144:	dc45      	bgt.n	c0d031d2 <handleApdu+0x12e>
c0d03146:	2802      	cmp	r0, #2
c0d03148:	d06d      	beq.n	c0d03226 <handleApdu+0x182>
c0d0314a:	2804      	cmp	r0, #4
c0d0314c:	d000      	beq.n	c0d03150 <handleApdu+0xac>
c0d0314e:	e086      	b.n	c0d0325e <handleApdu+0x1ba>
                               G_io_apdu_buffer[OFFSET_LC],
c0d03150:	7913      	ldrb	r3, [r2, #4]
                               G_io_apdu_buffer[OFFSET_P2],
c0d03152:	78d1      	ldrb	r1, [r2, #3]
                    handleSign(G_io_apdu_buffer[OFFSET_P1],
c0d03154:	7890      	ldrb	r0, [r2, #2]
c0d03156:	466e      	mov	r6, sp
c0d03158:	6035      	str	r5, [r6, #0]
c0d0315a:	6074      	str	r4, [r6, #4]
c0d0315c:	1d52      	adds	r2, r2, #5
c0d0315e:	f7fd fb83 	bl	c0d00868 <handleSign>
c0d03162:	e01c      	b.n	c0d0319e <handleApdu+0xfa>
c0d03164:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03166:	4955      	ldr	r1, [pc, #340]	; (c0d032bc <handleApdu+0x218>)
c0d03168:	520d      	strh	r5, [r1, r0]
    appState = APP_STATE_IDLE;
c0d0316a:	4855      	ldr	r0, [pc, #340]	; (c0d032c0 <handleApdu+0x21c>)
c0d0316c:	7005      	strb	r5, [r0, #0]
    called_from_swap = false;
c0d0316e:	4855      	ldr	r0, [pc, #340]	; (c0d032c4 <handleApdu+0x220>)
c0d03170:	7005      	strb	r5, [r0, #0]
    quantumSet = false;
c0d03172:	4855      	ldr	r0, [pc, #340]	; (c0d032c8 <handleApdu+0x224>)
c0d03174:	7005      	strb	r5, [r0, #0]
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03176:	4855      	ldr	r0, [pc, #340]	; (c0d032cc <handleApdu+0x228>)
c0d03178:	213c      	movs	r1, #60	; 0x3c
c0d0317a:	f006 fa35 	bl	c0d095e8 <__aeabi_memclr>
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d0317e:	4854      	ldr	r0, [pc, #336]	; (c0d032d0 <handleApdu+0x22c>)
c0d03180:	2180      	movs	r1, #128	; 0x80
c0d03182:	f006 fa31 	bl	c0d095e8 <__aeabi_memclr>
                    break;
c0d03186:	0570      	lsls	r0, r6, #21
c0d03188:	0f40      	lsrs	r0, r0, #29
c0d0318a:	3068      	adds	r0, #104	; 0x68
            G_io_apdu_buffer[*tx] = sw >> 8;
c0d0318c:	6821      	ldr	r1, [r4, #0]
c0d0318e:	4a4a      	ldr	r2, [pc, #296]	; (c0d032b8 <handleApdu+0x214>)
c0d03190:	5450      	strb	r0, [r2, r1]
            G_io_apdu_buffer[*tx + 1] = sw;
c0d03192:	6820      	ldr	r0, [r4, #0]
            G_io_apdu_buffer[*tx] = sw >> 8;
c0d03194:	1810      	adds	r0, r2, r0
            G_io_apdu_buffer[*tx + 1] = sw;
c0d03196:	7046      	strb	r6, [r0, #1]
            *tx += 2;
c0d03198:	6820      	ldr	r0, [r4, #0]
c0d0319a:	1c80      	adds	r0, r0, #2
c0d0319c:	6020      	str	r0, [r4, #0]
        FINALLY {
c0d0319e:	f002 fcd1 	bl	c0d05b44 <try_context_get>
c0d031a2:	a903      	add	r1, sp, #12
c0d031a4:	4288      	cmp	r0, r1
c0d031a6:	d102      	bne.n	c0d031ae <handleApdu+0x10a>
c0d031a8:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d031aa:	f002 fcd7 	bl	c0d05b5c <try_context_set>
c0d031ae:	a803      	add	r0, sp, #12
    END_TRY;
c0d031b0:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d031b2:	2800      	cmp	r0, #0
c0d031b4:	d035      	beq.n	c0d03222 <handleApdu+0x17e>
c0d031b6:	f000 fc24 	bl	c0d03a02 <os_longjmp>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d031ba:	2808      	cmp	r0, #8
c0d031bc:	d123      	bne.n	c0d03206 <handleApdu+0x162>
                                                      G_io_apdu_buffer[OFFSET_LC],
c0d031be:	7913      	ldrb	r3, [r2, #4]
                                                      G_io_apdu_buffer[OFFSET_P2],
c0d031c0:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareProvideQuantum(G_io_apdu_buffer[OFFSET_P1],
c0d031c2:	7890      	ldrb	r0, [r2, #2]
c0d031c4:	466e      	mov	r6, sp
c0d031c6:	6035      	str	r5, [r6, #0]
c0d031c8:	6074      	str	r4, [r6, #4]
c0d031ca:	1d52      	adds	r2, r2, #5
c0d031cc:	f7fd fc5a 	bl	c0d00a84 <handleStarkwareProvideQuantum>
c0d031d0:	e024      	b.n	c0d0321c <handleApdu+0x178>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d031d2:	2808      	cmp	r0, #8
c0d031d4:	d035      	beq.n	c0d03242 <handleApdu+0x19e>
c0d031d6:	280a      	cmp	r0, #10
c0d031d8:	d14d      	bne.n	c0d03276 <handleApdu+0x1d2>
                                                       G_io_apdu_buffer[OFFSET_LC],
c0d031da:	7913      	ldrb	r3, [r2, #4]
                                                       G_io_apdu_buffer[OFFSET_P2],
c0d031dc:	78d1      	ldrb	r1, [r2, #3]
                    handleProvideErc20TokenInformation(G_io_apdu_buffer[OFFSET_P1],
c0d031de:	7890      	ldrb	r0, [r2, #2]
c0d031e0:	466e      	mov	r6, sp
c0d031e2:	6035      	str	r5, [r6, #0]
c0d031e4:	6074      	str	r4, [r6, #4]
c0d031e6:	1d52      	adds	r2, r2, #5
c0d031e8:	f7fd f940 	bl	c0d0046c <handleProvideErc20TokenInformation>
c0d031ec:	e7d7      	b.n	c0d0319e <handleApdu+0xfa>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d031ee:	2804      	cmp	r0, #4
c0d031f0:	d15e      	bne.n	c0d032b0 <handleApdu+0x20c>
                                                   G_io_apdu_buffer[OFFSET_LC],
c0d031f2:	7913      	ldrb	r3, [r2, #4]
                                                   G_io_apdu_buffer[OFFSET_P2],
c0d031f4:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareSignMessage(G_io_apdu_buffer[OFFSET_P1],
c0d031f6:	7890      	ldrb	r0, [r2, #2]
c0d031f8:	466e      	mov	r6, sp
c0d031fa:	6035      	str	r5, [r6, #0]
c0d031fc:	6074      	str	r4, [r6, #4]
c0d031fe:	1d52      	adds	r2, r2, #5
c0d03200:	f7fd fcac 	bl	c0d00b5c <handleStarkwareSignMessage>
c0d03204:	e00a      	b.n	c0d0321c <handleApdu+0x178>
                switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03206:	280a      	cmp	r0, #10
c0d03208:	d152      	bne.n	c0d032b0 <handleApdu+0x20c>
                                                  G_io_apdu_buffer[OFFSET_LC],
c0d0320a:	7913      	ldrb	r3, [r2, #4]
                                                  G_io_apdu_buffer[OFFSET_P2],
c0d0320c:	78d1      	ldrb	r1, [r2, #3]
                        handleStarkwareUnsafeSign(G_io_apdu_buffer[OFFSET_P1],
c0d0320e:	7890      	ldrb	r0, [r2, #2]
c0d03210:	466e      	mov	r6, sp
c0d03212:	6035      	str	r5, [r6, #0]
c0d03214:	6074      	str	r4, [r6, #4]
c0d03216:	1d52      	adds	r2, r2, #5
c0d03218:	f7fd ff90 	bl	c0d0113c <handleStarkwareUnsafeSign>
                CLOSE_TRY;
c0d0321c:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d0321e:	f002 fc9d 	bl	c0d05b5c <try_context_set>
}
c0d03222:	b00f      	add	sp, #60	; 0x3c
c0d03224:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03226:	208e      	movs	r0, #142	; 0x8e
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03228:	4924      	ldr	r1, [pc, #144]	; (c0d032bc <handleApdu+0x218>)
c0d0322a:	2300      	movs	r3, #0
c0d0322c:	520b      	strh	r3, [r1, r0]
                                       G_io_apdu_buffer[OFFSET_LC],
c0d0322e:	7913      	ldrb	r3, [r2, #4]
                                       G_io_apdu_buffer[OFFSET_P2],
c0d03230:	78d1      	ldrb	r1, [r2, #3]
                    handleGetPublicKey(G_io_apdu_buffer[OFFSET_P1],
c0d03232:	7890      	ldrb	r0, [r2, #2]
c0d03234:	466e      	mov	r6, sp
c0d03236:	6035      	str	r5, [r6, #0]
c0d03238:	6074      	str	r4, [r6, #4]
c0d0323a:	1d52      	adds	r2, r2, #5
c0d0323c:	f7fd f878 	bl	c0d00330 <handleGetPublicKey>
c0d03240:	e7ad      	b.n	c0d0319e <handleApdu+0xfa>
c0d03242:	208e      	movs	r0, #142	; 0x8e
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03244:	491d      	ldr	r1, [pc, #116]	; (c0d032bc <handleApdu+0x218>)
c0d03246:	2300      	movs	r3, #0
c0d03248:	520b      	strh	r3, [r1, r0]
                                              G_io_apdu_buffer[OFFSET_LC],
c0d0324a:	7913      	ldrb	r3, [r2, #4]
                                              G_io_apdu_buffer[OFFSET_P2],
c0d0324c:	78d1      	ldrb	r1, [r2, #3]
                    handleSignPersonalMessage(G_io_apdu_buffer[OFFSET_P1],
c0d0324e:	7890      	ldrb	r0, [r2, #2]
c0d03250:	466e      	mov	r6, sp
c0d03252:	6035      	str	r5, [r6, #0]
c0d03254:	6074      	str	r4, [r6, #4]
c0d03256:	1d52      	adds	r2, r2, #5
c0d03258:	f7fd f986 	bl	c0d00568 <handleSignPersonalMessage>
c0d0325c:	e79f      	b.n	c0d0319e <handleApdu+0xfa>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d0325e:	2806      	cmp	r0, #6
c0d03260:	d126      	bne.n	c0d032b0 <handleApdu+0x20c>
                                              G_io_apdu_buffer[OFFSET_LC],
c0d03262:	7913      	ldrb	r3, [r2, #4]
                                              G_io_apdu_buffer[OFFSET_P2],
c0d03264:	78d1      	ldrb	r1, [r2, #3]
                    handleGetAppConfiguration(G_io_apdu_buffer[OFFSET_P1],
c0d03266:	7890      	ldrb	r0, [r2, #2]
c0d03268:	466e      	mov	r6, sp
c0d0326a:	6035      	str	r5, [r6, #0]
c0d0326c:	6074      	str	r4, [r6, #4]
c0d0326e:	1d52      	adds	r2, r2, #5
c0d03270:	f7fd f842 	bl	c0d002f8 <handleGetAppConfiguration>
c0d03274:	e793      	b.n	c0d0319e <handleApdu+0xfa>
            switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d03276:	280c      	cmp	r0, #12
c0d03278:	d11a      	bne.n	c0d032b0 <handleApdu+0x20c>
c0d0327a:	208e      	movs	r0, #142	; 0x8e
                    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d0327c:	490f      	ldr	r1, [pc, #60]	; (c0d032bc <handleApdu+0x218>)
c0d0327e:	2300      	movs	r3, #0
c0d03280:	520b      	strh	r3, [r1, r0]
                                            G_io_apdu_buffer[OFFSET_LC],
c0d03282:	7913      	ldrb	r3, [r2, #4]
                                            G_io_apdu_buffer[OFFSET_P2],
c0d03284:	78d1      	ldrb	r1, [r2, #3]
                    handleSignEIP712Message(G_io_apdu_buffer[OFFSET_P1],
c0d03286:	7890      	ldrb	r0, [r2, #2]
c0d03288:	466e      	mov	r6, sp
c0d0328a:	6035      	str	r5, [r6, #0]
c0d0328c:	6074      	str	r4, [r6, #4]
c0d0328e:	1d52      	adds	r2, r2, #5
c0d03290:	f7fd fa88 	bl	c0d007a4 <handleSignEIP712Message>
c0d03294:	e783      	b.n	c0d0319e <handleApdu+0xfa>
c0d03296:	a803      	add	r0, sp, #12
c0d03298:	2100      	movs	r1, #0
        CATCH(EXCEPTION_IO_RESET) {
c0d0329a:	8581      	strh	r1, [r0, #44]	; 0x2c
c0d0329c:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d0329e:	f002 fc5d 	bl	c0d05b5c <try_context_set>
c0d032a2:	2010      	movs	r0, #16
            THROW(EXCEPTION_IO_RESET);
c0d032a4:	f000 fbad 	bl	c0d03a02 <os_longjmp>
c0d032a8:	2037      	movs	r0, #55	; 0x37
c0d032aa:	0240      	lsls	r0, r0, #9
                THROW(0x6E00);
c0d032ac:	f000 fba9 	bl	c0d03a02 <os_longjmp>
c0d032b0:	206d      	movs	r0, #109	; 0x6d
c0d032b2:	0200      	lsls	r0, r0, #8
c0d032b4:	f000 fba5 	bl	c0d03a02 <os_longjmp>
c0d032b8:	20001e61 	.word	0x20001e61
c0d032bc:	20001804 	.word	0x20001804
c0d032c0:	20001800 	.word	0x20001800
c0d032c4:	2000189c 	.word	0x2000189c
c0d032c8:	2000189d 	.word	0x2000189d
c0d032cc:	200018a0 	.word	0x200018a0
c0d032d0:	200018dc 	.word	0x200018dc

c0d032d4 <app_main>:
void app_main(void) {
c0d032d4:	b08e      	sub	sp, #56	; 0x38
c0d032d6:	2400      	movs	r4, #0
    unsigned int tx = 0;
c0d032d8:	940d      	str	r4, [sp, #52]	; 0x34
    unsigned int flags = 0;
c0d032da:	940c      	str	r4, [sp, #48]	; 0x30
c0d032dc:	466f      	mov	r7, sp
            TRY {
c0d032de:	4638      	mov	r0, r7
c0d032e0:	f006 fabc 	bl	c0d0985c <setjmp>
c0d032e4:	85b8      	strh	r0, [r7, #44]	; 0x2c
c0d032e6:	b287      	uxth	r7, r0
c0d032e8:	2f00      	cmp	r7, #0
c0d032ea:	d025      	beq.n	c0d03338 <app_main+0x64>
c0d032ec:	2f10      	cmp	r7, #16
c0d032ee:	d065      	beq.n	c0d033bc <app_main+0xe8>
c0d032f0:	4606      	mov	r6, r0
c0d032f2:	4668      	mov	r0, sp
            CATCH_OTHER(e) {
c0d032f4:	8584      	strh	r4, [r0, #44]	; 0x2c
c0d032f6:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d032f8:	f002 fc30 	bl	c0d05b5c <try_context_set>
c0d032fc:	200f      	movs	r0, #15
c0d032fe:	0300      	lsls	r0, r0, #12
                switch (e & 0xF000) {
c0d03300:	4030      	ands	r0, r6
c0d03302:	2109      	movs	r1, #9
c0d03304:	030d      	lsls	r5, r1, #12
c0d03306:	42a8      	cmp	r0, r5
c0d03308:	d014      	beq.n	c0d03334 <app_main+0x60>
c0d0330a:	2103      	movs	r1, #3
c0d0330c:	0349      	lsls	r1, r1, #13
c0d0330e:	4288      	cmp	r0, r1
c0d03310:	d125      	bne.n	c0d0335e <app_main+0x8a>
c0d03312:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03314:	4930      	ldr	r1, [pc, #192]	; (c0d033d8 <app_main+0x104>)
c0d03316:	520c      	strh	r4, [r1, r0]
    appState = APP_STATE_IDLE;
c0d03318:	4830      	ldr	r0, [pc, #192]	; (c0d033dc <app_main+0x108>)
c0d0331a:	7004      	strb	r4, [r0, #0]
    called_from_swap = false;
c0d0331c:	4830      	ldr	r0, [pc, #192]	; (c0d033e0 <app_main+0x10c>)
c0d0331e:	7004      	strb	r4, [r0, #0]
    quantumSet = false;
c0d03320:	4830      	ldr	r0, [pc, #192]	; (c0d033e4 <app_main+0x110>)
c0d03322:	7004      	strb	r4, [r0, #0]
c0d03324:	213c      	movs	r1, #60	; 0x3c
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03326:	4830      	ldr	r0, [pc, #192]	; (c0d033e8 <app_main+0x114>)
c0d03328:	f006 f95e 	bl	c0d095e8 <__aeabi_memclr>
c0d0332c:	2180      	movs	r1, #128	; 0x80
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d0332e:	482f      	ldr	r0, [pc, #188]	; (c0d033ec <app_main+0x118>)
c0d03330:	f006 f95a 	bl	c0d095e8 <__aeabi_memclr>
c0d03334:	0a38      	lsrs	r0, r7, #8
c0d03336:	e026      	b.n	c0d03386 <app_main+0xb2>
c0d03338:	4668      	mov	r0, sp
            TRY {
c0d0333a:	f002 fc0f 	bl	c0d05b5c <try_context_set>
c0d0333e:	900a      	str	r0, [sp, #40]	; 0x28
c0d03340:	a80d      	add	r0, sp, #52	; 0x34
                rx = tx;
c0d03342:	8801      	ldrh	r1, [r0, #0]
                tx = 0;  // ensure no race in catch_other if io_exchange throws
c0d03344:	940d      	str	r4, [sp, #52]	; 0x34
c0d03346:	a80c      	add	r0, sp, #48	; 0x30
                rx = io_exchange(CHANNEL_APDU | flags, rx);
c0d03348:	7800      	ldrb	r0, [r0, #0]
c0d0334a:	f000 fea3 	bl	c0d04094 <io_exchange>
                flags = 0;
c0d0334e:	940c      	str	r4, [sp, #48]	; 0x30
                if (rx == 0) {
c0d03350:	2800      	cmp	r0, #0
c0d03352:	d03b      	beq.n	c0d033cc <app_main+0xf8>
c0d03354:	a80c      	add	r0, sp, #48	; 0x30
c0d03356:	a90d      	add	r1, sp, #52	; 0x34
                handleApdu(&flags, &tx);
c0d03358:	f7ff fea4 	bl	c0d030a4 <handleApdu>
c0d0335c:	e020      	b.n	c0d033a0 <app_main+0xcc>
c0d0335e:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03360:	491d      	ldr	r1, [pc, #116]	; (c0d033d8 <app_main+0x104>)
c0d03362:	520c      	strh	r4, [r1, r0]
    appState = APP_STATE_IDLE;
c0d03364:	481d      	ldr	r0, [pc, #116]	; (c0d033dc <app_main+0x108>)
c0d03366:	7004      	strb	r4, [r0, #0]
    called_from_swap = false;
c0d03368:	481d      	ldr	r0, [pc, #116]	; (c0d033e0 <app_main+0x10c>)
c0d0336a:	7004      	strb	r4, [r0, #0]
    quantumSet = false;
c0d0336c:	481d      	ldr	r0, [pc, #116]	; (c0d033e4 <app_main+0x110>)
c0d0336e:	7004      	strb	r4, [r0, #0]
c0d03370:	213c      	movs	r1, #60	; 0x3c
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03372:	481d      	ldr	r0, [pc, #116]	; (c0d033e8 <app_main+0x114>)
c0d03374:	f006 f938 	bl	c0d095e8 <__aeabi_memclr>
c0d03378:	2180      	movs	r1, #128	; 0x80
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d0337a:	481c      	ldr	r0, [pc, #112]	; (c0d033ec <app_main+0x118>)
c0d0337c:	f006 f934 	bl	c0d095e8 <__aeabi_memclr>
                        break;
c0d03380:	0570      	lsls	r0, r6, #21
c0d03382:	0f40      	lsrs	r0, r0, #29
c0d03384:	3068      	adds	r0, #104	; 0x68
                if (e != 0x9000) {
c0d03386:	42af      	cmp	r7, r5
c0d03388:	d003      	beq.n	c0d03392 <app_main+0xbe>
c0d0338a:	2110      	movs	r1, #16
                    flags &= ~IO_ASYNCH_REPLY;
c0d0338c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0d0338e:	438a      	bics	r2, r1
c0d03390:	920c      	str	r2, [sp, #48]	; 0x30
                G_io_apdu_buffer[tx] = sw >> 8;
c0d03392:	990d      	ldr	r1, [sp, #52]	; 0x34
c0d03394:	4a16      	ldr	r2, [pc, #88]	; (c0d033f0 <app_main+0x11c>)
c0d03396:	5450      	strb	r0, [r2, r1]
c0d03398:	1850      	adds	r0, r2, r1
                G_io_apdu_buffer[tx + 1] = sw;
c0d0339a:	7046      	strb	r6, [r0, #1]
                tx += 2;
c0d0339c:	1c88      	adds	r0, r1, #2
c0d0339e:	900d      	str	r0, [sp, #52]	; 0x34
            FINALLY {
c0d033a0:	f002 fbd0 	bl	c0d05b44 <try_context_get>
c0d033a4:	4669      	mov	r1, sp
c0d033a6:	4288      	cmp	r0, r1
c0d033a8:	d102      	bne.n	c0d033b0 <app_main+0xdc>
c0d033aa:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d033ac:	f002 fbd6 	bl	c0d05b5c <try_context_set>
c0d033b0:	4668      	mov	r0, sp
        END_TRY;
c0d033b2:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d033b4:	2800      	cmp	r0, #0
c0d033b6:	d091      	beq.n	c0d032dc <app_main+0x8>
c0d033b8:	f000 fb23 	bl	c0d03a02 <os_longjmp>
c0d033bc:	4668      	mov	r0, sp
            CATCH(EXCEPTION_IO_RESET) {
c0d033be:	8584      	strh	r4, [r0, #44]	; 0x2c
c0d033c0:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d033c2:	f002 fbcb 	bl	c0d05b5c <try_context_set>
c0d033c6:	2010      	movs	r0, #16
                THROW(EXCEPTION_IO_RESET);
c0d033c8:	f000 fb1b 	bl	c0d03a02 <os_longjmp>
c0d033cc:	4801      	ldr	r0, [pc, #4]	; (c0d033d4 <app_main+0x100>)
                    THROW(0x6982);
c0d033ce:	f000 fb18 	bl	c0d03a02 <os_longjmp>
c0d033d2:	46c0      	nop			; (mov r8, r8)
c0d033d4:	00006982 	.word	0x00006982
c0d033d8:	20001804 	.word	0x20001804
c0d033dc:	20001800 	.word	0x20001800
c0d033e0:	2000189c 	.word	0x2000189c
c0d033e4:	2000189d 	.word	0x2000189d
c0d033e8:	200018a0 	.word	0x200018a0
c0d033ec:	200018dc 	.word	0x200018dc
c0d033f0:	20001e61 	.word	0x20001e61

c0d033f4 <io_seproxyhal_display>:
void io_seproxyhal_display(const bagl_element_t *element) {
c0d033f4:	b580      	push	{r7, lr}
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d033f6:	f000 fdb5 	bl	c0d03f64 <io_seproxyhal_display_default>
}
c0d033fa:	bd80      	pop	{r7, pc}

c0d033fc <io_event>:
unsigned char io_event(unsigned char channel) {
c0d033fc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d033fe:	b081      	sub	sp, #4
    switch (G_io_seproxyhal_spi_buffer[0]) {
c0d03400:	4de7      	ldr	r5, [pc, #924]	; (c0d037a0 <io_event+0x3a4>)
c0d03402:	7828      	ldrb	r0, [r5, #0]
c0d03404:	280c      	cmp	r0, #12
c0d03406:	dc05      	bgt.n	c0d03414 <io_event+0x18>
c0d03408:	2805      	cmp	r0, #5
c0d0340a:	d100      	bne.n	c0d0340e <io_event+0x12>
c0d0340c:	e098      	b.n	c0d03540 <io_event+0x144>
c0d0340e:	280c      	cmp	r0, #12
c0d03410:	d10d      	bne.n	c0d0342e <io_event+0x32>
c0d03412:	e1b9      	b.n	c0d03788 <io_event+0x38c>
c0d03414:	280d      	cmp	r0, #13
c0d03416:	d100      	bne.n	c0d0341a <io_event+0x1e>
c0d03418:	e0ec      	b.n	c0d035f4 <io_event+0x1f8>
c0d0341a:	2815      	cmp	r0, #21
c0d0341c:	d107      	bne.n	c0d0342e <io_event+0x32>
            if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID &&
c0d0341e:	48e3      	ldr	r0, [pc, #908]	; (c0d037ac <io_event+0x3b0>)
c0d03420:	7980      	ldrb	r0, [r0, #6]
c0d03422:	2801      	cmp	r0, #1
c0d03424:	d103      	bne.n	c0d0342e <io_event+0x32>
                !(U4BE(G_io_seproxyhal_spi_buffer, 3) &
c0d03426:	79a8      	ldrb	r0, [r5, #6]
            if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID &&
c0d03428:	0700      	lsls	r0, r0, #28
c0d0342a:	d400      	bmi.n	c0d0342e <io_event+0x32>
c0d0342c:	e1b5      	b.n	c0d0379a <io_event+0x39e>
            UX_DEFAULT_EVENT();
c0d0342e:	4cdd      	ldr	r4, [pc, #884]	; (c0d037a4 <io_event+0x3a8>)
c0d03430:	2700      	movs	r7, #0
c0d03432:	6067      	str	r7, [r4, #4]
c0d03434:	2001      	movs	r0, #1
c0d03436:	7020      	strb	r0, [r4, #0]
c0d03438:	4620      	mov	r0, r4
c0d0343a:	f002 fb13 	bl	c0d05a64 <os_ux>
c0d0343e:	2004      	movs	r0, #4
c0d03440:	f002 fb98 	bl	c0d05b74 <os_sched_last_status>
c0d03444:	6060      	str	r0, [r4, #4]
c0d03446:	2869      	cmp	r0, #105	; 0x69
c0d03448:	d144      	bne.n	c0d034d4 <io_event+0xd8>
c0d0344a:	f000 fd31 	bl	c0d03eb0 <io_seproxyhal_init_ux>
c0d0344e:	f000 fd31 	bl	c0d03eb4 <io_seproxyhal_init_button>
c0d03452:	25be      	movs	r5, #190	; 0xbe
c0d03454:	4ed4      	ldr	r6, [pc, #848]	; (c0d037a8 <io_event+0x3ac>)
c0d03456:	5377      	strh	r7, [r6, r5]
c0d03458:	2004      	movs	r0, #4
c0d0345a:	f002 fb8b 	bl	c0d05b74 <os_sched_last_status>
c0d0345e:	6060      	str	r0, [r4, #4]
c0d03460:	2800      	cmp	r0, #0
c0d03462:	d100      	bne.n	c0d03466 <io_event+0x6a>
c0d03464:	e190      	b.n	c0d03788 <io_event+0x38c>
c0d03466:	2897      	cmp	r0, #151	; 0x97
c0d03468:	d100      	bne.n	c0d0346c <io_event+0x70>
c0d0346a:	e18d      	b.n	c0d03788 <io_event+0x38c>
c0d0346c:	24c0      	movs	r4, #192	; 0xc0
c0d0346e:	5930      	ldr	r0, [r6, r4]
c0d03470:	2800      	cmp	r0, #0
c0d03472:	d100      	bne.n	c0d03476 <io_event+0x7a>
c0d03474:	e188      	b.n	c0d03788 <io_event+0x38c>
c0d03476:	5b70      	ldrh	r0, [r6, r5]
c0d03478:	21c4      	movs	r1, #196	; 0xc4
c0d0347a:	5c71      	ldrb	r1, [r6, r1]
c0d0347c:	b280      	uxth	r0, r0
c0d0347e:	4288      	cmp	r0, r1
c0d03480:	d300      	bcc.n	c0d03484 <io_event+0x88>
c0d03482:	e181      	b.n	c0d03788 <io_event+0x38c>
c0d03484:	f002 fb42 	bl	c0d05b0c <io_seph_is_status_sent>
c0d03488:	2800      	cmp	r0, #0
c0d0348a:	d000      	beq.n	c0d0348e <io_event+0x92>
c0d0348c:	e17c      	b.n	c0d03788 <io_event+0x38c>
c0d0348e:	f002 fab3 	bl	c0d059f8 <os_perso_isonboarded>
c0d03492:	28aa      	cmp	r0, #170	; 0xaa
c0d03494:	d104      	bne.n	c0d034a0 <io_event+0xa4>
c0d03496:	f002 fad9 	bl	c0d05a4c <os_global_pin_is_validated>
c0d0349a:	28aa      	cmp	r0, #170	; 0xaa
c0d0349c:	d000      	beq.n	c0d034a0 <io_event+0xa4>
c0d0349e:	e173      	b.n	c0d03788 <io_event+0x38c>
c0d034a0:	5930      	ldr	r0, [r6, r4]
c0d034a2:	5b71      	ldrh	r1, [r6, r5]
c0d034a4:	0149      	lsls	r1, r1, #5
c0d034a6:	1840      	adds	r0, r0, r1
c0d034a8:	21cc      	movs	r1, #204	; 0xcc
c0d034aa:	5871      	ldr	r1, [r6, r1]
c0d034ac:	2900      	cmp	r1, #0
c0d034ae:	d002      	beq.n	c0d034b6 <io_event+0xba>
c0d034b0:	4788      	blx	r1
c0d034b2:	2800      	cmp	r0, #0
c0d034b4:	d007      	beq.n	c0d034c6 <io_event+0xca>
c0d034b6:	2801      	cmp	r0, #1
c0d034b8:	d103      	bne.n	c0d034c2 <io_event+0xc6>
c0d034ba:	5930      	ldr	r0, [r6, r4]
c0d034bc:	5b71      	ldrh	r1, [r6, r5]
c0d034be:	0149      	lsls	r1, r1, #5
c0d034c0:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d034c2:	f000 fd4f 	bl	c0d03f64 <io_seproxyhal_display_default>
            UX_DEFAULT_EVENT();
c0d034c6:	5b70      	ldrh	r0, [r6, r5]
c0d034c8:	1c40      	adds	r0, r0, #1
c0d034ca:	5370      	strh	r0, [r6, r5]
c0d034cc:	5931      	ldr	r1, [r6, r4]
c0d034ce:	2900      	cmp	r1, #0
c0d034d0:	d1d2      	bne.n	c0d03478 <io_event+0x7c>
c0d034d2:	e159      	b.n	c0d03788 <io_event+0x38c>
c0d034d4:	25c0      	movs	r5, #192	; 0xc0
c0d034d6:	4cb4      	ldr	r4, [pc, #720]	; (c0d037a8 <io_event+0x3ac>)
c0d034d8:	5960      	ldr	r0, [r4, r5]
c0d034da:	2800      	cmp	r0, #0
c0d034dc:	d100      	bne.n	c0d034e0 <io_event+0xe4>
c0d034de:	e14b      	b.n	c0d03778 <io_event+0x37c>
c0d034e0:	26be      	movs	r6, #190	; 0xbe
c0d034e2:	5ba0      	ldrh	r0, [r4, r6]
c0d034e4:	21c4      	movs	r1, #196	; 0xc4
c0d034e6:	5c61      	ldrb	r1, [r4, r1]
c0d034e8:	b280      	uxth	r0, r0
c0d034ea:	4288      	cmp	r0, r1
c0d034ec:	d300      	bcc.n	c0d034f0 <io_event+0xf4>
c0d034ee:	e143      	b.n	c0d03778 <io_event+0x37c>
c0d034f0:	f002 fb0c 	bl	c0d05b0c <io_seph_is_status_sent>
c0d034f4:	2800      	cmp	r0, #0
c0d034f6:	d000      	beq.n	c0d034fa <io_event+0xfe>
c0d034f8:	e13e      	b.n	c0d03778 <io_event+0x37c>
c0d034fa:	f002 fa7d 	bl	c0d059f8 <os_perso_isonboarded>
c0d034fe:	28aa      	cmp	r0, #170	; 0xaa
c0d03500:	d104      	bne.n	c0d0350c <io_event+0x110>
c0d03502:	f002 faa3 	bl	c0d05a4c <os_global_pin_is_validated>
c0d03506:	28aa      	cmp	r0, #170	; 0xaa
c0d03508:	d000      	beq.n	c0d0350c <io_event+0x110>
c0d0350a:	e135      	b.n	c0d03778 <io_event+0x37c>
c0d0350c:	5960      	ldr	r0, [r4, r5]
c0d0350e:	5ba1      	ldrh	r1, [r4, r6]
c0d03510:	0149      	lsls	r1, r1, #5
c0d03512:	1840      	adds	r0, r0, r1
c0d03514:	21cc      	movs	r1, #204	; 0xcc
c0d03516:	5861      	ldr	r1, [r4, r1]
c0d03518:	2900      	cmp	r1, #0
c0d0351a:	d002      	beq.n	c0d03522 <io_event+0x126>
c0d0351c:	4788      	blx	r1
c0d0351e:	2800      	cmp	r0, #0
c0d03520:	d007      	beq.n	c0d03532 <io_event+0x136>
c0d03522:	2801      	cmp	r0, #1
c0d03524:	d103      	bne.n	c0d0352e <io_event+0x132>
c0d03526:	5960      	ldr	r0, [r4, r5]
c0d03528:	5ba1      	ldrh	r1, [r4, r6]
c0d0352a:	0149      	lsls	r1, r1, #5
c0d0352c:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d0352e:	f000 fd19 	bl	c0d03f64 <io_seproxyhal_display_default>
            UX_DEFAULT_EVENT();
c0d03532:	5ba0      	ldrh	r0, [r4, r6]
c0d03534:	1c40      	adds	r0, r0, #1
c0d03536:	53a0      	strh	r0, [r4, r6]
c0d03538:	5961      	ldr	r1, [r4, r5]
c0d0353a:	2900      	cmp	r1, #0
c0d0353c:	d1d2      	bne.n	c0d034e4 <io_event+0xe8>
c0d0353e:	e11b      	b.n	c0d03778 <io_event+0x37c>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d03540:	4c98      	ldr	r4, [pc, #608]	; (c0d037a4 <io_event+0x3a8>)
c0d03542:	2700      	movs	r7, #0
c0d03544:	6067      	str	r7, [r4, #4]
c0d03546:	2001      	movs	r0, #1
c0d03548:	7020      	strb	r0, [r4, #0]
c0d0354a:	4620      	mov	r0, r4
c0d0354c:	f002 fa8a 	bl	c0d05a64 <os_ux>
c0d03550:	2004      	movs	r0, #4
c0d03552:	f002 fb0f 	bl	c0d05b74 <os_sched_last_status>
c0d03556:	6060      	str	r0, [r4, #4]
c0d03558:	2800      	cmp	r0, #0
c0d0355a:	d100      	bne.n	c0d0355e <io_event+0x162>
c0d0355c:	e114      	b.n	c0d03788 <io_event+0x38c>
c0d0355e:	2897      	cmp	r0, #151	; 0x97
c0d03560:	d100      	bne.n	c0d03564 <io_event+0x168>
c0d03562:	e111      	b.n	c0d03788 <io_event+0x38c>
c0d03564:	2869      	cmp	r0, #105	; 0x69
c0d03566:	d000      	beq.n	c0d0356a <io_event+0x16e>
c0d03568:	e0cd      	b.n	c0d03706 <io_event+0x30a>
c0d0356a:	f000 fca1 	bl	c0d03eb0 <io_seproxyhal_init_ux>
c0d0356e:	f000 fca1 	bl	c0d03eb4 <io_seproxyhal_init_button>
c0d03572:	25be      	movs	r5, #190	; 0xbe
c0d03574:	4e8c      	ldr	r6, [pc, #560]	; (c0d037a8 <io_event+0x3ac>)
c0d03576:	5377      	strh	r7, [r6, r5]
c0d03578:	2004      	movs	r0, #4
c0d0357a:	f002 fafb 	bl	c0d05b74 <os_sched_last_status>
c0d0357e:	6060      	str	r0, [r4, #4]
c0d03580:	2800      	cmp	r0, #0
c0d03582:	d100      	bne.n	c0d03586 <io_event+0x18a>
c0d03584:	e100      	b.n	c0d03788 <io_event+0x38c>
c0d03586:	2897      	cmp	r0, #151	; 0x97
c0d03588:	d100      	bne.n	c0d0358c <io_event+0x190>
c0d0358a:	e0fd      	b.n	c0d03788 <io_event+0x38c>
c0d0358c:	24c0      	movs	r4, #192	; 0xc0
c0d0358e:	5930      	ldr	r0, [r6, r4]
c0d03590:	2800      	cmp	r0, #0
c0d03592:	d100      	bne.n	c0d03596 <io_event+0x19a>
c0d03594:	e0f8      	b.n	c0d03788 <io_event+0x38c>
c0d03596:	5b70      	ldrh	r0, [r6, r5]
c0d03598:	21c4      	movs	r1, #196	; 0xc4
c0d0359a:	5c71      	ldrb	r1, [r6, r1]
c0d0359c:	b280      	uxth	r0, r0
c0d0359e:	4288      	cmp	r0, r1
c0d035a0:	d300      	bcc.n	c0d035a4 <io_event+0x1a8>
c0d035a2:	e0f1      	b.n	c0d03788 <io_event+0x38c>
c0d035a4:	f002 fab2 	bl	c0d05b0c <io_seph_is_status_sent>
c0d035a8:	2800      	cmp	r0, #0
c0d035aa:	d000      	beq.n	c0d035ae <io_event+0x1b2>
c0d035ac:	e0ec      	b.n	c0d03788 <io_event+0x38c>
c0d035ae:	f002 fa23 	bl	c0d059f8 <os_perso_isonboarded>
c0d035b2:	28aa      	cmp	r0, #170	; 0xaa
c0d035b4:	d104      	bne.n	c0d035c0 <io_event+0x1c4>
c0d035b6:	f002 fa49 	bl	c0d05a4c <os_global_pin_is_validated>
c0d035ba:	28aa      	cmp	r0, #170	; 0xaa
c0d035bc:	d000      	beq.n	c0d035c0 <io_event+0x1c4>
c0d035be:	e0e3      	b.n	c0d03788 <io_event+0x38c>
c0d035c0:	5930      	ldr	r0, [r6, r4]
c0d035c2:	5b71      	ldrh	r1, [r6, r5]
c0d035c4:	0149      	lsls	r1, r1, #5
c0d035c6:	1840      	adds	r0, r0, r1
c0d035c8:	21cc      	movs	r1, #204	; 0xcc
c0d035ca:	5871      	ldr	r1, [r6, r1]
c0d035cc:	2900      	cmp	r1, #0
c0d035ce:	d002      	beq.n	c0d035d6 <io_event+0x1da>
c0d035d0:	4788      	blx	r1
c0d035d2:	2800      	cmp	r0, #0
c0d035d4:	d007      	beq.n	c0d035e6 <io_event+0x1ea>
c0d035d6:	2801      	cmp	r0, #1
c0d035d8:	d103      	bne.n	c0d035e2 <io_event+0x1e6>
c0d035da:	5930      	ldr	r0, [r6, r4]
c0d035dc:	5b71      	ldrh	r1, [r6, r5]
c0d035de:	0149      	lsls	r1, r1, #5
c0d035e0:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d035e2:	f000 fcbf 	bl	c0d03f64 <io_seproxyhal_display_default>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d035e6:	5b70      	ldrh	r0, [r6, r5]
c0d035e8:	1c40      	adds	r0, r0, #1
c0d035ea:	5370      	strh	r0, [r6, r5]
c0d035ec:	5931      	ldr	r1, [r6, r4]
c0d035ee:	2900      	cmp	r1, #0
c0d035f0:	d1d2      	bne.n	c0d03598 <io_event+0x19c>
c0d035f2:	e0c9      	b.n	c0d03788 <io_event+0x38c>
            UX_DISPLAYED_EVENT({});
c0d035f4:	4c6b      	ldr	r4, [pc, #428]	; (c0d037a4 <io_event+0x3a8>)
c0d035f6:	2700      	movs	r7, #0
c0d035f8:	6067      	str	r7, [r4, #4]
c0d035fa:	2001      	movs	r0, #1
c0d035fc:	7020      	strb	r0, [r4, #0]
c0d035fe:	4620      	mov	r0, r4
c0d03600:	f002 fa30 	bl	c0d05a64 <os_ux>
c0d03604:	2004      	movs	r0, #4
c0d03606:	f002 fab5 	bl	c0d05b74 <os_sched_last_status>
c0d0360a:	6060      	str	r0, [r4, #4]
c0d0360c:	2800      	cmp	r0, #0
c0d0360e:	d100      	bne.n	c0d03612 <io_event+0x216>
c0d03610:	e0ba      	b.n	c0d03788 <io_event+0x38c>
c0d03612:	2869      	cmp	r0, #105	; 0x69
c0d03614:	d038      	beq.n	c0d03688 <io_event+0x28c>
c0d03616:	2897      	cmp	r0, #151	; 0x97
c0d03618:	d100      	bne.n	c0d0361c <io_event+0x220>
c0d0361a:	e0b5      	b.n	c0d03788 <io_event+0x38c>
c0d0361c:	25c0      	movs	r5, #192	; 0xc0
c0d0361e:	4c62      	ldr	r4, [pc, #392]	; (c0d037a8 <io_event+0x3ac>)
c0d03620:	5960      	ldr	r0, [r4, r5]
c0d03622:	2800      	cmp	r0, #0
c0d03624:	d100      	bne.n	c0d03628 <io_event+0x22c>
c0d03626:	e0a7      	b.n	c0d03778 <io_event+0x37c>
c0d03628:	26be      	movs	r6, #190	; 0xbe
c0d0362a:	5ba0      	ldrh	r0, [r4, r6]
c0d0362c:	21c4      	movs	r1, #196	; 0xc4
c0d0362e:	5c61      	ldrb	r1, [r4, r1]
c0d03630:	b280      	uxth	r0, r0
c0d03632:	4288      	cmp	r0, r1
c0d03634:	d300      	bcc.n	c0d03638 <io_event+0x23c>
c0d03636:	e09f      	b.n	c0d03778 <io_event+0x37c>
c0d03638:	f002 fa68 	bl	c0d05b0c <io_seph_is_status_sent>
c0d0363c:	2800      	cmp	r0, #0
c0d0363e:	d000      	beq.n	c0d03642 <io_event+0x246>
c0d03640:	e09a      	b.n	c0d03778 <io_event+0x37c>
c0d03642:	f002 f9d9 	bl	c0d059f8 <os_perso_isonboarded>
c0d03646:	28aa      	cmp	r0, #170	; 0xaa
c0d03648:	d104      	bne.n	c0d03654 <io_event+0x258>
c0d0364a:	f002 f9ff 	bl	c0d05a4c <os_global_pin_is_validated>
c0d0364e:	28aa      	cmp	r0, #170	; 0xaa
c0d03650:	d000      	beq.n	c0d03654 <io_event+0x258>
c0d03652:	e091      	b.n	c0d03778 <io_event+0x37c>
c0d03654:	5960      	ldr	r0, [r4, r5]
c0d03656:	5ba1      	ldrh	r1, [r4, r6]
c0d03658:	0149      	lsls	r1, r1, #5
c0d0365a:	1840      	adds	r0, r0, r1
c0d0365c:	21cc      	movs	r1, #204	; 0xcc
c0d0365e:	5861      	ldr	r1, [r4, r1]
c0d03660:	2900      	cmp	r1, #0
c0d03662:	d002      	beq.n	c0d0366a <io_event+0x26e>
c0d03664:	4788      	blx	r1
c0d03666:	2800      	cmp	r0, #0
c0d03668:	d007      	beq.n	c0d0367a <io_event+0x27e>
c0d0366a:	2801      	cmp	r0, #1
c0d0366c:	d103      	bne.n	c0d03676 <io_event+0x27a>
c0d0366e:	5960      	ldr	r0, [r4, r5]
c0d03670:	5ba1      	ldrh	r1, [r4, r6]
c0d03672:	0149      	lsls	r1, r1, #5
c0d03674:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d03676:	f000 fc75 	bl	c0d03f64 <io_seproxyhal_display_default>
            UX_DISPLAYED_EVENT({});
c0d0367a:	5ba0      	ldrh	r0, [r4, r6]
c0d0367c:	1c40      	adds	r0, r0, #1
c0d0367e:	53a0      	strh	r0, [r4, r6]
c0d03680:	5961      	ldr	r1, [r4, r5]
c0d03682:	2900      	cmp	r1, #0
c0d03684:	d1d2      	bne.n	c0d0362c <io_event+0x230>
c0d03686:	e077      	b.n	c0d03778 <io_event+0x37c>
c0d03688:	f000 fc12 	bl	c0d03eb0 <io_seproxyhal_init_ux>
c0d0368c:	f000 fc12 	bl	c0d03eb4 <io_seproxyhal_init_button>
c0d03690:	25be      	movs	r5, #190	; 0xbe
c0d03692:	4e45      	ldr	r6, [pc, #276]	; (c0d037a8 <io_event+0x3ac>)
c0d03694:	5377      	strh	r7, [r6, r5]
c0d03696:	2004      	movs	r0, #4
c0d03698:	f002 fa6c 	bl	c0d05b74 <os_sched_last_status>
c0d0369c:	6060      	str	r0, [r4, #4]
c0d0369e:	2800      	cmp	r0, #0
c0d036a0:	d072      	beq.n	c0d03788 <io_event+0x38c>
c0d036a2:	2897      	cmp	r0, #151	; 0x97
c0d036a4:	d070      	beq.n	c0d03788 <io_event+0x38c>
c0d036a6:	24c0      	movs	r4, #192	; 0xc0
c0d036a8:	5930      	ldr	r0, [r6, r4]
c0d036aa:	2800      	cmp	r0, #0
c0d036ac:	d06c      	beq.n	c0d03788 <io_event+0x38c>
c0d036ae:	5b70      	ldrh	r0, [r6, r5]
c0d036b0:	21c4      	movs	r1, #196	; 0xc4
c0d036b2:	5c71      	ldrb	r1, [r6, r1]
c0d036b4:	b280      	uxth	r0, r0
c0d036b6:	4288      	cmp	r0, r1
c0d036b8:	d266      	bcs.n	c0d03788 <io_event+0x38c>
c0d036ba:	f002 fa27 	bl	c0d05b0c <io_seph_is_status_sent>
c0d036be:	2800      	cmp	r0, #0
c0d036c0:	d162      	bne.n	c0d03788 <io_event+0x38c>
c0d036c2:	f002 f999 	bl	c0d059f8 <os_perso_isonboarded>
c0d036c6:	28aa      	cmp	r0, #170	; 0xaa
c0d036c8:	d103      	bne.n	c0d036d2 <io_event+0x2d6>
c0d036ca:	f002 f9bf 	bl	c0d05a4c <os_global_pin_is_validated>
c0d036ce:	28aa      	cmp	r0, #170	; 0xaa
c0d036d0:	d15a      	bne.n	c0d03788 <io_event+0x38c>
c0d036d2:	5930      	ldr	r0, [r6, r4]
c0d036d4:	5b71      	ldrh	r1, [r6, r5]
c0d036d6:	0149      	lsls	r1, r1, #5
c0d036d8:	1840      	adds	r0, r0, r1
c0d036da:	21cc      	movs	r1, #204	; 0xcc
c0d036dc:	5871      	ldr	r1, [r6, r1]
c0d036de:	2900      	cmp	r1, #0
c0d036e0:	d002      	beq.n	c0d036e8 <io_event+0x2ec>
c0d036e2:	4788      	blx	r1
c0d036e4:	2800      	cmp	r0, #0
c0d036e6:	d007      	beq.n	c0d036f8 <io_event+0x2fc>
c0d036e8:	2801      	cmp	r0, #1
c0d036ea:	d103      	bne.n	c0d036f4 <io_event+0x2f8>
c0d036ec:	5930      	ldr	r0, [r6, r4]
c0d036ee:	5b71      	ldrh	r1, [r6, r5]
c0d036f0:	0149      	lsls	r1, r1, #5
c0d036f2:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d036f4:	f000 fc36 	bl	c0d03f64 <io_seproxyhal_display_default>
            UX_DISPLAYED_EVENT({});
c0d036f8:	5b70      	ldrh	r0, [r6, r5]
c0d036fa:	1c40      	adds	r0, r0, #1
c0d036fc:	5370      	strh	r0, [r6, r5]
c0d036fe:	5931      	ldr	r1, [r6, r4]
c0d03700:	2900      	cmp	r1, #0
c0d03702:	d1d5      	bne.n	c0d036b0 <io_event+0x2b4>
c0d03704:	e040      	b.n	c0d03788 <io_event+0x38c>
c0d03706:	20d0      	movs	r0, #208	; 0xd0
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d03708:	4c27      	ldr	r4, [pc, #156]	; (c0d037a8 <io_event+0x3ac>)
c0d0370a:	5820      	ldr	r0, [r4, r0]
c0d0370c:	2800      	cmp	r0, #0
c0d0370e:	d003      	beq.n	c0d03718 <io_event+0x31c>
c0d03710:	78e9      	ldrb	r1, [r5, #3]
c0d03712:	0849      	lsrs	r1, r1, #1
c0d03714:	f000 fc6a 	bl	c0d03fec <io_seproxyhal_button_push>
c0d03718:	25c0      	movs	r5, #192	; 0xc0
c0d0371a:	5960      	ldr	r0, [r4, r5]
c0d0371c:	2800      	cmp	r0, #0
c0d0371e:	d02b      	beq.n	c0d03778 <io_event+0x37c>
c0d03720:	26be      	movs	r6, #190	; 0xbe
c0d03722:	5ba0      	ldrh	r0, [r4, r6]
c0d03724:	21c4      	movs	r1, #196	; 0xc4
c0d03726:	5c61      	ldrb	r1, [r4, r1]
c0d03728:	b280      	uxth	r0, r0
c0d0372a:	4288      	cmp	r0, r1
c0d0372c:	d224      	bcs.n	c0d03778 <io_event+0x37c>
c0d0372e:	f002 f9ed 	bl	c0d05b0c <io_seph_is_status_sent>
c0d03732:	2800      	cmp	r0, #0
c0d03734:	d120      	bne.n	c0d03778 <io_event+0x37c>
c0d03736:	f002 f95f 	bl	c0d059f8 <os_perso_isonboarded>
c0d0373a:	28aa      	cmp	r0, #170	; 0xaa
c0d0373c:	d103      	bne.n	c0d03746 <io_event+0x34a>
c0d0373e:	f002 f985 	bl	c0d05a4c <os_global_pin_is_validated>
c0d03742:	28aa      	cmp	r0, #170	; 0xaa
c0d03744:	d118      	bne.n	c0d03778 <io_event+0x37c>
c0d03746:	5960      	ldr	r0, [r4, r5]
c0d03748:	5ba1      	ldrh	r1, [r4, r6]
c0d0374a:	0149      	lsls	r1, r1, #5
c0d0374c:	1840      	adds	r0, r0, r1
c0d0374e:	21cc      	movs	r1, #204	; 0xcc
c0d03750:	5861      	ldr	r1, [r4, r1]
c0d03752:	2900      	cmp	r1, #0
c0d03754:	d002      	beq.n	c0d0375c <io_event+0x360>
c0d03756:	4788      	blx	r1
c0d03758:	2800      	cmp	r0, #0
c0d0375a:	d007      	beq.n	c0d0376c <io_event+0x370>
c0d0375c:	2801      	cmp	r0, #1
c0d0375e:	d103      	bne.n	c0d03768 <io_event+0x36c>
c0d03760:	5960      	ldr	r0, [r4, r5]
c0d03762:	5ba1      	ldrh	r1, [r4, r6]
c0d03764:	0149      	lsls	r1, r1, #5
c0d03766:	1840      	adds	r0, r0, r1
    io_seproxyhal_display_default((bagl_element_t *) element);
c0d03768:	f000 fbfc 	bl	c0d03f64 <io_seproxyhal_display_default>
            UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d0376c:	5ba0      	ldrh	r0, [r4, r6]
c0d0376e:	1c40      	adds	r0, r0, #1
c0d03770:	53a0      	strh	r0, [r4, r6]
c0d03772:	5961      	ldr	r1, [r4, r5]
c0d03774:	2900      	cmp	r1, #0
c0d03776:	d1d5      	bne.n	c0d03724 <io_event+0x328>
c0d03778:	20c4      	movs	r0, #196	; 0xc4
c0d0377a:	5c20      	ldrb	r0, [r4, r0]
c0d0377c:	21be      	movs	r1, #190	; 0xbe
c0d0377e:	5a61      	ldrh	r1, [r4, r1]
c0d03780:	4281      	cmp	r1, r0
c0d03782:	d301      	bcc.n	c0d03788 <io_event+0x38c>
c0d03784:	f002 f9c2 	bl	c0d05b0c <io_seph_is_status_sent>
    if (!io_seproxyhal_spi_is_status_sent()) {
c0d03788:	f002 f9c0 	bl	c0d05b0c <io_seph_is_status_sent>
c0d0378c:	2800      	cmp	r0, #0
c0d0378e:	d101      	bne.n	c0d03794 <io_event+0x398>
        io_seproxyhal_general_status();
c0d03790:	f000 fa48 	bl	c0d03c24 <io_seproxyhal_general_status>
c0d03794:	2001      	movs	r0, #1
    return 1;
c0d03796:	b001      	add	sp, #4
c0d03798:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0379a:	2010      	movs	r0, #16
                THROW(EXCEPTION_IO_RESET);
c0d0379c:	f000 f931 	bl	c0d03a02 <os_longjmp>
c0d037a0:	20001a5c 	.word	0x20001a5c
c0d037a4:	20001aa4 	.word	0x20001aa4
c0d037a8:	2000195c 	.word	0x2000195c
c0d037ac:	20001fb4 	.word	0x20001fb4

c0d037b0 <app_exit>:
void app_exit() {
c0d037b0:	b510      	push	{r4, lr}
c0d037b2:	b08c      	sub	sp, #48	; 0x30
c0d037b4:	466c      	mov	r4, sp
        TRY_L(exit) {
c0d037b6:	4620      	mov	r0, r4
c0d037b8:	f006 f850 	bl	c0d0985c <setjmp>
c0d037bc:	85a0      	strh	r0, [r4, #44]	; 0x2c
c0d037be:	0400      	lsls	r0, r0, #16
c0d037c0:	d106      	bne.n	c0d037d0 <app_exit+0x20>
c0d037c2:	4668      	mov	r0, sp
c0d037c4:	f002 f9ca 	bl	c0d05b5c <try_context_set>
c0d037c8:	900a      	str	r0, [sp, #40]	; 0x28
c0d037ca:	20ff      	movs	r0, #255	; 0xff
            os_sched_exit(-1);
c0d037cc:	f002 f986 	bl	c0d05adc <os_sched_exit>
        FINALLY_L(exit) {
c0d037d0:	f002 f9b8 	bl	c0d05b44 <try_context_get>
c0d037d4:	4669      	mov	r1, sp
c0d037d6:	4288      	cmp	r0, r1
c0d037d8:	d102      	bne.n	c0d037e0 <app_exit+0x30>
c0d037da:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d037dc:	f002 f9be 	bl	c0d05b5c <try_context_set>
c0d037e0:	4668      	mov	r0, sp
    END_TRY_L(exit);
c0d037e2:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d037e4:	2800      	cmp	r0, #0
c0d037e6:	d101      	bne.n	c0d037ec <app_exit+0x3c>
}
c0d037e8:	b00c      	add	sp, #48	; 0x30
c0d037ea:	bd10      	pop	{r4, pc}
    END_TRY_L(exit);
c0d037ec:	f000 f909 	bl	c0d03a02 <os_longjmp>

c0d037f0 <coin_main>:
void coin_main(chain_config_t *coin_config) {
c0d037f0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d037f2:	b093      	sub	sp, #76	; 0x4c
c0d037f4:	4604      	mov	r4, r0
    if (coin_config == NULL) {
c0d037f6:	2800      	cmp	r0, #0
c0d037f8:	d10a      	bne.n	c0d03810 <coin_main+0x20>
c0d037fa:	ac0e      	add	r4, sp, #56	; 0x38
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0d037fc:	1d60      	adds	r0, r4, #5
c0d037fe:	210f      	movs	r1, #15
c0d03800:	f005 fef2 	bl	c0d095e8 <__aeabi_memclr>
c0d03804:	2000      	movs	r0, #0
c0d03806:	7120      	strb	r0, [r4, #4]
    coin_config->kind = CHAIN_KIND;
c0d03808:	7420      	strb	r0, [r4, #16]
c0d0380a:	492b      	ldr	r1, [pc, #172]	; (c0d038b8 <coin_main+0xc8>)
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0d0380c:	910e      	str	r1, [sp, #56]	; 0x38
    coin_config->chainId = CHAIN_ID;
c0d0380e:	9011      	str	r0, [sp, #68]	; 0x44
c0d03810:	208e      	movs	r0, #142	; 0x8e
    memset(tmpCtx.transactionContext.tokenSet, 0, MAX_TOKEN);
c0d03812:	4d2a      	ldr	r5, [pc, #168]	; (c0d038bc <coin_main+0xcc>)
c0d03814:	2600      	movs	r6, #0
c0d03816:	522e      	strh	r6, [r5, r0]
    appState = APP_STATE_IDLE;
c0d03818:	4829      	ldr	r0, [pc, #164]	; (c0d038c0 <coin_main+0xd0>)
c0d0381a:	7006      	strb	r6, [r0, #0]
c0d0381c:	4829      	ldr	r0, [pc, #164]	; (c0d038c4 <coin_main+0xd4>)
c0d0381e:	6004      	str	r4, [r0, #0]
    called_from_swap = false;
c0d03820:	4829      	ldr	r0, [pc, #164]	; (c0d038c8 <coin_main+0xd8>)
c0d03822:	7006      	strb	r6, [r0, #0]
    quantumSet = false;
c0d03824:	4829      	ldr	r0, [pc, #164]	; (c0d038cc <coin_main+0xdc>)
c0d03826:	7006      	strb	r6, [r0, #0]
    memset((uint8_t *) &txContext, 0, sizeof(txContext));
c0d03828:	4829      	ldr	r0, [pc, #164]	; (c0d038d0 <coin_main+0xe0>)
c0d0382a:	213c      	movs	r1, #60	; 0x3c
c0d0382c:	f005 fedc 	bl	c0d095e8 <__aeabi_memclr>
    memset((uint8_t *) &tmpContent, 0, sizeof(tmpContent));
c0d03830:	4828      	ldr	r0, [pc, #160]	; (c0d038d4 <coin_main+0xe4>)
c0d03832:	2180      	movs	r1, #128	; 0x80
c0d03834:	f005 fed8 	bl	c0d095e8 <__aeabi_memclr>
c0d03838:	2090      	movs	r0, #144	; 0x90
    tmpCtx.transactionContext.currentTokenIndex = 0;
c0d0383a:	542e      	strb	r6, [r5, r0]
c0d0383c:	4c26      	ldr	r4, [pc, #152]	; (c0d038d8 <coin_main+0xe8>)
c0d0383e:	2701      	movs	r7, #1
c0d03840:	0239      	lsls	r1, r7, #8
        UX_INIT();
c0d03842:	4620      	mov	r0, r4
c0d03844:	f005 fed0 	bl	c0d095e8 <__aeabi_memclr>
c0d03848:	ad02      	add	r5, sp, #8
            TRY {
c0d0384a:	4628      	mov	r0, r5
c0d0384c:	f006 f806 	bl	c0d0985c <setjmp>
c0d03850:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0d03852:	b285      	uxth	r5, r0
c0d03854:	2d00      	cmp	r5, #0
c0d03856:	d00d      	beq.n	c0d03874 <coin_main+0x84>
c0d03858:	a802      	add	r0, sp, #8
c0d0385a:	8586      	strh	r6, [r0, #44]	; 0x2c
c0d0385c:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d0385e:	f002 f97d 	bl	c0d05b5c <try_context_set>
c0d03862:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d03864:	f002 f97a 	bl	c0d05b5c <try_context_set>
c0d03868:	2d10      	cmp	r5, #16
c0d0386a:	d0e8      	beq.n	c0d0383e <coin_main+0x4e>
    app_exit();
c0d0386c:	f7ff ffa0 	bl	c0d037b0 <app_exit>
}
c0d03870:	b013      	add	sp, #76	; 0x4c
c0d03872:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03874:	a802      	add	r0, sp, #8
            TRY {
c0d03876:	f002 f971 	bl	c0d05b5c <try_context_set>
c0d0387a:	900c      	str	r0, [sp, #48]	; 0x30
                io_seproxyhal_init();
c0d0387c:	f000 fafc 	bl	c0d03e78 <io_seproxyhal_init>
                if (N_storage.initialized != 0x01) {
c0d03880:	4816      	ldr	r0, [pc, #88]	; (c0d038dc <coin_main+0xec>)
c0d03882:	4478      	add	r0, pc
c0d03884:	f001 f8a6 	bl	c0d049d4 <pic>
c0d03888:	7880      	ldrb	r0, [r0, #2]
c0d0388a:	2801      	cmp	r0, #1
c0d0388c:	d00a      	beq.n	c0d038a4 <coin_main+0xb4>
c0d0388e:	ac01      	add	r4, sp, #4
                    storage.initialized = 0x01;
c0d03890:	70a7      	strb	r7, [r4, #2]
                    storage.dataAllowed = 0x00;
c0d03892:	8026      	strh	r6, [r4, #0]
                    nvm_write((void *) &N_storage, (void *) &storage, sizeof(internalStorage_t));
c0d03894:	4812      	ldr	r0, [pc, #72]	; (c0d038e0 <coin_main+0xf0>)
c0d03896:	4478      	add	r0, pc
c0d03898:	f001 f89c 	bl	c0d049d4 <pic>
c0d0389c:	2203      	movs	r2, #3
c0d0389e:	4621      	mov	r1, r4
c0d038a0:	f001 ff94 	bl	c0d057cc <nvm_write>
c0d038a4:	2000      	movs	r0, #0
                USB_power(0);
c0d038a6:	f004 fea3 	bl	c0d085f0 <USB_power>
c0d038aa:	2001      	movs	r0, #1
                USB_power(1);
c0d038ac:	f004 fea0 	bl	c0d085f0 <USB_power>
                ui_idle();
c0d038b0:	f7ff fb66 	bl	c0d02f80 <ui_idle>
                app_main();
c0d038b4:	f7ff fd0e 	bl	c0d032d4 <app_main>
c0d038b8:	20485445 	.word	0x20485445
c0d038bc:	20001804 	.word	0x20001804
c0d038c0:	20001800 	.word	0x20001800
c0d038c4:	20001b3c 	.word	0x20001b3c
c0d038c8:	2000189c 	.word	0x2000189c
c0d038cc:	2000189d 	.word	0x2000189d
c0d038d0:	200018a0 	.word	0x200018a0
c0d038d4:	200018dc 	.word	0x200018dc
c0d038d8:	2000195c 	.word	0x2000195c
c0d038dc:	00007e7a 	.word	0x00007e7a
c0d038e0:	00007e66 	.word	0x00007e66

c0d038e4 <library_main>:
void library_main(struct libargs_s *args) {
c0d038e4:	b092      	sub	sp, #72	; 0x48
c0d038e6:	4604      	mov	r4, r0
    if (args->chain_config == NULL) {
c0d038e8:	6880      	ldr	r0, [r0, #8]
c0d038ea:	2800      	cmp	r0, #0
c0d038ec:	d10b      	bne.n	c0d03906 <library_main+0x22>
c0d038ee:	ad0d      	add	r5, sp, #52	; 0x34
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0d038f0:	1d68      	adds	r0, r5, #5
c0d038f2:	210f      	movs	r1, #15
c0d038f4:	f005 fe78 	bl	c0d095e8 <__aeabi_memclr>
c0d038f8:	2000      	movs	r0, #0
    coin_config->kind = CHAIN_KIND;
c0d038fa:	7428      	strb	r0, [r5, #16]
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0d038fc:	7128      	strb	r0, [r5, #4]
    coin_config->chainId = CHAIN_ID;
c0d038fe:	9010      	str	r0, [sp, #64]	; 0x40
c0d03900:	4822      	ldr	r0, [pc, #136]	; (c0d0398c <library_main+0xa8>)
    strcpy(coin_config->coinName, CHAINID_COINNAME " ");
c0d03902:	900d      	str	r0, [sp, #52]	; 0x34
        args->chain_config = &coin_config;
c0d03904:	60a5      	str	r5, [r4, #8]
c0d03906:	2600      	movs	r6, #0
c0d03908:	ad01      	add	r5, sp, #4
            TRY {
c0d0390a:	4628      	mov	r0, r5
c0d0390c:	f005 ffa6 	bl	c0d0985c <setjmp>
c0d03910:	85a8      	strh	r0, [r5, #44]	; 0x2c
c0d03912:	0400      	lsls	r0, r0, #16
c0d03914:	d107      	bne.n	c0d03926 <library_main+0x42>
c0d03916:	a801      	add	r0, sp, #4
c0d03918:	f002 f920 	bl	c0d05b5c <try_context_set>
c0d0391c:	900b      	str	r0, [sp, #44]	; 0x2c
                if (!end) {
c0d0391e:	07f0      	lsls	r0, r6, #31
c0d03920:	d00f      	beq.n	c0d03942 <library_main+0x5e>
                os_lib_end();
c0d03922:	f002 f8b7 	bl	c0d05a94 <os_lib_end>
            FINALLY {
c0d03926:	f002 f90d 	bl	c0d05b44 <try_context_get>
c0d0392a:	a901      	add	r1, sp, #4
c0d0392c:	4288      	cmp	r0, r1
c0d0392e:	d102      	bne.n	c0d03936 <library_main+0x52>
c0d03930:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d03932:	f002 f913 	bl	c0d05b5c <try_context_set>
c0d03936:	a801      	add	r0, sp, #4
        END_TRY;
c0d03938:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
c0d0393a:	2800      	cmp	r0, #0
c0d0393c:	d124      	bne.n	c0d03988 <library_main+0xa4>
c0d0393e:	2601      	movs	r6, #1
c0d03940:	e7e2      	b.n	c0d03908 <library_main+0x24>
c0d03942:	200a      	movs	r0, #10
    check_api_level(CX_COMPAT_APILEVEL);
c0d03944:	f001 ff2c 	bl	c0d057a0 <check_api_level>
    switch (args->command) {
c0d03948:	6860      	ldr	r0, [r4, #4]
c0d0394a:	2802      	cmp	r0, #2
c0d0394c:	d012      	beq.n	c0d03974 <library_main+0x90>
c0d0394e:	2804      	cmp	r0, #4
c0d03950:	d00b      	beq.n	c0d0396a <library_main+0x86>
c0d03952:	2803      	cmp	r0, #3
c0d03954:	d1e5      	bne.n	c0d03922 <library_main+0x3e>
            args->check_address->result = 0;
c0d03956:	68e0      	ldr	r0, [r4, #12]
c0d03958:	2100      	movs	r1, #0
c0d0395a:	6181      	str	r1, [r0, #24]
                handle_check_address(args->check_address, args->chain_config);
c0d0395c:	68a1      	ldr	r1, [r4, #8]
c0d0395e:	68e0      	ldr	r0, [r4, #12]
c0d03960:	f7fe fe60 	bl	c0d02624 <handle_check_address>
            args->check_address->result =
c0d03964:	68e1      	ldr	r1, [r4, #12]
c0d03966:	6188      	str	r0, [r1, #24]
c0d03968:	e7db      	b.n	c0d03922 <library_main+0x3e>
            handle_get_printable_amount(args->get_printable_amount, args->chain_config);
c0d0396a:	68a1      	ldr	r1, [r4, #8]
c0d0396c:	68e0      	ldr	r0, [r4, #12]
c0d0396e:	f7fe fec9 	bl	c0d02704 <handle_get_printable_amount>
c0d03972:	e7d6      	b.n	c0d03922 <library_main+0x3e>
            if (copy_transaction_parameters(args->create_transaction, args->chain_config)) {
c0d03974:	68a1      	ldr	r1, [r4, #8]
c0d03976:	68e0      	ldr	r0, [r4, #12]
c0d03978:	f7fe ff04 	bl	c0d02784 <copy_transaction_parameters>
c0d0397c:	2800      	cmp	r0, #0
c0d0397e:	d0d0      	beq.n	c0d03922 <library_main+0x3e>
                handle_swap_sign_transaction(args->chain_config);
c0d03980:	68a0      	ldr	r0, [r4, #8]
c0d03982:	f7fe ff4f 	bl	c0d02824 <handle_swap_sign_transaction>
c0d03986:	e7cc      	b.n	c0d03922 <library_main+0x3e>
        END_TRY;
c0d03988:	f000 f83b 	bl	c0d03a02 <os_longjmp>
c0d0398c:	20485445 	.word	0x20485445

c0d03990 <os_boot>:

// apdu buffer must hold a complete apdu to avoid troubles
unsigned char G_io_apdu_buffer[IO_APDU_BUFFER_SIZE];


void os_boot(void) {
c0d03990:	b580      	push	{r7, lr}
c0d03992:	2000      	movs	r0, #0
  // // TODO patch entry point when romming (f)
  // // set the default try context to nothing
#ifndef HAVE_BOLOS
  try_context_set(NULL);
c0d03994:	f002 f8e2 	bl	c0d05b5c <try_context_set>
#endif // HAVE_BOLOS
}
c0d03998:	bd80      	pop	{r7, pc}

c0d0399a <os_memmove>:


REENTRANT(void os_memmove(void * dst, const void WIDE * src, unsigned int length)) {
c0d0399a:	b5b0      	push	{r4, r5, r7, lr}
#define DSTCHAR ((unsigned char *)dst)
#define SRCCHAR ((unsigned char WIDE *)src)
  if (dst > src) {
c0d0399c:	4288      	cmp	r0, r1
c0d0399e:	d908      	bls.n	c0d039b2 <os_memmove+0x18>
    while(length--) {
c0d039a0:	2a00      	cmp	r2, #0
c0d039a2:	d00f      	beq.n	c0d039c4 <os_memmove+0x2a>
c0d039a4:	1e49      	subs	r1, r1, #1
c0d039a6:	1e40      	subs	r0, r0, #1
      DSTCHAR[length] = SRCCHAR[length];
c0d039a8:	5c8b      	ldrb	r3, [r1, r2]
c0d039aa:	5483      	strb	r3, [r0, r2]
    while(length--) {
c0d039ac:	1e52      	subs	r2, r2, #1
c0d039ae:	d1fb      	bne.n	c0d039a8 <os_memmove+0xe>
c0d039b0:	e008      	b.n	c0d039c4 <os_memmove+0x2a>
    }
  }
  else {
    unsigned short l = 0;
    while (length--) {
c0d039b2:	2a00      	cmp	r2, #0
c0d039b4:	d006      	beq.n	c0d039c4 <os_memmove+0x2a>
c0d039b6:	2300      	movs	r3, #0
      DSTCHAR[l] = SRCCHAR[l];
c0d039b8:	b29c      	uxth	r4, r3
c0d039ba:	5d0d      	ldrb	r5, [r1, r4]
c0d039bc:	5505      	strb	r5, [r0, r4]
      l++;
c0d039be:	1c5b      	adds	r3, r3, #1
    while (length--) {
c0d039c0:	1e52      	subs	r2, r2, #1
c0d039c2:	d1f9      	bne.n	c0d039b8 <os_memmove+0x1e>
    }
  }
#undef DSTCHAR
}
c0d039c4:	bdb0      	pop	{r4, r5, r7, pc}

c0d039c6 <os_memset>:

void os_memset(void * dst, unsigned char c, unsigned int length) {
c0d039c6:	b580      	push	{r7, lr}
#define DSTCHAR ((unsigned char *)dst)
  while(length--) {
c0d039c8:	2a00      	cmp	r2, #0
c0d039ca:	d004      	beq.n	c0d039d6 <os_memset+0x10>
c0d039cc:	460b      	mov	r3, r1
    DSTCHAR[length] = c;
c0d039ce:	4611      	mov	r1, r2
c0d039d0:	461a      	mov	r2, r3
c0d039d2:	f005 fe17 	bl	c0d09604 <__aeabi_memset>
  }
#undef DSTCHAR
}
c0d039d6:	bd80      	pop	{r7, pc}

c0d039d8 <os_memcmp>:
  while(nbintval--) {
    ((unsigned int*) dst)[nbintval] = initval;
  }
}

char os_memcmp(const void WIDE * buf1, const void WIDE * buf2, unsigned int length) {
c0d039d8:	b5b0      	push	{r4, r5, r7, lr}
#define BUF1 ((unsigned char const WIDE *)buf1)
#define BUF2 ((unsigned char const WIDE *)buf2)
  while(length--) {
c0d039da:	1e40      	subs	r0, r0, #1
c0d039dc:	1e49      	subs	r1, r1, #1
c0d039de:	2a00      	cmp	r2, #0
c0d039e0:	d00a      	beq.n	c0d039f8 <os_memcmp+0x20>
c0d039e2:	1e55      	subs	r5, r2, #1
    if (BUF1[length] != BUF2[length]) {
c0d039e4:	5c8b      	ldrb	r3, [r1, r2]
c0d039e6:	5c84      	ldrb	r4, [r0, r2]
c0d039e8:	429c      	cmp	r4, r3
c0d039ea:	462a      	mov	r2, r5
c0d039ec:	d0f7      	beq.n	c0d039de <os_memcmp+0x6>
      return (BUF1[length] > BUF2[length])? 1:-1;
c0d039ee:	429c      	cmp	r4, r3
c0d039f0:	d804      	bhi.n	c0d039fc <os_memcmp+0x24>
c0d039f2:	2000      	movs	r0, #0
c0d039f4:	43c0      	mvns	r0, r0
c0d039f6:	e002      	b.n	c0d039fe <os_memcmp+0x26>
c0d039f8:	2000      	movs	r0, #0
c0d039fa:	e000      	b.n	c0d039fe <os_memcmp+0x26>
c0d039fc:	2001      	movs	r0, #1
  }
  return 0;
#undef BUF1
#undef BUF2

}
c0d039fe:	b2c0      	uxtb	r0, r0
c0d03a00:	bdb0      	pop	{r4, r5, r7, pc}

c0d03a02 <os_longjmp>:
  return (try_context_t*) current_ctx->jmp_buf[5];
}
#endif // BOLOS_EXCEPTION_OLD

#ifndef HAVE_BOLOS
void os_longjmp(unsigned int exception) {
c0d03a02:	4604      	mov	r4, r0
#ifdef HAVE_PRINTF  
  unsigned int lr_val;
  __asm volatile("mov %0, lr" :"=r"(lr_val));
  PRINTF("exception[%d]: LR=0x%08X\n", exception, lr_val);
#endif // HAVE_PRINTF
  longjmp(try_context_get()->jmp_buf, exception);
c0d03a04:	f002 f89e 	bl	c0d05b44 <try_context_get>
c0d03a08:	4621      	mov	r1, r4
c0d03a0a:	f005 ff33 	bl	c0d09874 <longjmp>

c0d03a0e <os_secure_memcmp>:
char os_secure_memcmp(void WIDE* src1, void WIDE* src2, unsigned int length) {
c0d03a0e:	b5b0      	push	{r4, r5, r7, lr}
c0d03a10:	b082      	sub	sp, #8
c0d03a12:	9201      	str	r2, [sp, #4]
c0d03a14:	9200      	str	r2, [sp, #0]
  while(!(!length && !l)) {
c0d03a16:	2a00      	cmp	r2, #0
c0d03a18:	d00c      	beq.n	c0d03a34 <os_secure_memcmp+0x26>
    length--;
c0d03a1a:	1e43      	subs	r3, r0, #1
c0d03a1c:	1e49      	subs	r1, r1, #1
c0d03a1e:	2000      	movs	r0, #0
    xoracc |= SRC1[length] ^ SRC2[length];
c0d03a20:	5c9c      	ldrb	r4, [r3, r2]
c0d03a22:	5c8d      	ldrb	r5, [r1, r2]
c0d03a24:	4065      	eors	r5, r4
c0d03a26:	4328      	orrs	r0, r5
    length--;
c0d03a28:	1e52      	subs	r2, r2, #1
  while(!(!length && !l)) {
c0d03a2a:	d1f9      	bne.n	c0d03a20 <os_secure_memcmp+0x12>
c0d03a2c:	2100      	movs	r1, #0
c0d03a2e:	9100      	str	r1, [sp, #0]
    length--;
c0d03a30:	9101      	str	r1, [sp, #4]
c0d03a32:	e000      	b.n	c0d03a36 <os_secure_memcmp+0x28>
c0d03a34:	2000      	movs	r0, #0
  if (*(volatile unsigned int*)&l!=*(volatile unsigned int*)&length) {
c0d03a36:	9900      	ldr	r1, [sp, #0]
c0d03a38:	9a01      	ldr	r2, [sp, #4]
c0d03a3a:	4291      	cmp	r1, r2
c0d03a3c:	d102      	bne.n	c0d03a44 <os_secure_memcmp+0x36>
  return xoracc;
c0d03a3e:	b2c0      	uxtb	r0, r0
c0d03a40:	b002      	add	sp, #8
c0d03a42:	bdb0      	pop	{r4, r5, r7, pc}
c0d03a44:	2001      	movs	r0, #1
    THROW(EXCEPTION);
c0d03a46:	f7ff ffdc 	bl	c0d03a02 <os_longjmp>
	...

c0d03a4c <os_parse_bertlv>:
// <tag> <length> <value>
// tag: 1 byte only
// length: 1 byte if little than 0x80, else 1 byte of length encoding (0x8Y, with Y the number of following bytes the length is encoded on) and then Y bytes of BE encoded total length
// value: no encoding, raw data
unsigned int os_parse_bertlv(unsigned char* mem, unsigned int mem_len, 
                             unsigned int * tlvoffset, unsigned int tag, unsigned int offset, void** buffer, unsigned int maxlength) {
c0d03a4c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d03a4e:	b08b      	sub	sp, #44	; 0x2c
c0d03a50:	4607      	mov	r7, r0
c0d03a52:	2000      	movs	r0, #0
  unsigned int check_equals_buffer = offset & OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER;
  unsigned int get_address = offset & OS_PARSE_BERTLV_OFFSET_GET_LENGTH;
  offset &= ~(OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER|OS_PARSE_BERTLV_OFFSET_GET_LENGTH);

  // nothing to be read
  if (mem_len == 0 || buffer == NULL || (!get_address && *buffer == NULL)) {
c0d03a54:	2900      	cmp	r1, #0
c0d03a56:	d05b      	beq.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03a58:	9d11      	ldr	r5, [sp, #68]	; 0x44
c0d03a5a:	2d00      	cmp	r5, #0
c0d03a5c:	d058      	beq.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03a5e:	920a      	str	r2, [sp, #40]	; 0x28
c0d03a60:	4c6f      	ldr	r4, [pc, #444]	; (c0d03c20 <os_parse_bertlv+0x1d4>)
c0d03a62:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0d03a64:	9409      	str	r4, [sp, #36]	; 0x24
  unsigned int get_address = offset & OS_PARSE_BERTLV_OFFSET_GET_LENGTH;
c0d03a66:	1c62      	adds	r2, r4, #1
c0d03a68:	4032      	ands	r2, r6
c0d03a6a:	9204      	str	r2, [sp, #16]
  if (mem_len == 0 || buffer == NULL || (!get_address && *buffer == NULL)) {
c0d03a6c:	2a00      	cmp	r2, #0
c0d03a6e:	d102      	bne.n	c0d03a76 <os_parse_bertlv+0x2a>
c0d03a70:	682c      	ldr	r4, [r5, #0]
c0d03a72:	2c00      	cmp	r4, #0
c0d03a74:	d04c      	beq.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03a76:	2000      	movs	r0, #0
c0d03a78:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  unsigned int remlen = mem_len;
  ret = 0;

  // account for a shift in the tlv list before parsing
  tlvoffset_in = 0;
  if (tlvoffset) {
c0d03a7a:	2a00      	cmp	r2, #0
c0d03a7c:	4604      	mov	r4, r0
c0d03a7e:	d000      	beq.n	c0d03a82 <os_parse_bertlv+0x36>
    tlvoffset_in = *tlvoffset;
c0d03a80:	6814      	ldr	r4, [r2, #0]
  }

  // parse tlv until some tag to parse
  while(remlen>=2) {
c0d03a82:	2902      	cmp	r1, #2
c0d03a84:	d344      	bcc.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03a86:	9406      	str	r4, [sp, #24]
c0d03a88:	9501      	str	r5, [sp, #4]
c0d03a8a:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d03a8c:	9602      	str	r6, [sp, #8]
c0d03a8e:	4030      	ands	r0, r6
c0d03a90:	9009      	str	r0, [sp, #36]	; 0x24
c0d03a92:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d03a94:	9003      	str	r0, [sp, #12]
c0d03a96:	2000      	movs	r0, #0
c0d03a98:	43c4      	mvns	r4, r0
c0d03a9a:	9405      	str	r4, [sp, #20]
c0d03a9c:	b2da      	uxtb	r2, r3
c0d03a9e:	9207      	str	r2, [sp, #28]
c0d03aa0:	460b      	mov	r3, r1
c0d03aa2:	463e      	mov	r6, r7
c0d03aa4:	9008      	str	r0, [sp, #32]
    remlen--;
    if (remlen == 0) {
      goto retret; 
    }
    unsigned int tlvlen = *tlv++;
    remlen--;
c0d03aa6:	1e9b      	subs	r3, r3, #2
    if (remlen == 0) {
c0d03aa8:	d032      	beq.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03aaa:	460a      	mov	r2, r1
c0d03aac:	4639      	mov	r1, r7
c0d03aae:	1cb5      	adds	r5, r6, #2
c0d03ab0:	7830      	ldrb	r0, [r6, #0]
c0d03ab2:	7876      	ldrb	r6, [r6, #1]
c0d03ab4:	b277      	sxtb	r7, r6
      goto retret; 
    }
    if (tlvlen >= 0x80) {
c0d03ab6:	2f00      	cmp	r7, #0
c0d03ab8:	da12      	bge.n	c0d03ae0 <os_parse_bertlv+0x94>
      // invalid encoding
      if (tlvlen == 0x80) {
c0d03aba:	3780      	adds	r7, #128	; 0x80
c0d03abc:	d05f      	beq.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03abe:	277f      	movs	r7, #127	; 0x7f
        goto retret; 
      }
      unsigned int tlvlenlen_ = tlvlen & 0x7F;
c0d03ac0:	403e      	ands	r6, r7
      tlvlen = 0;
      while(tlvlenlen_--) {
c0d03ac2:	9c05      	ldr	r4, [sp, #20]
c0d03ac4:	4366      	muls	r6, r4
c0d03ac6:	2700      	movs	r7, #0
c0d03ac8:	2e00      	cmp	r6, #0
c0d03aca:	d008      	beq.n	c0d03ade <os_parse_bertlv+0x92>
        // BE encoded
        tlvlen = (tlvlen << 8) | ((*tlv++)&0xFF);
c0d03acc:	782c      	ldrb	r4, [r5, #0]
c0d03ace:	023f      	lsls	r7, r7, #8
c0d03ad0:	193f      	adds	r7, r7, r4
        remlen--;
        if (remlen == 0) {
c0d03ad2:	1c76      	adds	r6, r6, #1
        remlen--;
c0d03ad4:	1e5b      	subs	r3, r3, #1
        tlvlen = (tlvlen << 8) | ((*tlv++)&0xFF);
c0d03ad6:	1c6d      	adds	r5, r5, #1
        if (remlen == 0) {
c0d03ad8:	2b00      	cmp	r3, #0
c0d03ada:	d1f5      	bne.n	c0d03ac8 <os_parse_bertlv+0x7c>
c0d03adc:	e017      	b.n	c0d03b0e <os_parse_bertlv+0xc2>
c0d03ade:	463e      	mov	r6, r7
c0d03ae0:	9c0a      	ldr	r4, [sp, #40]	; 0x28
          goto retret; 
        }
      }
    }
    // check if tag matches
    if (tlvtag == (tag&0xFF)) {
c0d03ae2:	9f07      	ldr	r7, [sp, #28]
c0d03ae4:	42b8      	cmp	r0, r7
c0d03ae6:	460f      	mov	r7, r1
c0d03ae8:	d106      	bne.n	c0d03af8 <os_parse_bertlv+0xac>
      if (tlvoffset) {
c0d03aea:	2c00      	cmp	r4, #0
c0d03aec:	d012      	beq.n	c0d03b14 <os_parse_bertlv+0xc8>
        unsigned int o = (unsigned int) tlv - (unsigned int)mem;
c0d03aee:	1be8      	subs	r0, r5, r7
        // compute the current position in the tlv bytes
        *tlvoffset = o;
c0d03af0:	6020      	str	r0, [r4, #0]
c0d03af2:	9906      	ldr	r1, [sp, #24]
c0d03af4:	4281      	cmp	r1, r0
c0d03af6:	d90d      	bls.n	c0d03b14 <os_parse_bertlv+0xc8>
      goto retret;
    }
  next_tlv:
    // skip to next tlv
    tlv += tlvlen;
    remlen-=MIN(remlen, tlvlen);
c0d03af8:	42b3      	cmp	r3, r6
c0d03afa:	461c      	mov	r4, r3
c0d03afc:	4611      	mov	r1, r2
c0d03afe:	d300      	bcc.n	c0d03b02 <os_parse_bertlv+0xb6>
c0d03b00:	4634      	mov	r4, r6
c0d03b02:	19ae      	adds	r6, r5, r6
c0d03b04:	1b1b      	subs	r3, r3, r4
  while(remlen>=2) {
c0d03b06:	2b01      	cmp	r3, #1
c0d03b08:	9808      	ldr	r0, [sp, #32]
c0d03b0a:	d8cc      	bhi.n	c0d03aa6 <os_parse_bertlv+0x5a>
c0d03b0c:	e000      	b.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03b0e:	2000      	movs	r0, #0
  }
retret:
  return ret;
}
c0d03b10:	b00b      	add	sp, #44	; 0x2c
c0d03b12:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03b14:	9809      	ldr	r0, [sp, #36]	; 0x24
      if (offset > tlvlen || offset > remlen) {
c0d03b16:	4298      	cmp	r0, r3
c0d03b18:	d831      	bhi.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b1a:	4286      	cmp	r6, r0
c0d03b1c:	d32f      	bcc.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b1e:	4611      	mov	r1, r2
      if (check_equals_buffer && (tlvlen-offset) != maxlength) {
c0d03b20:	1a34      	subs	r4, r6, r0
c0d03b22:	9a03      	ldr	r2, [sp, #12]
c0d03b24:	4294      	cmp	r4, r2
c0d03b26:	d002      	beq.n	c0d03b2e <os_parse_bertlv+0xe2>
c0d03b28:	9a02      	ldr	r2, [sp, #8]
c0d03b2a:	2a00      	cmp	r2, #0
c0d03b2c:	db27      	blt.n	c0d03b7e <os_parse_bertlv+0x132>
      maxlength = MIN(maxlength, MIN(tlvlen-offset, remlen));
c0d03b2e:	429c      	cmp	r4, r3
c0d03b30:	d300      	bcc.n	c0d03b34 <os_parse_bertlv+0xe8>
c0d03b32:	461c      	mov	r4, r3
c0d03b34:	9a03      	ldr	r2, [sp, #12]
c0d03b36:	4294      	cmp	r4, r2
c0d03b38:	d800      	bhi.n	c0d03b3c <os_parse_bertlv+0xf0>
c0d03b3a:	4622      	mov	r2, r4
        || maxlength > mem_len
c0d03b3c:	4288      	cmp	r0, r1
c0d03b3e:	d81e      	bhi.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b40:	428a      	cmp	r2, r1
c0d03b42:	d81c      	bhi.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b44:	1810      	adds	r0, r2, r0
c0d03b46:	4288      	cmp	r0, r1
c0d03b48:	d819      	bhi.n	c0d03b7e <os_parse_bertlv+0x132>
        || (unsigned int)tlv+offset < (unsigned int)mem 
c0d03b4a:	42bd      	cmp	r5, r7
c0d03b4c:	d317      	bcc.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b4e:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d03b50:	1940      	adds	r0, r0, r5
        || (unsigned int)tlv+offset+maxlength < (unsigned int)mem 
c0d03b52:	42b8      	cmp	r0, r7
c0d03b54:	d313      	bcc.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b56:	900a      	str	r0, [sp, #40]	; 0x28
c0d03b58:	1810      	adds	r0, r2, r0
        || (unsigned int)tlv > (unsigned int)mem+mem_len
c0d03b5a:	42b8      	cmp	r0, r7
c0d03b5c:	d30f      	bcc.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b5e:	1879      	adds	r1, r7, r1
        || (unsigned int)tlv+offset > (unsigned int)mem+mem_len
c0d03b60:	42a9      	cmp	r1, r5
c0d03b62:	d30c      	bcc.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b64:	9d0a      	ldr	r5, [sp, #40]	; 0x28
c0d03b66:	428d      	cmp	r5, r1
c0d03b68:	d809      	bhi.n	c0d03b7e <os_parse_bertlv+0x132>
c0d03b6a:	4288      	cmp	r0, r1
c0d03b6c:	d807      	bhi.n	c0d03b7e <os_parse_bertlv+0x132>
      if (get_address) {
c0d03b6e:	9804      	ldr	r0, [sp, #16]
c0d03b70:	2800      	cmp	r0, #0
c0d03b72:	d006      	beq.n	c0d03b82 <os_parse_bertlv+0x136>
        *buffer = tlv+offset;
c0d03b74:	9801      	ldr	r0, [sp, #4]
c0d03b76:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d03b78:	6001      	str	r1, [r0, #0]
c0d03b7a:	4620      	mov	r0, r4
c0d03b7c:	e7c8      	b.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03b7e:	9808      	ldr	r0, [sp, #32]
c0d03b80:	e7c6      	b.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03b82:	9801      	ldr	r0, [sp, #4]
c0d03b84:	6801      	ldr	r1, [r0, #0]
      if (!check_equals_buffer) {
c0d03b86:	9802      	ldr	r0, [sp, #8]
c0d03b88:	2800      	cmp	r0, #0
c0d03b8a:	db23      	blt.n	c0d03bd4 <os_parse_bertlv+0x188>
  if (dst > src) {
c0d03b8c:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d03b8e:	4281      	cmp	r1, r0
c0d03b90:	d928      	bls.n	c0d03be4 <os_parse_bertlv+0x198>
    while(length--) {
c0d03b92:	2a00      	cmp	r2, #0
c0d03b94:	9808      	ldr	r0, [sp, #32]
c0d03b96:	d0bb      	beq.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03b98:	9c05      	ldr	r4, [sp, #20]
c0d03b9a:	1b10      	subs	r0, r2, r4
c0d03b9c:	1909      	adds	r1, r1, r4
c0d03b9e:	1ae4      	subs	r4, r4, r3
c0d03ba0:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0d03ba2:	1e5b      	subs	r3, r3, #1
c0d03ba4:	1b9b      	subs	r3, r3, r6
c0d03ba6:	42a3      	cmp	r3, r4
c0d03ba8:	d800      	bhi.n	c0d03bac <os_parse_bertlv+0x160>
c0d03baa:	4623      	mov	r3, r4
c0d03bac:	9c0a      	ldr	r4, [sp, #40]	; 0x28
c0d03bae:	1824      	adds	r4, r4, r0
c0d03bb0:	1809      	adds	r1, r1, r0
c0d03bb2:	9805      	ldr	r0, [sp, #20]
c0d03bb4:	9d03      	ldr	r5, [sp, #12]
c0d03bb6:	1b40      	subs	r0, r0, r5
c0d03bb8:	4283      	cmp	r3, r0
c0d03bba:	d800      	bhi.n	c0d03bbe <os_parse_bertlv+0x172>
c0d03bbc:	4603      	mov	r3, r0
c0d03bbe:	1ea0      	subs	r0, r4, #2
c0d03bc0:	1e49      	subs	r1, r1, #1
c0d03bc2:	1c5b      	adds	r3, r3, #1
c0d03bc4:	9d05      	ldr	r5, [sp, #20]
      DSTCHAR[length] = SRCCHAR[length];
c0d03bc6:	7804      	ldrb	r4, [r0, #0]
c0d03bc8:	700c      	strb	r4, [r1, #0]
    while(length--) {
c0d03bca:	1940      	adds	r0, r0, r5
c0d03bcc:	1949      	adds	r1, r1, r5
c0d03bce:	1c5b      	adds	r3, r3, #1
c0d03bd0:	d1f9      	bne.n	c0d03bc6 <os_parse_bertlv+0x17a>
c0d03bd2:	e022      	b.n	c0d03c1a <os_parse_bertlv+0x1ce>
        ret = os_secure_memcmp(*buffer, tlv+offset, maxlength) == 0;
c0d03bd4:	4608      	mov	r0, r1
c0d03bd6:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d03bd8:	f7ff ff19 	bl	c0d03a0e <os_secure_memcmp>
c0d03bdc:	4601      	mov	r1, r0
c0d03bde:	4240      	negs	r0, r0
c0d03be0:	4148      	adcs	r0, r1
c0d03be2:	e795      	b.n	c0d03b10 <os_parse_bertlv+0xc4>
    while (length--) {
c0d03be4:	2a00      	cmp	r2, #0
c0d03be6:	9808      	ldr	r0, [sp, #32]
c0d03be8:	d092      	beq.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03bea:	9805      	ldr	r0, [sp, #20]
c0d03bec:	1ac3      	subs	r3, r0, r3
c0d03bee:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d03bf0:	1e40      	subs	r0, r0, #1
c0d03bf2:	1b80      	subs	r0, r0, r6
c0d03bf4:	4298      	cmp	r0, r3
c0d03bf6:	d800      	bhi.n	c0d03bfa <os_parse_bertlv+0x1ae>
c0d03bf8:	4618      	mov	r0, r3
c0d03bfa:	9b05      	ldr	r3, [sp, #20]
c0d03bfc:	9c03      	ldr	r4, [sp, #12]
c0d03bfe:	1b1b      	subs	r3, r3, r4
c0d03c00:	4298      	cmp	r0, r3
c0d03c02:	d800      	bhi.n	c0d03c06 <os_parse_bertlv+0x1ba>
c0d03c04:	4618      	mov	r0, r3
c0d03c06:	1c40      	adds	r0, r0, #1
c0d03c08:	2300      	movs	r3, #0
c0d03c0a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
      DSTCHAR[l] = SRCCHAR[l];
c0d03c0c:	b29c      	uxth	r4, r3
c0d03c0e:	5d35      	ldrb	r5, [r6, r4]
c0d03c10:	550d      	strb	r5, [r1, r4]
    while (length--) {
c0d03c12:	1c40      	adds	r0, r0, #1
      l++;
c0d03c14:	1c5b      	adds	r3, r3, #1
    while (length--) {
c0d03c16:	2800      	cmp	r0, #0
c0d03c18:	d1f8      	bne.n	c0d03c0c <os_parse_bertlv+0x1c0>
c0d03c1a:	4610      	mov	r0, r2
c0d03c1c:	e778      	b.n	c0d03b10 <os_parse_bertlv+0xc4>
c0d03c1e:	46c0      	nop			; (mov r8, r8)
c0d03c20:	3fffffff 	.word	0x3fffffff

c0d03c24 <io_seproxyhal_general_status>:

#ifndef IO_RAPDU_TRANSMIT_TIMEOUT_MS 
#define IO_RAPDU_TRANSMIT_TIMEOUT_MS 2000UL
#endif // IO_RAPDU_TRANSMIT_TIMEOUT_MS

void io_seproxyhal_general_status(void) {
c0d03c24:	b580      	push	{r7, lr}
  // avoid troubles
  if (io_seproxyhal_spi_is_status_sent()) {
c0d03c26:	f001 ff71 	bl	c0d05b0c <io_seph_is_status_sent>
c0d03c2a:	2800      	cmp	r0, #0
c0d03c2c:	d000      	beq.n	c0d03c30 <io_seproxyhal_general_status+0xc>
  G_io_seproxyhal_spi_buffer[1] = 0;
  G_io_seproxyhal_spi_buffer[2] = 2;
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND>>8;
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND;
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 5);
}
c0d03c2e:	bd80      	pop	{r7, pc}
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_GENERAL_STATUS;
c0d03c30:	4806      	ldr	r0, [pc, #24]	; (c0d03c4c <io_seproxyhal_general_status+0x28>)
c0d03c32:	2100      	movs	r1, #0
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND;
c0d03c34:	7101      	strb	r1, [r0, #4]
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND>>8;
c0d03c36:	70c1      	strb	r1, [r0, #3]
c0d03c38:	2202      	movs	r2, #2
  G_io_seproxyhal_spi_buffer[2] = 2;
c0d03c3a:	7082      	strb	r2, [r0, #2]
  G_io_seproxyhal_spi_buffer[1] = 0;
c0d03c3c:	7041      	strb	r1, [r0, #1]
c0d03c3e:	2160      	movs	r1, #96	; 0x60
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_GENERAL_STATUS;
c0d03c40:	7001      	strb	r1, [r0, #0]
c0d03c42:	2105      	movs	r1, #5
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 5);
c0d03c44:	f001 ff56 	bl	c0d05af4 <io_seph_send>
}
c0d03c48:	bd80      	pop	{r7, pc}
c0d03c4a:	46c0      	nop			; (mov r8, r8)
c0d03c4c:	20001a5c 	.word	0x20001a5c

c0d03c50 <io_seproxyhal_handle_usb_event>:
}

#ifdef HAVE_IO_USB
#ifdef HAVE_L4_USBLIB

void io_seproxyhal_handle_usb_event(void) {
c0d03c50:	b5b0      	push	{r4, r5, r7, lr}
  switch(G_io_seproxyhal_spi_buffer[3]) {
c0d03c52:	481a      	ldr	r0, [pc, #104]	; (c0d03cbc <io_seproxyhal_handle_usb_event+0x6c>)
c0d03c54:	78c0      	ldrb	r0, [r0, #3]
c0d03c56:	2803      	cmp	r0, #3
c0d03c58:	dc07      	bgt.n	c0d03c6a <io_seproxyhal_handle_usb_event+0x1a>
c0d03c5a:	2801      	cmp	r0, #1
c0d03c5c:	d00d      	beq.n	c0d03c7a <io_seproxyhal_handle_usb_event+0x2a>
c0d03c5e:	2802      	cmp	r0, #2
c0d03c60:	d128      	bne.n	c0d03cb4 <io_seproxyhal_handle_usb_event+0x64>
      }
      os_memset(G_io_app.usb_ep_xfer_len, 0, sizeof(G_io_app.usb_ep_xfer_len));
      os_memset(G_io_app.usb_ep_timeouts, 0, sizeof(G_io_app.usb_ep_timeouts));
      break;
    case SEPROXYHAL_TAG_USB_EVENT_SOF:
      USBD_LL_SOF(&USBD_Device);
c0d03c62:	4817      	ldr	r0, [pc, #92]	; (c0d03cc0 <io_seproxyhal_handle_usb_event+0x70>)
c0d03c64:	f004 f849 	bl	c0d07cfa <USBD_LL_SOF>
      break;
    case SEPROXYHAL_TAG_USB_EVENT_RESUMED:
      USBD_LL_Resume(&USBD_Device);
      break;
  }
}
c0d03c68:	bdb0      	pop	{r4, r5, r7, pc}
  switch(G_io_seproxyhal_spi_buffer[3]) {
c0d03c6a:	2804      	cmp	r0, #4
c0d03c6c:	d01f      	beq.n	c0d03cae <io_seproxyhal_handle_usb_event+0x5e>
c0d03c6e:	2808      	cmp	r0, #8
c0d03c70:	d120      	bne.n	c0d03cb4 <io_seproxyhal_handle_usb_event+0x64>
      USBD_LL_Resume(&USBD_Device);
c0d03c72:	4813      	ldr	r0, [pc, #76]	; (c0d03cc0 <io_seproxyhal_handle_usb_event+0x70>)
c0d03c74:	f004 f83f 	bl	c0d07cf6 <USBD_LL_Resume>
}
c0d03c78:	bdb0      	pop	{r4, r5, r7, pc}
      USBD_LL_SetSpeed(&USBD_Device, USBD_SPEED_FULL);  
c0d03c7a:	4c11      	ldr	r4, [pc, #68]	; (c0d03cc0 <io_seproxyhal_handle_usb_event+0x70>)
c0d03c7c:	2101      	movs	r1, #1
c0d03c7e:	4620      	mov	r0, r4
c0d03c80:	f004 f834 	bl	c0d07cec <USBD_LL_SetSpeed>
      USBD_LL_Reset(&USBD_Device);
c0d03c84:	4620      	mov	r0, r4
c0d03c86:	f004 f813 	bl	c0d07cb0 <USBD_LL_Reset>
      if (G_io_app.apdu_media != IO_APDU_MEDIA_NONE) {
c0d03c8a:	4c0e      	ldr	r4, [pc, #56]	; (c0d03cc4 <io_seproxyhal_handle_usb_event+0x74>)
c0d03c8c:	79a0      	ldrb	r0, [r4, #6]
c0d03c8e:	2800      	cmp	r0, #0
c0d03c90:	d111      	bne.n	c0d03cb6 <io_seproxyhal_handle_usb_event+0x66>
      os_memset(G_io_app.usb_ep_xfer_len, 0, sizeof(G_io_app.usb_ep_xfer_len));
c0d03c92:	4620      	mov	r0, r4
c0d03c94:	300c      	adds	r0, #12
c0d03c96:	2500      	movs	r5, #0
c0d03c98:	2204      	movs	r2, #4
c0d03c9a:	4629      	mov	r1, r5
c0d03c9c:	f7ff fe93 	bl	c0d039c6 <os_memset>
      os_memset(G_io_app.usb_ep_timeouts, 0, sizeof(G_io_app.usb_ep_timeouts));
c0d03ca0:	3410      	adds	r4, #16
c0d03ca2:	2208      	movs	r2, #8
c0d03ca4:	4620      	mov	r0, r4
c0d03ca6:	4629      	mov	r1, r5
c0d03ca8:	f7ff fe8d 	bl	c0d039c6 <os_memset>
}
c0d03cac:	bdb0      	pop	{r4, r5, r7, pc}
      USBD_LL_Suspend(&USBD_Device);
c0d03cae:	4804      	ldr	r0, [pc, #16]	; (c0d03cc0 <io_seproxyhal_handle_usb_event+0x70>)
c0d03cb0:	f004 f81f 	bl	c0d07cf2 <USBD_LL_Suspend>
}
c0d03cb4:	bdb0      	pop	{r4, r5, r7, pc}
c0d03cb6:	2010      	movs	r0, #16
        THROW(EXCEPTION_IO_RESET);
c0d03cb8:	f7ff fea3 	bl	c0d03a02 <os_longjmp>
c0d03cbc:	20001a5c 	.word	0x20001a5c
c0d03cc0:	20002074 	.word	0x20002074
c0d03cc4:	20001fb4 	.word	0x20001fb4

c0d03cc8 <io_seproxyhal_get_ep_rx_size>:

uint16_t io_seproxyhal_get_ep_rx_size(uint8_t epnum) {
c0d03cc8:	217f      	movs	r1, #127	; 0x7f
  if ((epnum & 0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d03cca:	4001      	ands	r1, r0
c0d03ccc:	2903      	cmp	r1, #3
c0d03cce:	d803      	bhi.n	c0d03cd8 <io_seproxyhal_get_ep_rx_size+0x10>
  return G_io_app.usb_ep_xfer_len[epnum&0x7F];
c0d03cd0:	4802      	ldr	r0, [pc, #8]	; (c0d03cdc <io_seproxyhal_get_ep_rx_size+0x14>)
c0d03cd2:	1840      	adds	r0, r0, r1
c0d03cd4:	7b00      	ldrb	r0, [r0, #12]
}
  return 0;
}
c0d03cd6:	4770      	bx	lr
c0d03cd8:	2000      	movs	r0, #0
c0d03cda:	4770      	bx	lr
c0d03cdc:	20001fb4 	.word	0x20001fb4

c0d03ce0 <io_seproxyhal_handle_usb_ep_xfer_event>:

void io_seproxyhal_handle_usb_ep_xfer_event(void) {
c0d03ce0:	b580      	push	{r7, lr}
  switch(G_io_seproxyhal_spi_buffer[4]) {
c0d03ce2:	4815      	ldr	r0, [pc, #84]	; (c0d03d38 <io_seproxyhal_handle_usb_ep_xfer_event+0x58>)
c0d03ce4:	7901      	ldrb	r1, [r0, #4]
c0d03ce6:	2904      	cmp	r1, #4
c0d03ce8:	d017      	beq.n	c0d03d1a <io_seproxyhal_handle_usb_ep_xfer_event+0x3a>
c0d03cea:	2902      	cmp	r1, #2
c0d03cec:	d006      	beq.n	c0d03cfc <io_seproxyhal_handle_usb_ep_xfer_event+0x1c>
c0d03cee:	2901      	cmp	r1, #1
c0d03cf0:	d120      	bne.n	c0d03d34 <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
    /* This event is received when a new SETUP token had been received on a control endpoint */
    case SEPROXYHAL_TAG_USB_EP_XFER_SETUP:
      // assume length of setup packet, and that it is on endpoint 0
      USBD_LL_SetupStage(&USBD_Device, &G_io_seproxyhal_spi_buffer[6]);
c0d03cf2:	1d81      	adds	r1, r0, #6
c0d03cf4:	4812      	ldr	r0, [pc, #72]	; (c0d03d40 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d03cf6:	f003 fee4 	bl	c0d07ac2 <USBD_LL_SetupStage>
        // prepare reception
        USBD_LL_DataOutStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
      }
      break;
  }
}
c0d03cfa:	bd80      	pop	{r7, pc}
      if ((G_io_seproxyhal_spi_buffer[3]&0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d03cfc:	78c2      	ldrb	r2, [r0, #3]
c0d03cfe:	217f      	movs	r1, #127	; 0x7f
c0d03d00:	4011      	ands	r1, r2
c0d03d02:	2903      	cmp	r1, #3
c0d03d04:	d816      	bhi.n	c0d03d34 <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
        G_io_app.usb_ep_timeouts[G_io_seproxyhal_spi_buffer[3]&0x7F].timeout = 0;
c0d03d06:	004a      	lsls	r2, r1, #1
c0d03d08:	4b0c      	ldr	r3, [pc, #48]	; (c0d03d3c <io_seproxyhal_handle_usb_ep_xfer_event+0x5c>)
c0d03d0a:	189a      	adds	r2, r3, r2
c0d03d0c:	2300      	movs	r3, #0
c0d03d0e:	8213      	strh	r3, [r2, #16]
        USBD_LL_DataInStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
c0d03d10:	1d82      	adds	r2, r0, #6
c0d03d12:	480b      	ldr	r0, [pc, #44]	; (c0d03d40 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d03d14:	f003 ff5a 	bl	c0d07bcc <USBD_LL_DataInStage>
}
c0d03d18:	bd80      	pop	{r7, pc}
      if ((G_io_seproxyhal_spi_buffer[3]&0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d03d1a:	78c2      	ldrb	r2, [r0, #3]
c0d03d1c:	217f      	movs	r1, #127	; 0x7f
c0d03d1e:	4011      	ands	r1, r2
c0d03d20:	2903      	cmp	r1, #3
c0d03d22:	d807      	bhi.n	c0d03d34 <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
        G_io_app.usb_ep_xfer_len[G_io_seproxyhal_spi_buffer[3]&0x7F] = G_io_seproxyhal_spi_buffer[5];
c0d03d24:	4a05      	ldr	r2, [pc, #20]	; (c0d03d3c <io_seproxyhal_handle_usb_ep_xfer_event+0x5c>)
c0d03d26:	1852      	adds	r2, r2, r1
c0d03d28:	7943      	ldrb	r3, [r0, #5]
c0d03d2a:	7313      	strb	r3, [r2, #12]
        USBD_LL_DataOutStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
c0d03d2c:	1d82      	adds	r2, r0, #6
c0d03d2e:	4804      	ldr	r0, [pc, #16]	; (c0d03d40 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d03d30:	f003 fef5 	bl	c0d07b1e <USBD_LL_DataOutStage>
}
c0d03d34:	bd80      	pop	{r7, pc}
c0d03d36:	46c0      	nop			; (mov r8, r8)
c0d03d38:	20001a5c 	.word	0x20001a5c
c0d03d3c:	20001fb4 	.word	0x20001fb4
c0d03d40:	20002074 	.word	0x20002074

c0d03d44 <io_usb_send_ep>:
#endif // HAVE_L4_USBLIB

// TODO, refactor this using the USB DataIn event like for the U2F tunnel
// TODO add a blocking parameter, for HID KBD sending, or use a USB busy flag per channel to know if 
// the transfer has been processed or not. and move on to the next transfer on the same endpoint
void io_usb_send_ep(unsigned int ep, unsigned char* buffer, unsigned short length, unsigned int timeout) {
c0d03d44:	b570      	push	{r4, r5, r6, lr}
  if (timeout) {
    timeout++;
  }

  // won't send if overflowing seproxyhal buffer format
  if (length > 255) {
c0d03d46:	2aff      	cmp	r2, #255	; 0xff
c0d03d48:	d81e      	bhi.n	c0d03d88 <io_usb_send_ep+0x44>
c0d03d4a:	4615      	mov	r5, r2
c0d03d4c:	460e      	mov	r6, r1
c0d03d4e:	4604      	mov	r4, r0
    return;
  }
  
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d03d50:	480e      	ldr	r0, [pc, #56]	; (c0d03d8c <io_usb_send_ep+0x48>)
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
  G_io_seproxyhal_spi_buffer[2] = (3+length);
  G_io_seproxyhal_spi_buffer[3] = ep|0x80;
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
  G_io_seproxyhal_spi_buffer[5] = length;
c0d03d52:	7142      	strb	r2, [r0, #5]
c0d03d54:	2120      	movs	r1, #32
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
c0d03d56:	7101      	strb	r1, [r0, #4]
c0d03d58:	2150      	movs	r1, #80	; 0x50
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d03d5a:	7001      	strb	r1, [r0, #0]
c0d03d5c:	2180      	movs	r1, #128	; 0x80
  G_io_seproxyhal_spi_buffer[3] = ep|0x80;
c0d03d5e:	4321      	orrs	r1, r4
c0d03d60:	70c1      	strb	r1, [r0, #3]
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
c0d03d62:	1cd1      	adds	r1, r2, #3
  G_io_seproxyhal_spi_buffer[2] = (3+length);
c0d03d64:	7081      	strb	r1, [r0, #2]
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
c0d03d66:	0a09      	lsrs	r1, r1, #8
c0d03d68:	7041      	strb	r1, [r0, #1]
c0d03d6a:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 6);
c0d03d6c:	f001 fec2 	bl	c0d05af4 <io_seph_send>
  io_seproxyhal_spi_send(buffer, length);
c0d03d70:	4630      	mov	r0, r6
c0d03d72:	4629      	mov	r1, r5
c0d03d74:	f001 febe 	bl	c0d05af4 <io_seph_send>
c0d03d78:	207f      	movs	r0, #127	; 0x7f
  // setup timeout of the endpoint
  G_io_app.usb_ep_timeouts[ep&0x7F].timeout = IO_RAPDU_TRANSMIT_TIMEOUT_MS;
c0d03d7a:	4020      	ands	r0, r4
c0d03d7c:	0040      	lsls	r0, r0, #1
c0d03d7e:	4904      	ldr	r1, [pc, #16]	; (c0d03d90 <io_usb_send_ep+0x4c>)
c0d03d80:	1808      	adds	r0, r1, r0
c0d03d82:	217d      	movs	r1, #125	; 0x7d
c0d03d84:	0109      	lsls	r1, r1, #4
c0d03d86:	8201      	strh	r1, [r0, #16]
}
c0d03d88:	bd70      	pop	{r4, r5, r6, pc}
c0d03d8a:	46c0      	nop			; (mov r8, r8)
c0d03d8c:	20001a5c 	.word	0x20001a5c
c0d03d90:	20001fb4 	.word	0x20001fb4

c0d03d94 <io_usb_send_apdu_data>:

void io_usb_send_apdu_data(unsigned char* buffer, unsigned short length) {
c0d03d94:	b580      	push	{r7, lr}
c0d03d96:	460a      	mov	r2, r1
c0d03d98:	4601      	mov	r1, r0
c0d03d9a:	2082      	movs	r0, #130	; 0x82
c0d03d9c:	2314      	movs	r3, #20
  // wait for 20 events before hanging up and timeout (~2 seconds of timeout)
  io_usb_send_ep(0x82, buffer, length, 20);
c0d03d9e:	f7ff ffd1 	bl	c0d03d44 <io_usb_send_ep>
}
c0d03da2:	bd80      	pop	{r7, pc}

c0d03da4 <io_usb_send_apdu_data_ep0x83>:

#ifdef HAVE_WEBUSB
void io_usb_send_apdu_data_ep0x83(unsigned char* buffer, unsigned short length) {
c0d03da4:	b580      	push	{r7, lr}
c0d03da6:	460a      	mov	r2, r1
c0d03da8:	4601      	mov	r1, r0
c0d03daa:	2083      	movs	r0, #131	; 0x83
c0d03dac:	2314      	movs	r3, #20
  // wait for 20 events before hanging up and timeout (~2 seconds of timeout)
  io_usb_send_ep(0x83, buffer, length, 20);
c0d03dae:	f7ff ffc9 	bl	c0d03d44 <io_usb_send_ep>
}
c0d03db2:	bd80      	pop	{r7, pc}

c0d03db4 <io_seproxyhal_handle_capdu_event>:
void io_seproxyhal_handle_bluenrg_event(void) {

}
#endif // HAVE_BLUENRG

void io_seproxyhal_handle_capdu_event(void) {
c0d03db4:	b580      	push	{r7, lr}
  if (G_io_app.apdu_state == APDU_IDLE) {
c0d03db6:	480b      	ldr	r0, [pc, #44]	; (c0d03de4 <io_seproxyhal_handle_capdu_event+0x30>)
c0d03db8:	7801      	ldrb	r1, [r0, #0]
c0d03dba:	2900      	cmp	r1, #0
c0d03dbc:	d000      	beq.n	c0d03dc0 <io_seproxyhal_handle_capdu_event+0xc>
    G_io_app.apdu_state = APDU_RAW; // for next call to io_exchange
    G_io_app.apdu_length = MIN(size, max);
    // copy apdu to apdu buffer
    os_memmove(G_io_apdu_buffer, G_io_seproxyhal_spi_buffer+3, G_io_app.apdu_length);
  }
}
c0d03dbe:	bd80      	pop	{r7, pc}
c0d03dc0:	2106      	movs	r1, #6
    G_io_app.apdu_media = IO_APDU_MEDIA_RAW; // for application code
c0d03dc2:	7181      	strb	r1, [r0, #6]
c0d03dc4:	210a      	movs	r1, #10
    G_io_app.apdu_state = APDU_RAW; // for next call to io_exchange
c0d03dc6:	7001      	strb	r1, [r0, #0]
    size_t size = U2BE(G_io_seproxyhal_spi_buffer, 1);
c0d03dc8:	4907      	ldr	r1, [pc, #28]	; (c0d03de8 <io_seproxyhal_handle_capdu_event+0x34>)
c0d03dca:	788a      	ldrb	r2, [r1, #2]
c0d03dcc:	784b      	ldrb	r3, [r1, #1]
c0d03dce:	021b      	lsls	r3, r3, #8
c0d03dd0:	189a      	adds	r2, r3, r2
    G_io_app.apdu_length = MIN(size, max);
c0d03dd2:	2a45      	cmp	r2, #69	; 0x45
c0d03dd4:	d300      	bcc.n	c0d03dd8 <io_seproxyhal_handle_capdu_event+0x24>
c0d03dd6:	2245      	movs	r2, #69	; 0x45
c0d03dd8:	8042      	strh	r2, [r0, #2]
    os_memmove(G_io_apdu_buffer, G_io_seproxyhal_spi_buffer+3, G_io_app.apdu_length);
c0d03dda:	1cc9      	adds	r1, r1, #3
c0d03ddc:	4803      	ldr	r0, [pc, #12]	; (c0d03dec <io_seproxyhal_handle_capdu_event+0x38>)
c0d03dde:	f7ff fddc 	bl	c0d0399a <os_memmove>
}
c0d03de2:	bd80      	pop	{r7, pc}
c0d03de4:	20001fb4 	.word	0x20001fb4
c0d03de8:	20001a5c 	.word	0x20001a5c
c0d03dec:	20001e61 	.word	0x20001e61

c0d03df0 <io_seproxyhal_handle_event>:

unsigned int io_seproxyhal_handle_event(void) {
c0d03df0:	b580      	push	{r7, lr}
  unsigned int rx_len = U2BE(G_io_seproxyhal_spi_buffer, 1);
c0d03df2:	491f      	ldr	r1, [pc, #124]	; (c0d03e70 <io_seproxyhal_handle_event+0x80>)
c0d03df4:	7888      	ldrb	r0, [r1, #2]
c0d03df6:	784a      	ldrb	r2, [r1, #1]
c0d03df8:	0212      	lsls	r2, r2, #8
c0d03dfa:	1810      	adds	r0, r2, r0

  switch(G_io_seproxyhal_spi_buffer[0]) {
c0d03dfc:	7809      	ldrb	r1, [r1, #0]
c0d03dfe:	290f      	cmp	r1, #15
c0d03e00:	dc09      	bgt.n	c0d03e16 <io_seproxyhal_handle_event+0x26>
c0d03e02:	290e      	cmp	r1, #14
c0d03e04:	d00f      	beq.n	c0d03e26 <io_seproxyhal_handle_event+0x36>
c0d03e06:	290f      	cmp	r1, #15
c0d03e08:	d120      	bne.n	c0d03e4c <io_seproxyhal_handle_event+0x5c>
  #ifdef HAVE_IO_USB
    case SEPROXYHAL_TAG_USB_EVENT:
      if (rx_len != 1) {
c0d03e0a:	2801      	cmp	r0, #1
c0d03e0c:	d124      	bne.n	c0d03e58 <io_seproxyhal_handle_event+0x68>
        return 0;
      }
      io_seproxyhal_handle_usb_event();
c0d03e0e:	f7ff ff1f 	bl	c0d03c50 <io_seproxyhal_handle_usb_event>
c0d03e12:	2001      	movs	r0, #1
    default:
      return io_event(CHANNEL_SPI);
  }
  // defaultly return as not processed
  return 0;
}
c0d03e14:	bd80      	pop	{r7, pc}
  switch(G_io_seproxyhal_spi_buffer[0]) {
c0d03e16:	2910      	cmp	r1, #16
c0d03e18:	d01c      	beq.n	c0d03e54 <io_seproxyhal_handle_event+0x64>
c0d03e1a:	2916      	cmp	r1, #22
c0d03e1c:	d116      	bne.n	c0d03e4c <io_seproxyhal_handle_event+0x5c>
      io_seproxyhal_handle_capdu_event();
c0d03e1e:	f7ff ffc9 	bl	c0d03db4 <io_seproxyhal_handle_capdu_event>
c0d03e22:	2001      	movs	r0, #1
}
c0d03e24:	bd80      	pop	{r7, pc}
      G_io_app.ms += 100; // value is by default, don't change the ticker configuration
c0d03e26:	4813      	ldr	r0, [pc, #76]	; (c0d03e74 <io_seproxyhal_handle_event+0x84>)
c0d03e28:	6881      	ldr	r1, [r0, #8]
c0d03e2a:	3164      	adds	r1, #100	; 0x64
c0d03e2c:	6081      	str	r1, [r0, #8]
c0d03e2e:	2116      	movs	r1, #22
          if (G_io_app.usb_ep_timeouts[i].timeout) {
c0d03e30:	5a42      	ldrh	r2, [r0, r1]
c0d03e32:	2a00      	cmp	r2, #0
c0d03e34:	d007      	beq.n	c0d03e46 <io_seproxyhal_handle_event+0x56>
            G_io_app.usb_ep_timeouts[i].timeout-=MIN(G_io_app.usb_ep_timeouts[i].timeout, 100);
c0d03e36:	2a64      	cmp	r2, #100	; 0x64
c0d03e38:	4613      	mov	r3, r2
c0d03e3a:	d300      	bcc.n	c0d03e3e <io_seproxyhal_handle_event+0x4e>
c0d03e3c:	2364      	movs	r3, #100	; 0x64
c0d03e3e:	1ad2      	subs	r2, r2, r3
c0d03e40:	5242      	strh	r2, [r0, r1]
            if (!G_io_app.usb_ep_timeouts[i].timeout) {
c0d03e42:	0412      	lsls	r2, r2, #16
c0d03e44:	d00e      	beq.n	c0d03e64 <io_seproxyhal_handle_event+0x74>
        while(i--) {
c0d03e46:	1e89      	subs	r1, r1, #2
c0d03e48:	290e      	cmp	r1, #14
c0d03e4a:	d1f1      	bne.n	c0d03e30 <io_seproxyhal_handle_event+0x40>
c0d03e4c:	2002      	movs	r0, #2
      return io_event(CHANNEL_SPI);
c0d03e4e:	f7ff fad5 	bl	c0d033fc <io_event>
}
c0d03e52:	bd80      	pop	{r7, pc}
      if (rx_len < 3) {
c0d03e54:	2803      	cmp	r0, #3
c0d03e56:	d201      	bcs.n	c0d03e5c <io_seproxyhal_handle_event+0x6c>
c0d03e58:	2000      	movs	r0, #0
}
c0d03e5a:	bd80      	pop	{r7, pc}
      io_seproxyhal_handle_usb_ep_xfer_event();
c0d03e5c:	f7ff ff40 	bl	c0d03ce0 <io_seproxyhal_handle_usb_ep_xfer_event>
c0d03e60:	2001      	movs	r0, #1
}
c0d03e62:	bd80      	pop	{r7, pc}
c0d03e64:	2100      	movs	r1, #0
              G_io_app.apdu_state = APDU_IDLE;
c0d03e66:	7001      	strb	r1, [r0, #0]
c0d03e68:	2010      	movs	r0, #16
              THROW(EXCEPTION_IO_RESET);
c0d03e6a:	f7ff fdca 	bl	c0d03a02 <os_longjmp>
c0d03e6e:	46c0      	nop			; (mov r8, r8)
c0d03e70:	20001a5c 	.word	0x20001a5c
c0d03e74:	20001fb4 	.word	0x20001fb4

c0d03e78 <io_seproxyhal_init>:
#ifdef HAVE_BOLOS_APP_STACK_CANARY
#define APP_STACK_CANARY_MAGIC 0xDEAD0031
extern unsigned int app_stack_canary;
#endif // HAVE_BOLOS_APP_STACK_CANARY

void io_seproxyhal_init(void) {
c0d03e78:	b5b0      	push	{r4, r5, r7, lr}
c0d03e7a:	200a      	movs	r0, #10
#ifndef HAVE_BOLOS
  // Enforce OS compatibility
  check_api_level(CX_COMPAT_APILEVEL);
c0d03e7c:	f001 fc90 	bl	c0d057a0 <check_api_level>

  // wipe the io structure before it's used
#ifdef TARGET_NANOX
  unsigned int plane = G_io_app.plane_mode;
#endif // TARGET_NANOX
  os_memset(&G_io_app, 0, sizeof(G_io_app));
c0d03e80:	4c09      	ldr	r4, [pc, #36]	; (c0d03ea8 <io_seproxyhal_init+0x30>)
c0d03e82:	2500      	movs	r5, #0
c0d03e84:	2218      	movs	r2, #24
c0d03e86:	4620      	mov	r0, r4
c0d03e88:	4629      	mov	r1, r5
c0d03e8a:	f7ff fd9c 	bl	c0d039c6 <os_memset>

  G_io_app.apdu_state = APDU_IDLE;
  G_io_app.apdu_length = 0;
  G_io_app.apdu_media = IO_APDU_MEDIA_NONE;

  G_io_app.ms = 0;
c0d03e8e:	60a5      	str	r5, [r4, #8]
  G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0d03e90:	71a5      	strb	r5, [r4, #6]
  G_io_app.apdu_length = 0;
c0d03e92:	8065      	strh	r5, [r4, #2]
  G_io_app.apdu_state = APDU_IDLE;
c0d03e94:	7025      	strb	r5, [r4, #0]
  #ifdef DEBUG_APDU
  debug_apdus_offset = 0;
  #endif // DEBUG_APDU

  #ifdef HAVE_USB_APDU
  io_usb_hid_init();
c0d03e96:	f000 fb3d 	bl	c0d04514 <io_usb_hid_init>
// #endif // TARGET_NANOX
}

void io_seproxyhal_init_button(void) {
  // no button push so far
  G_ux_os.button_mask = 0;
c0d03e9a:	4804      	ldr	r0, [pc, #16]	; (c0d03eac <io_seproxyhal_init+0x34>)
c0d03e9c:	6005      	str	r5, [r0, #0]
  G_ux_os.button_same_mask_counter = 0;
c0d03e9e:	6045      	str	r5, [r0, #4]
  check_audited_app();
c0d03ea0:	f7fc f924 	bl	c0d000ec <check_audited_app>
}
c0d03ea4:	bdb0      	pop	{r4, r5, r7, pc}
c0d03ea6:	46c0      	nop			; (mov r8, r8)
c0d03ea8:	20001fb4 	.word	0x20001fb4
c0d03eac:	20001fcc 	.word	0x20001fcc

c0d03eb0 <io_seproxyhal_init_ux>:
}
c0d03eb0:	4770      	bx	lr
	...

c0d03eb4 <io_seproxyhal_init_button>:
  G_ux_os.button_mask = 0;
c0d03eb4:	4802      	ldr	r0, [pc, #8]	; (c0d03ec0 <io_seproxyhal_init_button+0xc>)
c0d03eb6:	2100      	movs	r1, #0
c0d03eb8:	6001      	str	r1, [r0, #0]
  G_ux_os.button_same_mask_counter = 0;
c0d03eba:	6041      	str	r1, [r0, #4]
}
c0d03ebc:	4770      	bx	lr
c0d03ebe:	46c0      	nop			; (mov r8, r8)
c0d03ec0:	20001fcc 	.word	0x20001fcc

c0d03ec4 <io_seproxyhal_display_icon>:
    }
  }
}

#else // TARGET_NANOX
void io_seproxyhal_display_icon(bagl_component_t* icon_component, bagl_icon_details_t* icon_det) {
c0d03ec4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d03ec6:	b089      	sub	sp, #36	; 0x24
c0d03ec8:	4605      	mov	r5, r0
  bagl_component_t icon_component_mod;
  const bagl_icon_details_t* icon_details = (bagl_icon_details_t*)PIC(icon_det);
c0d03eca:	4608      	mov	r0, r1
c0d03ecc:	f000 fd82 	bl	c0d049d4 <pic>
  if (icon_details && icon_details->bitmap) {
c0d03ed0:	2800      	cmp	r0, #0
c0d03ed2:	d043      	beq.n	c0d03f5c <io_seproxyhal_display_icon+0x98>
c0d03ed4:	4604      	mov	r4, r0
c0d03ed6:	6900      	ldr	r0, [r0, #16]
c0d03ed8:	2800      	cmp	r0, #0
c0d03eda:	d03f      	beq.n	c0d03f5c <io_seproxyhal_display_icon+0x98>
    // ensure not being out of bounds in the icon component agianst the declared icon real size
    os_memmove(&icon_component_mod, (bagl_component_t *)PIC(icon_component), sizeof(bagl_component_t));
c0d03edc:	4628      	mov	r0, r5
c0d03ede:	f000 fd79 	bl	c0d049d4 <pic>
c0d03ee2:	4601      	mov	r1, r0
c0d03ee4:	ad02      	add	r5, sp, #8
c0d03ee6:	221c      	movs	r2, #28
c0d03ee8:	4628      	mov	r0, r5
c0d03eea:	9201      	str	r2, [sp, #4]
c0d03eec:	f7ff fd55 	bl	c0d0399a <os_memmove>
    icon_component_mod.width = icon_details->width;
c0d03ef0:	6821      	ldr	r1, [r4, #0]
c0d03ef2:	80e9      	strh	r1, [r5, #6]
    icon_component_mod.height = icon_details->height;
c0d03ef4:	6862      	ldr	r2, [r4, #4]
c0d03ef6:	812a      	strh	r2, [r5, #8]
    // component type = ICON, provided bitmap
    // => bitmap transmitted


    // color index size
    unsigned int h = (1<<(icon_details->bpp))*sizeof(unsigned int); 
c0d03ef8:	68a0      	ldr	r0, [r4, #8]
    unsigned int w = ((icon_component->width*icon_component->height*icon_details->bpp)/8)+((icon_component->width*icon_component->height*icon_details->bpp)%8?1:0);
    unsigned short length = sizeof(bagl_component_t)
                            +1 /* bpp */
                            +h /* color index */
                            +w; /* image bitmap size */
    G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d03efa:	4f19      	ldr	r7, [pc, #100]	; (c0d03f60 <io_seproxyhal_display_icon+0x9c>)
c0d03efc:	2365      	movs	r3, #101	; 0x65
c0d03efe:	463e      	mov	r6, r7
c0d03f00:	703b      	strb	r3, [r7, #0]
    unsigned int w = ((icon_component->width*icon_component->height*icon_details->bpp)/8)+((icon_component->width*icon_component->height*icon_details->bpp)%8?1:0);
c0d03f02:	b289      	uxth	r1, r1
c0d03f04:	b292      	uxth	r2, r2
c0d03f06:	434a      	muls	r2, r1
c0d03f08:	4342      	muls	r2, r0
c0d03f0a:	0751      	lsls	r1, r2, #29
c0d03f0c:	08d2      	lsrs	r2, r2, #3
c0d03f0e:	2900      	cmp	r1, #0
c0d03f10:	d000      	beq.n	c0d03f14 <io_seproxyhal_display_icon+0x50>
c0d03f12:	1c52      	adds	r2, r2, #1
c0d03f14:	9200      	str	r2, [sp, #0]
c0d03f16:	2704      	movs	r7, #4
    unsigned int h = (1<<(icon_details->bpp))*sizeof(unsigned int); 
c0d03f18:	4087      	lsls	r7, r0
                            +h /* color index */
c0d03f1a:	18b8      	adds	r0, r7, r2
                            +w; /* image bitmap size */
c0d03f1c:	301d      	adds	r0, #29
    G_io_seproxyhal_spi_buffer[1] = length>>8;
    G_io_seproxyhal_spi_buffer[2] = length;
c0d03f1e:	70b0      	strb	r0, [r6, #2]
    G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d03f20:	0a00      	lsrs	r0, r0, #8
c0d03f22:	7070      	strb	r0, [r6, #1]
c0d03f24:	2103      	movs	r1, #3
    io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d03f26:	4630      	mov	r0, r6
c0d03f28:	f001 fde4 	bl	c0d05af4 <io_seph_send>
    io_seproxyhal_spi_send((unsigned char*)icon_component, sizeof(bagl_component_t));
c0d03f2c:	4628      	mov	r0, r5
c0d03f2e:	9901      	ldr	r1, [sp, #4]
c0d03f30:	f001 fde0 	bl	c0d05af4 <io_seph_send>
    G_io_seproxyhal_spi_buffer[0] = icon_details->bpp;
c0d03f34:	68a0      	ldr	r0, [r4, #8]
c0d03f36:	7030      	strb	r0, [r6, #0]
c0d03f38:	2101      	movs	r1, #1
    io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 1);
c0d03f3a:	4630      	mov	r0, r6
c0d03f3c:	f001 fdda 	bl	c0d05af4 <io_seph_send>
    io_seproxyhal_spi_send((unsigned char*)PIC(icon_details->colors), h);
c0d03f40:	68e0      	ldr	r0, [r4, #12]
c0d03f42:	f000 fd47 	bl	c0d049d4 <pic>
c0d03f46:	b2b9      	uxth	r1, r7
c0d03f48:	f001 fdd4 	bl	c0d05af4 <io_seph_send>
    io_seproxyhal_spi_send((unsigned char*)PIC(icon_details->bitmap), w);
c0d03f4c:	9800      	ldr	r0, [sp, #0]
c0d03f4e:	b285      	uxth	r5, r0
c0d03f50:	6920      	ldr	r0, [r4, #16]
c0d03f52:	f000 fd3f 	bl	c0d049d4 <pic>
c0d03f56:	4629      	mov	r1, r5
c0d03f58:	f001 fdcc 	bl	c0d05af4 <io_seph_send>
  #endif // !SEPROXYHAL_TAG_SCREEN_DISPLAY_RAW_STATUS
  }
}
c0d03f5c:	b009      	add	sp, #36	; 0x24
c0d03f5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03f60:	20001a5c 	.word	0x20001a5c

c0d03f64 <io_seproxyhal_display_default>:

void io_seproxyhal_display_default(const bagl_element_t * el) {
c0d03f64:	b570      	push	{r4, r5, r6, lr}

  const bagl_element_t* element = (const bagl_element_t*) PIC(el);
c0d03f66:	f000 fd35 	bl	c0d049d4 <pic>
c0d03f6a:	4604      	mov	r4, r0

  // process automagically address from rom and from ram
  unsigned int type = (element->component.type & ~(BAGL_FLAG_TOUCHABLE));
c0d03f6c:	7806      	ldrb	r6, [r0, #0]

  // avoid sending another status :), fixes a lot of bugs in the end
  if (io_seproxyhal_spi_is_status_sent()) {
c0d03f6e:	f001 fdcd 	bl	c0d05b0c <io_seph_is_status_sent>
c0d03f72:	2800      	cmp	r0, #0
c0d03f74:	d132      	bne.n	c0d03fdc <io_seproxyhal_display_default+0x78>
c0d03f76:	207f      	movs	r0, #127	; 0x7f
c0d03f78:	4006      	ands	r6, r0
c0d03f7a:	2e00      	cmp	r6, #0
c0d03f7c:	d02e      	beq.n	c0d03fdc <io_seproxyhal_display_default+0x78>
    return;
  }

  if (type != BAGL_NONE) {
    if (element->text != NULL) {
c0d03f7e:	69e0      	ldr	r0, [r4, #28]
c0d03f80:	2800      	cmp	r0, #0
c0d03f82:	d01d      	beq.n	c0d03fc0 <io_seproxyhal_display_default+0x5c>
      unsigned int text_adr = PIC((unsigned int)element->text);
c0d03f84:	f000 fd26 	bl	c0d049d4 <pic>
c0d03f88:	4605      	mov	r5, r0
      // consider an icon details descriptor is pointed by the context
      if (type == BAGL_ICON && element->component.icon_id == 0) {
c0d03f8a:	2e05      	cmp	r6, #5
c0d03f8c:	d102      	bne.n	c0d03f94 <io_seproxyhal_display_default+0x30>
c0d03f8e:	7ea0      	ldrb	r0, [r4, #26]
c0d03f90:	2800      	cmp	r0, #0
c0d03f92:	d024      	beq.n	c0d03fde <io_seproxyhal_display_default+0x7a>
        io_seproxyhal_display_icon((bagl_component_t*)&element->component, (bagl_icon_details_t*)text_adr);
      }
      else {
        unsigned short length = sizeof(bagl_component_t)+strlen((const char*)text_adr);
c0d03f94:	4628      	mov	r0, r5
c0d03f96:	f005 fced 	bl	c0d09974 <strlen>
c0d03f9a:	4606      	mov	r6, r0
        G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d03f9c:	4812      	ldr	r0, [pc, #72]	; (c0d03fe8 <io_seproxyhal_display_default+0x84>)
c0d03f9e:	2165      	movs	r1, #101	; 0x65
c0d03fa0:	7001      	strb	r1, [r0, #0]
        unsigned short length = sizeof(bagl_component_t)+strlen((const char*)text_adr);
c0d03fa2:	4631      	mov	r1, r6
c0d03fa4:	311c      	adds	r1, #28
        G_io_seproxyhal_spi_buffer[1] = length>>8;
        G_io_seproxyhal_spi_buffer[2] = length;
c0d03fa6:	7081      	strb	r1, [r0, #2]
        G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d03fa8:	0a09      	lsrs	r1, r1, #8
c0d03faa:	7041      	strb	r1, [r0, #1]
c0d03fac:	2103      	movs	r1, #3
        io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d03fae:	f001 fda1 	bl	c0d05af4 <io_seph_send>
c0d03fb2:	211c      	movs	r1, #28
        io_seproxyhal_spi_send((unsigned char*)&element->component, sizeof(bagl_component_t));
c0d03fb4:	4620      	mov	r0, r4
c0d03fb6:	f001 fd9d 	bl	c0d05af4 <io_seph_send>
        io_seproxyhal_spi_send((unsigned char*)text_adr, length-sizeof(bagl_component_t));
c0d03fba:	b2b1      	uxth	r1, r6
c0d03fbc:	4628      	mov	r0, r5
c0d03fbe:	e00b      	b.n	c0d03fd8 <io_seproxyhal_display_default+0x74>
      }
    }
    else {
      unsigned short length = sizeof(bagl_component_t);
      G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d03fc0:	4809      	ldr	r0, [pc, #36]	; (c0d03fe8 <io_seproxyhal_display_default+0x84>)
c0d03fc2:	251c      	movs	r5, #28
      G_io_seproxyhal_spi_buffer[1] = length>>8;
      G_io_seproxyhal_spi_buffer[2] = length;
c0d03fc4:	7085      	strb	r5, [r0, #2]
c0d03fc6:	2100      	movs	r1, #0
      G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d03fc8:	7041      	strb	r1, [r0, #1]
c0d03fca:	2165      	movs	r1, #101	; 0x65
      G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d03fcc:	7001      	strb	r1, [r0, #0]
c0d03fce:	2103      	movs	r1, #3
      io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d03fd0:	f001 fd90 	bl	c0d05af4 <io_seph_send>
      io_seproxyhal_spi_send((unsigned char*)&element->component, sizeof(bagl_component_t));
c0d03fd4:	4620      	mov	r0, r4
c0d03fd6:	4629      	mov	r1, r5
c0d03fd8:	f001 fd8c 	bl	c0d05af4 <io_seph_send>
    }
  }
}
c0d03fdc:	bd70      	pop	{r4, r5, r6, pc}
        io_seproxyhal_display_icon((bagl_component_t*)&element->component, (bagl_icon_details_t*)text_adr);
c0d03fde:	4620      	mov	r0, r4
c0d03fe0:	4629      	mov	r1, r5
c0d03fe2:	f7ff ff6f 	bl	c0d03ec4 <io_seproxyhal_display_icon>
}
c0d03fe6:	bd70      	pop	{r4, r5, r6, pc}
c0d03fe8:	20001a5c 	.word	0x20001a5c

c0d03fec <io_seproxyhal_button_push>:
  
  // compute scrolled text length
  return 2*(textlen - e->component.width)*1000/e->component.icon_id + 2*(e->component.stroke & ~(0x80))*100;
}

void io_seproxyhal_button_push(button_push_callback_t button_callback, unsigned int new_button_mask) {
c0d03fec:	b570      	push	{r4, r5, r6, lr}
  if (button_callback) {
c0d03fee:	2800      	cmp	r0, #0
c0d03ff0:	d027      	beq.n	c0d04042 <io_seproxyhal_button_push+0x56>
c0d03ff2:	4604      	mov	r4, r0
    unsigned int button_mask;
    unsigned int button_same_mask_counter;
    // enable speeded up long push
    if (new_button_mask == G_ux_os.button_mask) {
c0d03ff4:	4813      	ldr	r0, [pc, #76]	; (c0d04044 <io_seproxyhal_button_push+0x58>)
c0d03ff6:	c860      	ldmia	r0!, {r5, r6}
c0d03ff8:	3808      	subs	r0, #8
c0d03ffa:	428d      	cmp	r5, r1
c0d03ffc:	d101      	bne.n	c0d04002 <io_seproxyhal_button_push+0x16>
      // each 100ms ~
      G_ux_os.button_same_mask_counter++;
c0d03ffe:	1c76      	adds	r6, r6, #1
c0d04000:	6046      	str	r6, [r0, #4]
    }

    // when new_button_mask is 0 and 

    // append the button mask
    button_mask = G_ux_os.button_mask | new_button_mask;
c0d04002:	430d      	orrs	r5, r1

    // pre reset variable due to os_sched_exit
    button_same_mask_counter = G_ux_os.button_same_mask_counter;

    // reset button mask
    if (new_button_mask == 0) {
c0d04004:	2900      	cmp	r1, #0
c0d04006:	d002      	beq.n	c0d0400e <io_seproxyhal_button_push+0x22>

      // notify button released event
      button_mask |= BUTTON_EVT_RELEASED;
    }
    else {
      G_ux_os.button_mask = button_mask;
c0d04008:	6005      	str	r5, [r0, #0]
    }

    // reset counter when button mask changes
    if (new_button_mask != G_ux_os.button_mask) {
c0d0400a:	462a      	mov	r2, r5
c0d0400c:	e005      	b.n	c0d0401a <io_seproxyhal_button_push+0x2e>
c0d0400e:	2200      	movs	r2, #0
      G_ux_os.button_mask = 0;
c0d04010:	6002      	str	r2, [r0, #0]
      G_ux_os.button_same_mask_counter=0;
c0d04012:	6042      	str	r2, [r0, #4]
c0d04014:	4b0c      	ldr	r3, [pc, #48]	; (c0d04048 <io_seproxyhal_button_push+0x5c>)
      button_mask |= BUTTON_EVT_RELEASED;
c0d04016:	1c5b      	adds	r3, r3, #1
c0d04018:	431d      	orrs	r5, r3
    if (new_button_mask != G_ux_os.button_mask) {
c0d0401a:	428a      	cmp	r2, r1
c0d0401c:	d001      	beq.n	c0d04022 <io_seproxyhal_button_push+0x36>
c0d0401e:	2100      	movs	r1, #0
      G_ux_os.button_same_mask_counter=0;
c0d04020:	6041      	str	r1, [r0, #4]
    }

    if (button_same_mask_counter >= BUTTON_FAST_THRESHOLD_CS) {
c0d04022:	2e08      	cmp	r6, #8
c0d04024:	d30a      	bcc.n	c0d0403c <io_seproxyhal_button_push+0x50>
c0d04026:	2103      	movs	r1, #3
      // fast bit when pressing and timing is right
      if ((button_same_mask_counter%BUTTON_FAST_ACTION_CS) == 0) {
c0d04028:	4630      	mov	r0, r6
c0d0402a:	f005 fabf 	bl	c0d095ac <__aeabi_uidivmod>
c0d0402e:	2001      	movs	r0, #1
c0d04030:	2900      	cmp	r1, #0
c0d04032:	d101      	bne.n	c0d04038 <io_seproxyhal_button_push+0x4c>
c0d04034:	0781      	lsls	r1, r0, #30
c0d04036:	430d      	orrs	r5, r1
c0d04038:	07c0      	lsls	r0, r0, #31
      }
      */

      // discard the release event after a fastskip has been detected, to avoid strange at release behavior
      // and also to enable user to cancel an operation by starting triggering the fast skip
      button_mask &= ~BUTTON_EVT_RELEASED;
c0d0403a:	4385      	bics	r5, r0
    }

    // indicate if button have been released
    button_callback(button_mask, button_same_mask_counter);
c0d0403c:	4628      	mov	r0, r5
c0d0403e:	4631      	mov	r1, r6
c0d04040:	47a0      	blx	r4

  }
}
c0d04042:	bd70      	pop	{r4, r5, r6, pc}
c0d04044:	20001fcc 	.word	0x20001fcc
c0d04048:	7fffffff 	.word	0x7fffffff

c0d0404c <os_io_seproxyhal_get_app_name_and_version>:
#ifdef HAVE_IO_U2F
u2f_service_t G_io_u2f;
#endif // HAVE_IO_U2F

unsigned int os_io_seproxyhal_get_app_name_and_version(void) __attribute__((weak));
unsigned int os_io_seproxyhal_get_app_name_and_version(void) {
c0d0404c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0404e:	b081      	sub	sp, #4
  unsigned int tx_len, len;
  // build the get app name and version reply
  tx_len = 0;
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d04050:	4e0f      	ldr	r6, [pc, #60]	; (c0d04090 <os_io_seproxyhal_get_app_name_and_version+0x44>)
c0d04052:	2401      	movs	r4, #1
c0d04054:	7034      	strb	r4, [r6, #0]

#ifndef HAVE_BOLOS
  // append app name
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPNAME, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len-1);
c0d04056:	1cb1      	adds	r1, r6, #2
c0d04058:	20a7      	movs	r0, #167	; 0xa7
c0d0405a:	0047      	lsls	r7, r0, #1
c0d0405c:	1c7a      	adds	r2, r7, #1
c0d0405e:	4620      	mov	r0, r4
c0d04060:	f001 fd2e 	bl	c0d05ac0 <os_registry_get_current_app_tag>
c0d04064:	4605      	mov	r5, r0
  G_io_apdu_buffer[tx_len++] = len;
c0d04066:	7070      	strb	r0, [r6, #1]
  tx_len += len;
  // append app version
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPVERSION, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len-1);
c0d04068:	1a3a      	subs	r2, r7, r0
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d0406a:	1837      	adds	r7, r6, r0
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPVERSION, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len-1);
c0d0406c:	1cf9      	adds	r1, r7, #3
c0d0406e:	2002      	movs	r0, #2
c0d04070:	f001 fd26 	bl	c0d05ac0 <os_registry_get_current_app_tag>
  G_io_apdu_buffer[tx_len++] = len;
c0d04074:	70b8      	strb	r0, [r7, #2]
c0d04076:	182d      	adds	r5, r5, r0
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d04078:	1976      	adds	r6, r6, r5
#endif // HAVE_BOLOS

#if !defined(HAVE_IO_TASK) || !defined(HAVE_BOLOS)
  // to be fixed within io tasks
  // return OS flags to notify of platform's global state (pin lock etc)
  G_io_apdu_buffer[tx_len++] = 1; // flags length
c0d0407a:	70f4      	strb	r4, [r6, #3]
  G_io_apdu_buffer[tx_len++] = os_flags();
c0d0407c:	f001 fd14 	bl	c0d05aa8 <os_flags>
c0d04080:	2100      	movs	r1, #0
#endif // !defined(HAVE_IO_TASK) || !defined(HAVE_BOLOS)

  // status words
  G_io_apdu_buffer[tx_len++] = 0x90;
  G_io_apdu_buffer[tx_len++] = 0x00;
c0d04082:	71b1      	strb	r1, [r6, #6]
c0d04084:	2190      	movs	r1, #144	; 0x90
  G_io_apdu_buffer[tx_len++] = 0x90;
c0d04086:	7171      	strb	r1, [r6, #5]
  G_io_apdu_buffer[tx_len++] = os_flags();
c0d04088:	7130      	strb	r0, [r6, #4]
  G_io_apdu_buffer[tx_len++] = 0x00;
c0d0408a:	1de8      	adds	r0, r5, #7
  return tx_len;
c0d0408c:	b001      	add	sp, #4
c0d0408e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04090:	20001e61 	.word	0x20001e61

c0d04094 <io_exchange>:
}


unsigned short io_exchange(unsigned char channel, unsigned short tx_len) {
c0d04094:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04096:	b08b      	sub	sp, #44	; 0x2c
c0d04098:	4607      	mov	r7, r0
  }
  after_debug:
#endif // DEBUG_APDU

reply_apdu:
  switch(channel&~(IO_FLAGS)) {
c0d0409a:	0740      	lsls	r0, r0, #29
c0d0409c:	d008      	beq.n	c0d040b0 <io_exchange+0x1c>
c0d0409e:	9707      	str	r7, [sp, #28]
      }
    }
    break;

  default:
    return io_exchange_al(channel, tx_len);
c0d040a0:	9807      	ldr	r0, [sp, #28]
c0d040a2:	b2c0      	uxtb	r0, r0
c0d040a4:	b289      	uxth	r1, r1
c0d040a6:	f7fe ffbd 	bl	c0d03024 <io_exchange_al>
  }
}
c0d040aa:	b280      	uxth	r0, r0
c0d040ac:	b00b      	add	sp, #44	; 0x2c
c0d040ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d040b0:	20a5      	movs	r0, #165	; 0xa5
c0d040b2:	0040      	lsls	r0, r0, #1
c0d040b4:	9001      	str	r0, [sp, #4]
c0d040b6:	4ca0      	ldr	r4, [pc, #640]	; (c0d04338 <io_exchange+0x2a4>)
c0d040b8:	4e9e      	ldr	r6, [pc, #632]	; (c0d04334 <io_exchange+0x2a0>)
c0d040ba:	9707      	str	r7, [sp, #28]
c0d040bc:	2010      	movs	r0, #16
    if (tx_len && !(channel&IO_ASYNCH_REPLY)) {
c0d040be:	463d      	mov	r5, r7
c0d040c0:	4005      	ands	r5, r0
c0d040c2:	b28a      	uxth	r2, r1
c0d040c4:	2a00      	cmp	r2, #0
c0d040c6:	d100      	bne.n	c0d040ca <io_exchange+0x36>
c0d040c8:	e0b1      	b.n	c0d0422e <io_exchange+0x19a>
c0d040ca:	2d00      	cmp	r5, #0
c0d040cc:	d000      	beq.n	c0d040d0 <io_exchange+0x3c>
c0d040ce:	e0ae      	b.n	c0d0422e <io_exchange+0x19a>
c0d040d0:	9206      	str	r2, [sp, #24]
c0d040d2:	9103      	str	r1, [sp, #12]
c0d040d4:	9004      	str	r0, [sp, #16]
c0d040d6:	9505      	str	r5, [sp, #20]
c0d040d8:	e007      	b.n	c0d040ea <io_exchange+0x56>
c0d040da:	2148      	movs	r1, #72	; 0x48
c0d040dc:	2200      	movs	r2, #0
        io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d040de:	4630      	mov	r0, r6
c0d040e0:	f001 fd20 	bl	c0d05b24 <io_seph_recv>
c0d040e4:	2001      	movs	r0, #1
        os_io_seph_recv_and_process(1);
c0d040e6:	f000 f939 	bl	c0d0435c <os_io_seph_recv_and_process>
      while (io_seproxyhal_spi_is_status_sent()) {
c0d040ea:	f001 fd0f 	bl	c0d05b0c <io_seph_is_status_sent>
c0d040ee:	2800      	cmp	r0, #0
c0d040f0:	d1f3      	bne.n	c0d040da <io_exchange+0x46>
c0d040f2:	207d      	movs	r0, #125	; 0x7d
c0d040f4:	0100      	lsls	r0, r0, #4
      timeout_ms = G_io_app.ms + IO_RAPDU_TRANSMIT_TIMEOUT_MS;
c0d040f6:	68a1      	ldr	r1, [r4, #8]
c0d040f8:	180d      	adds	r5, r1, r0
        switch(G_io_app.apdu_state) {
c0d040fa:	7820      	ldrb	r0, [r4, #0]
c0d040fc:	2809      	cmp	r0, #9
c0d040fe:	dc3f      	bgt.n	c0d04180 <io_exchange+0xec>
c0d04100:	2807      	cmp	r0, #7
c0d04102:	9906      	ldr	r1, [sp, #24]
c0d04104:	d047      	beq.n	c0d04196 <io_exchange+0x102>
c0d04106:	2809      	cmp	r0, #9
c0d04108:	d160      	bne.n	c0d041cc <io_exchange+0x138>
c0d0410a:	2100      	movs	r1, #0
c0d0410c:	488b      	ldr	r0, [pc, #556]	; (c0d0433c <io_exchange+0x2a8>)
c0d0410e:	9102      	str	r1, [sp, #8]
            u2f_message_set_autoreply_wait_user_presence(&G_io_u2f, false);
c0d04110:	f002 f994 	bl	c0d0643c <u2f_message_set_autoreply_wait_user_presence>
c0d04114:	e010      	b.n	c0d04138 <io_exchange+0xa4>
              io_seproxyhal_general_status();
c0d04116:	f7ff fd85 	bl	c0d03c24 <io_seproxyhal_general_status>
c0d0411a:	2148      	movs	r1, #72	; 0x48
c0d0411c:	2200      	movs	r2, #0
                io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d0411e:	4630      	mov	r0, r6
c0d04120:	f001 fd00 	bl	c0d05b24 <io_seph_recv>
                if (G_io_app.ms >= timeout_ms) {
c0d04124:	68a0      	ldr	r0, [r4, #8]
c0d04126:	42a8      	cmp	r0, r5
c0d04128:	d300      	bcc.n	c0d0412c <io_exchange+0x98>
c0d0412a:	e0f7      	b.n	c0d0431c <io_exchange+0x288>
                io_seproxyhal_handle_event();
c0d0412c:	f7ff fe60 	bl	c0d03df0 <io_seproxyhal_handle_event>
              } while (io_seproxyhal_spi_is_status_sent());
c0d04130:	f001 fcec 	bl	c0d05b0c <io_seph_is_status_sent>
c0d04134:	2800      	cmp	r0, #0
c0d04136:	d1f0      	bne.n	c0d0411a <io_exchange+0x86>
            while(!u2f_message_repliable(&G_io_u2f)) {
c0d04138:	4880      	ldr	r0, [pc, #512]	; (c0d0433c <io_exchange+0x2a8>)
c0d0413a:	f001 ff23 	bl	c0d05f84 <u2f_message_repliable>
c0d0413e:	2800      	cmp	r0, #0
c0d04140:	d0e9      	beq.n	c0d04116 <io_exchange+0x82>
            if (1U+ 4U+ tx_len +2U > sizeof(G_io_apdu_buffer)) {
c0d04142:	9801      	ldr	r0, [sp, #4]
c0d04144:	9a06      	ldr	r2, [sp, #24]
c0d04146:	4282      	cmp	r2, r0
c0d04148:	d900      	bls.n	c0d0414c <io_exchange+0xb8>
c0d0414a:	e0ed      	b.n	c0d04328 <io_exchange+0x294>
c0d0414c:	2090      	movs	r0, #144	; 0x90
c0d0414e:	497c      	ldr	r1, [pc, #496]	; (c0d04340 <io_exchange+0x2ac>)
            G_io_apdu_buffer[tx_len] = 0x90; //G_io_apdu_buffer[tx_len-2];
c0d04150:	5488      	strb	r0, [r1, r2]
c0d04152:	1888      	adds	r0, r1, r2
            G_io_apdu_buffer[tx_len+1] = 0x00; //G_io_apdu_buffer[tx_len-1];
c0d04154:	9a02      	ldr	r2, [sp, #8]
c0d04156:	7042      	strb	r2, [r0, #1]
            os_memmove(G_io_apdu_buffer+5, G_io_apdu_buffer, tx_len);
c0d04158:	1d48      	adds	r0, r1, #5
            tx_len += 2;
c0d0415a:	9a03      	ldr	r2, [sp, #12]
c0d0415c:	1c92      	adds	r2, r2, #2
            os_memmove(G_io_apdu_buffer+5, G_io_apdu_buffer, tx_len);
c0d0415e:	b292      	uxth	r2, r2
c0d04160:	f7ff fc1b 	bl	c0d0399a <os_memmove>
c0d04164:	2205      	movs	r2, #5
            os_memset(G_io_apdu_buffer, 0, 5);
c0d04166:	4876      	ldr	r0, [pc, #472]	; (c0d04340 <io_exchange+0x2ac>)
c0d04168:	9902      	ldr	r1, [sp, #8]
c0d0416a:	f7ff fc2c 	bl	c0d039c6 <os_memset>
            u2f_message_reply(&G_io_u2f, U2F_CMD_MSG, G_io_apdu_buffer, tx_len+5);
c0d0416e:	9803      	ldr	r0, [sp, #12]
c0d04170:	1dc0      	adds	r0, r0, #7
c0d04172:	b283      	uxth	r3, r0
c0d04174:	2183      	movs	r1, #131	; 0x83
c0d04176:	4871      	ldr	r0, [pc, #452]	; (c0d0433c <io_exchange+0x2a8>)
c0d04178:	4a71      	ldr	r2, [pc, #452]	; (c0d04340 <io_exchange+0x2ac>)
c0d0417a:	f002 f973 	bl	c0d06464 <u2f_message_reply>
c0d0417e:	e040      	b.n	c0d04202 <io_exchange+0x16e>
        switch(G_io_app.apdu_state) {
c0d04180:	280a      	cmp	r0, #10
c0d04182:	9a03      	ldr	r2, [sp, #12]
c0d04184:	9906      	ldr	r1, [sp, #24]
c0d04186:	d00b      	beq.n	c0d041a0 <io_exchange+0x10c>
c0d04188:	280b      	cmp	r0, #11
c0d0418a:	d122      	bne.n	c0d041d2 <io_exchange+0x13e>
            io_usb_hid_send(io_usb_send_apdu_data_ep0x83, tx_len);
c0d0418c:	486f      	ldr	r0, [pc, #444]	; (c0d0434c <io_exchange+0x2b8>)
c0d0418e:	4478      	add	r0, pc
c0d04190:	f000 fa32 	bl	c0d045f8 <io_usb_hid_send>
c0d04194:	e035      	b.n	c0d04202 <io_exchange+0x16e>
            io_usb_hid_send(io_usb_send_apdu_data, tx_len);
c0d04196:	486c      	ldr	r0, [pc, #432]	; (c0d04348 <io_exchange+0x2b4>)
c0d04198:	4478      	add	r0, pc
c0d0419a:	f000 fa2d 	bl	c0d045f8 <io_usb_hid_send>
c0d0419e:	e030      	b.n	c0d04202 <io_exchange+0x16e>
            if (tx_len > sizeof(G_io_apdu_buffer)) {
c0d041a0:	9801      	ldr	r0, [sp, #4]
c0d041a2:	1dc0      	adds	r0, r0, #7
c0d041a4:	4281      	cmp	r1, r0
c0d041a6:	d900      	bls.n	c0d041aa <io_exchange+0x116>
c0d041a8:	e0be      	b.n	c0d04328 <io_exchange+0x294>
c0d041aa:	460d      	mov	r5, r1
            G_io_seproxyhal_spi_buffer[2]  = (tx_len);
c0d041ac:	70b2      	strb	r2, [r6, #2]
c0d041ae:	2053      	movs	r0, #83	; 0x53
            G_io_seproxyhal_spi_buffer[0]  = SEPROXYHAL_TAG_RAPDU;
c0d041b0:	7030      	strb	r0, [r6, #0]
            G_io_seproxyhal_spi_buffer[1]  = (tx_len)>>8;
c0d041b2:	0a10      	lsrs	r0, r2, #8
c0d041b4:	7070      	strb	r0, [r6, #1]
c0d041b6:	2103      	movs	r1, #3
            io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d041b8:	4630      	mov	r0, r6
c0d041ba:	f001 fc9b 	bl	c0d05af4 <io_seph_send>
            io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);
c0d041be:	4860      	ldr	r0, [pc, #384]	; (c0d04340 <io_exchange+0x2ac>)
c0d041c0:	4629      	mov	r1, r5
c0d041c2:	f001 fc97 	bl	c0d05af4 <io_seph_send>
c0d041c6:	2000      	movs	r0, #0
            G_io_app.apdu_state = APDU_IDLE;
c0d041c8:	7020      	strb	r0, [r4, #0]
c0d041ca:	e01d      	b.n	c0d04208 <io_exchange+0x174>
        switch(G_io_app.apdu_state) {
c0d041cc:	2800      	cmp	r0, #0
c0d041ce:	d100      	bne.n	c0d041d2 <io_exchange+0x13e>
c0d041d0:	e0a7      	b.n	c0d04322 <io_exchange+0x28e>
            if (io_exchange_al(channel, tx_len) == 0) {
c0d041d2:	9807      	ldr	r0, [sp, #28]
c0d041d4:	b2c0      	uxtb	r0, r0
c0d041d6:	f7fe ff25 	bl	c0d03024 <io_exchange_al>
c0d041da:	2800      	cmp	r0, #0
c0d041dc:	d011      	beq.n	c0d04202 <io_exchange+0x16e>
c0d041de:	e0a0      	b.n	c0d04322 <io_exchange+0x28e>
          io_seproxyhal_general_status();
c0d041e0:	f7ff fd20 	bl	c0d03c24 <io_seproxyhal_general_status>
c0d041e4:	2148      	movs	r1, #72	; 0x48
c0d041e6:	2200      	movs	r2, #0
            io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d041e8:	4630      	mov	r0, r6
c0d041ea:	f001 fc9b 	bl	c0d05b24 <io_seph_recv>
            if (G_io_app.ms >= timeout_ms) {
c0d041ee:	68a0      	ldr	r0, [r4, #8]
c0d041f0:	42a8      	cmp	r0, r5
c0d041f2:	d300      	bcc.n	c0d041f6 <io_exchange+0x162>
c0d041f4:	e092      	b.n	c0d0431c <io_exchange+0x288>
            io_seproxyhal_handle_event();
c0d041f6:	f7ff fdfb 	bl	c0d03df0 <io_seproxyhal_handle_event>
          } while (io_seproxyhal_spi_is_status_sent());
c0d041fa:	f001 fc87 	bl	c0d05b0c <io_seph_is_status_sent>
c0d041fe:	2800      	cmp	r0, #0
c0d04200:	d1f0      	bne.n	c0d041e4 <io_exchange+0x150>
        while (G_io_app.apdu_state != APDU_IDLE) {
c0d04202:	7820      	ldrb	r0, [r4, #0]
c0d04204:	2800      	cmp	r0, #0
c0d04206:	d1eb      	bne.n	c0d041e0 <io_exchange+0x14c>
c0d04208:	2000      	movs	r0, #0
        G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0d0420a:	71a0      	strb	r0, [r4, #6]
        G_io_app.apdu_state = APDU_IDLE;
c0d0420c:	7020      	strb	r0, [r4, #0]
        G_io_app.apdu_length = 0;
c0d0420e:	8060      	strh	r0, [r4, #2]
        if (channel & IO_RETURN_AFTER_TX) {
c0d04210:	06b9      	lsls	r1, r7, #26
c0d04212:	d500      	bpl.n	c0d04216 <io_exchange+0x182>
c0d04214:	e749      	b.n	c0d040aa <io_exchange+0x16>
        io_seproxyhal_general_status();
c0d04216:	f7ff fd05 	bl	c0d03c24 <io_seproxyhal_general_status>
      if (channel & IO_RESET_AFTER_REPLIED) {
c0d0421a:	0638      	lsls	r0, r7, #24
c0d0421c:	9d05      	ldr	r5, [sp, #20]
c0d0421e:	9804      	ldr	r0, [sp, #16]
c0d04220:	d505      	bpl.n	c0d0422e <io_exchange+0x19a>
#define SYSCALL_os_sched_exit_ID_IN 0x60009abeUL
#define SYSCALL_os_sched_exit_ID_OUT 0x90009adeUL
__attribute__((always_inline)) inline void
os_sched_exit_inline(bolos_task_status_t exit_code) {
  volatile unsigned int parameters[2 + 1];
  parameters[0] = (unsigned int)exit_code;
c0d04222:	9008      	str	r0, [sp, #32]
c0d04224:	aa08      	add	r2, sp, #32
  __asm volatile("mov r0, %1\n"
c0d04226:	4b47      	ldr	r3, [pc, #284]	; (c0d04344 <io_exchange+0x2b0>)
c0d04228:	4618      	mov	r0, r3
c0d0422a:	4611      	mov	r1, r2
c0d0422c:	df01      	svc	1
    if (!(channel&IO_ASYNCH_REPLY)) {
c0d0422e:	2d00      	cmp	r5, #0
c0d04230:	d104      	bne.n	c0d0423c <io_exchange+0x1a8>
      if ((channel & (CHANNEL_APDU|IO_RECEIVE_DATA)) == (CHANNEL_APDU|IO_RECEIVE_DATA)) {
c0d04232:	0678      	lsls	r0, r7, #25
c0d04234:	d46d      	bmi.n	c0d04312 <io_exchange+0x27e>
c0d04236:	2000      	movs	r0, #0
      G_io_app.apdu_media = IO_APDU_MEDIA_NONE;
c0d04238:	71a0      	strb	r0, [r4, #6]
      G_io_app.apdu_state = APDU_IDLE;
c0d0423a:	7020      	strb	r0, [r4, #0]
c0d0423c:	4f40      	ldr	r7, [pc, #256]	; (c0d04340 <io_exchange+0x2ac>)
c0d0423e:	2000      	movs	r0, #0
c0d04240:	8060      	strh	r0, [r4, #2]
      if (!io_seproxyhal_spi_is_status_sent()) {
c0d04242:	f001 fc63 	bl	c0d05b0c <io_seph_is_status_sent>
c0d04246:	2800      	cmp	r0, #0
c0d04248:	d101      	bne.n	c0d0424e <io_exchange+0x1ba>
        io_seproxyhal_general_status();
c0d0424a:	f7ff fceb 	bl	c0d03c24 <io_seproxyhal_general_status>
c0d0424e:	2148      	movs	r1, #72	; 0x48
c0d04250:	2500      	movs	r5, #0
      rx_len = io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d04252:	4630      	mov	r0, r6
c0d04254:	462a      	mov	r2, r5
c0d04256:	f001 fc65 	bl	c0d05b24 <io_seph_recv>
      if (rx_len < 3 && rx_len != U2(G_io_seproxyhal_spi_buffer[1],G_io_seproxyhal_spi_buffer[2])+3U) {
c0d0425a:	2802      	cmp	r0, #2
c0d0425c:	d806      	bhi.n	c0d0426c <io_exchange+0x1d8>
c0d0425e:	78b1      	ldrb	r1, [r6, #2]
c0d04260:	7872      	ldrb	r2, [r6, #1]
c0d04262:	0212      	lsls	r2, r2, #8
c0d04264:	1851      	adds	r1, r2, r1
c0d04266:	1cc9      	adds	r1, r1, #3
c0d04268:	4281      	cmp	r1, r0
c0d0426a:	d108      	bne.n	c0d0427e <io_exchange+0x1ea>
      io_seproxyhal_handle_event();
c0d0426c:	f7ff fdc0 	bl	c0d03df0 <io_seproxyhal_handle_event>
      if (G_io_app.apdu_state != APDU_IDLE && G_io_app.apdu_length > 0) {
c0d04270:	8860      	ldrh	r0, [r4, #2]
c0d04272:	7821      	ldrb	r1, [r4, #0]
c0d04274:	2900      	cmp	r1, #0
c0d04276:	d0e4      	beq.n	c0d04242 <io_exchange+0x1ae>
c0d04278:	2800      	cmp	r0, #0
c0d0427a:	d0e2      	beq.n	c0d04242 <io_exchange+0x1ae>
c0d0427c:	e002      	b.n	c0d04284 <io_exchange+0x1f0>
c0d0427e:	2000      	movs	r0, #0
        G_io_app.apdu_state = APDU_IDLE;
c0d04280:	7020      	strb	r0, [r4, #0]
c0d04282:	e7dc      	b.n	c0d0423e <io_exchange+0x1aa>
        if (os_memcmp(G_io_apdu_buffer, "\xB0\x01\x00\x00", 4) == 0) {
c0d04284:	4932      	ldr	r1, [pc, #200]	; (c0d04350 <io_exchange+0x2bc>)
c0d04286:	4479      	add	r1, pc
c0d04288:	2204      	movs	r2, #4
c0d0428a:	4638      	mov	r0, r7
c0d0428c:	f7ff fba4 	bl	c0d039d8 <os_memcmp>
c0d04290:	2800      	cmp	r0, #0
c0d04292:	d026      	beq.n	c0d042e2 <io_exchange+0x24e>
        else if (os_memcmp(G_io_apdu_buffer, "\xB0\xA7\x00\x00", 4) == 0) {
c0d04294:	492f      	ldr	r1, [pc, #188]	; (c0d04354 <io_exchange+0x2c0>)
c0d04296:	4479      	add	r1, pc
c0d04298:	2204      	movs	r2, #4
c0d0429a:	4638      	mov	r0, r7
c0d0429c:	f7ff fb9c 	bl	c0d039d8 <os_memcmp>
c0d042a0:	2800      	cmp	r0, #0
c0d042a2:	d022      	beq.n	c0d042ea <io_exchange+0x256>
        else if (os_memcmp(G_io_apdu_buffer, "\xB0\x02\x00\x00", 4) == 0) {
c0d042a4:	492c      	ldr	r1, [pc, #176]	; (c0d04358 <io_exchange+0x2c4>)
c0d042a6:	4479      	add	r1, pc
c0d042a8:	2204      	movs	r2, #4
c0d042aa:	4638      	mov	r0, r7
c0d042ac:	f7ff fb94 	bl	c0d039d8 <os_memcmp>
c0d042b0:	2800      	cmp	r0, #0
c0d042b2:	d131      	bne.n	c0d04318 <io_exchange+0x284>
          if (os_global_pin_is_validated() == BOLOS_UX_OK) {
c0d042b4:	f001 fbca 	bl	c0d05a4c <os_global_pin_is_validated>
c0d042b8:	28aa      	cmp	r0, #170	; 0xaa
c0d042ba:	d11f      	bne.n	c0d042fc <io_exchange+0x268>
c0d042bc:	2001      	movs	r0, #1
            G_io_apdu_buffer[tx_len++] = 0x01;
c0d042be:	7038      	strb	r0, [r7, #0]
            i = os_perso_seed_cookie(G_io_apdu_buffer+1+1, MIN(64,sizeof(G_io_apdu_buffer)-1-1-2));
c0d042c0:	1cb8      	adds	r0, r7, #2
c0d042c2:	2140      	movs	r1, #64	; 0x40
c0d042c4:	f001 fbb4 	bl	c0d05a30 <os_perso_seed_cookie>
            G_io_apdu_buffer[tx_len++] = i;
c0d042c8:	7078      	strb	r0, [r7, #1]
            tx_len += i;
c0d042ca:	1c81      	adds	r1, r0, #2
c0d042cc:	4a18      	ldr	r2, [pc, #96]	; (c0d04330 <io_exchange+0x29c>)
c0d042ce:	4613      	mov	r3, r2
            G_io_apdu_buffer[tx_len++] = 0x90;
c0d042d0:	4011      	ands	r1, r2
c0d042d2:	2290      	movs	r2, #144	; 0x90
c0d042d4:	547a      	strb	r2, [r7, r1]
c0d042d6:	1cc1      	adds	r1, r0, #3
            G_io_apdu_buffer[tx_len++] = 0x00;
c0d042d8:	4019      	ands	r1, r3
c0d042da:	2500      	movs	r5, #0
c0d042dc:	547d      	strb	r5, [r7, r1]
c0d042de:	1d01      	adds	r1, r0, #4
c0d042e0:	e011      	b.n	c0d04306 <io_exchange+0x272>
          tx_len = os_io_seproxyhal_get_app_name_and_version();
c0d042e2:	f7ff feb3 	bl	c0d0404c <os_io_seproxyhal_get_app_name_and_version>
c0d042e6:	4601      	mov	r1, r0
c0d042e8:	e00d      	b.n	c0d04306 <io_exchange+0x272>
c0d042ea:	2000      	movs	r0, #0
          G_io_apdu_buffer[tx_len++] = 0x00;
c0d042ec:	7078      	strb	r0, [r7, #1]
c0d042ee:	2090      	movs	r0, #144	; 0x90
          G_io_apdu_buffer[tx_len++] = 0x90;
c0d042f0:	7038      	strb	r0, [r7, #0]
c0d042f2:	207f      	movs	r0, #127	; 0x7f
c0d042f4:	43c0      	mvns	r0, r0
c0d042f6:	9d07      	ldr	r5, [sp, #28]
          channel |= IO_RESET_AFTER_REPLIED;
c0d042f8:	4305      	orrs	r5, r0
c0d042fa:	e003      	b.n	c0d04304 <io_exchange+0x270>
c0d042fc:	2085      	movs	r0, #133	; 0x85
            G_io_apdu_buffer[tx_len++] = 0x85;
c0d042fe:	7078      	strb	r0, [r7, #1]
c0d04300:	2069      	movs	r0, #105	; 0x69
            G_io_apdu_buffer[tx_len++] = 0x69;
c0d04302:	7038      	strb	r0, [r7, #0]
c0d04304:	2102      	movs	r1, #2
  switch(channel&~(IO_FLAGS)) {
c0d04306:	b2ef      	uxtb	r7, r5
c0d04308:	9507      	str	r5, [sp, #28]
c0d0430a:	0768      	lsls	r0, r5, #29
c0d0430c:	d100      	bne.n	c0d04310 <io_exchange+0x27c>
c0d0430e:	e6d5      	b.n	c0d040bc <io_exchange+0x28>
c0d04310:	e6c6      	b.n	c0d040a0 <io_exchange+0xc>
        return G_io_app.apdu_length-5;
c0d04312:	8860      	ldrh	r0, [r4, #2]
c0d04314:	1f40      	subs	r0, r0, #5
c0d04316:	e6c8      	b.n	c0d040aa <io_exchange+0x16>
        return G_io_app.apdu_length;
c0d04318:	8860      	ldrh	r0, [r4, #2]
c0d0431a:	e6c6      	b.n	c0d040aa <io_exchange+0x16>
c0d0431c:	2010      	movs	r0, #16
c0d0431e:	f7ff fb70 	bl	c0d03a02 <os_longjmp>
c0d04322:	2009      	movs	r0, #9
            THROW(INVALID_STATE);
c0d04324:	f7ff fb6d 	bl	c0d03a02 <os_longjmp>
c0d04328:	2002      	movs	r0, #2
c0d0432a:	f7ff fb6a 	bl	c0d03a02 <os_longjmp>
c0d0432e:	46c0      	nop			; (mov r8, r8)
c0d04330:	0000ffff 	.word	0x0000ffff
c0d04334:	20001a5c 	.word	0x20001a5c
c0d04338:	20001fb4 	.word	0x20001fb4
c0d0433c:	20001fd4 	.word	0x20001fd4
c0d04340:	20001e61 	.word	0x20001e61
c0d04344:	60009abe 	.word	0x60009abe
c0d04348:	fffffbf9 	.word	0xfffffbf9
c0d0434c:	fffffc13 	.word	0xfffffc13
c0d04350:	00005f6b 	.word	0x00005f6b
c0d04354:	00005f60 	.word	0x00005f60
c0d04358:	00005f55 	.word	0x00005f55

c0d0435c <os_io_seph_recv_and_process>:

unsigned int os_io_seph_recv_and_process(unsigned int dont_process_ux_events) {
c0d0435c:	b570      	push	{r4, r5, r6, lr}
c0d0435e:	4605      	mov	r5, r0
  // send general status before receiving next event
  if (!io_seproxyhal_spi_is_status_sent()) {
c0d04360:	f001 fbd4 	bl	c0d05b0c <io_seph_is_status_sent>
c0d04364:	2800      	cmp	r0, #0
c0d04366:	d101      	bne.n	c0d0436c <os_io_seph_recv_and_process+0x10>
    io_seproxyhal_general_status();
c0d04368:	f7ff fc5c 	bl	c0d03c24 <io_seproxyhal_general_status>
  }

  io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d0436c:	4e0c      	ldr	r6, [pc, #48]	; (c0d043a0 <os_io_seph_recv_and_process+0x44>)
c0d0436e:	2148      	movs	r1, #72	; 0x48
c0d04370:	2400      	movs	r4, #0
c0d04372:	4630      	mov	r0, r6
c0d04374:	4622      	mov	r2, r4
c0d04376:	f001 fbd5 	bl	c0d05b24 <io_seph_recv>

  switch (G_io_seproxyhal_spi_buffer[0]) {
c0d0437a:	7830      	ldrb	r0, [r6, #0]
c0d0437c:	2815      	cmp	r0, #21
c0d0437e:	d806      	bhi.n	c0d0438e <os_io_seph_recv_and_process+0x32>
c0d04380:	2101      	movs	r1, #1
c0d04382:	4081      	lsls	r1, r0
c0d04384:	4807      	ldr	r0, [pc, #28]	; (c0d043a4 <os_io_seph_recv_and_process+0x48>)
c0d04386:	4201      	tst	r1, r0
c0d04388:	d001      	beq.n	c0d0438e <os_io_seph_recv_and_process+0x32>
    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
    case SEPROXYHAL_TAG_TICKER_EVENT:
    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
    case SEPROXYHAL_TAG_STATUS_EVENT:
      // perform UX event on these ones, don't process as an IO event
      if (dont_process_ux_events) {
c0d0438a:	2d00      	cmp	r5, #0
c0d0438c:	d106      	bne.n	c0d0439c <os_io_seph_recv_and_process+0x40>
      }
      /* fallthrough */

    default:
      // if malformed, then a stall is likely to occur
      if (io_seproxyhal_handle_event()) {
c0d0438e:	f7ff fd2f 	bl	c0d03df0 <io_seproxyhal_handle_event>
c0d04392:	2800      	cmp	r0, #0
c0d04394:	d101      	bne.n	c0d0439a <os_io_seph_recv_and_process+0x3e>
c0d04396:	4604      	mov	r4, r0
c0d04398:	e000      	b.n	c0d0439c <os_io_seph_recv_and_process+0x40>
c0d0439a:	2401      	movs	r4, #1
        return 1;
      }
  }
  return 0;
}
c0d0439c:	4620      	mov	r0, r4
c0d0439e:	bd70      	pop	{r4, r5, r6, pc}
c0d043a0:	20001a5c 	.word	0x20001a5c
c0d043a4:	00207020 	.word	0x00207020

c0d043a8 <io_seproxyhal_io_heartbeat>:
  }
}

#endif // HAVE_IO_TASK

void io_seproxyhal_io_heartbeat(void) {
c0d043a8:	b510      	push	{r4, lr}
  io_seproxyhal_general_status();
c0d043aa:	f7ff fc3b 	bl	c0d03c24 <io_seproxyhal_general_status>
c0d043ae:	4c08      	ldr	r4, [pc, #32]	; (c0d043d0 <io_seproxyhal_io_heartbeat+0x28>)
c0d043b0:	2148      	movs	r1, #72	; 0x48
c0d043b2:	2200      	movs	r2, #0
  do {
    io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d043b4:	4620      	mov	r0, r4
c0d043b6:	f001 fbb5 	bl	c0d05b24 <io_seph_recv>
    // avoid a general status to be replied
    if(G_io_seproxyhal_spi_buffer[0] != SEPROXYHAL_TAG_TICKER_EVENT) {
c0d043ba:	7820      	ldrb	r0, [r4, #0]
c0d043bc:	280e      	cmp	r0, #14
c0d043be:	d001      	beq.n	c0d043c4 <io_seproxyhal_io_heartbeat+0x1c>
      io_seproxyhal_handle_event();
c0d043c0:	f7ff fd16 	bl	c0d03df0 <io_seproxyhal_handle_event>
    }
  } while (io_seproxyhal_spi_is_status_sent());
c0d043c4:	f001 fba2 	bl	c0d05b0c <io_seph_is_status_sent>
c0d043c8:	2800      	cmp	r0, #0
c0d043ca:	d1f1      	bne.n	c0d043b0 <io_seproxyhal_io_heartbeat+0x8>
}
c0d043cc:	bd10      	pop	{r4, pc}
c0d043ce:	46c0      	nop			; (mov r8, r8)
c0d043d0:	20001a5c 	.word	0x20001a5c

c0d043d4 <io_usb_hid_receive>:
volatile unsigned int   G_io_usb_hid_channel;
volatile unsigned int   G_io_usb_hid_remaining_length;
volatile unsigned int   G_io_usb_hid_sequence_number;
volatile unsigned char* G_io_usb_hid_current_buffer;

io_usb_hid_receive_status_t io_usb_hid_receive (io_send_t sndfct, unsigned char* buffer, unsigned short l) {
c0d043d4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d043d6:	b081      	sub	sp, #4
c0d043d8:	9200      	str	r2, [sp, #0]
c0d043da:	4604      	mov	r4, r0
  // avoid over/under flows
  if (buffer != G_io_usb_ep_buffer) {
c0d043dc:	4e46      	ldr	r6, [pc, #280]	; (c0d044f8 <io_usb_hid_receive+0x124>)
c0d043de:	42b1      	cmp	r1, r6
c0d043e0:	d010      	beq.n	c0d04404 <io_usb_hid_receive+0x30>
c0d043e2:	460f      	mov	r7, r1
    os_memset(G_io_usb_ep_buffer, 0, sizeof(G_io_usb_ep_buffer));
c0d043e4:	4d44      	ldr	r5, [pc, #272]	; (c0d044f8 <io_usb_hid_receive+0x124>)
c0d043e6:	2100      	movs	r1, #0
c0d043e8:	2640      	movs	r6, #64	; 0x40
c0d043ea:	4628      	mov	r0, r5
c0d043ec:	4632      	mov	r2, r6
c0d043ee:	f7ff faea 	bl	c0d039c6 <os_memset>
c0d043f2:	9a00      	ldr	r2, [sp, #0]
    os_memmove(G_io_usb_ep_buffer, buffer, MIN(l, sizeof(G_io_usb_ep_buffer)));
c0d043f4:	2a40      	cmp	r2, #64	; 0x40
c0d043f6:	d300      	bcc.n	c0d043fa <io_usb_hid_receive+0x26>
c0d043f8:	4632      	mov	r2, r6
c0d043fa:	4628      	mov	r0, r5
c0d043fc:	4639      	mov	r1, r7
c0d043fe:	f7ff facc 	bl	c0d0399a <os_memmove>
c0d04402:	4e3d      	ldr	r6, [pc, #244]	; (c0d044f8 <io_usb_hid_receive+0x124>)
  }

  // process the chunk content
  switch(G_io_usb_ep_buffer[2]) {
c0d04404:	78b0      	ldrb	r0, [r6, #2]
c0d04406:	2801      	cmp	r0, #1
c0d04408:	dc0a      	bgt.n	c0d04420 <io_usb_hid_receive+0x4c>
c0d0440a:	2800      	cmp	r0, #0
c0d0440c:	d025      	beq.n	c0d0445a <io_usb_hid_receive+0x86>
c0d0440e:	2801      	cmp	r0, #1
c0d04410:	d160      	bne.n	c0d044d4 <io_usb_hid_receive+0x100>
    // await for the next chunk
    goto apdu_reset;

  case 0x01: // ALLOCATE CHANNEL
    // do not reset the current apdu reception if any
    cx_rng(G_io_usb_ep_buffer+3, 4);
c0d04412:	1cf0      	adds	r0, r6, #3
c0d04414:	2104      	movs	r1, #4
c0d04416:	f001 f9e7 	bl	c0d057e8 <cx_rng>
c0d0441a:	2140      	movs	r1, #64	; 0x40
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d0441c:	4630      	mov	r0, r6
c0d0441e:	e028      	b.n	c0d04472 <io_usb_hid_receive+0x9e>
  switch(G_io_usb_ep_buffer[2]) {
c0d04420:	2802      	cmp	r0, #2
c0d04422:	d024      	beq.n	c0d0446e <io_usb_hid_receive+0x9a>
c0d04424:	2805      	cmp	r0, #5
c0d04426:	d155      	bne.n	c0d044d4 <io_usb_hid_receive+0x100>
    if ((unsigned int)U2BE(G_io_usb_ep_buffer, 3) != (unsigned int)G_io_usb_hid_sequence_number) {
c0d04428:	7930      	ldrb	r0, [r6, #4]
c0d0442a:	78f1      	ldrb	r1, [r6, #3]
c0d0442c:	0209      	lsls	r1, r1, #8
c0d0442e:	1808      	adds	r0, r1, r0
c0d04430:	4c32      	ldr	r4, [pc, #200]	; (c0d044fc <io_usb_hid_receive+0x128>)
c0d04432:	6821      	ldr	r1, [r4, #0]
c0d04434:	2700      	movs	r7, #0
c0d04436:	4288      	cmp	r0, r1
c0d04438:	d153      	bne.n	c0d044e2 <io_usb_hid_receive+0x10e>
    if (G_io_usb_hid_sequence_number == 0) {
c0d0443a:	6820      	ldr	r0, [r4, #0]
c0d0443c:	2800      	cmp	r0, #0
c0d0443e:	d01b      	beq.n	c0d04478 <io_usb_hid_receive+0xa4>
    l -= 2+1+2;
c0d04440:	9800      	ldr	r0, [sp, #0]
c0d04442:	1f40      	subs	r0, r0, #5
      if (l > G_io_usb_hid_remaining_length) {
c0d04444:	b285      	uxth	r5, r0
c0d04446:	482e      	ldr	r0, [pc, #184]	; (c0d04500 <io_usb_hid_receive+0x12c>)
c0d04448:	6801      	ldr	r1, [r0, #0]
c0d0444a:	42a9      	cmp	r1, r5
c0d0444c:	d201      	bcs.n	c0d04452 <io_usb_hid_receive+0x7e>
        l = G_io_usb_hid_remaining_length;
c0d0444e:	6800      	ldr	r0, [r0, #0]
      os_memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+5, l);
c0d04450:	b285      	uxth	r5, r0
c0d04452:	482c      	ldr	r0, [pc, #176]	; (c0d04504 <io_usb_hid_receive+0x130>)
c0d04454:	6800      	ldr	r0, [r0, #0]
c0d04456:	1d71      	adds	r1, r6, #5
c0d04458:	e02e      	b.n	c0d044b8 <io_usb_hid_receive+0xe4>
    os_memset(G_io_usb_ep_buffer+3, 0, 4); // PROTOCOL VERSION is 0
c0d0445a:	1cf0      	adds	r0, r6, #3
c0d0445c:	2700      	movs	r7, #0
c0d0445e:	2204      	movs	r2, #4
c0d04460:	4639      	mov	r1, r7
c0d04462:	f7ff fab0 	bl	c0d039c6 <os_memset>
c0d04466:	2140      	movs	r1, #64	; 0x40
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d04468:	4630      	mov	r0, r6
c0d0446a:	47a0      	blx	r4
c0d0446c:	e039      	b.n	c0d044e2 <io_usb_hid_receive+0x10e>
    goto apdu_reset;

  case 0x02: // ECHO|PING
    // do not reset the current apdu reception if any
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d0446e:	4822      	ldr	r0, [pc, #136]	; (c0d044f8 <io_usb_hid_receive+0x124>)
c0d04470:	2140      	movs	r1, #64	; 0x40
c0d04472:	47a0      	blx	r4
c0d04474:	2700      	movs	r7, #0
c0d04476:	e034      	b.n	c0d044e2 <io_usb_hid_receive+0x10e>
      G_io_usb_hid_total_length = U2BE(G_io_usb_ep_buffer, 5); //(G_io_usb_ep_buffer[5]<<8)+(G_io_usb_ep_buffer[6]&0xFF);
c0d04478:	79b0      	ldrb	r0, [r6, #6]
c0d0447a:	7971      	ldrb	r1, [r6, #5]
c0d0447c:	0209      	lsls	r1, r1, #8
c0d0447e:	1809      	adds	r1, r1, r0
c0d04480:	4821      	ldr	r0, [pc, #132]	; (c0d04508 <io_usb_hid_receive+0x134>)
c0d04482:	6001      	str	r1, [r0, #0]
      if (G_io_usb_hid_total_length > sizeof(G_io_apdu_buffer)) {
c0d04484:	6801      	ldr	r1, [r0, #0]
c0d04486:	0849      	lsrs	r1, r1, #1
c0d04488:	29a8      	cmp	r1, #168	; 0xa8
c0d0448a:	d82a      	bhi.n	c0d044e2 <io_usb_hid_receive+0x10e>
      G_io_usb_hid_remaining_length = G_io_usb_hid_total_length;
c0d0448c:	6801      	ldr	r1, [r0, #0]
c0d0448e:	481c      	ldr	r0, [pc, #112]	; (c0d04500 <io_usb_hid_receive+0x12c>)
c0d04490:	6001      	str	r1, [r0, #0]
      G_io_usb_hid_channel = U2BE(G_io_usb_ep_buffer, 0);
c0d04492:	7871      	ldrb	r1, [r6, #1]
c0d04494:	7832      	ldrb	r2, [r6, #0]
c0d04496:	0212      	lsls	r2, r2, #8
c0d04498:	1851      	adds	r1, r2, r1
c0d0449a:	4a1c      	ldr	r2, [pc, #112]	; (c0d0450c <io_usb_hid_receive+0x138>)
c0d0449c:	6011      	str	r1, [r2, #0]
      G_io_usb_hid_current_buffer = G_io_apdu_buffer;
c0d0449e:	4919      	ldr	r1, [pc, #100]	; (c0d04504 <io_usb_hid_receive+0x130>)
c0d044a0:	4a1b      	ldr	r2, [pc, #108]	; (c0d04510 <io_usb_hid_receive+0x13c>)
c0d044a2:	600a      	str	r2, [r1, #0]
      l -= 2;
c0d044a4:	9900      	ldr	r1, [sp, #0]
c0d044a6:	1fc9      	subs	r1, r1, #7
      if (l > G_io_usb_hid_remaining_length) {
c0d044a8:	b28d      	uxth	r5, r1
c0d044aa:	6801      	ldr	r1, [r0, #0]
c0d044ac:	42a9      	cmp	r1, r5
c0d044ae:	d201      	bcs.n	c0d044b4 <io_usb_hid_receive+0xe0>
        l = G_io_usb_hid_remaining_length;
c0d044b0:	6800      	ldr	r0, [r0, #0]
      os_memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+7, l);
c0d044b2:	b285      	uxth	r5, r0
c0d044b4:	1df1      	adds	r1, r6, #7
c0d044b6:	4816      	ldr	r0, [pc, #88]	; (c0d04510 <io_usb_hid_receive+0x13c>)
c0d044b8:	462a      	mov	r2, r5
c0d044ba:	f7ff fa6e 	bl	c0d0399a <os_memmove>
    G_io_usb_hid_remaining_length -= l;
c0d044be:	4810      	ldr	r0, [pc, #64]	; (c0d04500 <io_usb_hid_receive+0x12c>)
c0d044c0:	6801      	ldr	r1, [r0, #0]
c0d044c2:	1b49      	subs	r1, r1, r5
c0d044c4:	6001      	str	r1, [r0, #0]
    G_io_usb_hid_current_buffer += l;
c0d044c6:	480f      	ldr	r0, [pc, #60]	; (c0d04504 <io_usb_hid_receive+0x130>)
c0d044c8:	6801      	ldr	r1, [r0, #0]
c0d044ca:	1949      	adds	r1, r1, r5
c0d044cc:	6001      	str	r1, [r0, #0]
    G_io_usb_hid_sequence_number++;
c0d044ce:	6820      	ldr	r0, [r4, #0]
c0d044d0:	1c40      	adds	r0, r0, #1
c0d044d2:	6020      	str	r0, [r4, #0]
    // await for the next chunk
    goto apdu_reset;
  }

  // if more data to be received, notify it
  if (G_io_usb_hid_remaining_length) {
c0d044d4:	480a      	ldr	r0, [pc, #40]	; (c0d04500 <io_usb_hid_receive+0x12c>)
c0d044d6:	6800      	ldr	r0, [r0, #0]
c0d044d8:	2800      	cmp	r0, #0
c0d044da:	d001      	beq.n	c0d044e0 <io_usb_hid_receive+0x10c>
c0d044dc:	2701      	movs	r7, #1
c0d044de:	e007      	b.n	c0d044f0 <io_usb_hid_receive+0x11c>
c0d044e0:	2702      	movs	r7, #2
c0d044e2:	4806      	ldr	r0, [pc, #24]	; (c0d044fc <io_usb_hid_receive+0x128>)
c0d044e4:	2100      	movs	r1, #0
c0d044e6:	6001      	str	r1, [r0, #0]
c0d044e8:	4806      	ldr	r0, [pc, #24]	; (c0d04504 <io_usb_hid_receive+0x130>)
c0d044ea:	6001      	str	r1, [r0, #0]
c0d044ec:	4804      	ldr	r0, [pc, #16]	; (c0d04500 <io_usb_hid_receive+0x12c>)
c0d044ee:	6001      	str	r1, [r0, #0]
  return IO_USB_APDU_RECEIVED;

apdu_reset:
  io_usb_hid_init();
  return IO_USB_APDU_RESET;
}
c0d044f0:	4638      	mov	r0, r7
c0d044f2:	b001      	add	sp, #4
c0d044f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d044f6:	46c0      	nop			; (mov r8, r8)
c0d044f8:	20002018 	.word	0x20002018
c0d044fc:	20002058 	.word	0x20002058
c0d04500:	20002060 	.word	0x20002060
c0d04504:	20002064 	.word	0x20002064
c0d04508:	2000205c 	.word	0x2000205c
c0d0450c:	20002068 	.word	0x20002068
c0d04510:	20001e61 	.word	0x20001e61

c0d04514 <io_usb_hid_init>:

void io_usb_hid_init(void) {
  G_io_usb_hid_sequence_number = 0; 
c0d04514:	4803      	ldr	r0, [pc, #12]	; (c0d04524 <io_usb_hid_init+0x10>)
c0d04516:	2100      	movs	r1, #0
c0d04518:	6001      	str	r1, [r0, #0]
  G_io_usb_hid_remaining_length = 0;
  G_io_usb_hid_current_buffer = NULL;
c0d0451a:	4803      	ldr	r0, [pc, #12]	; (c0d04528 <io_usb_hid_init+0x14>)
c0d0451c:	6001      	str	r1, [r0, #0]
  G_io_usb_hid_remaining_length = 0;
c0d0451e:	4803      	ldr	r0, [pc, #12]	; (c0d0452c <io_usb_hid_init+0x18>)
c0d04520:	6001      	str	r1, [r0, #0]
}
c0d04522:	4770      	bx	lr
c0d04524:	20002058 	.word	0x20002058
c0d04528:	20002064 	.word	0x20002064
c0d0452c:	20002060 	.word	0x20002060

c0d04530 <io_usb_hid_sent>:

/**
 * sent the next io_usb_hid transport chunk (rx on the host, tx on the device)
 */
void io_usb_hid_sent(io_send_t sndfct) {
c0d04530:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04532:	b081      	sub	sp, #4
  unsigned int l;

  // only prepare next chunk if some data to be sent remain
  if (G_io_usb_hid_remaining_length && G_io_usb_hid_current_buffer) {
c0d04534:	4f2a      	ldr	r7, [pc, #168]	; (c0d045e0 <io_usb_hid_sent+0xb0>)
c0d04536:	683a      	ldr	r2, [r7, #0]
c0d04538:	4c2a      	ldr	r4, [pc, #168]	; (c0d045e4 <io_usb_hid_sent+0xb4>)
c0d0453a:	6821      	ldr	r1, [r4, #0]
c0d0453c:	2900      	cmp	r1, #0
c0d0453e:	d01e      	beq.n	c0d0457e <io_usb_hid_sent+0x4e>
c0d04540:	2a00      	cmp	r2, #0
c0d04542:	d01c      	beq.n	c0d0457e <io_usb_hid_sent+0x4e>
c0d04544:	9000      	str	r0, [sp, #0]
    // fill the chunk
    os_memset(G_io_usb_ep_buffer, 0, sizeof(G_io_usb_ep_buffer));
c0d04546:	4d2a      	ldr	r5, [pc, #168]	; (c0d045f0 <io_usb_hid_sent+0xc0>)
c0d04548:	2100      	movs	r1, #0
c0d0454a:	2240      	movs	r2, #64	; 0x40
c0d0454c:	4628      	mov	r0, r5
c0d0454e:	f7ff fa3a 	bl	c0d039c6 <os_memset>
c0d04552:	2005      	movs	r0, #5

    // keep the channel identifier
    G_io_usb_ep_buffer[0] = (G_io_usb_hid_channel>>8)&0xFF;
    G_io_usb_ep_buffer[1] = G_io_usb_hid_channel&0xFF;
    G_io_usb_ep_buffer[2] = 0x05;
c0d04554:	70a8      	strb	r0, [r5, #2]
    G_io_usb_ep_buffer[0] = (G_io_usb_hid_channel>>8)&0xFF;
c0d04556:	4827      	ldr	r0, [pc, #156]	; (c0d045f4 <io_usb_hid_sent+0xc4>)
c0d04558:	6801      	ldr	r1, [r0, #0]
c0d0455a:	0a09      	lsrs	r1, r1, #8
c0d0455c:	7029      	strb	r1, [r5, #0]
    G_io_usb_ep_buffer[1] = G_io_usb_hid_channel&0xFF;
c0d0455e:	6800      	ldr	r0, [r0, #0]
c0d04560:	7068      	strb	r0, [r5, #1]
    G_io_usb_ep_buffer[3] = G_io_usb_hid_sequence_number>>8;
c0d04562:	4b21      	ldr	r3, [pc, #132]	; (c0d045e8 <io_usb_hid_sent+0xb8>)
c0d04564:	6818      	ldr	r0, [r3, #0]
c0d04566:	0a00      	lsrs	r0, r0, #8
c0d04568:	70e8      	strb	r0, [r5, #3]
    G_io_usb_ep_buffer[4] = G_io_usb_hid_sequence_number;
c0d0456a:	6818      	ldr	r0, [r3, #0]
c0d0456c:	7128      	strb	r0, [r5, #4]

    if (G_io_usb_hid_sequence_number == 0) {
c0d0456e:	6819      	ldr	r1, [r3, #0]
c0d04570:	6820      	ldr	r0, [r4, #0]
c0d04572:	2900      	cmp	r1, #0
c0d04574:	d00b      	beq.n	c0d0458e <io_usb_hid_sent+0x5e>
      os_memmove(G_io_usb_ep_buffer+7, (const void*)G_io_usb_hid_current_buffer, l);
      G_io_usb_hid_current_buffer += l;
      G_io_usb_hid_remaining_length -= l;
    }
    else {
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-5) ? IO_HID_EP_LENGTH-5 : G_io_usb_hid_remaining_length);
c0d04576:	283b      	cmp	r0, #59	; 0x3b
c0d04578:	d90d      	bls.n	c0d04596 <io_usb_hid_sent+0x66>
c0d0457a:	263b      	movs	r6, #59	; 0x3b
c0d0457c:	e00c      	b.n	c0d04598 <io_usb_hid_sent+0x68>
  G_io_usb_hid_sequence_number = 0; 
c0d0457e:	481a      	ldr	r0, [pc, #104]	; (c0d045e8 <io_usb_hid_sent+0xb8>)
c0d04580:	2100      	movs	r1, #0
c0d04582:	6001      	str	r1, [r0, #0]
  G_io_usb_hid_current_buffer = NULL;
c0d04584:	6039      	str	r1, [r7, #0]
  // cleanup when everything has been sent (ack for the last sent usb in packet)
  else {
    io_usb_hid_init();

    // we sent the whole response
    G_io_app.apdu_state = APDU_IDLE;
c0d04586:	4819      	ldr	r0, [pc, #100]	; (c0d045ec <io_usb_hid_sent+0xbc>)
c0d04588:	7001      	strb	r1, [r0, #0]
  G_io_usb_hid_remaining_length = 0;
c0d0458a:	6021      	str	r1, [r4, #0]
c0d0458c:	e026      	b.n	c0d045dc <io_usb_hid_sent+0xac>
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-7) ? IO_HID_EP_LENGTH-7 : G_io_usb_hid_remaining_length);
c0d0458e:	2839      	cmp	r0, #57	; 0x39
c0d04590:	d90a      	bls.n	c0d045a8 <io_usb_hid_sent+0x78>
c0d04592:	2639      	movs	r6, #57	; 0x39
c0d04594:	e009      	b.n	c0d045aa <io_usb_hid_sent+0x7a>
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-5) ? IO_HID_EP_LENGTH-5 : G_io_usb_hid_remaining_length);
c0d04596:	6826      	ldr	r6, [r4, #0]
      os_memmove(G_io_usb_ep_buffer+5, (const void*)G_io_usb_hid_current_buffer, l);
c0d04598:	6839      	ldr	r1, [r7, #0]
c0d0459a:	1d68      	adds	r0, r5, #5
c0d0459c:	4632      	mov	r2, r6
c0d0459e:	f7ff f9fc 	bl	c0d0399a <os_memmove>
c0d045a2:	9a00      	ldr	r2, [sp, #0]
c0d045a4:	4910      	ldr	r1, [pc, #64]	; (c0d045e8 <io_usb_hid_sent+0xb8>)
c0d045a6:	e00d      	b.n	c0d045c4 <io_usb_hid_sent+0x94>
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-7) ? IO_HID_EP_LENGTH-7 : G_io_usb_hid_remaining_length);
c0d045a8:	6826      	ldr	r6, [r4, #0]
      G_io_usb_ep_buffer[5] = G_io_usb_hid_remaining_length>>8;
c0d045aa:	6820      	ldr	r0, [r4, #0]
c0d045ac:	0a00      	lsrs	r0, r0, #8
c0d045ae:	7168      	strb	r0, [r5, #5]
      G_io_usb_ep_buffer[6] = G_io_usb_hid_remaining_length;
c0d045b0:	6820      	ldr	r0, [r4, #0]
c0d045b2:	71a8      	strb	r0, [r5, #6]
      os_memmove(G_io_usb_ep_buffer+7, (const void*)G_io_usb_hid_current_buffer, l);
c0d045b4:	6839      	ldr	r1, [r7, #0]
c0d045b6:	1de8      	adds	r0, r5, #7
c0d045b8:	4632      	mov	r2, r6
c0d045ba:	461d      	mov	r5, r3
c0d045bc:	f7ff f9ed 	bl	c0d0399a <os_memmove>
c0d045c0:	4629      	mov	r1, r5
c0d045c2:	9a00      	ldr	r2, [sp, #0]
c0d045c4:	6820      	ldr	r0, [r4, #0]
c0d045c6:	1b80      	subs	r0, r0, r6
c0d045c8:	6020      	str	r0, [r4, #0]
c0d045ca:	6838      	ldr	r0, [r7, #0]
c0d045cc:	1980      	adds	r0, r0, r6
c0d045ce:	6038      	str	r0, [r7, #0]
    G_io_usb_hid_sequence_number++;
c0d045d0:	6808      	ldr	r0, [r1, #0]
c0d045d2:	1c40      	adds	r0, r0, #1
c0d045d4:	6008      	str	r0, [r1, #0]
    sndfct(G_io_usb_ep_buffer, sizeof(G_io_usb_ep_buffer));
c0d045d6:	4806      	ldr	r0, [pc, #24]	; (c0d045f0 <io_usb_hid_sent+0xc0>)
c0d045d8:	2140      	movs	r1, #64	; 0x40
c0d045da:	4790      	blx	r2
  }
}
c0d045dc:	b001      	add	sp, #4
c0d045de:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d045e0:	20002064 	.word	0x20002064
c0d045e4:	20002060 	.word	0x20002060
c0d045e8:	20002058 	.word	0x20002058
c0d045ec:	20001fb4 	.word	0x20001fb4
c0d045f0:	20002018 	.word	0x20002018
c0d045f4:	20002068 	.word	0x20002068

c0d045f8 <io_usb_hid_send>:

void io_usb_hid_send(io_send_t sndfct, unsigned short sndlength) {
c0d045f8:	b580      	push	{r7, lr}
  // perform send
  if (sndlength) {
c0d045fa:	2900      	cmp	r1, #0
c0d045fc:	d00b      	beq.n	c0d04616 <io_usb_hid_send+0x1e>
    G_io_usb_hid_sequence_number = 0; 
c0d045fe:	4a06      	ldr	r2, [pc, #24]	; (c0d04618 <io_usb_hid_send+0x20>)
c0d04600:	2300      	movs	r3, #0
c0d04602:	6013      	str	r3, [r2, #0]
    G_io_usb_hid_current_buffer = G_io_apdu_buffer;
    G_io_usb_hid_remaining_length = sndlength;
c0d04604:	4a05      	ldr	r2, [pc, #20]	; (c0d0461c <io_usb_hid_send+0x24>)
c0d04606:	6011      	str	r1, [r2, #0]
    G_io_usb_hid_current_buffer = G_io_apdu_buffer;
c0d04608:	4a05      	ldr	r2, [pc, #20]	; (c0d04620 <io_usb_hid_send+0x28>)
c0d0460a:	4b06      	ldr	r3, [pc, #24]	; (c0d04624 <io_usb_hid_send+0x2c>)
c0d0460c:	6013      	str	r3, [r2, #0]
    G_io_usb_hid_total_length = sndlength;
c0d0460e:	4a06      	ldr	r2, [pc, #24]	; (c0d04628 <io_usb_hid_send+0x30>)
c0d04610:	6011      	str	r1, [r2, #0]
    io_usb_hid_sent(sndfct);
c0d04612:	f7ff ff8d 	bl	c0d04530 <io_usb_hid_sent>
  }
}
c0d04616:	bd80      	pop	{r7, pc}
c0d04618:	20002058 	.word	0x20002058
c0d0461c:	20002060 	.word	0x20002060
c0d04620:	20002064 	.word	0x20002064
c0d04624:	20001e61 	.word	0x20001e61
c0d04628:	2000205c 	.word	0x2000205c

c0d0462c <snprintf>:
#endif // HAVE_PRINTF

#ifdef HAVE_SPRINTF
//unsigned int snprintf(unsigned char * str, unsigned int str_size, const char* format, ...)
int snprintf(char * str, size_t str_size, const char * format, ...)
 {
c0d0462c:	b081      	sub	sp, #4
c0d0462e:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04630:	b08e      	sub	sp, #56	; 0x38
c0d04632:	9313      	str	r3, [sp, #76]	; 0x4c
    char cStrlenSet;
    
    //
    // Check the arguments.
    //
    if(format == NULL || str == NULL ||str_size < 2) {
c0d04634:	2902      	cmp	r1, #2
c0d04636:	d200      	bcs.n	c0d0463a <snprintf+0xe>
c0d04638:	e1bd      	b.n	c0d049b6 <snprintf+0x38a>
c0d0463a:	2800      	cmp	r0, #0
c0d0463c:	d100      	bne.n	c0d04640 <snprintf+0x14>
c0d0463e:	e1ba      	b.n	c0d049b6 <snprintf+0x38a>
c0d04640:	4615      	mov	r5, r2
c0d04642:	2a00      	cmp	r2, #0
c0d04644:	d100      	bne.n	c0d04648 <snprintf+0x1c>
c0d04646:	e1b6      	b.n	c0d049b6 <snprintf+0x38a>
c0d04648:	460c      	mov	r4, r1
c0d0464a:	4606      	mov	r6, r0
      return 0;
    }

    // ensure terminating string with a \0
    memset(str, 0, str_size);
c0d0464c:	f004 ffcc 	bl	c0d095e8 <__aeabi_memclr>
c0d04650:	a913      	add	r1, sp, #76	; 0x4c


    //
    // Start the varargs processing.
    //
    va_start(vaArgP, format);
c0d04652:	9109      	str	r1, [sp, #36]	; 0x24

    //
    // Loop while there are more characters in the string.
    //
    while(*format)
c0d04654:	7829      	ldrb	r1, [r5, #0]
c0d04656:	2900      	cmp	r1, #0
c0d04658:	d100      	bne.n	c0d0465c <snprintf+0x30>
c0d0465a:	e1ac      	b.n	c0d049b6 <snprintf+0x38a>
c0d0465c:	4630      	mov	r0, r6
    str_size--;
c0d0465e:	1e67      	subs	r7, r4, #1
c0d04660:	2600      	movs	r6, #0
c0d04662:	e002      	b.n	c0d0466a <snprintf+0x3e>
    {
        //
        // Find the first non-% character, or the end of the string.
        //
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0d04664:	19a9      	adds	r1, r5, r6
c0d04666:	7849      	ldrb	r1, [r1, #1]
            ulIdx++)
c0d04668:	1c76      	adds	r6, r6, #1
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0d0466a:	b2c9      	uxtb	r1, r1
c0d0466c:	2900      	cmp	r1, #0
c0d0466e:	d001      	beq.n	c0d04674 <snprintf+0x48>
c0d04670:	2925      	cmp	r1, #37	; 0x25
c0d04672:	d1f7      	bne.n	c0d04664 <snprintf+0x38>
        }

        //
        // Write this portion of the string.
        //
        ulIdx = MIN(ulIdx, str_size);
c0d04674:	42be      	cmp	r6, r7
c0d04676:	d300      	bcc.n	c0d0467a <snprintf+0x4e>
c0d04678:	463e      	mov	r6, r7
        memmove(str, format, ulIdx);
c0d0467a:	4629      	mov	r1, r5
c0d0467c:	4604      	mov	r4, r0
c0d0467e:	4632      	mov	r2, r6
c0d04680:	f004 ffbc 	bl	c0d095fc <__aeabi_memmove>
        str+= ulIdx;
        str_size -= ulIdx;
c0d04684:	1bbf      	subs	r7, r7, r6
c0d04686:	9706      	str	r7, [sp, #24]
c0d04688:	d100      	bne.n	c0d0468c <snprintf+0x60>
c0d0468a:	e194      	b.n	c0d049b6 <snprintf+0x38a>
c0d0468c:	4620      	mov	r0, r4
c0d0468e:	19a0      	adds	r0, r4, r6
        format += ulIdx;

        //
        // See if the next character is a %.
        //
        if(*format == '%')
c0d04690:	5da9      	ldrb	r1, [r5, r6]
        format += ulIdx;
c0d04692:	19ad      	adds	r5, r5, r6
        if(*format == '%')
c0d04694:	2925      	cmp	r1, #37	; 0x25
c0d04696:	d000      	beq.n	c0d0469a <snprintf+0x6e>
c0d04698:	e189      	b.n	c0d049ae <snprintf+0x382>
c0d0469a:	9004      	str	r0, [sp, #16]
        {
            //
            // Skip the %.
            //
            format++;
c0d0469c:	1c6b      	adds	r3, r5, #1
c0d0469e:	2000      	movs	r0, #0
c0d046a0:	2120      	movs	r1, #32
c0d046a2:	9105      	str	r1, [sp, #20]
c0d046a4:	210a      	movs	r1, #10
c0d046a6:	9108      	str	r1, [sp, #32]
c0d046a8:	4607      	mov	r7, r0
c0d046aa:	9003      	str	r0, [sp, #12]
c0d046ac:	4604      	mov	r4, r0
c0d046ae:	e005      	b.n	c0d046bc <snprintf+0x90>
c0d046b0:	2402      	movs	r4, #2
c0d046b2:	462b      	mov	r3, r5
c0d046b4:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d046b6:	1d0a      	adds	r2, r1, #4
c0d046b8:	9209      	str	r2, [sp, #36]	; 0x24
c0d046ba:	680f      	ldr	r7, [r1, #0]
c0d046bc:	461d      	mov	r5, r3
c0d046be:	4622      	mov	r2, r4
again:

            //
            // Determine how to handle the next character.
            //
            switch(*format++)
c0d046c0:	7829      	ldrb	r1, [r5, #0]
c0d046c2:	1c6d      	adds	r5, r5, #1
c0d046c4:	2400      	movs	r4, #0
c0d046c6:	292d      	cmp	r1, #45	; 0x2d
c0d046c8:	d0f9      	beq.n	c0d046be <snprintf+0x92>
c0d046ca:	2947      	cmp	r1, #71	; 0x47
c0d046cc:	dc15      	bgt.n	c0d046fa <snprintf+0xce>
c0d046ce:	292f      	cmp	r1, #47	; 0x2f
c0d046d0:	dd23      	ble.n	c0d0471a <snprintf+0xee>
c0d046d2:	460b      	mov	r3, r1
c0d046d4:	3b30      	subs	r3, #48	; 0x30
c0d046d6:	2b0a      	cmp	r3, #10
c0d046d8:	d300      	bcc.n	c0d046dc <snprintf+0xb0>
c0d046da:	e104      	b.n	c0d048e6 <snprintf+0x2ba>
                {
                    //
                    // If this is a zero, and it is the first digit, then the
                    // fill character is a zero instead of a space.
                    //
                    if((format[-1] == '0') && (ulCount == 0))
c0d046dc:	2930      	cmp	r1, #48	; 0x30
c0d046de:	9c05      	ldr	r4, [sp, #20]
c0d046e0:	d100      	bne.n	c0d046e4 <snprintf+0xb8>
c0d046e2:	460c      	mov	r4, r1
c0d046e4:	2800      	cmp	r0, #0
c0d046e6:	d000      	beq.n	c0d046ea <snprintf+0xbe>
c0d046e8:	9c05      	ldr	r4, [sp, #20]
c0d046ea:	230a      	movs	r3, #10
                    }

                    //
                    // Update the digit count.
                    //
                    ulCount *= 10;
c0d046ec:	4343      	muls	r3, r0
                    ulCount += format[-1] - '0';
c0d046ee:	1858      	adds	r0, r3, r1
c0d046f0:	3830      	subs	r0, #48	; 0x30
c0d046f2:	462b      	mov	r3, r5
c0d046f4:	9405      	str	r4, [sp, #20]
c0d046f6:	4614      	mov	r4, r2
c0d046f8:	e7e0      	b.n	c0d046bc <snprintf+0x90>
            switch(*format++)
c0d046fa:	2967      	cmp	r1, #103	; 0x67
c0d046fc:	dc06      	bgt.n	c0d0470c <snprintf+0xe0>
c0d046fe:	2962      	cmp	r1, #98	; 0x62
c0d04700:	dc37      	bgt.n	c0d04772 <snprintf+0x146>
c0d04702:	2948      	cmp	r1, #72	; 0x48
c0d04704:	d146      	bne.n	c0d04794 <snprintf+0x168>
c0d04706:	2101      	movs	r1, #1
c0d04708:	9103      	str	r1, [sp, #12]
c0d0470a:	e003      	b.n	c0d04714 <snprintf+0xe8>
c0d0470c:	2972      	cmp	r1, #114	; 0x72
c0d0470e:	dc1a      	bgt.n	c0d04746 <snprintf+0x11a>
c0d04710:	2968      	cmp	r1, #104	; 0x68
c0d04712:	d145      	bne.n	c0d047a0 <snprintf+0x174>
c0d04714:	2110      	movs	r1, #16
c0d04716:	9108      	str	r1, [sp, #32]
c0d04718:	e017      	b.n	c0d0474a <snprintf+0x11e>
c0d0471a:	2925      	cmp	r1, #37	; 0x25
c0d0471c:	d100      	bne.n	c0d04720 <snprintf+0xf4>
c0d0471e:	e0cd      	b.n	c0d048bc <snprintf+0x290>
c0d04720:	292a      	cmp	r1, #42	; 0x2a
c0d04722:	d022      	beq.n	c0d0476a <snprintf+0x13e>
c0d04724:	292e      	cmp	r1, #46	; 0x2e
c0d04726:	d000      	beq.n	c0d0472a <snprintf+0xfe>
c0d04728:	e0dd      	b.n	c0d048e6 <snprintf+0x2ba>
                // special %.*H or %.*h format to print a given length of hex digits (case: H UPPER, h lower)
                //
                case '.':
                {
                  // ensure next char is '*' and next one is 's'/'h'/'H'
                  if (format[0] == '*' && (format[1] == 's' || format[1] == 'H' || format[1] == 'h')) {
c0d0472a:	7829      	ldrb	r1, [r5, #0]
c0d0472c:	292a      	cmp	r1, #42	; 0x2a
c0d0472e:	d000      	beq.n	c0d04732 <snprintf+0x106>
c0d04730:	e13c      	b.n	c0d049ac <snprintf+0x380>
c0d04732:	7869      	ldrb	r1, [r5, #1]
c0d04734:	1c6b      	adds	r3, r5, #1
c0d04736:	2401      	movs	r4, #1
c0d04738:	2948      	cmp	r1, #72	; 0x48
c0d0473a:	d0bb      	beq.n	c0d046b4 <snprintf+0x88>
c0d0473c:	2968      	cmp	r1, #104	; 0x68
c0d0473e:	d0b9      	beq.n	c0d046b4 <snprintf+0x88>
c0d04740:	2973      	cmp	r1, #115	; 0x73
c0d04742:	d0b7      	beq.n	c0d046b4 <snprintf+0x88>
c0d04744:	e131      	b.n	c0d049aa <snprintf+0x37e>
            switch(*format++)
c0d04746:	2973      	cmp	r1, #115	; 0x73
c0d04748:	d12d      	bne.n	c0d047a6 <snprintf+0x17a>
                case_s:
                {
                    //
                    // Get the string pointer from the varargs.
                    //
                    pcStr = va_arg(vaArgP, char *);
c0d0474a:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d0474c:	1d0b      	adds	r3, r1, #4
c0d0474e:	9309      	str	r3, [sp, #36]	; 0x24

                    //
                    // Determine the length of the string. (if not specified using .*)
                    //
                    switch(cStrlenSet) {
c0d04750:	b2d3      	uxtb	r3, r2
                    pcStr = va_arg(vaArgP, char *);
c0d04752:	6809      	ldr	r1, [r1, #0]
                    switch(cStrlenSet) {
c0d04754:	2b01      	cmp	r3, #1
c0d04756:	d100      	bne.n	c0d0475a <snprintf+0x12e>
c0d04758:	e0be      	b.n	c0d048d8 <snprintf+0x2ac>
c0d0475a:	2b02      	cmp	r3, #2
c0d0475c:	d100      	bne.n	c0d04760 <snprintf+0x134>
c0d0475e:	e0be      	b.n	c0d048de <snprintf+0x2b2>
c0d04760:	2b03      	cmp	r3, #3
c0d04762:	462b      	mov	r3, r5
c0d04764:	4614      	mov	r4, r2
c0d04766:	d0a9      	beq.n	c0d046bc <snprintf+0x90>
c0d04768:	e0c1      	b.n	c0d048ee <snprintf+0x2c2>
                  if (*format == 's' ) {                    
c0d0476a:	7829      	ldrb	r1, [r5, #0]
c0d0476c:	2973      	cmp	r1, #115	; 0x73
c0d0476e:	d09f      	beq.n	c0d046b0 <snprintf+0x84>
c0d04770:	e11c      	b.n	c0d049ac <snprintf+0x380>
            switch(*format++)
c0d04772:	2963      	cmp	r1, #99	; 0x63
c0d04774:	d100      	bne.n	c0d04778 <snprintf+0x14c>
c0d04776:	e0a3      	b.n	c0d048c0 <snprintf+0x294>
c0d04778:	2964      	cmp	r1, #100	; 0x64
c0d0477a:	d000      	beq.n	c0d0477e <snprintf+0x152>
c0d0477c:	e0b3      	b.n	c0d048e6 <snprintf+0x2ba>
c0d0477e:	9007      	str	r0, [sp, #28]
                    ulValue = va_arg(vaArgP, unsigned long);
c0d04780:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d04782:	1d01      	adds	r1, r0, #4
c0d04784:	9109      	str	r1, [sp, #36]	; 0x24
c0d04786:	6800      	ldr	r0, [r0, #0]
c0d04788:	17c1      	asrs	r1, r0, #31
c0d0478a:	1847      	adds	r7, r0, r1
c0d0478c:	404f      	eors	r7, r1
                    if((long)ulValue < 0)
c0d0478e:	0fc1      	lsrs	r1, r0, #31
c0d04790:	200a      	movs	r0, #10
c0d04792:	e012      	b.n	c0d047ba <snprintf+0x18e>
            switch(*format++)
c0d04794:	2958      	cmp	r1, #88	; 0x58
c0d04796:	d000      	beq.n	c0d0479a <snprintf+0x16e>
c0d04798:	e0a5      	b.n	c0d048e6 <snprintf+0x2ba>
c0d0479a:	2101      	movs	r1, #1
c0d0479c:	9103      	str	r1, [sp, #12]
c0d0479e:	e005      	b.n	c0d047ac <snprintf+0x180>
c0d047a0:	2970      	cmp	r1, #112	; 0x70
c0d047a2:	d003      	beq.n	c0d047ac <snprintf+0x180>
c0d047a4:	e09f      	b.n	c0d048e6 <snprintf+0x2ba>
c0d047a6:	2978      	cmp	r1, #120	; 0x78
c0d047a8:	d000      	beq.n	c0d047ac <snprintf+0x180>
c0d047aa:	e09c      	b.n	c0d048e6 <snprintf+0x2ba>
c0d047ac:	9007      	str	r0, [sp, #28]
                case 'p':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);
c0d047ae:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d047b0:	1d01      	adds	r1, r0, #4
c0d047b2:	9109      	str	r1, [sp, #36]	; 0x24
c0d047b4:	6807      	ldr	r7, [r0, #0]
c0d047b6:	2100      	movs	r1, #0
c0d047b8:	2010      	movs	r0, #16
                    // Determine the number of digits in the string version of
                    // the value.
                    //
convert:
                    for(ulIdx = 1;
                        (((ulIdx * ulBase) <= ulValue) &&
c0d047ba:	42b8      	cmp	r0, r7
c0d047bc:	9708      	str	r7, [sp, #32]
c0d047be:	9102      	str	r1, [sp, #8]
c0d047c0:	d902      	bls.n	c0d047c8 <snprintf+0x19c>
c0d047c2:	2401      	movs	r4, #1
c0d047c4:	4607      	mov	r7, r0
c0d047c6:	e012      	b.n	c0d047ee <snprintf+0x1c2>
c0d047c8:	2601      	movs	r6, #1
c0d047ca:	4607      	mov	r7, r0
c0d047cc:	4604      	mov	r4, r0
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
c0d047ce:	4639      	mov	r1, r7
c0d047d0:	f004 fe66 	bl	c0d094a0 <__udivsi3>
                    for(ulIdx = 1;
c0d047d4:	42b0      	cmp	r0, r6
c0d047d6:	d109      	bne.n	c0d047ec <snprintf+0x1c0>
                        (((ulIdx * ulBase) <= ulValue) &&
c0d047d8:	4638      	mov	r0, r7
c0d047da:	4360      	muls	r0, r4
                        ulIdx *= ulBase, ulCount--)
c0d047dc:	9907      	ldr	r1, [sp, #28]
c0d047de:	1e49      	subs	r1, r1, #1
                        (((ulIdx * ulBase) <= ulValue) &&
c0d047e0:	9107      	str	r1, [sp, #28]
c0d047e2:	9908      	ldr	r1, [sp, #32]
c0d047e4:	4288      	cmp	r0, r1
c0d047e6:	4626      	mov	r6, r4
c0d047e8:	d9f0      	bls.n	c0d047cc <snprintf+0x1a0>
c0d047ea:	e000      	b.n	c0d047ee <snprintf+0x1c2>
c0d047ec:	4634      	mov	r4, r6
c0d047ee:	9701      	str	r7, [sp, #4]
c0d047f0:	9a02      	ldr	r2, [sp, #8]

                    //
                    // If the value is negative, reduce the count of padding
                    // characters needed.
                    //
                    if(ulNeg)
c0d047f2:	2a00      	cmp	r2, #0
c0d047f4:	d101      	bne.n	c0d047fa <snprintf+0x1ce>
c0d047f6:	9907      	ldr	r1, [sp, #28]
c0d047f8:	e001      	b.n	c0d047fe <snprintf+0x1d2>
c0d047fa:	9807      	ldr	r0, [sp, #28]
c0d047fc:	1e41      	subs	r1, r0, #1
c0d047fe:	2300      	movs	r3, #0
c0d04800:	2a00      	cmp	r2, #0
c0d04802:	d101      	bne.n	c0d04808 <snprintf+0x1dc>
c0d04804:	4617      	mov	r7, r2
c0d04806:	e000      	b.n	c0d0480a <snprintf+0x1de>
c0d04808:	43df      	mvns	r7, r3

                    //
                    // If the value is negative and the value is padded with
                    // zeros, then place the minus sign before the padding.
                    //
                    if(ulNeg && (cFill == '0'))
c0d0480a:	2a00      	cmp	r2, #0
c0d0480c:	d008      	beq.n	c0d04820 <snprintf+0x1f4>
c0d0480e:	9805      	ldr	r0, [sp, #20]
c0d04810:	b2c0      	uxtb	r0, r0
c0d04812:	2830      	cmp	r0, #48	; 0x30
c0d04814:	d106      	bne.n	c0d04824 <snprintf+0x1f8>
c0d04816:	a80a      	add	r0, sp, #40	; 0x28
c0d04818:	222d      	movs	r2, #45	; 0x2d
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
c0d0481a:	7002      	strb	r2, [r0, #0]
c0d0481c:	2601      	movs	r6, #1
c0d0481e:	e003      	b.n	c0d04828 <snprintf+0x1fc>
c0d04820:	461e      	mov	r6, r3
c0d04822:	e001      	b.n	c0d04828 <snprintf+0x1fc>
c0d04824:	461e      	mov	r6, r3
c0d04826:	4613      	mov	r3, r2

                    //
                    // Provide additional padding at the beginning of the
                    // string conversion if needed.
                    //
                    if((ulCount > 1) && (ulCount < 16))
c0d04828:	1e88      	subs	r0, r1, #2
c0d0482a:	280d      	cmp	r0, #13
c0d0482c:	d812      	bhi.n	c0d04854 <snprintf+0x228>
c0d0482e:	a80a      	add	r0, sp, #40	; 0x28
                    {
                        for(ulCount--; ulCount; ulCount--)
                        {
                            pcBuf[ulPos++] = cFill;
c0d04830:	1980      	adds	r0, r0, r6
c0d04832:	1e49      	subs	r1, r1, #1
c0d04834:	9a05      	ldr	r2, [sp, #20]
c0d04836:	b2d2      	uxtb	r2, r2
c0d04838:	9705      	str	r7, [sp, #20]
c0d0483a:	461f      	mov	r7, r3
c0d0483c:	f004 fee2 	bl	c0d09604 <__aeabi_memset>
c0d04840:	463b      	mov	r3, r7
c0d04842:	2001      	movs	r0, #1
c0d04844:	9907      	ldr	r1, [sp, #28]
c0d04846:	1a40      	subs	r0, r0, r1
c0d04848:	9905      	ldr	r1, [sp, #20]
c0d0484a:	1a40      	subs	r0, r0, r1
                        for(ulCount--; ulCount; ulCount--)
c0d0484c:	1c40      	adds	r0, r0, #1
                            pcBuf[ulPos++] = cFill;
c0d0484e:	1c76      	adds	r6, r6, #1
                        for(ulCount--; ulCount; ulCount--)
c0d04850:	2800      	cmp	r0, #0
c0d04852:	d1fb      	bne.n	c0d0484c <snprintf+0x220>

                    //
                    // If the value is negative, then place the minus sign
                    // before the number.
                    //
                    if(ulNeg)
c0d04854:	2b00      	cmp	r3, #0
c0d04856:	d003      	beq.n	c0d04860 <snprintf+0x234>
c0d04858:	a80a      	add	r0, sp, #40	; 0x28
c0d0485a:	212d      	movs	r1, #45	; 0x2d
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
c0d0485c:	5581      	strb	r1, [r0, r6]
c0d0485e:	1c76      	adds	r6, r6, #1
                    }

                    //
                    // Convert the value into a string.
                    //
                    for(; ulIdx; ulIdx /= ulBase)
c0d04860:	2c00      	cmp	r4, #0
c0d04862:	d01c      	beq.n	c0d0489e <snprintf+0x272>
c0d04864:	9803      	ldr	r0, [sp, #12]
c0d04866:	2800      	cmp	r0, #0
c0d04868:	d002      	beq.n	c0d04870 <snprintf+0x244>
c0d0486a:	4859      	ldr	r0, [pc, #356]	; (c0d049d0 <snprintf+0x3a4>)
c0d0486c:	4478      	add	r0, pc
c0d0486e:	e001      	b.n	c0d04874 <snprintf+0x248>
c0d04870:	4856      	ldr	r0, [pc, #344]	; (c0d049cc <snprintf+0x3a0>)
c0d04872:	4478      	add	r0, pc
c0d04874:	9007      	str	r0, [sp, #28]
c0d04876:	9f01      	ldr	r7, [sp, #4]
c0d04878:	9808      	ldr	r0, [sp, #32]
c0d0487a:	4621      	mov	r1, r4
c0d0487c:	f004 fe10 	bl	c0d094a0 <__udivsi3>
c0d04880:	4639      	mov	r1, r7
c0d04882:	f004 fe93 	bl	c0d095ac <__aeabi_uidivmod>
c0d04886:	9807      	ldr	r0, [sp, #28]
c0d04888:	5c40      	ldrb	r0, [r0, r1]
c0d0488a:	a90a      	add	r1, sp, #40	; 0x28
                    {
                        if (!ulCap) {
                          pcBuf[ulPos++] = g_pcHex[(ulValue / ulIdx) % ulBase];
c0d0488c:	5588      	strb	r0, [r1, r6]
                    for(; ulIdx; ulIdx /= ulBase)
c0d0488e:	4620      	mov	r0, r4
c0d04890:	4639      	mov	r1, r7
c0d04892:	f004 fe05 	bl	c0d094a0 <__udivsi3>
c0d04896:	1c76      	adds	r6, r6, #1
c0d04898:	42a7      	cmp	r7, r4
c0d0489a:	4604      	mov	r4, r0
c0d0489c:	d9ec      	bls.n	c0d04878 <snprintf+0x24c>
c0d0489e:	9f06      	ldr	r7, [sp, #24]
                    }

                    //
                    // Write the string.
                    //
                    ulPos = MIN(ulPos, str_size);
c0d048a0:	42be      	cmp	r6, r7
c0d048a2:	d300      	bcc.n	c0d048a6 <snprintf+0x27a>
c0d048a4:	463e      	mov	r6, r7
c0d048a6:	a90a      	add	r1, sp, #40	; 0x28
c0d048a8:	9c04      	ldr	r4, [sp, #16]
                    memmove(str, pcBuf, ulPos);
c0d048aa:	4620      	mov	r0, r4
c0d048ac:	4632      	mov	r2, r6
c0d048ae:	f004 fea5 	bl	c0d095fc <__aeabi_memmove>
                    str+= ulPos;
                    str_size -= ulPos;
c0d048b2:	1bbf      	subs	r7, r7, r6
                    if (str_size == 0) {
c0d048b4:	d07f      	beq.n	c0d049b6 <snprintf+0x38a>
c0d048b6:	4620      	mov	r0, r4
c0d048b8:	19a0      	adds	r0, r4, r6
c0d048ba:	e016      	b.n	c0d048ea <snprintf+0x2be>
c0d048bc:	2125      	movs	r1, #37	; 0x25
c0d048be:	e003      	b.n	c0d048c8 <snprintf+0x29c>
                    ulValue = va_arg(vaArgP, unsigned long);
c0d048c0:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d048c2:	1d01      	adds	r1, r0, #4
c0d048c4:	9109      	str	r1, [sp, #36]	; 0x24
c0d048c6:	6801      	ldr	r1, [r0, #0]
c0d048c8:	9804      	ldr	r0, [sp, #16]
c0d048ca:	7001      	strb	r1, [r0, #0]
c0d048cc:	9906      	ldr	r1, [sp, #24]
c0d048ce:	1e49      	subs	r1, r1, #1
c0d048d0:	9106      	str	r1, [sp, #24]
c0d048d2:	d070      	beq.n	c0d049b6 <snprintf+0x38a>
c0d048d4:	1c40      	adds	r0, r0, #1
c0d048d6:	e007      	b.n	c0d048e8 <snprintf+0x2bc>
c0d048d8:	9007      	str	r0, [sp, #28]
c0d048da:	463e      	mov	r6, r7
c0d048dc:	e00e      	b.n	c0d048fc <snprintf+0x2d0>
c0d048de:	9007      	str	r0, [sp, #28]
                        if (pcStr[0] == '\0') {
c0d048e0:	7808      	ldrb	r0, [r1, #0]
c0d048e2:	2800      	cmp	r0, #0
c0d048e4:	d042      	beq.n	c0d0496c <snprintf+0x340>
c0d048e6:	9804      	ldr	r0, [sp, #16]
c0d048e8:	9f06      	ldr	r7, [sp, #24]
    while(*format)
c0d048ea:	7829      	ldrb	r1, [r5, #0]
c0d048ec:	e060      	b.n	c0d049b0 <snprintf+0x384>
c0d048ee:	9007      	str	r0, [sp, #28]
c0d048f0:	2200      	movs	r2, #0
                        for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
c0d048f2:	5c8b      	ldrb	r3, [r1, r2]
c0d048f4:	1c52      	adds	r2, r2, #1
c0d048f6:	2b00      	cmp	r3, #0
c0d048f8:	d1fb      	bne.n	c0d048f2 <snprintf+0x2c6>
                    switch(ulBase) {
c0d048fa:	1e56      	subs	r6, r2, #1
c0d048fc:	9804      	ldr	r0, [sp, #16]
c0d048fe:	9f06      	ldr	r7, [sp, #24]
c0d04900:	9a08      	ldr	r2, [sp, #32]
c0d04902:	2a10      	cmp	r2, #16
c0d04904:	d127      	bne.n	c0d04956 <snprintf+0x32a>
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d04906:	2e00      	cmp	r6, #0
c0d04908:	d0ef      	beq.n	c0d048ea <snprintf+0x2be>
c0d0490a:	2200      	movs	r2, #0
                          nibble1 = (pcStr[ulCount]>>4)&0xF;
c0d0490c:	9207      	str	r2, [sp, #28]
                          if (str_size < 2) {
c0d0490e:	2f02      	cmp	r7, #2
c0d04910:	d351      	bcc.n	c0d049b6 <snprintf+0x38a>
c0d04912:	463c      	mov	r4, r7
c0d04914:	9a07      	ldr	r2, [sp, #28]
c0d04916:	5c8a      	ldrb	r2, [r1, r2]
c0d04918:	9b03      	ldr	r3, [sp, #12]
                          switch(ulCap) {
c0d0491a:	2b00      	cmp	r3, #0
c0d0491c:	d005      	beq.n	c0d0492a <snprintf+0x2fe>
c0d0491e:	2b01      	cmp	r3, #1
c0d04920:	d10e      	bne.n	c0d04940 <snprintf+0x314>
c0d04922:	4607      	mov	r7, r0
c0d04924:	4828      	ldr	r0, [pc, #160]	; (c0d049c8 <snprintf+0x39c>)
c0d04926:	4478      	add	r0, pc
c0d04928:	e002      	b.n	c0d04930 <snprintf+0x304>
c0d0492a:	4607      	mov	r7, r0
c0d0492c:	4825      	ldr	r0, [pc, #148]	; (c0d049c4 <snprintf+0x398>)
c0d0492e:	4478      	add	r0, pc
c0d04930:	230f      	movs	r3, #15
c0d04932:	4013      	ands	r3, r2
c0d04934:	0912      	lsrs	r2, r2, #4
c0d04936:	5cc3      	ldrb	r3, [r0, r3]
c0d04938:	707b      	strb	r3, [r7, #1]
c0d0493a:	5c82      	ldrb	r2, [r0, r2]
c0d0493c:	4638      	mov	r0, r7
c0d0493e:	703a      	strb	r2, [r7, #0]
                          if (str_size == 0) {
c0d04940:	2c02      	cmp	r4, #2
c0d04942:	d038      	beq.n	c0d049b6 <snprintf+0x38a>
c0d04944:	4627      	mov	r7, r4
c0d04946:	1ea7      	subs	r7, r4, #2
c0d04948:	9a07      	ldr	r2, [sp, #28]
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d0494a:	1c52      	adds	r2, r2, #1
                          str+= 2;
c0d0494c:	1c80      	adds	r0, r0, #2
c0d0494e:	9207      	str	r2, [sp, #28]
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d04950:	42b2      	cmp	r2, r6
c0d04952:	d3dc      	bcc.n	c0d0490e <snprintf+0x2e2>
c0d04954:	e018      	b.n	c0d04988 <snprintf+0x35c>
                        ulIdx = MIN(ulIdx, str_size);
c0d04956:	42be      	cmp	r6, r7
c0d04958:	d300      	bcc.n	c0d0495c <snprintf+0x330>
c0d0495a:	463e      	mov	r6, r7
                        memmove(str, pcStr, ulIdx);
c0d0495c:	4632      	mov	r2, r6
c0d0495e:	f004 fe4d 	bl	c0d095fc <__aeabi_memmove>
c0d04962:	9804      	ldr	r0, [sp, #16]
                        str_size -= ulIdx;
c0d04964:	1bbf      	subs	r7, r7, r6
                        if (str_size == 0) {
c0d04966:	d026      	beq.n	c0d049b6 <snprintf+0x38a>
c0d04968:	1980      	adds	r0, r0, r6
c0d0496a:	e00d      	b.n	c0d04988 <snprintf+0x35c>
c0d0496c:	9c06      	ldr	r4, [sp, #24]
                          ulStrlen = MIN(ulStrlen, str_size);
c0d0496e:	42a7      	cmp	r7, r4
c0d04970:	d300      	bcc.n	c0d04974 <snprintf+0x348>
c0d04972:	4627      	mov	r7, r4
c0d04974:	2220      	movs	r2, #32
                          memset(str, ' ', ulStrlen);
c0d04976:	9804      	ldr	r0, [sp, #16]
c0d04978:	4639      	mov	r1, r7
c0d0497a:	f004 fe43 	bl	c0d09604 <__aeabi_memset>
c0d0497e:	9804      	ldr	r0, [sp, #16]
                          str_size -= ulStrlen;
c0d04980:	1be4      	subs	r4, r4, r7
                          if (str_size == 0) {
c0d04982:	d018      	beq.n	c0d049b6 <snprintf+0x38a>
c0d04984:	19c0      	adds	r0, r0, r7
c0d04986:	4627      	mov	r7, r4
c0d04988:	9907      	ldr	r1, [sp, #28]
                    if(ulCount > ulIdx)
c0d0498a:	42b1      	cmp	r1, r6
c0d0498c:	d9ad      	bls.n	c0d048ea <snprintf+0x2be>
                        ulCount -= ulIdx;
c0d0498e:	1b8c      	subs	r4, r1, r6
                        ulCount = MIN(ulCount, str_size);
c0d04990:	42bc      	cmp	r4, r7
c0d04992:	d300      	bcc.n	c0d04996 <snprintf+0x36a>
c0d04994:	463c      	mov	r4, r7
c0d04996:	2220      	movs	r2, #32
c0d04998:	4606      	mov	r6, r0
                        memset(str, ' ', ulCount);
c0d0499a:	4621      	mov	r1, r4
c0d0499c:	f004 fe32 	bl	c0d09604 <__aeabi_memset>
                        str_size -= ulCount;
c0d049a0:	1b3f      	subs	r7, r7, r4
                        if (str_size == 0) {
c0d049a2:	d008      	beq.n	c0d049b6 <snprintf+0x38a>
c0d049a4:	4630      	mov	r0, r6
c0d049a6:	1930      	adds	r0, r6, r4
c0d049a8:	e79f      	b.n	c0d048ea <snprintf+0x2be>
c0d049aa:	212a      	movs	r1, #42	; 0x2a
c0d049ac:	9804      	ldr	r0, [sp, #16]
c0d049ae:	9f06      	ldr	r7, [sp, #24]
    while(*format)
c0d049b0:	2900      	cmp	r1, #0
c0d049b2:	d000      	beq.n	c0d049b6 <snprintf+0x38a>
c0d049b4:	e654      	b.n	c0d04660 <snprintf+0x34>
c0d049b6:	2000      	movs	r0, #0
    // End the varargs processing.
    //
    va_end(vaArgP);

    return 0;
}
c0d049b8:	b00e      	add	sp, #56	; 0x38
c0d049ba:	bcf0      	pop	{r4, r5, r6, r7}
c0d049bc:	bc02      	pop	{r1}
c0d049be:	b001      	add	sp, #4
c0d049c0:	4708      	bx	r1
c0d049c2:	46c0      	nop			; (mov r8, r8)
c0d049c4:	000058d2 	.word	0x000058d2
c0d049c8:	000058ea 	.word	0x000058ea
c0d049cc:	0000598e 	.word	0x0000598e
c0d049d0:	000059a4 	.word	0x000059a4

c0d049d4 <pic>:

// only apply PIC conversion if link_address is in linked code (over 0xC0D00000 in our example)
// this way, PIC call are armless if the address is not meant to be converted
extern unsigned int _nvram;
extern unsigned int _envram;
unsigned int pic(unsigned int link_address) {
c0d049d4:	b580      	push	{r7, lr}
//  screen_printf(" %08X", link_address);
	if (link_address >= ((unsigned int)&_nvram) && link_address < ((unsigned int)&_envram)) {
c0d049d6:	4904      	ldr	r1, [pc, #16]	; (c0d049e8 <pic+0x14>)
c0d049d8:	4288      	cmp	r0, r1
c0d049da:	d304      	bcc.n	c0d049e6 <pic+0x12>
c0d049dc:	4903      	ldr	r1, [pc, #12]	; (c0d049ec <pic+0x18>)
c0d049de:	4288      	cmp	r0, r1
c0d049e0:	d201      	bcs.n	c0d049e6 <pic+0x12>
		link_address = pic_internal(link_address);
c0d049e2:	f000 f805 	bl	c0d049f0 <pic_internal>
//    screen_printf(" -> %08X\n", link_address);
  }
	return link_address;
c0d049e6:	bd80      	pop	{r7, pc}
c0d049e8:	c0d00000 	.word	0xc0d00000
c0d049ec:	c0d0b740 	.word	0xc0d0b740

c0d049f0 <pic_internal>:

unsigned int pic_internal(unsigned int link_address) __attribute__((naked));
unsigned int pic_internal(unsigned int link_address) 
{
  // compute the delta offset between LinkMemAddr & ExecMemAddr
  __asm volatile ("mov r2, pc\n");          // r2 = 0x109004
c0d049f0:	467a      	mov	r2, pc
  __asm volatile ("ldr r1, =pic_internal\n");        // r1 = 0xC0D00001
c0d049f2:	4902      	ldr	r1, [pc, #8]	; (c0d049fc <pic_internal+0xc>)
  __asm volatile ("adds r1, r1, #3\n");     // r1 = 0xC0D00004
c0d049f4:	1cc9      	adds	r1, r1, #3
  __asm volatile ("subs r1, r1, r2\n");     // r1 = 0xC0BF7000 (delta between load and exec address)
c0d049f6:	1a89      	subs	r1, r1, r2

  // adjust value of the given parameter
  __asm volatile ("subs r0, r0, r1\n");     // r0 = 0xC0D0C244 => r0 = 0x115244
c0d049f8:	1a40      	subs	r0, r0, r1
  __asm volatile ("bx lr\n");
c0d049fa:	4770      	bx	lr
c0d049fc:	c0d049f1 	.word	0xc0d049f1

c0d04a00 <poorstream_init>:
#ifdef HAVE_STARKWARE

#include "poorstream.h"

void poorstream_init(poorstream_t *stream, uint8_t *buffer) {
c0d04a00:	b5b0      	push	{r4, r5, r7, lr}
c0d04a02:	460c      	mov	r4, r1
c0d04a04:	4605      	mov	r5, r0
c0d04a06:	1d00      	adds	r0, r0, #4
c0d04a08:	2114      	movs	r1, #20
    memset((void *) stream, 0, sizeof(poorstream_t));
c0d04a0a:	f004 fded 	bl	c0d095e8 <__aeabi_memclr>
    stream->pointer = buffer;
c0d04a0e:	602c      	str	r4, [r5, #0]
}
c0d04a10:	bdb0      	pop	{r4, r5, r7, pc}

c0d04a12 <poorstream_flush>:

void poorstream_flush(poorstream_t *stream) {
    // PRINTF("Flush\n");
    *(stream->pointer + 0) = (stream->accumulator >> 56);
c0d04a12:	6801      	ldr	r1, [r0, #0]
c0d04a14:	7dc2      	ldrb	r2, [r0, #23]
c0d04a16:	700a      	strb	r2, [r1, #0]
    *(stream->pointer + 1) = (stream->accumulator >> 48);
c0d04a18:	6801      	ldr	r1, [r0, #0]
c0d04a1a:	7d82      	ldrb	r2, [r0, #22]
c0d04a1c:	704a      	strb	r2, [r1, #1]
    *(stream->pointer + 2) = (stream->accumulator >> 40);
c0d04a1e:	6801      	ldr	r1, [r0, #0]
c0d04a20:	7d42      	ldrb	r2, [r0, #21]
c0d04a22:	708a      	strb	r2, [r1, #2]
    *(stream->pointer + 3) = (stream->accumulator >> 32);
c0d04a24:	6801      	ldr	r1, [r0, #0]
c0d04a26:	7d02      	ldrb	r2, [r0, #20]
c0d04a28:	70ca      	strb	r2, [r1, #3]
    *(stream->pointer + 4) = (stream->accumulator >> 24);
c0d04a2a:	6801      	ldr	r1, [r0, #0]
c0d04a2c:	7cc2      	ldrb	r2, [r0, #19]
c0d04a2e:	710a      	strb	r2, [r1, #4]
    *(stream->pointer + 5) = (stream->accumulator >> 16);
c0d04a30:	6801      	ldr	r1, [r0, #0]
c0d04a32:	7c82      	ldrb	r2, [r0, #18]
c0d04a34:	714a      	strb	r2, [r1, #5]
    *(stream->pointer + 6) = (stream->accumulator >> 8);
c0d04a36:	6801      	ldr	r1, [r0, #0]
c0d04a38:	7c42      	ldrb	r2, [r0, #17]
c0d04a3a:	718a      	strb	r2, [r1, #6]
    *(stream->pointer + 7) = (stream->accumulator >> 0);
c0d04a3c:	6801      	ldr	r1, [r0, #0]
c0d04a3e:	7c00      	ldrb	r0, [r0, #16]
c0d04a40:	71c8      	strb	r0, [r1, #7]
}
c0d04a42:	4770      	bx	lr

c0d04a44 <poorstream_write_bits>:

void poorstream_write_bits(poorstream_t *stream, uint64_t bits, uint32_t num_bits) {
c0d04a44:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04a46:	b087      	sub	sp, #28
c0d04a48:	4614      	mov	r4, r2
c0d04a4a:	4606      	mov	r6, r0
    stream->offset += num_bits;
c0d04a4c:	6841      	ldr	r1, [r0, #4]
c0d04a4e:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d04a50:	180a      	adds	r2, r1, r0
c0d04a52:	6072      	str	r2, [r6, #4]
    if (stream->offset < 64) {
c0d04a54:	2a3f      	cmp	r2, #63	; 0x3f
c0d04a56:	d80c      	bhi.n	c0d04a72 <poorstream_write_bits+0x2e>
c0d04a58:	2040      	movs	r0, #64	; 0x40
        stream->accumulator |= (bits << (64 - stream->offset));
c0d04a5a:	1a82      	subs	r2, r0, r2
c0d04a5c:	4620      	mov	r0, r4
c0d04a5e:	4619      	mov	r1, r3
c0d04a60:	f004 fdb6 	bl	c0d095d0 <__aeabi_llsl>
c0d04a64:	6972      	ldr	r2, [r6, #20]
c0d04a66:	430a      	orrs	r2, r1
c0d04a68:	6172      	str	r2, [r6, #20]
c0d04a6a:	6931      	ldr	r1, [r6, #16]
c0d04a6c:	4301      	orrs	r1, r0
c0d04a6e:	6131      	str	r1, [r6, #16]
c0d04a70:	e03b      	b.n	c0d04aea <poorstream_write_bits+0xa6>
c0d04a72:	4637      	mov	r7, r6
c0d04a74:	3708      	adds	r7, #8
c0d04a76:	4631      	mov	r1, r6
c0d04a78:	3110      	adds	r1, #16
c0d04a7a:	9105      	str	r1, [sp, #20]
        // PRINTF("ACC |= << %d\n", (64 - stream->offset));
    } else {
        stream->offset -= 64;
c0d04a7c:	3a40      	subs	r2, #64	; 0x40
c0d04a7e:	6072      	str	r2, [r6, #4]
        stream->mask = ((1 << (num_bits - stream->offset)) - 1);
c0d04a80:	1a80      	subs	r0, r0, r2
c0d04a82:	2100      	movs	r1, #0
c0d04a84:	9106      	str	r1, [sp, #24]
c0d04a86:	43cd      	mvns	r5, r1
c0d04a88:	9501      	str	r5, [sp, #4]
c0d04a8a:	4085      	lsls	r5, r0
c0d04a8c:	43e9      	mvns	r1, r5
c0d04a8e:	4620      	mov	r0, r4
c0d04a90:	17cc      	asrs	r4, r1, #31
c0d04a92:	6039      	str	r1, [r7, #0]
c0d04a94:	9702      	str	r7, [sp, #8]
c0d04a96:	607c      	str	r4, [r7, #4]
c0d04a98:	9003      	str	r0, [sp, #12]
c0d04a9a:	9304      	str	r3, [sp, #16]
        // PRINTF("Mask %lx\n", stream->mask);
        // PRINTF("Offset %d\n", stream->offset);
        stream->accumulator |= ((bits >> stream->offset) & stream->mask);
c0d04a9c:	4619      	mov	r1, r3
c0d04a9e:	f004 fd8b 	bl	c0d095b8 <__aeabi_llsr>
c0d04aa2:	4021      	ands	r1, r4
c0d04aa4:	9c05      	ldr	r4, [sp, #20]
c0d04aa6:	6862      	ldr	r2, [r4, #4]
c0d04aa8:	430a      	orrs	r2, r1
c0d04aaa:	6062      	str	r2, [r4, #4]
c0d04aac:	43a8      	bics	r0, r5
c0d04aae:	6821      	ldr	r1, [r4, #0]
c0d04ab0:	4301      	orrs	r1, r0
c0d04ab2:	6021      	str	r1, [r4, #0]
        poorstream_flush(stream);
c0d04ab4:	4630      	mov	r0, r6
c0d04ab6:	f7ff ffac 	bl	c0d04a12 <poorstream_flush>
c0d04aba:	9806      	ldr	r0, [sp, #24]
        stream->accumulator = 0;
c0d04abc:	6020      	str	r0, [r4, #0]
c0d04abe:	6060      	str	r0, [r4, #4]
        stream->pointer += 8;
c0d04ac0:	6830      	ldr	r0, [r6, #0]
c0d04ac2:	3008      	adds	r0, #8
c0d04ac4:	6030      	str	r0, [r6, #0]
        if (stream->offset) {
c0d04ac6:	6870      	ldr	r0, [r6, #4]
c0d04ac8:	2800      	cmp	r0, #0
c0d04aca:	d00e      	beq.n	c0d04aea <poorstream_write_bits+0xa6>
c0d04acc:	9d01      	ldr	r5, [sp, #4]
            stream->mask = ((1 << stream->offset) - 1);
c0d04ace:	4085      	lsls	r5, r0
c0d04ad0:	43e9      	mvns	r1, r5
c0d04ad2:	17cb      	asrs	r3, r1, #31
c0d04ad4:	9a02      	ldr	r2, [sp, #8]
c0d04ad6:	c20a      	stmia	r2!, {r1, r3}
c0d04ad8:	2140      	movs	r1, #64	; 0x40
            stream->accumulator |= ((bits & stream->mask) << (64 - stream->offset));
c0d04ada:	1a0a      	subs	r2, r1, r0
c0d04adc:	9803      	ldr	r0, [sp, #12]
c0d04ade:	43a8      	bics	r0, r5
c0d04ae0:	9904      	ldr	r1, [sp, #16]
c0d04ae2:	4019      	ands	r1, r3
c0d04ae4:	f004 fd74 	bl	c0d095d0 <__aeabi_llsl>
c0d04ae8:	c403      	stmia	r4!, {r0, r1}
        }
    }
}
c0d04aea:	b007      	add	sp, #28
c0d04aec:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d04af0 <starkDerivePrivateKey>:
// C_cx_secp256k1_n - (C_cx_secp256k1_n % C_cx_Stark256_n)
static unsigned char const STARK_DERIVE_BIAS[] = {
    0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7,
    0x38, 0xa1, 0x3b, 0x4b, 0x92, 0x0e, 0x94, 0x11, 0xae, 0x6d, 0xa5, 0xf4, 0x0b, 0x03, 0x58, 0xb1};

void starkDerivePrivateKey(uint32_t *bip32Path, uint32_t bip32PathLength, uint8_t *privateKeyData) {
c0d04af0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04af2:	b08b      	sub	sp, #44	; 0x2c
c0d04af4:	4614      	mov	r4, r2
c0d04af6:	460a      	mov	r2, r1
  PRINTF("Private key after processing %.*H\n", 32, privateKeyData);
#else
    uint8_t tmp[33];
    uint8_t index = 0;
    // Sanity check
    if ((bip32PathLength < 2) || (bip32Path[0] != STARK_BIP32_PATH_0) ||
c0d04af8:	2902      	cmp	r1, #2
c0d04afa:	d32e      	bcc.n	c0d04b5a <starkDerivePrivateKey+0x6a>
c0d04afc:	4601      	mov	r1, r0
c0d04afe:	6800      	ldr	r0, [r0, #0]
c0d04b00:	4b18      	ldr	r3, [pc, #96]	; (c0d04b64 <starkDerivePrivateKey+0x74>)
c0d04b02:	4298      	cmp	r0, r3
c0d04b04:	d129      	bne.n	c0d04b5a <starkDerivePrivateKey+0x6a>
        (bip32Path[1] != STARK_BIP32_PATH_1)) {
c0d04b06:	6848      	ldr	r0, [r1, #4]
c0d04b08:	4b17      	ldr	r3, [pc, #92]	; (c0d04b68 <starkDerivePrivateKey+0x78>)
    if ((bip32PathLength < 2) || (bip32Path[0] != STARK_BIP32_PATH_0) ||
c0d04b0a:	4298      	cmp	r0, r3
c0d04b0c:	d125      	bne.n	c0d04b5a <starkDerivePrivateKey+0x6a>
c0d04b0e:	2500      	movs	r5, #0
        PRINTF("Invalid Stark derivation path %d %d\n", bip32Path[0], bip32Path[1]);
        THROW(0x6a80);
    }
    os_perso_derive_node_bip32(CX_CURVE_256K1, bip32Path, bip32PathLength, tmp, NULL);
c0d04b10:	4668      	mov	r0, sp
c0d04b12:	6005      	str	r5, [r0, #0]
c0d04b14:	2021      	movs	r0, #33	; 0x21
c0d04b16:	ae02      	add	r6, sp, #8
c0d04b18:	4633      	mov	r3, r6
c0d04b1a:	f000 ff79 	bl	c0d05a10 <os_perso_derive_node_bip32>
c0d04b1e:	3620      	adds	r6, #32
c0d04b20:	9601      	str	r6, [sp, #4]
c0d04b22:	4e12      	ldr	r6, [pc, #72]	; (c0d04b6c <starkDerivePrivateKey+0x7c>)
c0d04b24:	447e      	add	r6, pc
    PRINTF("Private key before processing %.*H\n", 32, tmp);
    for (;;) {
        tmp[32] = index;
c0d04b26:	9801      	ldr	r0, [sp, #4]
c0d04b28:	7005      	strb	r5, [r0, #0]
c0d04b2a:	a802      	add	r0, sp, #8
c0d04b2c:	2121      	movs	r1, #33	; 0x21
c0d04b2e:	2720      	movs	r7, #32
        cx_hash_sha256(tmp, 33, privateKeyData, 32);
c0d04b30:	4622      	mov	r2, r4
c0d04b32:	463b      	mov	r3, r7
c0d04b34:	f000 fe86 	bl	c0d05844 <cx_hash_sha256>
        PRINTF("Key hash %.*H\n", 32, privateKeyData);
        if (cx_math_cmp(privateKeyData, STARK_DERIVE_BIAS, 32) < 0) {
c0d04b38:	4620      	mov	r0, r4
c0d04b3a:	4631      	mov	r1, r6
c0d04b3c:	463a      	mov	r2, r7
c0d04b3e:	f000 ff31 	bl	c0d059a4 <cx_math_cmp>
            cx_math_modm(privateKeyData, 32, C_cx_Stark256_n, 32);
            break;
        }
        index++;
c0d04b42:	1c6d      	adds	r5, r5, #1
        if (cx_math_cmp(privateKeyData, STARK_DERIVE_BIAS, 32) < 0) {
c0d04b44:	2800      	cmp	r0, #0
c0d04b46:	daee      	bge.n	c0d04b26 <starkDerivePrivateKey+0x36>
            cx_math_modm(privateKeyData, 32, C_cx_Stark256_n, 32);
c0d04b48:	4a09      	ldr	r2, [pc, #36]	; (c0d04b70 <starkDerivePrivateKey+0x80>)
c0d04b4a:	447a      	add	r2, pc
c0d04b4c:	2120      	movs	r1, #32
c0d04b4e:	4620      	mov	r0, r4
c0d04b50:	460b      	mov	r3, r1
c0d04b52:	f000 ff43 	bl	c0d059dc <cx_math_modm>
    }
    PRINTF("Key result %.*H\n", 32, privateKeyData);

#endif
}
c0d04b56:	b00b      	add	sp, #44	; 0x2c
c0d04b58:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04b5a:	20d5      	movs	r0, #213	; 0xd5
c0d04b5c:	01c0      	lsls	r0, r0, #7
        THROW(0x6a80);
c0d04b5e:	f7fe ff50 	bl	c0d03a02 <os_longjmp>
c0d04b62:	46c0      	nop			; (mov r8, r8)
c0d04b64:	80000a55 	.word	0x80000a55
c0d04b68:	a2862ad3 	.word	0xa2862ad3
c0d04b6c:	000056fc 	.word	0x000056fc
c0d04b70:	000056f6 	.word	0x000056f6

c0d04b74 <stark_get_amount_string>:

void stark_get_amount_string(uint8_t *contractAddress,
                             uint8_t *quantum256,
                             uint8_t *amount64,
                             char *tmp100,
                             char *target100) {
c0d04b74:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04b76:	b09f      	sub	sp, #124	; 0x7c
c0d04b78:	9305      	str	r3, [sp, #20]
c0d04b7a:	9203      	str	r2, [sp, #12]
c0d04b7c:	460c      	mov	r4, r1
c0d04b7e:	4607      	mov	r7, r0
    uint256_t amountPre, quantum, amount;
    uint8_t decimals;
    char *ticker = (char *) PIC(chainConfig->coinName);
c0d04b80:	4826      	ldr	r0, [pc, #152]	; (c0d04c1c <stark_get_amount_string+0xa8>)
c0d04b82:	6800      	ldr	r0, [r0, #0]
c0d04b84:	f7ff ff26 	bl	c0d049d4 <pic>
c0d04b88:	2200      	movs	r2, #0
c0d04b8a:	9e24      	ldr	r6, [sp, #144]	; 0x90
        if (buf[i]) {
c0d04b8c:	5cb9      	ldrb	r1, [r7, r2]
c0d04b8e:	2900      	cmp	r1, #0
c0d04b90:	d105      	bne.n	c0d04b9e <stark_get_amount_string+0x2a>
c0d04b92:	1c52      	adds	r2, r2, #1
    for (int i = 0; i < n; ++i) {
c0d04b94:	2a13      	cmp	r2, #19
c0d04b96:	d9f9      	bls.n	c0d04b8c <stark_get_amount_string+0x18>
c0d04b98:	2112      	movs	r1, #18
c0d04b9a:	9104      	str	r1, [sp, #16]
c0d04b9c:	e008      	b.n	c0d04bb0 <stark_get_amount_string+0x3c>

    if (allzeroes(contractAddress, 20)) {
        decimals = WEI_TO_ETHER;
        PRINTF("stark_get_amount_string - ETH\n");
    } else {
        tokenDefinition_t *token = getKnownToken(contractAddress);
c0d04b9e:	4638      	mov	r0, r7
c0d04ba0:	f7fe fa62 	bl	c0d03068 <getKnownToken>
        if (token == NULL) {  // caught earlier
c0d04ba4:	2800      	cmp	r0, #0
c0d04ba6:	d034      	beq.n	c0d04c12 <stark_get_amount_string+0x9e>
c0d04ba8:	2120      	movs	r1, #32
            THROW(0x6A80);
        }
        decimals = token->decimals;
c0d04baa:	5c41      	ldrb	r1, [r0, r1]
        ticker = (char *) token->ticker;
c0d04bac:	9104      	str	r1, [sp, #16]
c0d04bae:	3014      	adds	r0, #20
c0d04bb0:	9002      	str	r0, [sp, #8]
c0d04bb2:	2108      	movs	r1, #8
c0d04bb4:	af16      	add	r7, sp, #88	; 0x58
        PRINTF("stark_get_amount_string - decimals %d ticker %s\n", decimals, ticker);
    }
    convertUint256BE(amount64, 8, &amountPre);
c0d04bb6:	9803      	ldr	r0, [sp, #12]
c0d04bb8:	463a      	mov	r2, r7
c0d04bba:	f003 fddd 	bl	c0d08778 <convertUint256BE>
c0d04bbe:	ad0e      	add	r5, sp, #56	; 0x38
    readu256BE(quantum256, &quantum);
c0d04bc0:	4620      	mov	r0, r4
c0d04bc2:	4629      	mov	r1, r5
c0d04bc4:	f002 f8b6 	bl	c0d06d34 <readu256BE>
c0d04bc8:	ac06      	add	r4, sp, #24
    mul256(&amountPre, &quantum, &amount);
c0d04bca:	4638      	mov	r0, r7
c0d04bcc:	4629      	mov	r1, r5
c0d04bce:	4622      	mov	r2, r4
c0d04bd0:	f002 fbd0 	bl	c0d07374 <mul256>
c0d04bd4:	210a      	movs	r1, #10
c0d04bd6:	2764      	movs	r7, #100	; 0x64
    tostring256(&amount, 10, tmp100, 100);
c0d04bd8:	4620      	mov	r0, r4
c0d04bda:	9d05      	ldr	r5, [sp, #20]
c0d04bdc:	462a      	mov	r2, r5
c0d04bde:	463b      	mov	r3, r7
c0d04be0:	f002 fd60 	bl	c0d076a4 <tostring256>
    PRINTF("stark_get_amount_string - mul256 %s\n", tmp100);
    strcpy(target100, ticker);
c0d04be4:	4630      	mov	r0, r6
c0d04be6:	9c02      	ldr	r4, [sp, #8]
c0d04be8:	4621      	mov	r1, r4
c0d04bea:	f004 febb 	bl	c0d09964 <strcpy>
    adjustDecimals(tmp100, strlen(tmp100), target100 + strlen(ticker), 100, decimals);
c0d04bee:	4628      	mov	r0, r5
c0d04bf0:	f004 fec0 	bl	c0d09974 <strlen>
c0d04bf4:	9003      	str	r0, [sp, #12]
c0d04bf6:	4620      	mov	r0, r4
c0d04bf8:	f004 febc 	bl	c0d09974 <strlen>
c0d04bfc:	4669      	mov	r1, sp
c0d04bfe:	9a04      	ldr	r2, [sp, #16]
c0d04c00:	600a      	str	r2, [r1, #0]
c0d04c02:	1832      	adds	r2, r6, r0
c0d04c04:	4628      	mov	r0, r5
c0d04c06:	9903      	ldr	r1, [sp, #12]
c0d04c08:	463b      	mov	r3, r7
c0d04c0a:	f7fd fa17 	bl	c0d0203c <adjustDecimals>
    PRINTF("get_amount_string %s\n", target100);
}
c0d04c0e:	b01f      	add	sp, #124	; 0x7c
c0d04c10:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04c12:	20d5      	movs	r0, #213	; 0xd5
c0d04c14:	01c0      	lsls	r0, r0, #7
            THROW(0x6A80);
c0d04c16:	f7fe fef4 	bl	c0d03a02 <os_longjmp>
c0d04c1a:	46c0      	nop			; (mov r8, r8)
c0d04c1c:	20001b3c 	.word	0x20001b3c

c0d04c20 <accum_ec_mul>:
        0x01, 0xb7, 0x7b, 0x3e, 0x37, 0xd1, 0x35, 0x04, 0xb3, 0x48, 0x04,
        0x62, 0x68, 0xd8, 0xae, 0x25, 0xce, 0x98, 0xad, 0x78, 0x3c, 0x25,
        0x56, 0x1a, 0x87, 0x9d, 0xcc, 0x77, 0xe9, 0x9c, 0x24, 0x26,
    }};

void accum_ec_mul(ECPoint *hash, uint8_t *buf, int len, int pedersen_idx) {
c0d04c20:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04c22:	b093      	sub	sp, #76	; 0x4c
c0d04c24:	4616      	mov	r6, r2
c0d04c26:	2a01      	cmp	r2, #1
c0d04c28:	db29      	blt.n	c0d04c7e <accum_ec_mul+0x5e>
c0d04c2a:	460d      	mov	r5, r1
c0d04c2c:	4602      	mov	r2, r0
c0d04c2e:	2000      	movs	r0, #0
        if (buf[i]) {
c0d04c30:	5c29      	ldrb	r1, [r5, r0]
c0d04c32:	2900      	cmp	r1, #0
c0d04c34:	d103      	bne.n	c0d04c3e <accum_ec_mul+0x1e>
c0d04c36:	1c40      	adds	r0, r0, #1
    for (int i = 0; i < n; ++i) {
c0d04c38:	42b0      	cmp	r0, r6
c0d04c3a:	dbf9      	blt.n	c0d04c30 <accum_ec_mul+0x10>
c0d04c3c:	e01f      	b.n	c0d04c7e <accum_ec_mul+0x5e>
c0d04c3e:	2741      	movs	r7, #65	; 0x41
    ECPoint tmp;
    if (!allzeroes(buf, len)) {
        memcpy(tmp, PEDERSEN_POINTS[pedersen_idx], sizeof(ECPoint));
c0d04c40:	437b      	muls	r3, r7
c0d04c42:	4810      	ldr	r0, [pc, #64]	; (c0d04c84 <accum_ec_mul+0x64>)
c0d04c44:	4478      	add	r0, pc
c0d04c46:	18c1      	adds	r1, r0, r3
c0d04c48:	ac02      	add	r4, sp, #8
c0d04c4a:	4620      	mov	r0, r4
c0d04c4c:	9201      	str	r2, [sp, #4]
c0d04c4e:	463a      	mov	r2, r7
c0d04c50:	f004 fcd0 	bl	c0d095f4 <__aeabi_memcpy>
        io_seproxyhal_io_heartbeat();
c0d04c54:	f7ff fba8 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
        cx_ecfp_scalar_mult(CX_CURVE_Stark256, tmp, sizeof(ECPoint), buf, len);
c0d04c58:	4668      	mov	r0, sp
c0d04c5a:	6006      	str	r6, [r0, #0]
c0d04c5c:	262e      	movs	r6, #46	; 0x2e
c0d04c5e:	4630      	mov	r0, r6
c0d04c60:	4621      	mov	r1, r4
c0d04c62:	463a      	mov	r2, r7
c0d04c64:	462b      	mov	r3, r5
c0d04c66:	f000 fe1d 	bl	c0d058a4 <cx_ecfp_scalar_mult>
        io_seproxyhal_io_heartbeat();
c0d04c6a:	f7ff fb9d 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
        cx_ecfp_add_point(CX_CURVE_Stark256, *hash, *hash, tmp, sizeof(ECPoint));
c0d04c6e:	4668      	mov	r0, sp
c0d04c70:	6007      	str	r7, [r0, #0]
c0d04c72:	4630      	mov	r0, r6
c0d04c74:	9901      	ldr	r1, [sp, #4]
c0d04c76:	460a      	mov	r2, r1
c0d04c78:	4623      	mov	r3, r4
c0d04c7a:	f000 fe01 	bl	c0d05880 <cx_ecfp_add_point>
    }
}
c0d04c7e:	b013      	add	sp, #76	; 0x4c
c0d04c80:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04c82:	46c0      	nop			; (mov r8, r8)
c0d04c84:	0000561c 	.word	0x0000561c

c0d04c88 <pedersen>:

void pedersen(FieldElement res, /* out */
              FieldElement a,
              FieldElement b) {
c0d04c88:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04c8a:	b093      	sub	sp, #76	; 0x4c
c0d04c8c:	4616      	mov	r6, r2
c0d04c8e:	460c      	mov	r4, r1
c0d04c90:	9001      	str	r0, [sp, #4]
c0d04c92:	ad02      	add	r5, sp, #8
    ECPoint hash;

    memcpy(hash, PEDERSEN_SHIFT, sizeof(hash));
c0d04c94:	4913      	ldr	r1, [pc, #76]	; (c0d04ce4 <pedersen+0x5c>)
c0d04c96:	4479      	add	r1, pc
c0d04c98:	2241      	movs	r2, #65	; 0x41
c0d04c9a:	4628      	mov	r0, r5
c0d04c9c:	f004 fcaa 	bl	c0d095f4 <__aeabi_memcpy>
c0d04ca0:	2701      	movs	r7, #1

    accum_ec_mul(&hash, a, 1, 1);
c0d04ca2:	4628      	mov	r0, r5
c0d04ca4:	4621      	mov	r1, r4
c0d04ca6:	463a      	mov	r2, r7
c0d04ca8:	463b      	mov	r3, r7
c0d04caa:	f7ff ffb9 	bl	c0d04c20 <accum_ec_mul>
    accum_ec_mul(&hash, a + 1, FIELD_ELEMENT_SIZE - 1, 0);
c0d04cae:	1c61      	adds	r1, r4, #1
c0d04cb0:	241f      	movs	r4, #31
c0d04cb2:	2300      	movs	r3, #0
c0d04cb4:	4628      	mov	r0, r5
c0d04cb6:	4622      	mov	r2, r4
c0d04cb8:	f7ff ffb2 	bl	c0d04c20 <accum_ec_mul>
c0d04cbc:	2303      	movs	r3, #3
    accum_ec_mul(&hash, b, 1, 3);
c0d04cbe:	4628      	mov	r0, r5
c0d04cc0:	4631      	mov	r1, r6
c0d04cc2:	463a      	mov	r2, r7
c0d04cc4:	f7ff ffac 	bl	c0d04c20 <accum_ec_mul>
    accum_ec_mul(&hash, b + 1, FIELD_ELEMENT_SIZE - 1, 2);
c0d04cc8:	1c71      	adds	r1, r6, #1
c0d04cca:	2302      	movs	r3, #2
c0d04ccc:	4628      	mov	r0, r5
c0d04cce:	4622      	mov	r2, r4
c0d04cd0:	f7ff ffa6 	bl	c0d04c20 <accum_ec_mul>

    memcpy(res, hash + 1, FIELD_ELEMENT_SIZE);
c0d04cd4:	1c69      	adds	r1, r5, #1
c0d04cd6:	2220      	movs	r2, #32
c0d04cd8:	9801      	ldr	r0, [sp, #4]
c0d04cda:	f004 fc8b 	bl	c0d095f4 <__aeabi_memcpy>
}
c0d04cde:	b013      	add	sp, #76	; 0x4c
c0d04ce0:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04ce2:	46c0      	nop			; (mov r8, r8)
c0d04ce4:	000056ce 	.word	0x000056ce

c0d04ce8 <stark_sign>:
int stark_sign(uint8_t *signature, /* out */
               uint8_t *privateKeyData,
               FieldElement token1,
               FieldElement token2,
               FieldElement msg,
               FieldElement condition) {
c0d04ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04cea:	b099      	sub	sp, #100	; 0x64
c0d04cec:	460d      	mov	r5, r1
c0d04cee:	9005      	str	r0, [sp, #20]
c0d04cf0:	2000      	movs	r0, #0
    unsigned int info = 0;
c0d04cf2:	9018      	str	r0, [sp, #96]	; 0x60
c0d04cf4:	a810      	add	r0, sp, #64	; 0x40
    PRINTF("Stark sign msg w2 %.*H\n", 32, token2);
    PRINTF("Stark sign w3 %.*H\n", 32, msg);
    if (condition != NULL) {
        PRINTF("Stark sign w4 %.*H\n", 32, condition);
    }
    pedersen(hash, token1, token2);
c0d04cf6:	4611      	mov	r1, r2
c0d04cf8:	461a      	mov	r2, r3
c0d04cfa:	f7ff ffc5 	bl	c0d04c88 <pedersen>
c0d04cfe:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
c0d04d00:	9f1e      	ldr	r7, [sp, #120]	; 0x78
    PRINTF("Pedersen hash 1 %.*H\n", 32, hash);
    if (condition != NULL) {
c0d04d02:	2a00      	cmp	r2, #0
c0d04d04:	d003      	beq.n	c0d04d0e <stark_sign+0x26>
c0d04d06:	a810      	add	r0, sp, #64	; 0x40
        pedersen(hash, hash, condition);
c0d04d08:	4601      	mov	r1, r0
c0d04d0a:	f7ff ffbd 	bl	c0d04c88 <pedersen>
c0d04d0e:	ae10      	add	r6, sp, #64	; 0x40
        PRINTF("Pedersen hash condition %.*H\n", 32, hash);
    }
    pedersen(hash, hash, msg);
c0d04d10:	4630      	mov	r0, r6
c0d04d12:	4631      	mov	r1, r6
c0d04d14:	463a      	mov	r2, r7
c0d04d16:	f7ff ffb7 	bl	c0d04c88 <pedersen>
c0d04d1a:	202e      	movs	r0, #46	; 0x2e
c0d04d1c:	2420      	movs	r4, #32
c0d04d1e:	af06      	add	r7, sp, #24
    PRINTF("Pedersen hash 2 %.*H\n", 32, hash);
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d04d20:	4629      	mov	r1, r5
c0d04d22:	4622      	mov	r2, r4
c0d04d24:	463b      	mov	r3, r7
c0d04d26:	f000 fddf 	bl	c0d058e8 <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d04d2a:	f7ff fb3d 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d04d2e:	a818      	add	r0, sp, #96	; 0x60
    int signatureLength = cx_ecdsa_sign(&privateKey,
c0d04d30:	4669      	mov	r1, sp
c0d04d32:	2248      	movs	r2, #72	; 0x48
c0d04d34:	600c      	str	r4, [r1, #0]
c0d04d36:	9b05      	ldr	r3, [sp, #20]
c0d04d38:	604b      	str	r3, [r1, #4]
c0d04d3a:	608a      	str	r2, [r1, #8]
c0d04d3c:	60c8      	str	r0, [r1, #12]
c0d04d3e:	4904      	ldr	r1, [pc, #16]	; (c0d04d50 <stark_sign+0x68>)
c0d04d40:	2203      	movs	r2, #3
c0d04d42:	4638      	mov	r0, r7
c0d04d44:	4633      	mov	r3, r6
c0d04d46:	f000 fdef 	bl	c0d05928 <cx_ecdsa_sign>
                                        sizeof(hash),
                                        signature,
                                        SIGNATURE_MAX_LEN,
                                        &info);
    PRINTF("Stark signature %.*H\n", signatureLength, signature);
    return signatureLength;
c0d04d4a:	b019      	add	sp, #100	; 0x64
c0d04d4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04d4e:	46c0      	nop			; (mov r8, r8)
c0d04d50:	00000601 	.word	0x00000601

c0d04d54 <compute_token_id>:
                      uint8_t *contractAddress,
                      uint8_t quantumType,
                      uint8_t *quantum,
                      uint8_t *mintingBlob,
                      bool assetTypeOnly,
                      uint8_t *output) {
c0d04d54:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04d56:	b08f      	sub	sp, #60	; 0x3c
c0d04d58:	461d      	mov	r5, r3
c0d04d5a:	4614      	mov	r4, r2
c0d04d5c:	460e      	mov	r6, r1
c0d04d5e:	2101      	movs	r1, #1
c0d04d60:	9104      	str	r1, [sp, #16]
c0d04d62:	0209      	lsls	r1, r1, #8
c0d04d64:	9005      	str	r0, [sp, #20]
c0d04d66:	9103      	str	r1, [sp, #12]
    uint8_t tmp[36];
    cx_keccak_init(sha3, 256);
c0d04d68:	f000 fd7c 	bl	c0d05864 <cx_keccak_init>
    if ((contractAddress != NULL) && (!allzeroes(contractAddress, 20))) {
c0d04d6c:	2e00      	cmp	r6, #0
c0d04d6e:	d006      	beq.n	c0d04d7e <compute_token_id+0x2a>
c0d04d70:	2000      	movs	r0, #0
        if (buf[i]) {
c0d04d72:	5c31      	ldrb	r1, [r6, r0]
c0d04d74:	2900      	cmp	r1, #0
c0d04d76:	d10d      	bne.n	c0d04d94 <compute_token_id+0x40>
c0d04d78:	1c40      	adds	r0, r0, #1
    for (int i = 0; i < n; ++i) {
c0d04d7a:	2813      	cmp	r0, #19
c0d04d7c:	d9f9      	bls.n	c0d04d72 <compute_token_id+0x1e>
c0d04d7e:	2100      	movs	r1, #0
        memmove(tmp, selector, 4);
        memmove(tmp + 16, contractAddress, 20);
        cx_hash((cx_hash_t *) sha3, 0, tmp, sizeof(tmp), NULL, 0);
    } else {
        PRINTF("compute_token_id for ETH\n");
        cx_hash((cx_hash_t *) sha3, 0, ETH_SELECTOR, sizeof(ETH_SELECTOR), NULL, 0);
c0d04d80:	4668      	mov	r0, sp
c0d04d82:	6001      	str	r1, [r0, #0]
c0d04d84:	6041      	str	r1, [r0, #4]
c0d04d86:	4a57      	ldr	r2, [pc, #348]	; (c0d04ee4 <compute_token_id+0x190>)
c0d04d88:	447a      	add	r2, pc
c0d04d8a:	2304      	movs	r3, #4
c0d04d8c:	9805      	ldr	r0, [sp, #20]
c0d04d8e:	f000 fd39 	bl	c0d05804 <cx_hash>
c0d04d92:	e038      	b.n	c0d04e06 <compute_token_id+0xb2>
        switch (quantumType) {
c0d04d94:	2c02      	cmp	r4, #2
c0d04d96:	9502      	str	r5, [sp, #8]
c0d04d98:	dd09      	ble.n	c0d04dae <compute_token_id+0x5a>
c0d04d9a:	2c05      	cmp	r4, #5
c0d04d9c:	d00e      	beq.n	c0d04dbc <compute_token_id+0x68>
c0d04d9e:	2c04      	cmp	r4, #4
c0d04da0:	d00f      	beq.n	c0d04dc2 <compute_token_id+0x6e>
c0d04da2:	2c03      	cmp	r4, #3
c0d04da4:	d000      	beq.n	c0d04da8 <compute_token_id+0x54>
c0d04da6:	e093      	b.n	c0d04ed0 <compute_token_id+0x17c>
c0d04da8:	484b      	ldr	r0, [pc, #300]	; (c0d04ed8 <compute_token_id+0x184>)
c0d04daa:	4478      	add	r0, pc
c0d04dac:	e00b      	b.n	c0d04dc6 <compute_token_id+0x72>
c0d04dae:	4849      	ldr	r0, [pc, #292]	; (c0d04ed4 <compute_token_id+0x180>)
c0d04db0:	4478      	add	r0, pc
c0d04db2:	2c00      	cmp	r4, #0
c0d04db4:	d007      	beq.n	c0d04dc6 <compute_token_id+0x72>
c0d04db6:	2c02      	cmp	r4, #2
c0d04db8:	d005      	beq.n	c0d04dc6 <compute_token_id+0x72>
c0d04dba:	e089      	b.n	c0d04ed0 <compute_token_id+0x17c>
c0d04dbc:	4848      	ldr	r0, [pc, #288]	; (c0d04ee0 <compute_token_id+0x18c>)
c0d04dbe:	4478      	add	r0, pc
c0d04dc0:	e001      	b.n	c0d04dc6 <compute_token_id+0x72>
c0d04dc2:	4846      	ldr	r0, [pc, #280]	; (c0d04edc <compute_token_id+0x188>)
c0d04dc4:	4478      	add	r0, pc
c0d04dc6:	2700      	movs	r7, #0
        memset(tmp, 0, sizeof(tmp));
c0d04dc8:	9709      	str	r7, [sp, #36]	; 0x24
c0d04dca:	9708      	str	r7, [sp, #32]
c0d04dcc:	9707      	str	r7, [sp, #28]
        memmove(tmp, selector, 4);
c0d04dce:	7801      	ldrb	r1, [r0, #0]
c0d04dd0:	7842      	ldrb	r2, [r0, #1]
c0d04dd2:	0212      	lsls	r2, r2, #8
c0d04dd4:	1851      	adds	r1, r2, r1
c0d04dd6:	7882      	ldrb	r2, [r0, #2]
c0d04dd8:	78c0      	ldrb	r0, [r0, #3]
c0d04dda:	0200      	lsls	r0, r0, #8
c0d04ddc:	1880      	adds	r0, r0, r2
c0d04dde:	0400      	lsls	r0, r0, #16
c0d04de0:	1840      	adds	r0, r0, r1
c0d04de2:	9006      	str	r0, [sp, #24]
c0d04de4:	ad06      	add	r5, sp, #24
        memmove(tmp + 16, contractAddress, 20);
c0d04de6:	4628      	mov	r0, r5
c0d04de8:	3010      	adds	r0, #16
c0d04dea:	2214      	movs	r2, #20
c0d04dec:	4631      	mov	r1, r6
c0d04dee:	f004 fc01 	bl	c0d095f4 <__aeabi_memcpy>
        cx_hash((cx_hash_t *) sha3, 0, tmp, sizeof(tmp), NULL, 0);
c0d04df2:	4668      	mov	r0, sp
c0d04df4:	6007      	str	r7, [r0, #0]
c0d04df6:	6047      	str	r7, [r0, #4]
c0d04df8:	2324      	movs	r3, #36	; 0x24
c0d04dfa:	9805      	ldr	r0, [sp, #20]
c0d04dfc:	4639      	mov	r1, r7
c0d04dfe:	462a      	mov	r2, r5
c0d04e00:	f000 fd00 	bl	c0d05804 <cx_hash>
c0d04e04:	9d02      	ldr	r5, [sp, #8]
c0d04e06:	9e16      	ldr	r6, [sp, #88]	; 0x58
    }
    if ((quantumType == STARK_QUANTUM_ERC721) || (quantumType == STARK_QUANTUM_MINTABLE_ERC721)) {
c0d04e08:	2c05      	cmp	r4, #5
c0d04e0a:	d001      	beq.n	c0d04e10 <compute_token_id+0xbc>
c0d04e0c:	2c03      	cmp	r4, #3
c0d04e0e:	d10d      	bne.n	c0d04e2c <compute_token_id+0xd8>
c0d04e10:	ad06      	add	r5, sp, #24
c0d04e12:	2720      	movs	r7, #32
        memset(tmp, 0, 32);
c0d04e14:	4628      	mov	r0, r5
c0d04e16:	4639      	mov	r1, r7
c0d04e18:	f004 fbe6 	bl	c0d095e8 <__aeabi_memclr>
c0d04e1c:	9904      	ldr	r1, [sp, #16]
        tmp[31] = 1;
c0d04e1e:	77e9      	strb	r1, [r5, #31]
        PRINTF("compute_token_id quantum %.*H\n", 32, tmp);
        cx_hash((cx_hash_t *) sha3, CX_LAST, tmp, 32, output, 32);
c0d04e20:	4668      	mov	r0, sp
c0d04e22:	c0c0      	stmia	r0!, {r6, r7}
c0d04e24:	9805      	ldr	r0, [sp, #20]
c0d04e26:	462a      	mov	r2, r5
c0d04e28:	463b      	mov	r3, r7
c0d04e2a:	e006      	b.n	c0d04e3a <compute_token_id+0xe6>
c0d04e2c:	2320      	movs	r3, #32
    } else {
        PRINTF("compute_token_id quantum %.*H\n", 32, quantum);
        cx_hash((cx_hash_t *) sha3, CX_LAST, quantum, 32, output, 32);
c0d04e2e:	4668      	mov	r0, sp
c0d04e30:	6006      	str	r6, [r0, #0]
c0d04e32:	6043      	str	r3, [r0, #4]
c0d04e34:	2101      	movs	r1, #1
c0d04e36:	9805      	ldr	r0, [sp, #20]
c0d04e38:	462a      	mov	r2, r5
c0d04e3a:	f000 fce3 	bl	c0d05804 <cx_hash>
    }
    if (!assetTypeOnly &&
c0d04e3e:	2c03      	cmp	r4, #3
c0d04e40:	d342      	bcc.n	c0d04ec8 <compute_token_id+0x174>
c0d04e42:	9815      	ldr	r0, [sp, #84]	; 0x54
c0d04e44:	2800      	cmp	r0, #0
c0d04e46:	d13f      	bne.n	c0d04ec8 <compute_token_id+0x174>
        ((quantumType != STARK_QUANTUM_LEGACY) && (quantumType != STARK_QUANTUM_ETH) &&
         (quantumType != STARK_QUANTUM_ERC20))) {
        const char *prefix = NULL;
        output[0] &= 0x03;
c0d04e48:	7830      	ldrb	r0, [r6, #0]
c0d04e4a:	2103      	movs	r1, #3
c0d04e4c:	4001      	ands	r1, r0
c0d04e4e:	7031      	strb	r1, [r6, #0]
        cx_keccak_init(sha3, 256);
c0d04e50:	9805      	ldr	r0, [sp, #20]
c0d04e52:	9903      	ldr	r1, [sp, #12]
c0d04e54:	f000 fd06 	bl	c0d05864 <cx_keccak_init>
        switch (quantumType) {
c0d04e58:	1f20      	subs	r0, r4, #4
c0d04e5a:	2802      	cmp	r0, #2
c0d04e5c:	d203      	bcs.n	c0d04e66 <compute_token_id+0x112>
c0d04e5e:	9403      	str	r4, [sp, #12]
c0d04e60:	4d22      	ldr	r5, [pc, #136]	; (c0d04eec <compute_token_id+0x198>)
c0d04e62:	447d      	add	r5, pc
c0d04e64:	e004      	b.n	c0d04e70 <compute_token_id+0x11c>
c0d04e66:	2c03      	cmp	r4, #3
c0d04e68:	d132      	bne.n	c0d04ed0 <compute_token_id+0x17c>
c0d04e6a:	9403      	str	r4, [sp, #12]
c0d04e6c:	4d1e      	ldr	r5, [pc, #120]	; (c0d04ee8 <compute_token_id+0x194>)
c0d04e6e:	447d      	add	r5, pc
c0d04e70:	9814      	ldr	r0, [sp, #80]	; 0x50
                break;
            default:
                PRINTF("Unsupported non default quantum type %d\n", quantumType);
                return;
        }
        cx_hash((cx_hash_t *) sha3, 0, (const uint8_t *) prefix, strlen(prefix), NULL, 0);
c0d04e72:	9004      	str	r0, [sp, #16]
c0d04e74:	4628      	mov	r0, r5
c0d04e76:	f004 fd7d 	bl	c0d09974 <strlen>
c0d04e7a:	4603      	mov	r3, r0
c0d04e7c:	2700      	movs	r7, #0
c0d04e7e:	4668      	mov	r0, sp
c0d04e80:	6007      	str	r7, [r0, #0]
c0d04e82:	6047      	str	r7, [r0, #4]
c0d04e84:	9c05      	ldr	r4, [sp, #20]
c0d04e86:	4620      	mov	r0, r4
c0d04e88:	4639      	mov	r1, r7
c0d04e8a:	462a      	mov	r2, r5
c0d04e8c:	f000 fcba 	bl	c0d05804 <cx_hash>
        cx_hash((cx_hash_t *) sha3, 0, output, 32, NULL, 0);
c0d04e90:	4668      	mov	r0, sp
c0d04e92:	6007      	str	r7, [r0, #0]
c0d04e94:	6047      	str	r7, [r0, #4]
c0d04e96:	2520      	movs	r5, #32
c0d04e98:	4620      	mov	r0, r4
c0d04e9a:	4639      	mov	r1, r7
c0d04e9c:	4632      	mov	r2, r6
c0d04e9e:	462b      	mov	r3, r5
c0d04ea0:	f000 fcb0 	bl	c0d05804 <cx_hash>
        cx_hash((cx_hash_t *) sha3, CX_LAST, mintingBlob, 32, output, 32);
c0d04ea4:	4668      	mov	r0, sp
c0d04ea6:	6006      	str	r6, [r0, #0]
c0d04ea8:	6045      	str	r5, [r0, #4]
c0d04eaa:	2101      	movs	r1, #1
c0d04eac:	4620      	mov	r0, r4
c0d04eae:	9a04      	ldr	r2, [sp, #16]
c0d04eb0:	462b      	mov	r3, r5
c0d04eb2:	f000 fca7 	bl	c0d05804 <cx_hash>
c0d04eb6:	20fe      	movs	r0, #254	; 0xfe
c0d04eb8:	9903      	ldr	r1, [sp, #12]
    }
    if (!assetTypeOnly && ((quantumType == STARK_QUANTUM_MINTABLE_ERC20) ||
c0d04eba:	4001      	ands	r1, r0
c0d04ebc:	2904      	cmp	r1, #4
c0d04ebe:	d103      	bne.n	c0d04ec8 <compute_token_id+0x174>
                           (quantumType == STARK_QUANTUM_MINTABLE_ERC721))) {
        output[0] = 0x04;
        output[1] = 0x00;
c0d04ec0:	7077      	strb	r7, [r6, #1]
c0d04ec2:	2004      	movs	r0, #4
        output[0] = 0x04;
c0d04ec4:	7030      	strb	r0, [r6, #0]
c0d04ec6:	e003      	b.n	c0d04ed0 <compute_token_id+0x17c>
    } else {
        output[0] &= 0x03;
c0d04ec8:	7830      	ldrb	r0, [r6, #0]
c0d04eca:	2103      	movs	r1, #3
c0d04ecc:	4001      	ands	r1, r0
c0d04ece:	7031      	strb	r1, [r6, #0]
    }
    PRINTF("compute_token_id computed token %.*H\n", 32, output);
}
c0d04ed0:	b00f      	add	sp, #60	; 0x3c
c0d04ed2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04ed4:	000055f5 	.word	0x000055f5
c0d04ed8:	000055ff 	.word	0x000055ff
c0d04edc:	000055e9 	.word	0x000055e9
c0d04ee0:	000055f3 	.word	0x000055f3
c0d04ee4:	0000562d 	.word	0x0000562d
c0d04ee8:	0000684e 	.word	0x0000684e
c0d04eec:	00005557 	.word	0x00005557

c0d04ef0 <starkware_verify_asset_id>:
    }
    return false;
}

// TODO : rewrite as independant code
bool starkware_verify_asset_id(uint8_t *tmp32, uint8_t *tokenId, bool assetTypeOnly) {
c0d04ef0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04ef2:	b0f1      	sub	sp, #452	; 0x1c4
c0d04ef4:	4605      	mov	r5, r0
    if (quantumSet) {
c0d04ef6:	4819      	ldr	r0, [pc, #100]	; (c0d04f5c <starkware_verify_asset_id+0x6c>)
c0d04ef8:	7800      	ldrb	r0, [r0, #0]
c0d04efa:	2800      	cmp	r0, #0
c0d04efc:	d01c      	beq.n	c0d04f38 <starkware_verify_asset_id+0x48>
c0d04efe:	9105      	str	r1, [sp, #20]
c0d04f00:	20e4      	movs	r0, #228	; 0xe4
        cx_sha3_t sha3;
        tokenDefinition_t *currentToken = NULL;
        if (dataContext.tokenContext.quantumIndex != MAX_TOKEN) {
c0d04f02:	4e17      	ldr	r6, [pc, #92]	; (c0d04f60 <starkware_verify_asset_id+0x70>)
c0d04f04:	5c30      	ldrb	r0, [r6, r0]
            currentToken = &tmpCtx.transactionContext.tokens[dataContext.tokenContext.quantumIndex];
        }
        cx_keccak_init(&sha3, 256);
c0d04f06:	9004      	str	r0, [sp, #16]
c0d04f08:	2001      	movs	r0, #1
c0d04f0a:	0201      	lsls	r1, r0, #8
c0d04f0c:	af06      	add	r7, sp, #24
c0d04f0e:	4638      	mov	r0, r7
c0d04f10:	4614      	mov	r4, r2
c0d04f12:	f000 fca7 	bl	c0d05864 <cx_keccak_init>
c0d04f16:	20e5      	movs	r0, #229	; 0xe5
        compute_token_id(&sha3,
                         (currentToken != NULL ? currentToken->address : NULL),
                         dataContext.tokenContext.quantumType,
c0d04f18:	5c32      	ldrb	r2, [r6, r0]
        compute_token_id(&sha3,
c0d04f1a:	4668      	mov	r0, sp
c0d04f1c:	4631      	mov	r1, r6
c0d04f1e:	31c4      	adds	r1, #196	; 0xc4
c0d04f20:	6001      	str	r1, [r0, #0]
c0d04f22:	9904      	ldr	r1, [sp, #16]
c0d04f24:	6044      	str	r4, [r0, #4]
c0d04f26:	6085      	str	r5, [r0, #8]
        if (dataContext.tokenContext.quantumIndex != MAX_TOKEN) {
c0d04f28:	2902      	cmp	r1, #2
c0d04f2a:	d008      	beq.n	c0d04f3e <starkware_verify_asset_id+0x4e>
c0d04f2c:	2021      	movs	r0, #33	; 0x21
c0d04f2e:	4348      	muls	r0, r1
c0d04f30:	490c      	ldr	r1, [pc, #48]	; (c0d04f64 <starkware_verify_asset_id+0x74>)
c0d04f32:	1809      	adds	r1, r1, r0
c0d04f34:	314c      	adds	r1, #76	; 0x4c
c0d04f36:	e003      	b.n	c0d04f40 <starkware_verify_asset_id+0x50>
c0d04f38:	2000      	movs	r0, #0
    } else {
        PRINTF("Quantum not set\n");
        return false;
    }
    return true;
}
c0d04f3a:	b071      	add	sp, #452	; 0x1c4
c0d04f3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04f3e:	2100      	movs	r1, #0
        compute_token_id(&sha3,
c0d04f40:	36a4      	adds	r6, #164	; 0xa4
c0d04f42:	4638      	mov	r0, r7
c0d04f44:	4633      	mov	r3, r6
c0d04f46:	f7ff ff05 	bl	c0d04d54 <compute_token_id>
c0d04f4a:	2220      	movs	r2, #32
        if (memcmp(tokenId, tmp32, 32) != 0) {
c0d04f4c:	9805      	ldr	r0, [sp, #20]
c0d04f4e:	4629      	mov	r1, r5
c0d04f50:	f004 fb64 	bl	c0d0961c <memcmp>
c0d04f54:	4241      	negs	r1, r0
c0d04f56:	4148      	adcs	r0, r1
c0d04f58:	b071      	add	sp, #452	; 0x1c4
c0d04f5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04f5c:	2000189d 	.word	0x2000189d
c0d04f60:	20001b40 	.word	0x20001b40
c0d04f64:	20001804 	.word	0x20001804

c0d04f68 <starkware_verify_nft_token_id>:

bool starkware_verify_nft_token_id(uint8_t *tokenId) {
c0d04f68:	b580      	push	{r7, lr}
c0d04f6a:	4601      	mov	r1, r0
    if (!quantumSet) {
c0d04f6c:	480a      	ldr	r0, [pc, #40]	; (c0d04f98 <starkware_verify_nft_token_id+0x30>)
c0d04f6e:	7802      	ldrb	r2, [r0, #0]
c0d04f70:	2000      	movs	r0, #0
c0d04f72:	2a00      	cmp	r2, #0
c0d04f74:	d00e      	beq.n	c0d04f94 <starkware_verify_nft_token_id+0x2c>
c0d04f76:	22e5      	movs	r2, #229	; 0xe5
        PRINTF("Quantum not set\n");
        return false;
    }
    switch (dataContext.tokenContext.quantumType) {
c0d04f78:	4b08      	ldr	r3, [pc, #32]	; (c0d04f9c <starkware_verify_nft_token_id+0x34>)
c0d04f7a:	5c9a      	ldrb	r2, [r3, r2]
c0d04f7c:	2a05      	cmp	r2, #5
c0d04f7e:	d001      	beq.n	c0d04f84 <starkware_verify_nft_token_id+0x1c>
c0d04f80:	2a03      	cmp	r2, #3
c0d04f82:	d107      	bne.n	c0d04f94 <starkware_verify_nft_token_id+0x2c>
        default:
            PRINTF("Unexpected quantum type for NFT token id check %d\n",
                   dataContext.tokenContext.quantumType);
            return false;
    }
    if (memcmp(dataContext.tokenContext.quantum, tokenId, 32) != 0) {
c0d04f84:	33a4      	adds	r3, #164	; 0xa4
c0d04f86:	2220      	movs	r2, #32
c0d04f88:	4618      	mov	r0, r3
c0d04f8a:	f004 fb47 	bl	c0d0961c <memcmp>
c0d04f8e:	4601      	mov	r1, r0
c0d04f90:	4240      	negs	r0, r0
c0d04f92:	4148      	adcs	r0, r1
        PRINTF("Token ID not matching - expected %.*H\n", 32, dataContext.tokenContext.quantum);
        PRINTF("Current token ID %.*H\n", 32, tokenId);
        return false;
    }
    return true;
}
c0d04f94:	bd80      	pop	{r7, pc}
c0d04f96:	46c0      	nop			; (mov r8, r8)
c0d04f98:	2000189d 	.word	0x2000189d
c0d04f9c:	20001b40 	.word	0x20001b40

c0d04fa0 <starkware_print_stark_key>:

void starkware_print_vault_id(uint32_t vaultId, char *destination) {
    snprintf(destination, 10, "%d", vaultId);
}

void starkware_print_stark_key(uint8_t *starkKey, char *destination) {
c0d04fa0:	b510      	push	{r4, lr}
c0d04fa2:	b082      	sub	sp, #8
c0d04fa4:	460c      	mov	r4, r1
    snprintf(destination, 70, "0x%.*H", 32, starkKey);
c0d04fa6:	4669      	mov	r1, sp
c0d04fa8:	6008      	str	r0, [r1, #0]
c0d04faa:	2146      	movs	r1, #70	; 0x46
c0d04fac:	4a03      	ldr	r2, [pc, #12]	; (c0d04fbc <starkware_print_stark_key+0x1c>)
c0d04fae:	447a      	add	r2, pc
c0d04fb0:	2320      	movs	r3, #32
c0d04fb2:	4620      	mov	r0, r4
c0d04fb4:	f7ff fb3a 	bl	c0d0462c <snprintf>
}
c0d04fb8:	b002      	add	sp, #8
c0d04fba:	bd10      	pop	{r4, pc}
c0d04fbc:	00004c49 	.word	0x00004c49

c0d04fc0 <starkware_print_eth_address>:

// TODO : rewrite as independant code
void starkware_print_eth_address(uint8_t *address, char *destination) {
c0d04fc0:	b510      	push	{r4, lr}
c0d04fc2:	460c      	mov	r4, r1
c0d04fc4:	2178      	movs	r1, #120	; 0x78
    destination[0] = '0';
    destination[1] = 'x';
c0d04fc6:	7061      	strb	r1, [r4, #1]
c0d04fc8:	2130      	movs	r1, #48	; 0x30
    destination[0] = '0';
c0d04fca:	7021      	strb	r1, [r4, #0]
    getEthAddressStringFromBinary(address, destination + 2, &global_sha3, chainConfig);
c0d04fcc:	4904      	ldr	r1, [pc, #16]	; (c0d04fe0 <starkware_print_eth_address+0x20>)
c0d04fce:	680b      	ldr	r3, [r1, #0]
c0d04fd0:	1ca1      	adds	r1, r4, #2
c0d04fd2:	4a04      	ldr	r2, [pc, #16]	; (c0d04fe4 <starkware_print_eth_address+0x24>)
c0d04fd4:	f7fc ffce 	bl	c0d01f74 <getEthAddressStringFromBinary>
c0d04fd8:	202a      	movs	r0, #42	; 0x2a
c0d04fda:	2100      	movs	r1, #0
    destination[42] = '\0';
c0d04fdc:	5421      	strb	r1, [r4, r0]
}
c0d04fde:	bd10      	pop	{r4, pc}
c0d04fe0:	20001b3c 	.word	0x20001b3c
c0d04fe4:	20001cb8 	.word	0x20001cb8

c0d04fe8 <starkware_print_amount>:

// TODO : rewrite as independant code
void starkware_print_amount(uint8_t *amountData, char *destination, bool forEscape) {
c0d04fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04fea:	b09b      	sub	sp, #108	; 0x6c
c0d04fec:	4617      	mov	r7, r2
c0d04fee:	460c      	mov	r4, r1
c0d04ff0:	4606      	mov	r6, r0
    uint256_t amount, amountPre, quantum;
    uint8_t decimals;
    char *ticker = (char *) PIC(chainConfig->coinName);
c0d04ff2:	482b      	ldr	r0, [pc, #172]	; (c0d050a0 <starkware_print_amount+0xb8>)
c0d04ff4:	6800      	ldr	r0, [r0, #0]
c0d04ff6:	f7ff fced 	bl	c0d049d4 <pic>
c0d04ffa:	4605      	mov	r5, r0

    if ((amountData == NULL) ||
c0d04ffc:	2e00      	cmp	r6, #0
c0d04ffe:	d006      	beq.n	c0d0500e <starkware_print_amount+0x26>
c0d05000:	20e4      	movs	r0, #228	; 0xe4
        (forEscape && (dataContext.tokenContext.quantumIndex == MAX_TOKEN))) {
c0d05002:	4928      	ldr	r1, [pc, #160]	; (c0d050a4 <starkware_print_amount+0xbc>)
c0d05004:	5c08      	ldrb	r0, [r1, r0]
c0d05006:	2802      	cmp	r0, #2
c0d05008:	d108      	bne.n	c0d0501c <starkware_print_amount+0x34>
c0d0500a:	2f00      	cmp	r7, #0
c0d0500c:	d006      	beq.n	c0d0501c <starkware_print_amount+0x34>
        decimals = WEI_TO_ETHER;
        if (!forEscape) {
c0d0500e:	2f00      	cmp	r7, #0
c0d05010:	d011      	beq.n	c0d05036 <starkware_print_amount+0x4e>
c0d05012:	a90a      	add	r1, sp, #40	; 0x28
            convertUint256BE(tmpContent.txContent.value.value,
                             tmpContent.txContent.value.length,
                             &amount);
        } else {
            readu256BE(amountData, &amountPre);
c0d05014:	4630      	mov	r0, r6
c0d05016:	f001 fe8d 	bl	c0d06d34 <readu256BE>
c0d0501a:	e013      	b.n	c0d05044 <starkware_print_amount+0x5c>
c0d0501c:	2121      	movs	r1, #33	; 0x21
        }
    } else {
        tokenDefinition_t *token =
            &tmpCtx.transactionContext.tokens[dataContext.tokenContext.quantumIndex];
        decimals = token->decimals;
c0d0501e:	4341      	muls	r1, r0
c0d05020:	4821      	ldr	r0, [pc, #132]	; (c0d050a8 <starkware_print_amount+0xc0>)
c0d05022:	1845      	adds	r5, r0, r1
c0d05024:	206c      	movs	r0, #108	; 0x6c
c0d05026:	5c28      	ldrb	r0, [r5, r0]
        ticker = (char *) token->ticker;
        readu256BE(amountData, &amountPre);
c0d05028:	9001      	str	r0, [sp, #4]
c0d0502a:	a90a      	add	r1, sp, #40	; 0x28
c0d0502c:	4630      	mov	r0, r6
c0d0502e:	f001 fe81 	bl	c0d06d34 <readu256BE>
        ticker = (char *) token->ticker;
c0d05032:	3560      	adds	r5, #96	; 0x60
c0d05034:	e00a      	b.n	c0d0504c <starkware_print_amount+0x64>
c0d05036:	2162      	movs	r1, #98	; 0x62
                             tmpContent.txContent.value.length,
c0d05038:	481c      	ldr	r0, [pc, #112]	; (c0d050ac <starkware_print_amount+0xc4>)
c0d0503a:	5c41      	ldrb	r1, [r0, r1]
            convertUint256BE(tmpContent.txContent.value.value,
c0d0503c:	3042      	adds	r0, #66	; 0x42
c0d0503e:	aa12      	add	r2, sp, #72	; 0x48
c0d05040:	f003 fb9a 	bl	c0d08778 <convertUint256BE>
c0d05044:	2012      	movs	r0, #18
    }
    if (amountData != NULL) {
c0d05046:	9001      	str	r0, [sp, #4]
c0d05048:	2e00      	cmp	r6, #0
c0d0504a:	d00a      	beq.n	c0d05062 <starkware_print_amount+0x7a>
        readu256BE(dataContext.tokenContext.quantum, &quantum);
c0d0504c:	4815      	ldr	r0, [pc, #84]	; (c0d050a4 <starkware_print_amount+0xbc>)
c0d0504e:	30a4      	adds	r0, #164	; 0xa4
c0d05050:	ae02      	add	r6, sp, #8
c0d05052:	4631      	mov	r1, r6
c0d05054:	f001 fe6e 	bl	c0d06d34 <readu256BE>
c0d05058:	a80a      	add	r0, sp, #40	; 0x28
c0d0505a:	aa12      	add	r2, sp, #72	; 0x48
        mul256(&amountPre, &quantum, &amount);
c0d0505c:	4631      	mov	r1, r6
c0d0505e:	f002 f989 	bl	c0d07374 <mul256>
    }
    tostring256(&amount, 10, (char *) (G_io_apdu_buffer + 100), 100);
c0d05062:	4e13      	ldr	r6, [pc, #76]	; (c0d050b0 <starkware_print_amount+0xc8>)
c0d05064:	3664      	adds	r6, #100	; 0x64
c0d05066:	a812      	add	r0, sp, #72	; 0x48
c0d05068:	210a      	movs	r1, #10
c0d0506a:	2364      	movs	r3, #100	; 0x64
c0d0506c:	4632      	mov	r2, r6
c0d0506e:	f002 fb19 	bl	c0d076a4 <tostring256>
    strcpy(destination, ticker);
c0d05072:	4620      	mov	r0, r4
c0d05074:	4629      	mov	r1, r5
c0d05076:	f004 fc75 	bl	c0d09964 <strcpy>
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
                   strlen((char *) (G_io_apdu_buffer + 100)),
c0d0507a:	4630      	mov	r0, r6
c0d0507c:	f004 fc7a 	bl	c0d09974 <strlen>
c0d05080:	4607      	mov	r7, r0
                   destination + strlen(ticker),
c0d05082:	4628      	mov	r0, r5
c0d05084:	f004 fc76 	bl	c0d09974 <strlen>
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
c0d05088:	4669      	mov	r1, sp
c0d0508a:	9a01      	ldr	r2, [sp, #4]
c0d0508c:	600a      	str	r2, [r1, #0]
                   destination + strlen(ticker),
c0d0508e:	1822      	adds	r2, r4, r0
c0d05090:	2132      	movs	r1, #50	; 0x32
                   50 - strlen(ticker),
c0d05092:	1a0b      	subs	r3, r1, r0
    adjustDecimals((char *) (G_io_apdu_buffer + 100),
c0d05094:	4630      	mov	r0, r6
c0d05096:	4639      	mov	r1, r7
c0d05098:	f7fc ffd0 	bl	c0d0203c <adjustDecimals>
                   decimals);
}
c0d0509c:	b01b      	add	sp, #108	; 0x6c
c0d0509e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d050a0:	20001b3c 	.word	0x20001b3c
c0d050a4:	20001b40 	.word	0x20001b40
c0d050a8:	20001804 	.word	0x20001804
c0d050ac:	200018dc 	.word	0x200018dc
c0d050b0:	20001e61 	.word	0x20001e61

c0d050b4 <starkware_print_asset_contract>:
    }
    strcpy(destination, ticker);
}

// TODO : rewrite as independant code
void starkware_print_asset_contract(char *destination) {
c0d050b4:	b510      	push	{r4, lr}
c0d050b6:	4604      	mov	r4, r0
c0d050b8:	20e4      	movs	r0, #228	; 0xe4
    // token has been validated to be present previously
    if (dataContext.tokenContext.quantumIndex != MAX_TOKEN) {
c0d050ba:	4913      	ldr	r1, [pc, #76]	; (c0d05108 <starkware_print_asset_contract+0x54>)
c0d050bc:	5c08      	ldrb	r0, [r1, r0]
c0d050be:	2802      	cmp	r0, #2
c0d050c0:	d10e      	bne.n	c0d050e0 <starkware_print_asset_contract+0x2c>
c0d050c2:	2000      	movs	r0, #0
        tokenDefinition_t *token =
            &tmpCtx.transactionContext.tokens[dataContext.tokenContext.quantumIndex];
        starkware_print_eth_address(token->address, destination);
    } else {
        strcpy(destination, "UNKNOWN");
c0d050c4:	71e0      	strb	r0, [r4, #7]
c0d050c6:	204e      	movs	r0, #78	; 0x4e
c0d050c8:	71a0      	strb	r0, [r4, #6]
c0d050ca:	2157      	movs	r1, #87	; 0x57
c0d050cc:	7161      	strb	r1, [r4, #5]
c0d050ce:	214f      	movs	r1, #79	; 0x4f
c0d050d0:	7121      	strb	r1, [r4, #4]
c0d050d2:	70e0      	strb	r0, [r4, #3]
c0d050d4:	214b      	movs	r1, #75	; 0x4b
c0d050d6:	70a1      	strb	r1, [r4, #2]
c0d050d8:	7060      	strb	r0, [r4, #1]
c0d050da:	2055      	movs	r0, #85	; 0x55
c0d050dc:	7020      	strb	r0, [r4, #0]
    }
}
c0d050de:	bd10      	pop	{r4, pc}
c0d050e0:	2178      	movs	r1, #120	; 0x78
    destination[1] = 'x';
c0d050e2:	7061      	strb	r1, [r4, #1]
c0d050e4:	2130      	movs	r1, #48	; 0x30
    destination[0] = '0';
c0d050e6:	7021      	strb	r1, [r4, #0]
c0d050e8:	2121      	movs	r1, #33	; 0x21
        starkware_print_eth_address(token->address, destination);
c0d050ea:	4341      	muls	r1, r0
c0d050ec:	4807      	ldr	r0, [pc, #28]	; (c0d0510c <starkware_print_asset_contract+0x58>)
c0d050ee:	1840      	adds	r0, r0, r1
c0d050f0:	304c      	adds	r0, #76	; 0x4c
    getEthAddressStringFromBinary(address, destination + 2, &global_sha3, chainConfig);
c0d050f2:	4907      	ldr	r1, [pc, #28]	; (c0d05110 <starkware_print_asset_contract+0x5c>)
c0d050f4:	680b      	ldr	r3, [r1, #0]
c0d050f6:	1ca1      	adds	r1, r4, #2
c0d050f8:	4a06      	ldr	r2, [pc, #24]	; (c0d05114 <starkware_print_asset_contract+0x60>)
c0d050fa:	f7fc ff3b 	bl	c0d01f74 <getEthAddressStringFromBinary>
c0d050fe:	202a      	movs	r0, #42	; 0x2a
c0d05100:	2100      	movs	r1, #0
    destination[42] = '\0';
c0d05102:	5421      	strb	r1, [r4, r0]
}
c0d05104:	bd10      	pop	{r4, pc}
c0d05106:	46c0      	nop			; (mov r8, r8)
c0d05108:	20001b40 	.word	0x20001b40
c0d0510c:	20001804 	.word	0x20001804
c0d05110:	20001b3c 	.word	0x20001b3c
c0d05114:	20001cb8 	.word	0x20001cb8

c0d05118 <starkware_get_source_address>:

// TODO : rewrite as independant code
void starkware_get_source_address(char *destination) {
c0d05118:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0511a:	b0a9      	sub	sp, #164	; 0xa4
c0d0511c:	9002      	str	r0, [sp, #8]
    uint8_t privateKeyData[32];
    cx_ecfp_private_key_t privateKey;
    cx_ecfp_public_key_t publicKey;
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.transactionContext.bip32Path,
                               tmpCtx.transactionContext.pathLength,
c0d0511e:	481d      	ldr	r0, [pc, #116]	; (c0d05194 <starkware_get_source_address+0x7c>)
c0d05120:	7802      	ldrb	r2, [r0, #0]
c0d05122:	2300      	movs	r3, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d05124:	9303      	str	r3, [sp, #12]
c0d05126:	4669      	mov	r1, sp
c0d05128:	600b      	str	r3, [r1, #0]
c0d0512a:	1d01      	adds	r1, r0, #4
c0d0512c:	2621      	movs	r6, #33	; 0x21
c0d0512e:	ad21      	add	r5, sp, #132	; 0x84
c0d05130:	4630      	mov	r0, r6
c0d05132:	462b      	mov	r3, r5
c0d05134:	f000 fc6c 	bl	c0d05a10 <os_perso_derive_node_bip32>
c0d05138:	2720      	movs	r7, #32
c0d0513a:	ac17      	add	r4, sp, #92	; 0x5c
                               privateKeyData,
                               NULL);
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d0513c:	4630      	mov	r0, r6
c0d0513e:	4629      	mov	r1, r5
c0d05140:	463a      	mov	r2, r7
c0d05142:	4623      	mov	r3, r4
c0d05144:	f000 fbd0 	bl	c0d058e8 <cx_ecfp_init_private_key>
    io_seproxyhal_io_heartbeat();
c0d05148:	f7ff f92e 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d0514c:	a904      	add	r1, sp, #16
c0d0514e:	2301      	movs	r3, #1
    cx_ecfp_generate_pair(CX_CURVE_256K1, &publicKey, &privateKey, 1);
c0d05150:	4630      	mov	r0, r6
c0d05152:	460e      	mov	r6, r1
c0d05154:	4622      	mov	r2, r4
c0d05156:	f000 fbd7 	bl	c0d05908 <cx_ecfp_generate_pair>
c0d0515a:	2128      	movs	r1, #40	; 0x28
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d0515c:	4620      	mov	r0, r4
c0d0515e:	f004 fa59 	bl	c0d09614 <explicit_bzero>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d05162:	4628      	mov	r0, r5
c0d05164:	4639      	mov	r1, r7
c0d05166:	f004 fa55 	bl	c0d09614 <explicit_bzero>
    io_seproxyhal_io_heartbeat();
c0d0516a:	f7ff f91d 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d0516e:	2078      	movs	r0, #120	; 0x78
c0d05170:	9a02      	ldr	r2, [sp, #8]
    destination[0] = '0';
    destination[1] = 'x';
c0d05172:	7050      	strb	r0, [r2, #1]
c0d05174:	2030      	movs	r0, #48	; 0x30
    destination[0] = '0';
c0d05176:	7010      	strb	r0, [r2, #0]
    getEthAddressStringFromKey(&publicKey, destination + 2, &global_sha3, chainConfig);
c0d05178:	4807      	ldr	r0, [pc, #28]	; (c0d05198 <starkware_get_source_address+0x80>)
c0d0517a:	6803      	ldr	r3, [r0, #0]
c0d0517c:	1c91      	adds	r1, r2, #2
c0d0517e:	4614      	mov	r4, r2
c0d05180:	4a06      	ldr	r2, [pc, #24]	; (c0d0519c <starkware_get_source_address+0x84>)
c0d05182:	4630      	mov	r0, r6
c0d05184:	f7fc fed6 	bl	c0d01f34 <getEthAddressStringFromKey>
c0d05188:	202a      	movs	r0, #42	; 0x2a
    destination[42] = '\0';
c0d0518a:	9903      	ldr	r1, [sp, #12]
c0d0518c:	5421      	strb	r1, [r4, r0]
}
c0d0518e:	b029      	add	sp, #164	; 0xa4
c0d05190:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05192:	46c0      	nop			; (mov r8, r8)
c0d05194:	20001804 	.word	0x20001804
c0d05198:	20001b3c 	.word	0x20001b3c
c0d0519c:	20001cb8 	.word	0x20001cb8

c0d051a0 <starkware_plugin_call>:

void starkware_plugin_call(int message, void *parameters) {
c0d051a0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d051a2:	b081      	sub	sp, #4
c0d051a4:	460c      	mov	r4, r1
c0d051a6:	2181      	movs	r1, #129	; 0x81
c0d051a8:	0049      	lsls	r1, r1, #1
    switch (message) {
c0d051aa:	4288      	cmp	r0, r1
c0d051ac:	dd3a      	ble.n	c0d05224 <starkware_plugin_call+0x84>
c0d051ae:	21ff      	movs	r1, #255	; 0xff
c0d051b0:	460a      	mov	r2, r1
c0d051b2:	3204      	adds	r2, #4
c0d051b4:	4290      	cmp	r0, r2
c0d051b6:	d05e      	beq.n	c0d05276 <starkware_plugin_call+0xd6>
c0d051b8:	3106      	adds	r1, #6
c0d051ba:	4288      	cmp	r0, r1
c0d051bc:	d06b      	beq.n	c0d05296 <starkware_plugin_call+0xf6>
c0d051be:	2183      	movs	r1, #131	; 0x83
c0d051c0:	0049      	lsls	r1, r1, #1
c0d051c2:	4288      	cmp	r0, r1
c0d051c4:	d000      	beq.n	c0d051c8 <starkware_plugin_call+0x28>
c0d051c6:	e2a3      	b.n	c0d05710 <starkware_plugin_call+0x570>
        } break;

        case ETH_PLUGIN_QUERY_CONTRACT_UI: {
            ethQueryContractUI_t *msg = (ethQueryContractUI_t *) parameters;
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
            switch (msg->screenIndex) {
c0d051c8:	7b20      	ldrb	r0, [r4, #12]
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d051ca:	68a5      	ldr	r5, [r4, #8]
            switch (msg->screenIndex) {
c0d051cc:	2801      	cmp	r0, #1
c0d051ce:	dc00      	bgt.n	c0d051d2 <starkware_plugin_call+0x32>
c0d051d0:	e0c0      	b.n	c0d05354 <starkware_plugin_call+0x1b4>
c0d051d2:	2802      	cmp	r0, #2
c0d051d4:	d100      	bne.n	c0d051d8 <starkware_plugin_call+0x38>
c0d051d6:	e105      	b.n	c0d053e4 <starkware_plugin_call+0x244>
c0d051d8:	2803      	cmp	r0, #3
c0d051da:	d100      	bne.n	c0d051de <starkware_plugin_call+0x3e>
c0d051dc:	e110      	b.n	c0d05400 <starkware_plugin_call+0x260>
c0d051de:	2804      	cmp	r0, #4
c0d051e0:	d000      	beq.n	c0d051e4 <starkware_plugin_call+0x44>
c0d051e2:	e295      	b.n	c0d05710 <starkware_plugin_call+0x570>
                    }
                    msg->result = ETH_PLUGIN_RESULT_OK;
                    break;

                case 4:
                    switch (context->selectorIndex) {
c0d051e4:	7928      	ldrb	r0, [r5, #4]
c0d051e6:	280f      	cmp	r0, #15
c0d051e8:	d900      	bls.n	c0d051ec <starkware_plugin_call+0x4c>
c0d051ea:	e22b      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
c0d051ec:	2101      	movs	r1, #1
c0d051ee:	4081      	lsls	r1, r0
c0d051f0:	201b      	movs	r0, #27
c0d051f2:	02c0      	lsls	r0, r0, #11
c0d051f4:	4201      	tst	r1, r0
c0d051f6:	d100      	bne.n	c0d051fa <starkware_plugin_call+0x5a>
c0d051f8:	e224      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
                        case STARKWARE_WITHDRAW_NFT:
                        case STARKWARE_WITHDRAW_NFT_TO:
                        case STARKWARE_DEPOSIT_NFT:
                        case STARKWARE_DEPOSIT_NFT_RECLAIM:
                            strcpy(msg->title, "TokenID");
c0d051fa:	6920      	ldr	r0, [r4, #16]
c0d051fc:	2100      	movs	r1, #0
c0d051fe:	71c1      	strb	r1, [r0, #7]
c0d05200:	2144      	movs	r1, #68	; 0x44
c0d05202:	7181      	strb	r1, [r0, #6]
c0d05204:	2149      	movs	r1, #73	; 0x49
c0d05206:	7141      	strb	r1, [r0, #5]
c0d05208:	216e      	movs	r1, #110	; 0x6e
c0d0520a:	7101      	strb	r1, [r0, #4]
c0d0520c:	2165      	movs	r1, #101	; 0x65
c0d0520e:	70c1      	strb	r1, [r0, #3]
c0d05210:	216b      	movs	r1, #107	; 0x6b
c0d05212:	7081      	strb	r1, [r0, #2]
c0d05214:	216f      	movs	r1, #111	; 0x6f
c0d05216:	7041      	strb	r1, [r0, #1]
c0d05218:	2154      	movs	r1, #84	; 0x54
c0d0521a:	7001      	strb	r1, [r0, #0]
                            starkware_print_stark_key(dataContext.tokenContext.quantum, msg->msg);
c0d0521c:	69a0      	ldr	r0, [r4, #24]
    snprintf(destination, 70, "0x%.*H", 32, starkKey);
c0d0521e:	49fc      	ldr	r1, [pc, #1008]	; (c0d05610 <starkware_plugin_call+0x470>)
c0d05220:	31a4      	adds	r1, #164	; 0xa4
c0d05222:	e0ae      	b.n	c0d05382 <starkware_plugin_call+0x1e2>
c0d05224:	22ff      	movs	r2, #255	; 0xff
c0d05226:	3202      	adds	r2, #2
    switch (message) {
c0d05228:	4290      	cmp	r0, r2
c0d0522a:	d04a      	beq.n	c0d052c2 <starkware_plugin_call+0x122>
c0d0522c:	4288      	cmp	r0, r1
c0d0522e:	d000      	beq.n	c0d05232 <starkware_plugin_call+0x92>
c0d05230:	e26e      	b.n	c0d05710 <starkware_plugin_call+0x570>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d05232:	68a5      	ldr	r5, [r4, #8]
            if (context->selectorIndex == STARKWARE_VERIFY_ESCAPE) {
c0d05234:	7928      	ldrb	r0, [r5, #4]
c0d05236:	2809      	cmp	r0, #9
c0d05238:	d100      	bne.n	c0d0523c <starkware_plugin_call+0x9c>
c0d0523a:	e267      	b.n	c0d0570c <starkware_plugin_call+0x56c>
            switch (msg->parameterOffset) {
c0d0523c:	6921      	ldr	r1, [r4, #16]
c0d0523e:	1f09      	subs	r1, r1, #4
c0d05240:	2205      	movs	r2, #5
c0d05242:	41d1      	rors	r1, r2
c0d05244:	2901      	cmp	r1, #1
c0d05246:	dd00      	ble.n	c0d0524a <starkware_plugin_call+0xaa>
c0d05248:	e0a5      	b.n	c0d05396 <starkware_plugin_call+0x1f6>
c0d0524a:	2900      	cmp	r1, #0
c0d0524c:	d100      	bne.n	c0d05250 <starkware_plugin_call+0xb0>
c0d0524e:	e134      	b.n	c0d054ba <starkware_plugin_call+0x31a>
c0d05250:	2901      	cmp	r1, #1
c0d05252:	d000      	beq.n	c0d05256 <starkware_plugin_call+0xb6>
c0d05254:	e148      	b.n	c0d054e8 <starkware_plugin_call+0x348>
                    switch (context->selectorIndex) {
c0d05256:	280f      	cmp	r0, #15
c0d05258:	d900      	bls.n	c0d0525c <starkware_plugin_call+0xbc>
c0d0525a:	e236      	b.n	c0d056ca <starkware_plugin_call+0x52a>
c0d0525c:	2101      	movs	r1, #1
c0d0525e:	4081      	lsls	r1, r0
c0d05260:	4afa      	ldr	r2, [pc, #1000]	; (c0d0564c <starkware_plugin_call+0x4ac>)
c0d05262:	4211      	tst	r1, r2
c0d05264:	d100      	bne.n	c0d05268 <starkware_plugin_call+0xc8>
c0d05266:	e1c4      	b.n	c0d055f2 <starkware_plugin_call+0x452>
c0d05268:	68e1      	ldr	r1, [r4, #12]
c0d0526a:	4628      	mov	r0, r5
c0d0526c:	3025      	adds	r0, #37	; 0x25
c0d0526e:	2201      	movs	r2, #1
c0d05270:	f7ff fe3e 	bl	c0d04ef0 <starkware_verify_asset_id>
c0d05274:	e1a0      	b.n	c0d055b8 <starkware_plugin_call+0x418>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d05276:	68a0      	ldr	r0, [r4, #8]
c0d05278:	2145      	movs	r1, #69	; 0x45
            if (!context->validToken) {
c0d0527a:	5c41      	ldrb	r1, [r0, r1]
c0d0527c:	2900      	cmp	r1, #0
c0d0527e:	d100      	bne.n	c0d05282 <starkware_plugin_call+0xe2>
c0d05280:	e086      	b.n	c0d05390 <starkware_plugin_call+0x1f0>
c0d05282:	2102      	movs	r1, #2
                msg->uiType = ETH_UI_TYPE_GENERIC;
c0d05284:	7721      	strb	r1, [r4, #28]
                msg->numScreens = STARKWARE_NUM_SCREENS[context->selectorIndex];
c0d05286:	7900      	ldrb	r0, [r0, #4]
c0d05288:	2101      	movs	r1, #1
                msg->result = ETH_PLUGIN_RESULT_OK;
c0d0528a:	77a1      	strb	r1, [r4, #30]
                msg->numScreens = STARKWARE_NUM_SCREENS[context->selectorIndex];
c0d0528c:	49f0      	ldr	r1, [pc, #960]	; (c0d05650 <starkware_plugin_call+0x4b0>)
c0d0528e:	4479      	add	r1, pc
c0d05290:	5c08      	ldrb	r0, [r1, r0]
c0d05292:	7760      	strb	r0, [r4, #29]
c0d05294:	e23c      	b.n	c0d05710 <starkware_plugin_call+0x570>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d05296:	68a0      	ldr	r0, [r4, #8]
            switch (context->selectorIndex) {
c0d05298:	7900      	ldrb	r0, [r0, #4]
c0d0529a:	2807      	cmp	r0, #7
c0d0529c:	dc4b      	bgt.n	c0d05336 <starkware_plugin_call+0x196>
c0d0529e:	2803      	cmp	r0, #3
c0d052a0:	dd00      	ble.n	c0d052a4 <starkware_plugin_call+0x104>
c0d052a2:	e08a      	b.n	c0d053ba <starkware_plugin_call+0x21a>
c0d052a4:	1e41      	subs	r1, r0, #1
c0d052a6:	2902      	cmp	r1, #2
c0d052a8:	d200      	bcs.n	c0d052ac <starkware_plugin_call+0x10c>
c0d052aa:	e0e3      	b.n	c0d05474 <starkware_plugin_call+0x2d4>
c0d052ac:	2800      	cmp	r0, #0
c0d052ae:	d100      	bne.n	c0d052b2 <starkware_plugin_call+0x112>
c0d052b0:	e132      	b.n	c0d05518 <starkware_plugin_call+0x378>
c0d052b2:	2803      	cmp	r0, #3
c0d052b4:	d000      	beq.n	c0d052b8 <starkware_plugin_call+0x118>
c0d052b6:	e13f      	b.n	c0d05538 <starkware_plugin_call+0x398>
                    strcpy(msg->name, "Cancel Deposit");
c0d052b8:	68e0      	ldr	r0, [r4, #12]
c0d052ba:	49e6      	ldr	r1, [pc, #920]	; (c0d05654 <starkware_plugin_call+0x4b4>)
c0d052bc:	4479      	add	r1, pc
c0d052be:	220f      	movs	r2, #15
c0d052c0:	e138      	b.n	c0d05534 <starkware_plugin_call+0x394>
            starkware_parameters_t *context = (starkware_parameters_t *) msg->pluginContext;
c0d052c2:	68a5      	ldr	r5, [r4, #8]
c0d052c4:	2600      	movs	r6, #0
c0d052c6:	4fe4      	ldr	r7, [pc, #912]	; (c0d05658 <starkware_plugin_call+0x4b8>)
c0d052c8:	447f      	add	r7, pc
                if (memcmp(PIC(STARKWARE_SELECTORS[i]), msg->selector, SELECTOR_SIZE) == 0) {
c0d052ca:	6838      	ldr	r0, [r7, #0]
c0d052cc:	f7ff fb82 	bl	c0d049d4 <pic>
c0d052d0:	7801      	ldrb	r1, [r0, #0]
c0d052d2:	7842      	ldrb	r2, [r0, #1]
c0d052d4:	0212      	lsls	r2, r2, #8
c0d052d6:	1851      	adds	r1, r2, r1
c0d052d8:	7882      	ldrb	r2, [r0, #2]
c0d052da:	78c0      	ldrb	r0, [r0, #3]
c0d052dc:	0200      	lsls	r0, r0, #8
c0d052de:	1880      	adds	r0, r0, r2
c0d052e0:	0400      	lsls	r0, r0, #16
c0d052e2:	1840      	adds	r0, r0, r1
c0d052e4:	6921      	ldr	r1, [r4, #16]
c0d052e6:	780a      	ldrb	r2, [r1, #0]
c0d052e8:	784b      	ldrb	r3, [r1, #1]
c0d052ea:	021b      	lsls	r3, r3, #8
c0d052ec:	189a      	adds	r2, r3, r2
c0d052ee:	788b      	ldrb	r3, [r1, #2]
c0d052f0:	78c9      	ldrb	r1, [r1, #3]
c0d052f2:	0209      	lsls	r1, r1, #8
c0d052f4:	18c9      	adds	r1, r1, r3
c0d052f6:	0409      	lsls	r1, r1, #16
c0d052f8:	1889      	adds	r1, r1, r2
c0d052fa:	4288      	cmp	r0, r1
c0d052fc:	d009      	beq.n	c0d05312 <starkware_plugin_call+0x172>
            for (i = 0; i < NUM_STARKWARE_SELECTORS; i++) {
c0d052fe:	1d3f      	adds	r7, r7, #4
c0d05300:	1c76      	adds	r6, r6, #1
c0d05302:	2e10      	cmp	r6, #16
c0d05304:	d3e1      	bcc.n	c0d052ca <starkware_plugin_call+0x12a>
            uint8_t i;
c0d05306:	b2f0      	uxtb	r0, r6
            if (i == NUM_STARKWARE_SELECTORS) {
c0d05308:	2810      	cmp	r0, #16
c0d0530a:	d100      	bne.n	c0d0530e <starkware_plugin_call+0x16e>
c0d0530c:	e200      	b.n	c0d05710 <starkware_plugin_call+0x570>
            if (STARKWARE_EXPECTED_DATA_SIZE[context->selectorIndex] != 0) {
c0d0530e:	792e      	ldrb	r6, [r5, #4]
c0d05310:	e000      	b.n	c0d05314 <starkware_plugin_call+0x174>
                    context->selectorIndex = i;
c0d05312:	712e      	strb	r6, [r5, #4]
            if (STARKWARE_EXPECTED_DATA_SIZE[context->selectorIndex] != 0) {
c0d05314:	b2f0      	uxtb	r0, r6
c0d05316:	49d1      	ldr	r1, [pc, #836]	; (c0d0565c <starkware_plugin_call+0x4bc>)
c0d05318:	40c1      	lsrs	r1, r0
c0d0531a:	07c9      	lsls	r1, r1, #31
c0d0531c:	d006      	beq.n	c0d0532c <starkware_plugin_call+0x18c>
c0d0531e:	49fd      	ldr	r1, [pc, #1012]	; (c0d05714 <starkware_plugin_call+0x574>)
c0d05320:	4479      	add	r1, pc
c0d05322:	5c08      	ldrb	r0, [r1, r0]
                if (msg->dataSize != STARKWARE_EXPECTED_DATA_SIZE[context->selectorIndex]) {
c0d05324:	6961      	ldr	r1, [r4, #20]
c0d05326:	4281      	cmp	r1, r0
c0d05328:	d000      	beq.n	c0d0532c <starkware_plugin_call+0x18c>
c0d0532a:	e1f1      	b.n	c0d05710 <starkware_plugin_call+0x570>
c0d0532c:	2045      	movs	r0, #69	; 0x45
c0d0532e:	2101      	movs	r1, #1
            context->validToken = true;
c0d05330:	5429      	strb	r1, [r5, r0]
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d05332:	7721      	strb	r1, [r4, #28]
c0d05334:	e1ec      	b.n	c0d05710 <starkware_plugin_call+0x570>
            switch (context->selectorIndex) {
c0d05336:	280b      	cmp	r0, #11
c0d05338:	dc46      	bgt.n	c0d053c8 <starkware_plugin_call+0x228>
c0d0533a:	2809      	cmp	r0, #9
c0d0533c:	dd00      	ble.n	c0d05340 <starkware_plugin_call+0x1a0>
c0d0533e:	e095      	b.n	c0d0546c <starkware_plugin_call+0x2cc>
c0d05340:	2808      	cmp	r0, #8
c0d05342:	d100      	bne.n	c0d05346 <starkware_plugin_call+0x1a6>
c0d05344:	e0ed      	b.n	c0d05522 <starkware_plugin_call+0x382>
c0d05346:	2809      	cmp	r0, #9
c0d05348:	d000      	beq.n	c0d0534c <starkware_plugin_call+0x1ac>
c0d0534a:	e0f5      	b.n	c0d05538 <starkware_plugin_call+0x398>
                    strcpy(msg->name, "Verify Escape");
c0d0534c:	68e0      	ldr	r0, [r4, #12]
c0d0534e:	49fd      	ldr	r1, [pc, #1012]	; (c0d05744 <starkware_plugin_call+0x5a4>)
c0d05350:	4479      	add	r1, pc
c0d05352:	e0b0      	b.n	c0d054b6 <starkware_plugin_call+0x316>
            switch (msg->screenIndex) {
c0d05354:	2800      	cmp	r0, #0
c0d05356:	d068      	beq.n	c0d0542a <starkware_plugin_call+0x28a>
c0d05358:	2801      	cmp	r0, #1
c0d0535a:	d000      	beq.n	c0d0535e <starkware_plugin_call+0x1be>
c0d0535c:	e1d8      	b.n	c0d05710 <starkware_plugin_call+0x570>
                    switch (context->selectorIndex) {
c0d0535e:	7928      	ldrb	r0, [r5, #4]
c0d05360:	280f      	cmp	r0, #15
c0d05362:	d900      	bls.n	c0d05366 <starkware_plugin_call+0x1c6>
c0d05364:	e16e      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
c0d05366:	2101      	movs	r1, #1
c0d05368:	4081      	lsls	r1, r0
c0d0536a:	4aef      	ldr	r2, [pc, #956]	; (c0d05728 <starkware_plugin_call+0x588>)
c0d0536c:	4211      	tst	r1, r2
c0d0536e:	d100      	bne.n	c0d05372 <starkware_plugin_call+0x1d2>
c0d05370:	e192      	b.n	c0d05698 <starkware_plugin_call+0x4f8>
c0d05372:	6920      	ldr	r0, [r4, #16]
c0d05374:	49ef      	ldr	r1, [pc, #956]	; (c0d05734 <starkware_plugin_call+0x594>)
c0d05376:	4479      	add	r1, pc
c0d05378:	220f      	movs	r2, #15
c0d0537a:	f004 f93b 	bl	c0d095f4 <__aeabi_memcpy>
c0d0537e:	69a0      	ldr	r0, [r4, #24]
c0d05380:	1d69      	adds	r1, r5, #5
c0d05382:	466a      	mov	r2, sp
c0d05384:	6011      	str	r1, [r2, #0]
c0d05386:	2146      	movs	r1, #70	; 0x46
c0d05388:	4aeb      	ldr	r2, [pc, #940]	; (c0d05738 <starkware_plugin_call+0x598>)
c0d0538a:	447a      	add	r2, pc
c0d0538c:	2320      	movs	r3, #32
c0d0538e:	e157      	b.n	c0d05640 <starkware_plugin_call+0x4a0>
c0d05390:	2003      	movs	r0, #3
                msg->result = ETH_PLUGIN_RESULT_FALLBACK;
c0d05392:	77a0      	strb	r0, [r4, #30]
c0d05394:	e1bc      	b.n	c0d05710 <starkware_plugin_call+0x570>
            switch (msg->parameterOffset) {
c0d05396:	2902      	cmp	r1, #2
c0d05398:	d100      	bne.n	c0d0539c <starkware_plugin_call+0x1fc>
c0d0539a:	e09b      	b.n	c0d054d4 <starkware_plugin_call+0x334>
c0d0539c:	2903      	cmp	r1, #3
c0d0539e:	d000      	beq.n	c0d053a2 <starkware_plugin_call+0x202>
c0d053a0:	e0a2      	b.n	c0d054e8 <starkware_plugin_call+0x348>
                    switch (context->selectorIndex) {
c0d053a2:	280a      	cmp	r0, #10
c0d053a4:	dc00      	bgt.n	c0d053a8 <starkware_plugin_call+0x208>
c0d053a6:	e10a      	b.n	c0d055be <starkware_plugin_call+0x41e>
c0d053a8:	4601      	mov	r1, r0
c0d053aa:	390b      	subs	r1, #11
c0d053ac:	2902      	cmp	r1, #2
c0d053ae:	d200      	bcs.n	c0d053b2 <starkware_plugin_call+0x212>
c0d053b0:	e0ff      	b.n	c0d055b2 <starkware_plugin_call+0x412>
c0d053b2:	280f      	cmp	r0, #15
c0d053b4:	d100      	bne.n	c0d053b8 <starkware_plugin_call+0x218>
c0d053b6:	e1a2      	b.n	c0d056fe <starkware_plugin_call+0x55e>
c0d053b8:	e1a8      	b.n	c0d0570c <starkware_plugin_call+0x56c>
            switch (context->selectorIndex) {
c0d053ba:	2805      	cmp	r0, #5
c0d053bc:	dc6c      	bgt.n	c0d05498 <starkware_plugin_call+0x2f8>
c0d053be:	2804      	cmp	r0, #4
c0d053c0:	d072      	beq.n	c0d054a8 <starkware_plugin_call+0x308>
c0d053c2:	2805      	cmp	r0, #5
c0d053c4:	d009      	beq.n	c0d053da <starkware_plugin_call+0x23a>
c0d053c6:	e0b7      	b.n	c0d05538 <starkware_plugin_call+0x398>
c0d053c8:	4601      	mov	r1, r0
c0d053ca:	390d      	subs	r1, #13
c0d053cc:	2902      	cmp	r1, #2
c0d053ce:	d304      	bcc.n	c0d053da <starkware_plugin_call+0x23a>
c0d053d0:	280c      	cmp	r0, #12
c0d053d2:	d069      	beq.n	c0d054a8 <starkware_plugin_call+0x308>
c0d053d4:	280f      	cmp	r0, #15
c0d053d6:	d06b      	beq.n	c0d054b0 <starkware_plugin_call+0x310>
c0d053d8:	e0ae      	b.n	c0d05538 <starkware_plugin_call+0x398>
                    strcpy(msg->name, "Withdrawal");
c0d053da:	68e0      	ldr	r0, [r4, #12]
c0d053dc:	49d7      	ldr	r1, [pc, #860]	; (c0d0573c <starkware_plugin_call+0x59c>)
c0d053de:	4479      	add	r1, pc
c0d053e0:	220b      	movs	r2, #11
c0d053e2:	e0a7      	b.n	c0d05534 <starkware_plugin_call+0x394>
                    switch (context->selectorIndex) {
c0d053e4:	7928      	ldrb	r0, [r5, #4]
c0d053e6:	2807      	cmp	r0, #7
c0d053e8:	dd00      	ble.n	c0d053ec <starkware_plugin_call+0x24c>
c0d053ea:	e081      	b.n	c0d054f0 <starkware_plugin_call+0x350>
c0d053ec:	2804      	cmp	r0, #4
c0d053ee:	dd00      	ble.n	c0d053f2 <starkware_plugin_call+0x252>
c0d053f0:	e0ee      	b.n	c0d055d0 <starkware_plugin_call+0x430>
c0d053f2:	1e41      	subs	r1, r0, #1
c0d053f4:	2904      	cmp	r1, #4
c0d053f6:	d200      	bcs.n	c0d053fa <starkware_plugin_call+0x25a>
c0d053f8:	e10e      	b.n	c0d05618 <starkware_plugin_call+0x478>
c0d053fa:	2800      	cmp	r0, #0
c0d053fc:	d0b9      	beq.n	c0d05372 <starkware_plugin_call+0x1d2>
c0d053fe:	e121      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
                    switch (context->selectorIndex) {
c0d05400:	7928      	ldrb	r0, [r5, #4]
c0d05402:	280f      	cmp	r0, #15
c0d05404:	d900      	bls.n	c0d05408 <starkware_plugin_call+0x268>
c0d05406:	e12b      	b.n	c0d05660 <starkware_plugin_call+0x4c0>
c0d05408:	2101      	movs	r1, #1
c0d0540a:	4081      	lsls	r1, r0
c0d0540c:	221b      	movs	r2, #27
c0d0540e:	02d2      	lsls	r2, r2, #11
c0d05410:	4211      	tst	r1, r2
c0d05412:	d100      	bne.n	c0d05416 <starkware_plugin_call+0x276>
c0d05414:	e0a7      	b.n	c0d05566 <starkware_plugin_call+0x3c6>
                            strcpy(msg->title, "NFT Contract");
c0d05416:	6920      	ldr	r0, [r4, #16]
c0d05418:	49df      	ldr	r1, [pc, #892]	; (c0d05798 <starkware_plugin_call+0x5f8>)
c0d0541a:	4479      	add	r1, pc
c0d0541c:	220d      	movs	r2, #13
c0d0541e:	f004 f8e9 	bl	c0d095f4 <__aeabi_memcpy>
c0d05422:	69a0      	ldr	r0, [r4, #24]
c0d05424:	f7ff fe46 	bl	c0d050b4 <starkware_print_asset_contract>
c0d05428:	e10c      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
                    strcpy(msg->title, "Contract Name");
c0d0542a:	6920      	ldr	r0, [r4, #16]
c0d0542c:	49ce      	ldr	r1, [pc, #824]	; (c0d05768 <starkware_plugin_call+0x5c8>)
c0d0542e:	4479      	add	r1, pc
c0d05430:	220e      	movs	r2, #14
c0d05432:	f004 f8df 	bl	c0d095f4 <__aeabi_memcpy>
        if (memcmp(address, DEVERSIFI_CONTRACT + offset + 1, 20) == 0) {
c0d05436:	4ebd      	ldr	r6, [pc, #756]	; (c0d0572c <starkware_plugin_call+0x58c>)
c0d05438:	3663      	adds	r6, #99	; 0x63
c0d0543a:	48cc      	ldr	r0, [pc, #816]	; (c0d0576c <starkware_plugin_call+0x5cc>)
c0d0543c:	4478      	add	r0, pc
c0d0543e:	1c41      	adds	r1, r0, #1
c0d05440:	2214      	movs	r2, #20
c0d05442:	4630      	mov	r0, r6
c0d05444:	f004 f8ea 	bl	c0d0961c <memcmp>
c0d05448:	69a5      	ldr	r5, [r4, #24]
                    if (is_deversify_contract(tmpContent.txContent.destination)) {
c0d0544a:	2800      	cmp	r0, #0
c0d0544c:	d05d      	beq.n	c0d0550a <starkware_plugin_call+0x36a>
c0d0544e:	2078      	movs	r0, #120	; 0x78
    destination[1] = 'x';
c0d05450:	7068      	strb	r0, [r5, #1]
c0d05452:	2030      	movs	r0, #48	; 0x30
    destination[0] = '0';
c0d05454:	7028      	strb	r0, [r5, #0]
    getEthAddressStringFromBinary(address, destination + 2, &global_sha3, chainConfig);
c0d05456:	48b1      	ldr	r0, [pc, #708]	; (c0d0571c <starkware_plugin_call+0x57c>)
c0d05458:	6803      	ldr	r3, [r0, #0]
c0d0545a:	1ca9      	adds	r1, r5, #2
c0d0545c:	4ab1      	ldr	r2, [pc, #708]	; (c0d05724 <starkware_plugin_call+0x584>)
c0d0545e:	4630      	mov	r0, r6
c0d05460:	f7fc fd88 	bl	c0d01f74 <getEthAddressStringFromBinary>
c0d05464:	202a      	movs	r0, #42	; 0x2a
c0d05466:	2100      	movs	r1, #0
    destination[42] = '\0';
c0d05468:	5429      	strb	r1, [r5, r0]
c0d0546a:	e0eb      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
            switch (context->selectorIndex) {
c0d0546c:	280a      	cmp	r0, #10
c0d0546e:	d01f      	beq.n	c0d054b0 <starkware_plugin_call+0x310>
c0d05470:	280b      	cmp	r0, #11
c0d05472:	d161      	bne.n	c0d05538 <starkware_plugin_call+0x398>
                    strcpy(msg->name, "Deposit");
c0d05474:	68e0      	ldr	r0, [r4, #12]
c0d05476:	2100      	movs	r1, #0
c0d05478:	71c1      	strb	r1, [r0, #7]
c0d0547a:	2174      	movs	r1, #116	; 0x74
c0d0547c:	7181      	strb	r1, [r0, #6]
c0d0547e:	2169      	movs	r1, #105	; 0x69
c0d05480:	7141      	strb	r1, [r0, #5]
c0d05482:	2173      	movs	r1, #115	; 0x73
c0d05484:	7101      	strb	r1, [r0, #4]
c0d05486:	216f      	movs	r1, #111	; 0x6f
c0d05488:	70c1      	strb	r1, [r0, #3]
c0d0548a:	2170      	movs	r1, #112	; 0x70
c0d0548c:	7081      	strb	r1, [r0, #2]
c0d0548e:	2165      	movs	r1, #101	; 0x65
c0d05490:	7041      	strb	r1, [r0, #1]
c0d05492:	2144      	movs	r1, #68	; 0x44
c0d05494:	7001      	strb	r1, [r0, #0]
c0d05496:	e04f      	b.n	c0d05538 <starkware_plugin_call+0x398>
            switch (context->selectorIndex) {
c0d05498:	2806      	cmp	r0, #6
c0d0549a:	d047      	beq.n	c0d0552c <starkware_plugin_call+0x38c>
c0d0549c:	2807      	cmp	r0, #7
c0d0549e:	d14b      	bne.n	c0d05538 <starkware_plugin_call+0x398>
                    strcpy(msg->name, "Freeze");
c0d054a0:	68e0      	ldr	r0, [r4, #12]
c0d054a2:	49a7      	ldr	r1, [pc, #668]	; (c0d05740 <starkware_plugin_call+0x5a0>)
c0d054a4:	4479      	add	r1, pc
c0d054a6:	e03f      	b.n	c0d05528 <starkware_plugin_call+0x388>
                    strcpy(msg->name, "Reclaim Deposit");
c0d054a8:	68e0      	ldr	r0, [r4, #12]
c0d054aa:	49ab      	ldr	r1, [pc, #684]	; (c0d05758 <starkware_plugin_call+0x5b8>)
c0d054ac:	4479      	add	r1, pc
c0d054ae:	e040      	b.n	c0d05532 <starkware_plugin_call+0x392>
                    strcpy(msg->name, "Withdrawal To");
c0d054b0:	68e0      	ldr	r0, [r4, #12]
c0d054b2:	49a7      	ldr	r1, [pc, #668]	; (c0d05750 <starkware_plugin_call+0x5b0>)
c0d054b4:	4479      	add	r1, pc
c0d054b6:	220e      	movs	r2, #14
c0d054b8:	e03c      	b.n	c0d05534 <starkware_plugin_call+0x394>
                    switch (context->selectorIndex) {
c0d054ba:	280f      	cmp	r0, #15
c0d054bc:	d900      	bls.n	c0d054c0 <starkware_plugin_call+0x320>
c0d054be:	e125      	b.n	c0d0570c <starkware_plugin_call+0x56c>
c0d054c0:	2101      	movs	r1, #1
c0d054c2:	4081      	lsls	r1, r0
c0d054c4:	4a9a      	ldr	r2, [pc, #616]	; (c0d05730 <starkware_plugin_call+0x590>)
c0d054c6:	4211      	tst	r1, r2
c0d054c8:	d100      	bne.n	c0d054cc <starkware_plugin_call+0x32c>
c0d054ca:	e116      	b.n	c0d056fa <starkware_plugin_call+0x55a>
c0d054cc:	68e1      	ldr	r1, [r4, #12]
c0d054ce:	1d68      	adds	r0, r5, #5
c0d054d0:	2220      	movs	r2, #32
c0d054d2:	e119      	b.n	c0d05708 <starkware_plugin_call+0x568>
                    switch (context->selectorIndex) {
c0d054d4:	2809      	cmp	r0, #9
c0d054d6:	dc63      	bgt.n	c0d055a0 <starkware_plugin_call+0x400>
c0d054d8:	1e41      	subs	r1, r0, #1
c0d054da:	2904      	cmp	r1, #4
c0d054dc:	d200      	bcs.n	c0d054e0 <starkware_plugin_call+0x340>
c0d054de:	e08d      	b.n	c0d055fc <starkware_plugin_call+0x45c>
c0d054e0:	2808      	cmp	r0, #8
c0d054e2:	d100      	bne.n	c0d054e6 <starkware_plugin_call+0x346>
c0d054e4:	e6c0      	b.n	c0d05268 <starkware_plugin_call+0xc8>
c0d054e6:	e111      	b.n	c0d0570c <starkware_plugin_call+0x56c>
                    switch (context->selectorIndex) {
c0d054e8:	2800      	cmp	r0, #0
c0d054ea:	d000      	beq.n	c0d054ee <starkware_plugin_call+0x34e>
c0d054ec:	e110      	b.n	c0d05710 <starkware_plugin_call+0x570>
c0d054ee:	e10d      	b.n	c0d0570c <starkware_plugin_call+0x56c>
                    switch (context->selectorIndex) {
c0d054f0:	280c      	cmp	r0, #12
c0d054f2:	dc73      	bgt.n	c0d055dc <starkware_plugin_call+0x43c>
c0d054f4:	4601      	mov	r1, r0
c0d054f6:	390b      	subs	r1, #11
c0d054f8:	2902      	cmp	r1, #2
c0d054fa:	d200      	bcs.n	c0d054fe <starkware_plugin_call+0x35e>
c0d054fc:	e08c      	b.n	c0d05618 <starkware_plugin_call+0x478>
c0d054fe:	2808      	cmp	r0, #8
c0d05500:	d100      	bne.n	c0d05504 <starkware_plugin_call+0x364>
c0d05502:	e736      	b.n	c0d05372 <starkware_plugin_call+0x1d2>
c0d05504:	280a      	cmp	r0, #10
c0d05506:	d06f      	beq.n	c0d055e8 <starkware_plugin_call+0x448>
c0d05508:	e09c      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
                        strcpy(msg->msg, "DeversiFi");
c0d0550a:	4999      	ldr	r1, [pc, #612]	; (c0d05770 <starkware_plugin_call+0x5d0>)
c0d0550c:	4479      	add	r1, pc
c0d0550e:	220a      	movs	r2, #10
c0d05510:	4628      	mov	r0, r5
c0d05512:	f004 f86f 	bl	c0d095f4 <__aeabi_memcpy>
c0d05516:	e095      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
                    strcpy(msg->name, "Register");
c0d05518:	68e0      	ldr	r0, [r4, #12]
c0d0551a:	498e      	ldr	r1, [pc, #568]	; (c0d05754 <starkware_plugin_call+0x5b4>)
c0d0551c:	4479      	add	r1, pc
c0d0551e:	2209      	movs	r2, #9
c0d05520:	e008      	b.n	c0d05534 <starkware_plugin_call+0x394>
                    strcpy(msg->name, "Escape");
c0d05522:	68e0      	ldr	r0, [r4, #12]
c0d05524:	498e      	ldr	r1, [pc, #568]	; (c0d05760 <starkware_plugin_call+0x5c0>)
c0d05526:	4479      	add	r1, pc
c0d05528:	2207      	movs	r2, #7
c0d0552a:	e003      	b.n	c0d05534 <starkware_plugin_call+0x394>
                    strcpy(msg->name, "Full Withdrawal");
c0d0552c:	68e0      	ldr	r0, [r4, #12]
c0d0552e:	498b      	ldr	r1, [pc, #556]	; (c0d0575c <starkware_plugin_call+0x5bc>)
c0d05530:	4479      	add	r1, pc
c0d05532:	2210      	movs	r2, #16
c0d05534:	f004 f85e 	bl	c0d095f4 <__aeabi_memcpy>
            strcpy(msg->version,
c0d05538:	6965      	ldr	r5, [r4, #20]
        if (memcmp(address, DEVERSIFI_CONTRACT + offset + 1, 20) == 0) {
c0d0553a:	487c      	ldr	r0, [pc, #496]	; (c0d0572c <starkware_plugin_call+0x58c>)
c0d0553c:	3063      	adds	r0, #99	; 0x63
c0d0553e:	4982      	ldr	r1, [pc, #520]	; (c0d05748 <starkware_plugin_call+0x5a8>)
c0d05540:	4479      	add	r1, pc
c0d05542:	1c49      	adds	r1, r1, #1
c0d05544:	2214      	movs	r2, #20
c0d05546:	f004 f869 	bl	c0d0961c <memcmp>
                   is_deversify_contract(tmpContent.txContent.destination) ? "DeversiFi"
c0d0554a:	2800      	cmp	r0, #0
c0d0554c:	d002      	beq.n	c0d05554 <starkware_plugin_call+0x3b4>
c0d0554e:	4985      	ldr	r1, [pc, #532]	; (c0d05764 <starkware_plugin_call+0x5c4>)
c0d05550:	4479      	add	r1, pc
c0d05552:	e001      	b.n	c0d05558 <starkware_plugin_call+0x3b8>
c0d05554:	497d      	ldr	r1, [pc, #500]	; (c0d0574c <starkware_plugin_call+0x5ac>)
c0d05556:	4479      	add	r1, pc
c0d05558:	220a      	movs	r2, #10
            strcpy(msg->version,
c0d0555a:	4628      	mov	r0, r5
c0d0555c:	f004 f84a 	bl	c0d095f4 <__aeabi_memcpy>
c0d05560:	2001      	movs	r0, #1
            msg->result = ETH_PLUGIN_RESULT_OK;
c0d05562:	7720      	strb	r0, [r4, #28]
c0d05564:	e0d4      	b.n	c0d05710 <starkware_plugin_call+0x570>
c0d05566:	2621      	movs	r6, #33	; 0x21
c0d05568:	0172      	lsls	r2, r6, #5
c0d0556a:	4211      	tst	r1, r2
c0d0556c:	d052      	beq.n	c0d05614 <starkware_plugin_call+0x474>
                            strcpy(msg->title, "Token Symbol");
c0d0556e:	6920      	ldr	r0, [r4, #16]
c0d05570:	4988      	ldr	r1, [pc, #544]	; (c0d05794 <starkware_plugin_call+0x5f4>)
c0d05572:	4479      	add	r1, pc
c0d05574:	220d      	movs	r2, #13
c0d05576:	f004 f83d 	bl	c0d095f4 <__aeabi_memcpy>
                            starkware_print_ticker(msg->msg);
c0d0557a:	69a5      	ldr	r5, [r4, #24]
    char *ticker = (char *) PIC(chainConfig->coinName);
c0d0557c:	4867      	ldr	r0, [pc, #412]	; (c0d0571c <starkware_plugin_call+0x57c>)
c0d0557e:	6800      	ldr	r0, [r0, #0]
c0d05580:	f7ff fa28 	bl	c0d049d4 <pic>
c0d05584:	4601      	mov	r1, r0
c0d05586:	20e4      	movs	r0, #228	; 0xe4
    if (dataContext.tokenContext.quantumIndex != MAX_TOKEN) {
c0d05588:	4a63      	ldr	r2, [pc, #396]	; (c0d05718 <starkware_plugin_call+0x578>)
c0d0558a:	5c10      	ldrb	r0, [r2, r0]
c0d0558c:	2802      	cmp	r0, #2
c0d0558e:	d003      	beq.n	c0d05598 <starkware_plugin_call+0x3f8>
c0d05590:	4346      	muls	r6, r0
c0d05592:	4863      	ldr	r0, [pc, #396]	; (c0d05720 <starkware_plugin_call+0x580>)
c0d05594:	1981      	adds	r1, r0, r6
c0d05596:	3160      	adds	r1, #96	; 0x60
    strcpy(destination, ticker);
c0d05598:	4628      	mov	r0, r5
c0d0559a:	f004 f9e3 	bl	c0d09964 <strcpy>
c0d0559e:	e051      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
                    switch (context->selectorIndex) {
c0d055a0:	4601      	mov	r1, r0
c0d055a2:	390b      	subs	r1, #11
c0d055a4:	2902      	cmp	r1, #2
c0d055a6:	d329      	bcc.n	c0d055fc <starkware_plugin_call+0x45c>
c0d055a8:	4601      	mov	r1, r0
c0d055aa:	390e      	subs	r1, #14
c0d055ac:	2902      	cmp	r1, #2
c0d055ae:	d300      	bcc.n	c0d055b2 <starkware_plugin_call+0x412>
c0d055b0:	e08e      	b.n	c0d056d0 <starkware_plugin_call+0x530>
c0d055b2:	68e0      	ldr	r0, [r4, #12]
c0d055b4:	f7ff fcd8 	bl	c0d04f68 <starkware_verify_nft_token_id>
c0d055b8:	2145      	movs	r1, #69	; 0x45
c0d055ba:	5468      	strb	r0, [r5, r1]
c0d055bc:	e0a6      	b.n	c0d0570c <starkware_plugin_call+0x56c>
                    switch (context->selectorIndex) {
c0d055be:	2801      	cmp	r0, #1
c0d055c0:	d002      	beq.n	c0d055c8 <starkware_plugin_call+0x428>
c0d055c2:	2808      	cmp	r0, #8
c0d055c4:	d000      	beq.n	c0d055c8 <starkware_plugin_call+0x428>
c0d055c6:	e0a1      	b.n	c0d0570c <starkware_plugin_call+0x56c>
                            memmove(context->amount, msg->parameter, 32);
c0d055c8:	68e1      	ldr	r1, [r4, #12]
c0d055ca:	3525      	adds	r5, #37	; 0x25
c0d055cc:	2220      	movs	r2, #32
c0d055ce:	e09a      	b.n	c0d05706 <starkware_plugin_call+0x566>
                    switch (context->selectorIndex) {
c0d055d0:	1f81      	subs	r1, r0, #6
c0d055d2:	2902      	cmp	r1, #2
c0d055d4:	d320      	bcc.n	c0d05618 <starkware_plugin_call+0x478>
c0d055d6:	2805      	cmp	r0, #5
c0d055d8:	d054      	beq.n	c0d05684 <starkware_plugin_call+0x4e4>
c0d055da:	e033      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
c0d055dc:	280d      	cmp	r0, #13
c0d055de:	d07a      	beq.n	c0d056d6 <starkware_plugin_call+0x536>
c0d055e0:	280e      	cmp	r0, #14
c0d055e2:	d04f      	beq.n	c0d05684 <starkware_plugin_call+0x4e4>
c0d055e4:	280f      	cmp	r0, #15
c0d055e6:	d12d      	bne.n	c0d05644 <starkware_plugin_call+0x4a4>
                            strcpy(msg->title, "To ETH Address");
c0d055e8:	6920      	ldr	r0, [r4, #16]
c0d055ea:	4965      	ldr	r1, [pc, #404]	; (c0d05780 <starkware_plugin_call+0x5e0>)
c0d055ec:	4479      	add	r1, pc
c0d055ee:	220f      	movs	r2, #15
c0d055f0:	e058      	b.n	c0d056a4 <starkware_plugin_call+0x504>
c0d055f2:	0609      	lsls	r1, r1, #24
c0d055f4:	0f89      	lsrs	r1, r1, #30
c0d055f6:	d101      	bne.n	c0d055fc <starkware_plugin_call+0x45c>
c0d055f8:	2808      	cmp	r0, #8
c0d055fa:	d166      	bne.n	c0d056ca <starkware_plugin_call+0x52a>
c0d055fc:	68e0      	ldr	r0, [r4, #12]
c0d055fe:	7f01      	ldrb	r1, [r0, #28]
c0d05600:	7f42      	ldrb	r2, [r0, #29]
c0d05602:	7f83      	ldrb	r3, [r0, #30]
c0d05604:	7fc0      	ldrb	r0, [r0, #31]
c0d05606:	70e8      	strb	r0, [r5, #3]
c0d05608:	70ab      	strb	r3, [r5, #2]
c0d0560a:	706a      	strb	r2, [r5, #1]
c0d0560c:	7029      	strb	r1, [r5, #0]
c0d0560e:	e07d      	b.n	c0d0570c <starkware_plugin_call+0x56c>
c0d05610:	20001b40 	.word	0x20001b40
c0d05614:	2808      	cmp	r0, #8
c0d05616:	d123      	bne.n	c0d05660 <starkware_plugin_call+0x4c0>
c0d05618:	6920      	ldr	r0, [r4, #16]
c0d0561a:	495c      	ldr	r1, [pc, #368]	; (c0d0578c <starkware_plugin_call+0x5ec>)
c0d0561c:	4479      	add	r1, pc
c0d0561e:	220e      	movs	r2, #14
c0d05620:	f003 ffe8 	bl	c0d095f4 <__aeabi_memcpy>
c0d05624:	78e8      	ldrb	r0, [r5, #3]
c0d05626:	78a9      	ldrb	r1, [r5, #2]
c0d05628:	0209      	lsls	r1, r1, #8
c0d0562a:	1808      	adds	r0, r1, r0
c0d0562c:	7869      	ldrb	r1, [r5, #1]
c0d0562e:	782a      	ldrb	r2, [r5, #0]
c0d05630:	0212      	lsls	r2, r2, #8
c0d05632:	1851      	adds	r1, r2, r1
c0d05634:	0409      	lsls	r1, r1, #16
c0d05636:	1843      	adds	r3, r0, r1
c0d05638:	69a0      	ldr	r0, [r4, #24]
c0d0563a:	210a      	movs	r1, #10
c0d0563c:	4a54      	ldr	r2, [pc, #336]	; (c0d05790 <starkware_plugin_call+0x5f0>)
c0d0563e:	447a      	add	r2, pc
c0d05640:	f7fe fff4 	bl	c0d0462c <snprintf>
c0d05644:	2020      	movs	r0, #32
c0d05646:	2101      	movs	r1, #1
c0d05648:	5421      	strb	r1, [r4, r0]
c0d0564a:	e061      	b.n	c0d05710 <starkware_plugin_call+0x570>
c0d0564c:	0000fc26 	.word	0x0000fc26
c0d05650:	00005172 	.word	0x00005172
c0d05654:	00005160 	.word	0x00005160
c0d05658:	00004b70 	.word	0x00004b70
c0d0565c:	0000ddfe 	.word	0x0000ddfe
                    switch (context->selectorIndex) {
c0d05660:	1e40      	subs	r0, r0, #1
c0d05662:	2802      	cmp	r0, #2
c0d05664:	d2ee      	bcs.n	c0d05644 <starkware_plugin_call+0x4a4>
                            strcpy(msg->title, "Amount");
c0d05666:	6920      	ldr	r0, [r4, #16]
c0d05668:	4947      	ldr	r1, [pc, #284]	; (c0d05788 <starkware_plugin_call+0x5e8>)
c0d0566a:	4479      	add	r1, pc
c0d0566c:	2207      	movs	r2, #7
c0d0566e:	f003 ffc1 	bl	c0d095f4 <__aeabi_memcpy>
                                (context->selectorIndex == STARKWARE_DEPOSIT_ETH ? NULL
c0d05672:	7928      	ldrb	r0, [r5, #4]
c0d05674:	2200      	movs	r2, #0
c0d05676:	2802      	cmp	r0, #2
c0d05678:	4610      	mov	r0, r2
c0d0567a:	d001      	beq.n	c0d05680 <starkware_plugin_call+0x4e0>
c0d0567c:	3525      	adds	r5, #37	; 0x25
c0d0567e:	4628      	mov	r0, r5
                                msg->msg,
c0d05680:	69a1      	ldr	r1, [r4, #24]
c0d05682:	e037      	b.n	c0d056f4 <starkware_plugin_call+0x554>
                            strcpy(msg->title, "To ETH Address");
c0d05684:	6920      	ldr	r0, [r4, #16]
c0d05686:	493d      	ldr	r1, [pc, #244]	; (c0d0577c <starkware_plugin_call+0x5dc>)
c0d05688:	4479      	add	r1, pc
c0d0568a:	220f      	movs	r2, #15
c0d0568c:	f003 ffb2 	bl	c0d095f4 <__aeabi_memcpy>
                            starkware_get_source_address(msg->msg);
c0d05690:	69a0      	ldr	r0, [r4, #24]
c0d05692:	f7ff fd41 	bl	c0d05118 <starkware_get_source_address>
c0d05696:	e7d5      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
c0d05698:	2800      	cmp	r0, #0
c0d0569a:	d121      	bne.n	c0d056e0 <starkware_plugin_call+0x540>
                            strcpy(msg->title, "From ETH Address");
c0d0569c:	6920      	ldr	r0, [r4, #16]
c0d0569e:	4935      	ldr	r1, [pc, #212]	; (c0d05774 <starkware_plugin_call+0x5d4>)
c0d056a0:	4479      	add	r1, pc
c0d056a2:	2211      	movs	r2, #17
c0d056a4:	f003 ffa6 	bl	c0d095f4 <__aeabi_memcpy>
c0d056a8:	69a6      	ldr	r6, [r4, #24]
c0d056aa:	2078      	movs	r0, #120	; 0x78
c0d056ac:	7070      	strb	r0, [r6, #1]
c0d056ae:	2030      	movs	r0, #48	; 0x30
c0d056b0:	7030      	strb	r0, [r6, #0]
c0d056b2:	481a      	ldr	r0, [pc, #104]	; (c0d0571c <starkware_plugin_call+0x57c>)
c0d056b4:	6803      	ldr	r3, [r0, #0]
c0d056b6:	3525      	adds	r5, #37	; 0x25
c0d056b8:	1cb1      	adds	r1, r6, #2
c0d056ba:	4a1a      	ldr	r2, [pc, #104]	; (c0d05724 <starkware_plugin_call+0x584>)
c0d056bc:	4628      	mov	r0, r5
c0d056be:	f7fc fc59 	bl	c0d01f74 <getEthAddressStringFromBinary>
c0d056c2:	202a      	movs	r0, #42	; 0x2a
c0d056c4:	2100      	movs	r1, #0
c0d056c6:	5431      	strb	r1, [r6, r0]
c0d056c8:	e7bc      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
                    switch (context->selectorIndex) {
c0d056ca:	2800      	cmp	r0, #0
c0d056cc:	d11e      	bne.n	c0d0570c <starkware_plugin_call+0x56c>
c0d056ce:	e6fd      	b.n	c0d054cc <starkware_plugin_call+0x32c>
                    switch (context->selectorIndex) {
c0d056d0:	280a      	cmp	r0, #10
c0d056d2:	d014      	beq.n	c0d056fe <starkware_plugin_call+0x55e>
c0d056d4:	e01a      	b.n	c0d0570c <starkware_plugin_call+0x56c>
                            strcpy(msg->title, "Asset Contract");
c0d056d6:	6920      	ldr	r0, [r4, #16]
c0d056d8:	492a      	ldr	r1, [pc, #168]	; (c0d05784 <starkware_plugin_call+0x5e4>)
c0d056da:	4479      	add	r1, pc
c0d056dc:	220f      	movs	r2, #15
c0d056de:	e69e      	b.n	c0d0541e <starkware_plugin_call+0x27e>
                            strcpy(msg->title, "Amount");
c0d056e0:	6920      	ldr	r0, [r4, #16]
c0d056e2:	4925      	ldr	r1, [pc, #148]	; (c0d05778 <starkware_plugin_call+0x5d8>)
c0d056e4:	4479      	add	r1, pc
c0d056e6:	2207      	movs	r2, #7
c0d056e8:	f003 ff84 	bl	c0d095f4 <__aeabi_memcpy>
                            starkware_print_amount(context->amount, msg->msg, true);
c0d056ec:	69a1      	ldr	r1, [r4, #24]
c0d056ee:	3525      	adds	r5, #37	; 0x25
c0d056f0:	2201      	movs	r2, #1
c0d056f2:	4628      	mov	r0, r5
c0d056f4:	f7ff fc78 	bl	c0d04fe8 <starkware_print_amount>
c0d056f8:	e7a4      	b.n	c0d05644 <starkware_plugin_call+0x4a4>
c0d056fa:	2800      	cmp	r0, #0
c0d056fc:	d106      	bne.n	c0d0570c <starkware_plugin_call+0x56c>
c0d056fe:	68e1      	ldr	r1, [r4, #12]
c0d05700:	3525      	adds	r5, #37	; 0x25
c0d05702:	310c      	adds	r1, #12
c0d05704:	2214      	movs	r2, #20
c0d05706:	4628      	mov	r0, r5
c0d05708:	f003 ff78 	bl	c0d095fc <__aeabi_memmove>
c0d0570c:	2001      	movs	r0, #1
c0d0570e:	7520      	strb	r0, [r4, #20]
c0d05710:	b001      	add	sp, #4
c0d05712:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05714:	000050d0 	.word	0x000050d0
c0d05718:	20001b40 	.word	0x20001b40
c0d0571c:	20001b3c 	.word	0x20001b3c
c0d05720:	20001804 	.word	0x20001804
c0d05724:	20001cb8 	.word	0x20001cb8
c0d05728:	0000fefe 	.word	0x0000fefe
c0d0572c:	200018dc 	.word	0x200018dc
c0d05730:	0000fdfe 	.word	0x0000fdfe
c0d05734:	00005122 	.word	0x00005122
c0d05738:	0000486d 	.word	0x0000486d
c0d0573c:	0000505e 	.word	0x0000505e
c0d05740:	00004f34 	.word	0x00004f34
c0d05744:	00005108 	.word	0x00005108
c0d05748:	00004e83 	.word	0x00004e83
c0d0574c:	00004f22 	.word	0x00004f22
c0d05750:	00004fb4 	.word	0x00004fb4
c0d05754:	00004ef4 	.word	0x00004ef4
c0d05758:	00004f80 	.word	0x00004f80
c0d0575c:	00004f18 	.word	0x00004f18
c0d05760:	00004eb9 	.word	0x00004eb9
c0d05764:	00004e96 	.word	0x00004e96
c0d05768:	0000495e 	.word	0x0000495e
c0d0576c:	00004f87 	.word	0x00004f87
c0d05770:	00004f6c 	.word	0x00004f6c
c0d05774:	00004de4 	.word	0x00004de4
c0d05778:	000045a4 	.word	0x000045a4
c0d0577c:	00004e30 	.word	0x00004e30
c0d05780:	00004ecc 	.word	0x00004ecc
c0d05784:	00004dee 	.word	0x00004dee
c0d05788:	0000461e 	.word	0x0000461e
c0d0578c:	00004e8c 	.word	0x00004e8c
c0d05790:	00004bb0 	.word	0x00004bb0
c0d05794:	00004f66 	.word	0x00004f66
c0d05798:	00004982 	.word	0x00004982

c0d0579c <SVC_Call>:

// avoid a separate asm file, but avoid any intrusion from the compiler
__attribute__((naked)) void SVC_Call(unsigned int syscall_id, volatile unsigned int * parameters);
__attribute__((naked)) void SVC_Call(__attribute__((unused)) unsigned int syscall_id, __attribute__((unused)) volatile unsigned int * parameters) {
  // delegate svc, ensure no optimization by gcc with naked and r0, r1 marked as clobbered
  asm volatile("svc #1":::"r0","r1");
c0d0579c:	df01      	svc	1
  asm volatile("bx  lr");
c0d0579e:	4770      	bx	lr

c0d057a0 <check_api_level>:
}
void check_api_level ( unsigned int apiLevel ) 
{
c0d057a0:	b580      	push	{r7, lr}
c0d057a2:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
  parameters[0] = (unsigned int)apiLevel;
c0d057a4:	9001      	str	r0, [sp, #4]
c0d057a6:	4803      	ldr	r0, [pc, #12]	; (c0d057b4 <check_api_level+0x14>)
c0d057a8:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_check_api_level_ID_IN, parameters);
c0d057aa:	f7ff fff7 	bl	c0d0579c <SVC_Call>
}
c0d057ae:	b004      	add	sp, #16
c0d057b0:	bd80      	pop	{r7, pc}
c0d057b2:	46c0      	nop			; (mov r8, r8)
c0d057b4:	60000137 	.word	0x60000137

c0d057b8 <halt>:

void halt ( void ) 
{
c0d057b8:	b580      	push	{r7, lr}
c0d057ba:	b082      	sub	sp, #8
c0d057bc:	4802      	ldr	r0, [pc, #8]	; (c0d057c8 <halt+0x10>)
c0d057be:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
  SVC_Call(SYSCALL_halt_ID_IN, parameters);
c0d057c0:	f7ff ffec 	bl	c0d0579c <SVC_Call>
}
c0d057c4:	b002      	add	sp, #8
c0d057c6:	bd80      	pop	{r7, pc}
c0d057c8:	6000023c 	.word	0x6000023c

c0d057cc <nvm_write>:

void nvm_write ( void * dst_adr, void * src_adr, unsigned int src_len ) 
{
c0d057cc:	b580      	push	{r7, lr}
c0d057ce:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)dst_adr;
c0d057d0:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)src_adr;
c0d057d2:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)src_len;
c0d057d4:	9203      	str	r2, [sp, #12]
c0d057d6:	4803      	ldr	r0, [pc, #12]	; (c0d057e4 <nvm_write+0x18>)
c0d057d8:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_nvm_write_ID_IN, parameters);
c0d057da:	f7ff ffdf 	bl	c0d0579c <SVC_Call>
}
c0d057de:	b006      	add	sp, #24
c0d057e0:	bd80      	pop	{r7, pc}
c0d057e2:	46c0      	nop			; (mov r8, r8)
c0d057e4:	6000037f 	.word	0x6000037f

c0d057e8 <cx_rng>:
  SVC_Call(SYSCALL_cx_rng_u8_ID_IN, parameters);
  return (unsigned char)(((volatile unsigned int*)parameters)[1]);
}

unsigned char * cx_rng ( unsigned char * buffer, unsigned int len ) 
{
c0d057e8:	b580      	push	{r7, lr}
c0d057ea:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+2];
  parameters[0] = (unsigned int)buffer;
c0d057ec:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)len;
c0d057ee:	9101      	str	r1, [sp, #4]
c0d057f0:	4803      	ldr	r0, [pc, #12]	; (c0d05800 <cx_rng+0x18>)
c0d057f2:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_rng_ID_IN, parameters);
c0d057f4:	f7ff ffd2 	bl	c0d0579c <SVC_Call>
  return (unsigned char *)(((volatile unsigned int*)parameters)[1]);
c0d057f8:	9801      	ldr	r0, [sp, #4]
c0d057fa:	b004      	add	sp, #16
c0d057fc:	bd80      	pop	{r7, pc}
c0d057fe:	46c0      	nop			; (mov r8, r8)
c0d05800:	6000052c 	.word	0x6000052c

c0d05804 <cx_hash>:
}

int cx_hash ( cx_hash_t * hash, int mode, const unsigned char * in, unsigned int len, unsigned char * out, unsigned int out_len ) 
{
c0d05804:	b580      	push	{r7, lr}
c0d05806:	b088      	sub	sp, #32
  volatile unsigned int parameters [2+6];
  parameters[0] = (unsigned int)hash;
c0d05808:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)mode;
c0d0580a:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)in;
c0d0580c:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)len;
c0d0580e:	9303      	str	r3, [sp, #12]
c0d05810:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[4] = (unsigned int)out;
c0d05812:	9004      	str	r0, [sp, #16]
c0d05814:	980b      	ldr	r0, [sp, #44]	; 0x2c
  parameters[5] = (unsigned int)out_len;
c0d05816:	9005      	str	r0, [sp, #20]
c0d05818:	4803      	ldr	r0, [pc, #12]	; (c0d05828 <cx_hash+0x24>)
c0d0581a:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_hash_ID_IN, parameters);
c0d0581c:	f7ff ffbe 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d05820:	9801      	ldr	r0, [sp, #4]
c0d05822:	b008      	add	sp, #32
c0d05824:	bd80      	pop	{r7, pc}
c0d05826:	46c0      	nop			; (mov r8, r8)
c0d05828:	6000073b 	.word	0x6000073b

c0d0582c <cx_sha256_init>:
  SVC_Call(SYSCALL_cx_sha224_init_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

int cx_sha256_init ( cx_sha256_t * hash ) 
{
c0d0582c:	b580      	push	{r7, lr}
c0d0582e:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  parameters[0] = (unsigned int)hash;
c0d05830:	9001      	str	r0, [sp, #4]
c0d05832:	4803      	ldr	r0, [pc, #12]	; (c0d05840 <cx_sha256_init+0x14>)
c0d05834:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_sha256_init_ID_IN, parameters);
c0d05836:	f7ff ffb1 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d0583a:	9802      	ldr	r0, [sp, #8]
c0d0583c:	b004      	add	sp, #16
c0d0583e:	bd80      	pop	{r7, pc}
c0d05840:	60000adb 	.word	0x60000adb

c0d05844 <cx_hash_sha256>:
}

int cx_hash_sha256 ( const unsigned char * in, unsigned int len, unsigned char * out, unsigned int out_len ) 
{
c0d05844:	b580      	push	{r7, lr}
c0d05846:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)in;
c0d05848:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)len;
c0d0584a:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)out;
c0d0584c:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)out_len;
c0d0584e:	9303      	str	r3, [sp, #12]
c0d05850:	4803      	ldr	r0, [pc, #12]	; (c0d05860 <cx_hash_sha256+0x1c>)
c0d05852:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_hash_sha256_ID_IN, parameters);
c0d05854:	f7ff ffa2 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d05858:	9801      	ldr	r0, [sp, #4]
c0d0585a:	b006      	add	sp, #24
c0d0585c:	bd80      	pop	{r7, pc}
c0d0585e:	46c0      	nop			; (mov r8, r8)
c0d05860:	60000b2c 	.word	0x60000b2c

c0d05864 <cx_keccak_init>:
  SVC_Call(SYSCALL_cx_sha3_init_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

int cx_keccak_init ( cx_sha3_t * hash, unsigned int size ) 
{
c0d05864:	b580      	push	{r7, lr}
c0d05866:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+2];
  parameters[0] = (unsigned int)hash;
c0d05868:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)size;
c0d0586a:	9101      	str	r1, [sp, #4]
c0d0586c:	4803      	ldr	r0, [pc, #12]	; (c0d0587c <cx_keccak_init+0x18>)
c0d0586e:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_keccak_init_ID_IN, parameters);
c0d05870:	f7ff ff94 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d05874:	9801      	ldr	r0, [sp, #4]
c0d05876:	b004      	add	sp, #16
c0d05878:	bd80      	pop	{r7, pc}
c0d0587a:	46c0      	nop			; (mov r8, r8)
c0d0587c:	600010cf 	.word	0x600010cf

c0d05880 <cx_ecfp_add_point>:
  SVC_Call(SYSCALL_cx_ecfp_is_cryptographic_point_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

int cx_ecfp_add_point ( cx_curve_t curve, unsigned char * R, const unsigned char * P, const unsigned char * Q, unsigned int X_len ) 
{
c0d05880:	b580      	push	{r7, lr}
c0d05882:	b088      	sub	sp, #32
  volatile unsigned int parameters [2+5];
  parameters[0] = (unsigned int)curve;
c0d05884:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)R;
c0d05886:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)P;
c0d05888:	9203      	str	r2, [sp, #12]
  parameters[3] = (unsigned int)Q;
c0d0588a:	9304      	str	r3, [sp, #16]
c0d0588c:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[4] = (unsigned int)X_len;
c0d0588e:	9005      	str	r0, [sp, #20]
c0d05890:	4803      	ldr	r0, [pc, #12]	; (c0d058a0 <cx_ecfp_add_point+0x20>)
c0d05892:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_ecfp_add_point_ID_IN, parameters);
c0d05894:	f7ff ff82 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d05898:	9802      	ldr	r0, [sp, #8]
c0d0589a:	b008      	add	sp, #32
c0d0589c:	bd80      	pop	{r7, pc}
c0d0589e:	46c0      	nop			; (mov r8, r8)
c0d058a0:	60002b17 	.word	0x60002b17

c0d058a4 <cx_ecfp_scalar_mult>:
}

int cx_ecfp_scalar_mult ( cx_curve_t curve, unsigned char * P, unsigned int P_len, const unsigned char * k, unsigned int k_len ) 
{
c0d058a4:	b580      	push	{r7, lr}
c0d058a6:	b088      	sub	sp, #32
  volatile unsigned int parameters [2+5];
  parameters[0] = (unsigned int)curve;
c0d058a8:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)P;
c0d058aa:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)P_len;
c0d058ac:	9203      	str	r2, [sp, #12]
  parameters[3] = (unsigned int)k;
c0d058ae:	9304      	str	r3, [sp, #16]
c0d058b0:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[4] = (unsigned int)k_len;
c0d058b2:	9005      	str	r0, [sp, #20]
c0d058b4:	4803      	ldr	r0, [pc, #12]	; (c0d058c4 <cx_ecfp_scalar_mult+0x20>)
c0d058b6:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_ecfp_scalar_mult_ID_IN, parameters);
c0d058b8:	f7ff ff70 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d058bc:	9802      	ldr	r0, [sp, #8]
c0d058be:	b008      	add	sp, #32
c0d058c0:	bd80      	pop	{r7, pc}
c0d058c2:	46c0      	nop			; (mov r8, r8)
c0d058c4:	60002cf3 	.word	0x60002cf3

c0d058c8 <cx_ecfp_init_public_key>:
}

int cx_ecfp_init_public_key ( cx_curve_t curve, const unsigned char * rawkey, unsigned int key_len, cx_ecfp_public_key_t * key ) 
{
c0d058c8:	b580      	push	{r7, lr}
c0d058ca:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)curve;
c0d058cc:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)rawkey;
c0d058ce:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)key_len;
c0d058d0:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)key;
c0d058d2:	9303      	str	r3, [sp, #12]
c0d058d4:	4803      	ldr	r0, [pc, #12]	; (c0d058e4 <cx_ecfp_init_public_key+0x1c>)
c0d058d6:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_ecfp_init_public_key_ID_IN, parameters);
c0d058d8:	f7ff ff60 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d058dc:	9801      	ldr	r0, [sp, #4]
c0d058de:	b006      	add	sp, #24
c0d058e0:	bd80      	pop	{r7, pc}
c0d058e2:	46c0      	nop			; (mov r8, r8)
c0d058e4:	60002ded 	.word	0x60002ded

c0d058e8 <cx_ecfp_init_private_key>:
}

int cx_ecfp_init_private_key ( cx_curve_t curve, const unsigned char * rawkey, unsigned int key_len, cx_ecfp_private_key_t * pvkey ) 
{
c0d058e8:	b580      	push	{r7, lr}
c0d058ea:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)curve;
c0d058ec:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)rawkey;
c0d058ee:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)key_len;
c0d058f0:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)pvkey;
c0d058f2:	9303      	str	r3, [sp, #12]
c0d058f4:	4803      	ldr	r0, [pc, #12]	; (c0d05904 <cx_ecfp_init_private_key+0x1c>)
c0d058f6:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_ecfp_init_private_key_ID_IN, parameters);
c0d058f8:	f7ff ff50 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d058fc:	9801      	ldr	r0, [sp, #4]
c0d058fe:	b006      	add	sp, #24
c0d05900:	bd80      	pop	{r7, pc}
c0d05902:	46c0      	nop			; (mov r8, r8)
c0d05904:	60002eea 	.word	0x60002eea

c0d05908 <cx_ecfp_generate_pair>:
}

int cx_ecfp_generate_pair ( cx_curve_t curve, cx_ecfp_public_key_t * pubkey, cx_ecfp_private_key_t * privkey, int keepprivate ) 
{
c0d05908:	b580      	push	{r7, lr}
c0d0590a:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)curve;
c0d0590c:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)pubkey;
c0d0590e:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)privkey;
c0d05910:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)keepprivate;
c0d05912:	9303      	str	r3, [sp, #12]
c0d05914:	4803      	ldr	r0, [pc, #12]	; (c0d05924 <cx_ecfp_generate_pair+0x1c>)
c0d05916:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_ecfp_generate_pair_ID_IN, parameters);
c0d05918:	f7ff ff40 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d0591c:	9801      	ldr	r0, [sp, #4]
c0d0591e:	b006      	add	sp, #24
c0d05920:	bd80      	pop	{r7, pc}
c0d05922:	46c0      	nop			; (mov r8, r8)
c0d05924:	60002f2e 	.word	0x60002f2e

c0d05928 <cx_ecdsa_sign>:
  SVC_Call(SYSCALL_cx_ecfp_generate_pair2_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

int cx_ecdsa_sign ( const cx_ecfp_private_key_t * pvkey, int mode, cx_md_t hashID, const unsigned char * hash, unsigned int hash_len, unsigned char * sig, unsigned int sig_len, unsigned int * info ) 
{
c0d05928:	b580      	push	{r7, lr}
c0d0592a:	b08a      	sub	sp, #40	; 0x28
  volatile unsigned int parameters [2+8];
  parameters[0] = (unsigned int)pvkey;
c0d0592c:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)mode;
c0d0592e:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)hashID;
c0d05930:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)hash;
c0d05932:	9303      	str	r3, [sp, #12]
c0d05934:	980c      	ldr	r0, [sp, #48]	; 0x30
  parameters[4] = (unsigned int)hash_len;
c0d05936:	9004      	str	r0, [sp, #16]
c0d05938:	980d      	ldr	r0, [sp, #52]	; 0x34
  parameters[5] = (unsigned int)sig;
c0d0593a:	9005      	str	r0, [sp, #20]
c0d0593c:	980e      	ldr	r0, [sp, #56]	; 0x38
  parameters[6] = (unsigned int)sig_len;
c0d0593e:	9006      	str	r0, [sp, #24]
c0d05940:	980f      	ldr	r0, [sp, #60]	; 0x3c
  parameters[7] = (unsigned int)info;
c0d05942:	9007      	str	r0, [sp, #28]
c0d05944:	4803      	ldr	r0, [pc, #12]	; (c0d05954 <cx_ecdsa_sign+0x2c>)
c0d05946:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_ecdsa_sign_ID_IN, parameters);
c0d05948:	f7ff ff28 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d0594c:	9801      	ldr	r0, [sp, #4]
c0d0594e:	b00a      	add	sp, #40	; 0x28
c0d05950:	bd80      	pop	{r7, pc}
c0d05952:	46c0      	nop			; (mov r8, r8)
c0d05954:	600038f3 	.word	0x600038f3

c0d05958 <cx_ecdsa_verify>:
}

int cx_ecdsa_verify ( const cx_ecfp_public_key_t * pukey, int mode, cx_md_t hashID, const unsigned char * hash, unsigned int hash_len, const unsigned char * sig, unsigned int sig_len ) 
{
c0d05958:	b580      	push	{r7, lr}
c0d0595a:	b08a      	sub	sp, #40	; 0x28
  volatile unsigned int parameters [2+7];
  parameters[0] = (unsigned int)pukey;
c0d0595c:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)mode;
c0d0595e:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)hashID;
c0d05960:	9203      	str	r2, [sp, #12]
  parameters[3] = (unsigned int)hash;
c0d05962:	9304      	str	r3, [sp, #16]
c0d05964:	980c      	ldr	r0, [sp, #48]	; 0x30
  parameters[4] = (unsigned int)hash_len;
c0d05966:	9005      	str	r0, [sp, #20]
c0d05968:	980d      	ldr	r0, [sp, #52]	; 0x34
  parameters[5] = (unsigned int)sig;
c0d0596a:	9006      	str	r0, [sp, #24]
c0d0596c:	980e      	ldr	r0, [sp, #56]	; 0x38
  parameters[6] = (unsigned int)sig_len;
c0d0596e:	9007      	str	r0, [sp, #28]
c0d05970:	4803      	ldr	r0, [pc, #12]	; (c0d05980 <cx_ecdsa_verify+0x28>)
c0d05972:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_ecdsa_verify_ID_IN, parameters);
c0d05974:	f7ff ff12 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d05978:	9802      	ldr	r0, [sp, #8]
c0d0597a:	b00a      	add	sp, #40	; 0x28
c0d0597c:	bd80      	pop	{r7, pc}
c0d0597e:	46c0      	nop			; (mov r8, r8)
c0d05980:	600039f1 	.word	0x600039f1

c0d05984 <cx_crc16_update>:
  SVC_Call(SYSCALL_cx_crc16_ID_IN, parameters);
  return (unsigned short)(((volatile unsigned int*)parameters)[1]);
}

unsigned short cx_crc16_update ( unsigned short crc, const void * buffer, size_t len ) 
{
c0d05984:	b580      	push	{r7, lr}
c0d05986:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)crc;
c0d05988:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)buffer;
c0d0598a:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)len;
c0d0598c:	9203      	str	r2, [sp, #12]
c0d0598e:	4804      	ldr	r0, [pc, #16]	; (c0d059a0 <cx_crc16_update+0x1c>)
c0d05990:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_crc16_update_ID_IN, parameters);
c0d05992:	f7ff ff03 	bl	c0d0579c <SVC_Call>
  return (unsigned short)(((volatile unsigned int*)parameters)[1]);
c0d05996:	9802      	ldr	r0, [sp, #8]
c0d05998:	b280      	uxth	r0, r0
c0d0599a:	b006      	add	sp, #24
c0d0599c:	bd80      	pop	{r7, pc}
c0d0599e:	46c0      	nop			; (mov r8, r8)
c0d059a0:	6000926e 	.word	0x6000926e

c0d059a4 <cx_math_cmp>:
}

int cx_math_cmp ( const unsigned char * a, const unsigned char * b, unsigned int len ) 
{
c0d059a4:	b580      	push	{r7, lr}
c0d059a6:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)a;
c0d059a8:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)b;
c0d059aa:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)len;
c0d059ac:	9203      	str	r2, [sp, #12]
c0d059ae:	4803      	ldr	r0, [pc, #12]	; (c0d059bc <cx_math_cmp+0x18>)
c0d059b0:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_cx_math_cmp_ID_IN, parameters);
c0d059b2:	f7ff fef3 	bl	c0d0579c <SVC_Call>
  return (int)(((volatile unsigned int*)parameters)[1]);
c0d059b6:	9802      	ldr	r0, [sp, #8]
c0d059b8:	b006      	add	sp, #24
c0d059ba:	bd80      	pop	{r7, pc}
c0d059bc:	60003d5b 	.word	0x60003d5b

c0d059c0 <cx_math_mult>:
  SVC_Call(SYSCALL_cx_math_sub_ID_IN, parameters);
  return (int)(((volatile unsigned int*)parameters)[1]);
}

void cx_math_mult ( unsigned char * r, const unsigned char * a, const unsigned char * b, unsigned int len ) 
{
c0d059c0:	b580      	push	{r7, lr}
c0d059c2:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)r;
c0d059c4:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)a;
c0d059c6:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)b;
c0d059c8:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)len;
c0d059ca:	9303      	str	r3, [sp, #12]
c0d059cc:	4802      	ldr	r0, [pc, #8]	; (c0d059d8 <cx_math_mult+0x18>)
c0d059ce:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_math_mult_ID_IN, parameters);
c0d059d0:	f7ff fee4 	bl	c0d0579c <SVC_Call>
}
c0d059d4:	b006      	add	sp, #24
c0d059d6:	bd80      	pop	{r7, pc}
c0d059d8:	6000413e 	.word	0x6000413e

c0d059dc <cx_math_modm>:
  parameters[5] = (unsigned int)len;
  SVC_Call(SYSCALL_cx_math_powm_ID_IN, parameters);
}

void cx_math_modm ( unsigned char * v, unsigned int len_v, const unsigned char * m, unsigned int len_m ) 
{
c0d059dc:	b580      	push	{r7, lr}
c0d059de:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+4];
  parameters[0] = (unsigned int)v;
c0d059e0:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)len_v;
c0d059e2:	9101      	str	r1, [sp, #4]
  parameters[2] = (unsigned int)m;
c0d059e4:	9202      	str	r2, [sp, #8]
  parameters[3] = (unsigned int)len_m;
c0d059e6:	9303      	str	r3, [sp, #12]
c0d059e8:	4802      	ldr	r0, [pc, #8]	; (c0d059f4 <cx_math_modm+0x18>)
c0d059ea:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_cx_math_modm_ID_IN, parameters);
c0d059ec:	f7ff fed6 	bl	c0d0579c <SVC_Call>
}
c0d059f0:	b006      	add	sp, #24
c0d059f2:	bd80      	pop	{r7, pc}
c0d059f4:	60004645 	.word	0x60004645

c0d059f8 <os_perso_isonboarded>:
  volatile unsigned int parameters [2];
  SVC_Call(SYSCALL_os_perso_finalize_ID_IN, parameters);
}

bolos_bool_t os_perso_isonboarded ( void ) 
{
c0d059f8:	b580      	push	{r7, lr}
c0d059fa:	b082      	sub	sp, #8
c0d059fc:	4803      	ldr	r0, [pc, #12]	; (c0d05a0c <os_perso_isonboarded+0x14>)
c0d059fe:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_os_perso_isonboarded_ID_IN, parameters);
c0d05a00:	f7ff fecc 	bl	c0d0579c <SVC_Call>
  return (bolos_bool_t)(((volatile unsigned int*)parameters)[1]);
c0d05a04:	9801      	ldr	r0, [sp, #4]
c0d05a06:	b2c0      	uxtb	r0, r0
c0d05a08:	b002      	add	sp, #8
c0d05a0a:	bd80      	pop	{r7, pc}
c0d05a0c:	60009f4f 	.word	0x60009f4f

c0d05a10 <os_perso_derive_node_bip32>:
}

void os_perso_derive_node_bip32 ( cx_curve_t curve, const unsigned int * path, unsigned int pathLength, unsigned char * privateKey, unsigned char * chain ) 
{
c0d05a10:	b580      	push	{r7, lr}
c0d05a12:	b088      	sub	sp, #32
  volatile unsigned int parameters [2+5];
  parameters[0] = (unsigned int)curve;
c0d05a14:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)path;
c0d05a16:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)pathLength;
c0d05a18:	9203      	str	r2, [sp, #12]
  parameters[3] = (unsigned int)privateKey;
c0d05a1a:	9304      	str	r3, [sp, #16]
c0d05a1c:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[4] = (unsigned int)chain;
c0d05a1e:	9005      	str	r0, [sp, #20]
c0d05a20:	4802      	ldr	r0, [pc, #8]	; (c0d05a2c <os_perso_derive_node_bip32+0x1c>)
c0d05a22:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_perso_derive_node_bip32_ID_IN, parameters);
c0d05a24:	f7ff feba 	bl	c0d0579c <SVC_Call>
}
c0d05a28:	b008      	add	sp, #32
c0d05a2a:	bd80      	pop	{r7, pc}
c0d05a2c:	600053ba 	.word	0x600053ba

c0d05a30 <os_perso_seed_cookie>:
  parameters[7] = (unsigned int)seed_key_length;
  SVC_Call(SYSCALL_os_perso_derive_node_with_seed_key_ID_IN, parameters);
}

unsigned int os_perso_seed_cookie ( unsigned char * seed_cookie, unsigned int seed_cookie_length ) 
{
c0d05a30:	b580      	push	{r7, lr}
c0d05a32:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+2];
  parameters[0] = (unsigned int)seed_cookie;
c0d05a34:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)seed_cookie_length;
c0d05a36:	9101      	str	r1, [sp, #4]
c0d05a38:	4803      	ldr	r0, [pc, #12]	; (c0d05a48 <os_perso_seed_cookie+0x18>)
c0d05a3a:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_os_perso_seed_cookie_ID_IN, parameters);
c0d05a3c:	f7ff feae 	bl	c0d0579c <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d05a40:	9801      	ldr	r0, [sp, #4]
c0d05a42:	b004      	add	sp, #16
c0d05a44:	bd80      	pop	{r7, pc}
c0d05a46:	46c0      	nop			; (mov r8, r8)
c0d05a48:	6000a8fc 	.word	0x6000a8fc

c0d05a4c <os_global_pin_is_validated>:
  SVC_Call(SYSCALL_os_endorsement_key2_derive_sign_data_ID_IN, parameters);
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
}

bolos_bool_t os_global_pin_is_validated ( void ) 
{
c0d05a4c:	b580      	push	{r7, lr}
c0d05a4e:	b082      	sub	sp, #8
c0d05a50:	4803      	ldr	r0, [pc, #12]	; (c0d05a60 <os_global_pin_is_validated+0x14>)
c0d05a52:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_os_global_pin_is_validated_ID_IN, parameters);
c0d05a54:	f7ff fea2 	bl	c0d0579c <SVC_Call>
  return (bolos_bool_t)(((volatile unsigned int*)parameters)[1]);
c0d05a58:	9801      	ldr	r0, [sp, #4]
c0d05a5a:	b2c0      	uxtb	r0, r0
c0d05a5c:	b002      	add	sp, #8
c0d05a5e:	bd80      	pop	{r7, pc}
c0d05a60:	6000a03c 	.word	0x6000a03c

c0d05a64 <os_ux>:
  parameters[1] = (unsigned int)out_application_entry;
  SVC_Call(SYSCALL_os_registry_get_ID_IN, parameters);
}

unsigned int os_ux ( bolos_ux_params_t * params ) 
{
c0d05a64:	b580      	push	{r7, lr}
c0d05a66:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  parameters[0] = (unsigned int)params;
c0d05a68:	9001      	str	r0, [sp, #4]
c0d05a6a:	4803      	ldr	r0, [pc, #12]	; (c0d05a78 <os_ux+0x14>)
c0d05a6c:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_ux_ID_IN, parameters);
c0d05a6e:	f7ff fe95 	bl	c0d0579c <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d05a72:	9802      	ldr	r0, [sp, #8]
c0d05a74:	b004      	add	sp, #16
c0d05a76:	bd80      	pop	{r7, pc}
c0d05a78:	60006458 	.word	0x60006458

c0d05a7c <os_lib_call>:
  parameters[0] = (unsigned int)params;
  SVC_Call(SYSCALL_os_ux_read_parameters_ID_IN, parameters);
}

void os_lib_call ( unsigned int * call_parameters ) 
{
c0d05a7c:	b580      	push	{r7, lr}
c0d05a7e:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
  parameters[0] = (unsigned int)call_parameters;
c0d05a80:	9001      	str	r0, [sp, #4]
c0d05a82:	4803      	ldr	r0, [pc, #12]	; (c0d05a90 <os_lib_call+0x14>)
c0d05a84:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_lib_call_ID_IN, parameters);
c0d05a86:	f7ff fe89 	bl	c0d0579c <SVC_Call>
}
c0d05a8a:	b004      	add	sp, #16
c0d05a8c:	bd80      	pop	{r7, pc}
c0d05a8e:	46c0      	nop			; (mov r8, r8)
c0d05a90:	6000670d 	.word	0x6000670d

c0d05a94 <os_lib_end>:

void os_lib_end ( void ) 
{
c0d05a94:	b580      	push	{r7, lr}
c0d05a96:	b082      	sub	sp, #8
c0d05a98:	4802      	ldr	r0, [pc, #8]	; (c0d05aa4 <os_lib_end+0x10>)
c0d05a9a:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
  SVC_Call(SYSCALL_os_lib_end_ID_IN, parameters);
c0d05a9c:	f7ff fe7e 	bl	c0d0579c <SVC_Call>
}
c0d05aa0:	b002      	add	sp, #8
c0d05aa2:	bd80      	pop	{r7, pc}
c0d05aa4:	6000688d 	.word	0x6000688d

c0d05aa8 <os_flags>:
  parameters[0] = (unsigned int)exception;
  SVC_Call(SYSCALL_os_lib_throw_ID_IN, parameters);
}

unsigned int os_flags ( void ) 
{
c0d05aa8:	b580      	push	{r7, lr}
c0d05aaa:	b082      	sub	sp, #8
c0d05aac:	4803      	ldr	r0, [pc, #12]	; (c0d05abc <os_flags+0x14>)
c0d05aae:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_os_flags_ID_IN, parameters);
c0d05ab0:	f7ff fe74 	bl	c0d0579c <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d05ab4:	9801      	ldr	r0, [sp, #4]
c0d05ab6:	b002      	add	sp, #8
c0d05ab8:	bd80      	pop	{r7, pc}
c0d05aba:	46c0      	nop			; (mov r8, r8)
c0d05abc:	60006a6e 	.word	0x60006a6e

c0d05ac0 <os_registry_get_current_app_tag>:
  SVC_Call(SYSCALL_os_registry_get_tag_ID_IN, parameters);
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
}

unsigned int os_registry_get_current_app_tag ( unsigned int tag, unsigned char * buffer, unsigned int maxlen ) 
{
c0d05ac0:	b580      	push	{r7, lr}
c0d05ac2:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)tag;
c0d05ac4:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)buffer;
c0d05ac6:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)maxlen;
c0d05ac8:	9203      	str	r2, [sp, #12]
c0d05aca:	4803      	ldr	r0, [pc, #12]	; (c0d05ad8 <os_registry_get_current_app_tag+0x18>)
c0d05acc:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_registry_get_current_app_tag_ID_IN, parameters);
c0d05ace:	f7ff fe65 	bl	c0d0579c <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d05ad2:	9802      	ldr	r0, [sp, #8]
c0d05ad4:	b006      	add	sp, #24
c0d05ad6:	bd80      	pop	{r7, pc}
c0d05ad8:	600074d4 	.word	0x600074d4

c0d05adc <os_sched_exit>:
  parameters[0] = (unsigned int)application_index;
  SVC_Call(SYSCALL_os_sched_exec_ID_IN, parameters);
}

void os_sched_exit ( bolos_task_status_t exit_code ) 
{
c0d05adc:	b580      	push	{r7, lr}
c0d05ade:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
  parameters[0] = (unsigned int)exit_code;
c0d05ae0:	9001      	str	r0, [sp, #4]
c0d05ae2:	4803      	ldr	r0, [pc, #12]	; (c0d05af0 <os_sched_exit+0x14>)
c0d05ae4:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_sched_exit_ID_IN, parameters);
c0d05ae6:	f7ff fe59 	bl	c0d0579c <SVC_Call>
}
c0d05aea:	b004      	add	sp, #16
c0d05aec:	bd80      	pop	{r7, pc}
c0d05aee:	46c0      	nop			; (mov r8, r8)
c0d05af0:	60009abe 	.word	0x60009abe

c0d05af4 <io_seph_send>:
  parameters[0] = (unsigned int)taskidx;
  SVC_Call(SYSCALL_os_sched_kill_ID_IN, parameters);
}

void io_seph_send ( const unsigned char * buffer, unsigned short length ) 
{
c0d05af4:	b580      	push	{r7, lr}
c0d05af6:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+2];
  parameters[0] = (unsigned int)buffer;
c0d05af8:	9000      	str	r0, [sp, #0]
  parameters[1] = (unsigned int)length;
c0d05afa:	9101      	str	r1, [sp, #4]
c0d05afc:	4802      	ldr	r0, [pc, #8]	; (c0d05b08 <io_seph_send+0x14>)
c0d05afe:	4669      	mov	r1, sp
  SVC_Call(SYSCALL_io_seph_send_ID_IN, parameters);
c0d05b00:	f7ff fe4c 	bl	c0d0579c <SVC_Call>
}
c0d05b04:	b004      	add	sp, #16
c0d05b06:	bd80      	pop	{r7, pc}
c0d05b08:	60008381 	.word	0x60008381

c0d05b0c <io_seph_is_status_sent>:

unsigned int io_seph_is_status_sent ( void ) 
{
c0d05b0c:	b580      	push	{r7, lr}
c0d05b0e:	b082      	sub	sp, #8
c0d05b10:	4803      	ldr	r0, [pc, #12]	; (c0d05b20 <io_seph_is_status_sent+0x14>)
c0d05b12:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_io_seph_is_status_sent_ID_IN, parameters);
c0d05b14:	f7ff fe42 	bl	c0d0579c <SVC_Call>
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
c0d05b18:	9801      	ldr	r0, [sp, #4]
c0d05b1a:	b002      	add	sp, #8
c0d05b1c:	bd80      	pop	{r7, pc}
c0d05b1e:	46c0      	nop			; (mov r8, r8)
c0d05b20:	600084bb 	.word	0x600084bb

c0d05b24 <io_seph_recv>:
}

unsigned short io_seph_recv ( unsigned char * buffer, unsigned short maxlength, unsigned int flags ) 
{
c0d05b24:	b580      	push	{r7, lr}
c0d05b26:	b086      	sub	sp, #24
  volatile unsigned int parameters [2+3];
  parameters[0] = (unsigned int)buffer;
c0d05b28:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)maxlength;
c0d05b2a:	9102      	str	r1, [sp, #8]
  parameters[2] = (unsigned int)flags;
c0d05b2c:	9203      	str	r2, [sp, #12]
c0d05b2e:	4804      	ldr	r0, [pc, #16]	; (c0d05b40 <io_seph_recv+0x1c>)
c0d05b30:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_io_seph_recv_ID_IN, parameters);
c0d05b32:	f7ff fe33 	bl	c0d0579c <SVC_Call>
  return (unsigned short)(((volatile unsigned int*)parameters)[1]);
c0d05b36:	9802      	ldr	r0, [sp, #8]
c0d05b38:	b280      	uxth	r0, r0
c0d05b3a:	b006      	add	sp, #24
c0d05b3c:	bd80      	pop	{r7, pc}
c0d05b3e:	46c0      	nop			; (mov r8, r8)
c0d05b40:	600085e4 	.word	0x600085e4

c0d05b44 <try_context_get>:
  parameters[0] = (unsigned int)page_adr;
  SVC_Call(SYSCALL_nvm_write_page_ID_IN, parameters);
}

try_context_t * try_context_get ( void ) 
{
c0d05b44:	b580      	push	{r7, lr}
c0d05b46:	b082      	sub	sp, #8
c0d05b48:	4803      	ldr	r0, [pc, #12]	; (c0d05b58 <try_context_get+0x14>)
c0d05b4a:	4669      	mov	r1, sp
  volatile unsigned int parameters [2];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  SVC_Call(SYSCALL_try_context_get_ID_IN, parameters);
c0d05b4c:	f7ff fe26 	bl	c0d0579c <SVC_Call>
  return (try_context_t *)(((volatile unsigned int*)parameters)[1]);
c0d05b50:	9801      	ldr	r0, [sp, #4]
c0d05b52:	b002      	add	sp, #8
c0d05b54:	bd80      	pop	{r7, pc}
c0d05b56:	46c0      	nop			; (mov r8, r8)
c0d05b58:	600087b1 	.word	0x600087b1

c0d05b5c <try_context_set>:
}

try_context_t * try_context_set ( try_context_t * context ) 
{
c0d05b5c:	b580      	push	{r7, lr}
c0d05b5e:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  parameters[0] = (unsigned int)context;
c0d05b60:	9001      	str	r0, [sp, #4]
c0d05b62:	4803      	ldr	r0, [pc, #12]	; (c0d05b70 <try_context_set+0x14>)
c0d05b64:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_try_context_set_ID_IN, parameters);
c0d05b66:	f7ff fe19 	bl	c0d0579c <SVC_Call>
  return (try_context_t *)(((volatile unsigned int*)parameters)[1]);
c0d05b6a:	9802      	ldr	r0, [sp, #8]
c0d05b6c:	b004      	add	sp, #16
c0d05b6e:	bd80      	pop	{r7, pc}
c0d05b70:	60008875 	.word	0x60008875

c0d05b74 <os_sched_last_status>:
  SVC_Call(SYSCALL_cx_rng_u32_ID_IN, parameters);
  return (unsigned int)(((volatile unsigned int*)parameters)[1]);
}

bolos_task_status_t os_sched_last_status ( unsigned int task_idx ) 
{
c0d05b74:	b580      	push	{r7, lr}
c0d05b76:	b084      	sub	sp, #16
  volatile unsigned int parameters [2+1];
#ifdef __clang_analyzer__
  parameters[1] = 0;
#endif
  parameters[0] = (unsigned int)task_idx;
c0d05b78:	9001      	str	r0, [sp, #4]
c0d05b7a:	4804      	ldr	r0, [pc, #16]	; (c0d05b8c <os_sched_last_status+0x18>)
c0d05b7c:	a901      	add	r1, sp, #4
  SVC_Call(SYSCALL_os_sched_last_status_ID_IN, parameters);
c0d05b7e:	f7ff fe0d 	bl	c0d0579c <SVC_Call>
  return (bolos_task_status_t)(((volatile unsigned int*)parameters)[1]);
c0d05b82:	9802      	ldr	r0, [sp, #8]
c0d05b84:	b2c0      	uxtb	r0, r0
c0d05b86:	b004      	add	sp, #16
c0d05b88:	bd80      	pop	{r7, pc}
c0d05b8a:	46c0      	nop			; (mov r8, r8)
c0d05b8c:	60009c8b 	.word	0x60009c8b

c0d05b90 <u2f_apdu_sign>:

    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)SW_INTERNAL, sizeof(SW_INTERNAL));
}

void u2f_apdu_sign(u2f_service_t *service, uint8_t p1, uint8_t p2,
                     uint8_t *buffer, uint16_t length) {
c0d05b90:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05b92:	b083      	sub	sp, #12
    UNUSED(p2);
    uint8_t keyHandleLength;
    uint8_t i;

    // can't process the apdu if another one is already scheduled in
    if (G_io_app.apdu_state != APDU_IDLE) {
c0d05b94:	4a36      	ldr	r2, [pc, #216]	; (c0d05c70 <u2f_apdu_sign+0xe0>)
c0d05b96:	7812      	ldrb	r2, [r2, #0]
c0d05b98:	2a00      	cmp	r2, #0
c0d05b9a:	d003      	beq.n	c0d05ba4 <u2f_apdu_sign+0x14>
c0d05b9c:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d05b9e:	4a36      	ldr	r2, [pc, #216]	; (c0d05c78 <u2f_apdu_sign+0xe8>)
c0d05ba0:	447a      	add	r2, pc
c0d05ba2:	e00b      	b.n	c0d05bbc <u2f_apdu_sign+0x2c>
c0d05ba4:	9a08      	ldr	r2, [sp, #32]
                  (uint8_t *)SW_BUSY,
                  sizeof(SW_BUSY));
        return;        
    }

    if (length < U2F_HANDLE_SIGN_HEADER_SIZE + 5 /*at least an apdu header*/) {
c0d05ba6:	2a45      	cmp	r2, #69	; 0x45
c0d05ba8:	d803      	bhi.n	c0d05bb2 <u2f_apdu_sign+0x22>
c0d05baa:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d05bac:	4a33      	ldr	r2, [pc, #204]	; (c0d05c7c <u2f_apdu_sign+0xec>)
c0d05bae:	447a      	add	r2, pc
c0d05bb0:	e004      	b.n	c0d05bbc <u2f_apdu_sign+0x2c>
                  sizeof(SW_WRONG_LENGTH));
        return;
    }

    // Confirm immediately if it's just a validation call
    if (p1 == P1_SIGN_CHECK_ONLY) {
c0d05bb2:	2907      	cmp	r1, #7
c0d05bb4:	d107      	bne.n	c0d05bc6 <u2f_apdu_sign+0x36>
c0d05bb6:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d05bb8:	4a31      	ldr	r2, [pc, #196]	; (c0d05c80 <u2f_apdu_sign+0xf0>)
c0d05bba:	447a      	add	r2, pc
c0d05bbc:	2302      	movs	r3, #2
c0d05bbe:	f000 fc51 	bl	c0d06464 <u2f_message_reply>
    app_dispatch();
    if ((btchip_context_D.io_flags & IO_ASYNCH_REPLY) == 0) {
        u2f_proxy_response(service, btchip_context_D.outLength);
    }
    */
}
c0d05bc2:	b003      	add	sp, #12
c0d05bc4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05bc6:	9200      	str	r2, [sp, #0]
c0d05bc8:	9001      	str	r0, [sp, #4]
c0d05bca:	2040      	movs	r0, #64	; 0x40
c0d05bcc:	9302      	str	r3, [sp, #8]
    keyHandleLength = buffer[U2F_HANDLE_SIGN_HEADER_SIZE-1];
c0d05bce:	5c1e      	ldrb	r6, [r3, r0]
    if (keyHandleLength == 5) {
c0d05bd0:	2e00      	cmp	r6, #0
c0d05bd2:	d01b      	beq.n	c0d05c0c <u2f_apdu_sign+0x7c>
c0d05bd4:	2e05      	cmp	r6, #5
c0d05bd6:	9d02      	ldr	r5, [sp, #8]
c0d05bd8:	d109      	bne.n	c0d05bee <u2f_apdu_sign+0x5e>
        if (os_memcmp(buffer+U2F_HANDLE_SIGN_HEADER_SIZE, "\xF1\xD0\x00\x00\x00", 5) == 0 ) {
c0d05bda:	4628      	mov	r0, r5
c0d05bdc:	3041      	adds	r0, #65	; 0x41
c0d05bde:	4929      	ldr	r1, [pc, #164]	; (c0d05c84 <u2f_apdu_sign+0xf4>)
c0d05be0:	4479      	add	r1, pc
c0d05be2:	2405      	movs	r4, #5
c0d05be4:	4622      	mov	r2, r4
c0d05be6:	f7fd fef7 	bl	c0d039d8 <os_memcmp>
c0d05bea:	2800      	cmp	r0, #0
c0d05bec:	d02b      	beq.n	c0d05c46 <u2f_apdu_sign+0xb6>
        buffer[U2F_HANDLE_SIGN_HEADER_SIZE + i] ^= U2F_PROXY_MAGIC[i % (sizeof(U2F_PROXY_MAGIC)-1)];
c0d05bee:	3541      	adds	r5, #65	; 0x41
c0d05bf0:	2400      	movs	r4, #0
c0d05bf2:	4f25      	ldr	r7, [pc, #148]	; (c0d05c88 <u2f_apdu_sign+0xf8>)
c0d05bf4:	447f      	add	r7, pc
c0d05bf6:	b2e0      	uxtb	r0, r4
c0d05bf8:	2105      	movs	r1, #5
c0d05bfa:	f003 fcd7 	bl	c0d095ac <__aeabi_uidivmod>
c0d05bfe:	5d28      	ldrb	r0, [r5, r4]
c0d05c00:	5c79      	ldrb	r1, [r7, r1]
c0d05c02:	4041      	eors	r1, r0
c0d05c04:	5529      	strb	r1, [r5, r4]
    for (i = 0; i < keyHandleLength; i++) {
c0d05c06:	1c64      	adds	r4, r4, #1
c0d05c08:	42a6      	cmp	r6, r4
c0d05c0a:	d1f4      	bne.n	c0d05bf6 <u2f_apdu_sign+0x66>
c0d05c0c:	2045      	movs	r0, #69	; 0x45
c0d05c0e:	9902      	ldr	r1, [sp, #8]
    if (length != U2F_HANDLE_SIGN_HEADER_SIZE + 5 + buffer[U2F_HANDLE_SIGN_HEADER_SIZE + 4]) {
c0d05c10:	5c08      	ldrb	r0, [r1, r0]
c0d05c12:	3046      	adds	r0, #70	; 0x46
c0d05c14:	9a00      	ldr	r2, [sp, #0]
c0d05c16:	4290      	cmp	r0, r2
c0d05c18:	d10f      	bne.n	c0d05c3a <u2f_apdu_sign+0xaa>
    os_memmove(G_io_apdu_buffer, buffer + U2F_HANDLE_SIGN_HEADER_SIZE, keyHandleLength);
c0d05c1a:	3141      	adds	r1, #65	; 0x41
c0d05c1c:	4815      	ldr	r0, [pc, #84]	; (c0d05c74 <u2f_apdu_sign+0xe4>)
c0d05c1e:	4632      	mov	r2, r6
c0d05c20:	f7fd febb 	bl	c0d0399a <os_memmove>
c0d05c24:	2007      	movs	r0, #7
c0d05c26:	4912      	ldr	r1, [pc, #72]	; (c0d05c70 <u2f_apdu_sign+0xe0>)
    G_io_app.apdu_media = IO_APDU_MEDIA_U2F; // the effective transport is managed by the U2F layer
c0d05c28:	7188      	strb	r0, [r1, #6]
    G_io_app.apdu_length = keyHandleLength;
c0d05c2a:	804e      	strh	r6, [r1, #2]
c0d05c2c:	2009      	movs	r0, #9
    G_io_app.apdu_state = APDU_U2F;
c0d05c2e:	7008      	strb	r0, [r1, #0]
c0d05c30:	2101      	movs	r1, #1
    u2f_message_set_autoreply_wait_user_presence(service, true);
c0d05c32:	9801      	ldr	r0, [sp, #4]
c0d05c34:	f000 fc02 	bl	c0d0643c <u2f_message_set_autoreply_wait_user_presence>
c0d05c38:	e7c3      	b.n	c0d05bc2 <u2f_apdu_sign+0x32>
c0d05c3a:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d05c3c:	4a13      	ldr	r2, [pc, #76]	; (c0d05c8c <u2f_apdu_sign+0xfc>)
c0d05c3e:	447a      	add	r2, pc
c0d05c40:	2302      	movs	r3, #2
c0d05c42:	9801      	ldr	r0, [sp, #4]
c0d05c44:	e7bb      	b.n	c0d05bbe <u2f_apdu_sign+0x2e>
            G_io_apdu_buffer[0] = sizeof(U2F_PROXY_MAGIC)-1;
c0d05c46:	4d0b      	ldr	r5, [pc, #44]	; (c0d05c74 <u2f_apdu_sign+0xe4>)
c0d05c48:	702c      	strb	r4, [r5, #0]
            os_memmove(G_io_apdu_buffer+1, U2F_PROXY_MAGIC, sizeof(U2F_PROXY_MAGIC)-1);
c0d05c4a:	1c68      	adds	r0, r5, #1
c0d05c4c:	4910      	ldr	r1, [pc, #64]	; (c0d05c90 <u2f_apdu_sign+0x100>)
c0d05c4e:	4479      	add	r1, pc
c0d05c50:	4622      	mov	r2, r4
c0d05c52:	f7fd fea2 	bl	c0d0399a <os_memmove>
            os_memmove(G_io_apdu_buffer+1+sizeof(U2F_PROXY_MAGIC)-1, "\x90\x00\x90\x00", 4);
c0d05c56:	1da8      	adds	r0, r5, #6
c0d05c58:	490e      	ldr	r1, [pc, #56]	; (c0d05c94 <u2f_apdu_sign+0x104>)
c0d05c5a:	4479      	add	r1, pc
c0d05c5c:	2204      	movs	r2, #4
c0d05c5e:	f7fd fe9c 	bl	c0d0399a <os_memmove>
                              G_io_apdu_buffer[0]+1+2+2);
c0d05c62:	7828      	ldrb	r0, [r5, #0]
c0d05c64:	1d43      	adds	r3, r0, #5
c0d05c66:	2183      	movs	r1, #131	; 0x83
            u2f_message_reply(service, U2F_CMD_MSG,
c0d05c68:	9801      	ldr	r0, [sp, #4]
c0d05c6a:	462a      	mov	r2, r5
c0d05c6c:	e7a7      	b.n	c0d05bbe <u2f_apdu_sign+0x2e>
c0d05c6e:	46c0      	nop			; (mov r8, r8)
c0d05c70:	20001fb4 	.word	0x20001fb4
c0d05c74:	20001e61 	.word	0x20001e61
c0d05c78:	00004947 	.word	0x00004947
c0d05c7c:	0000493b 	.word	0x0000493b
c0d05c80:	00004931 	.word	0x00004931
c0d05c84:	0000490d 	.word	0x0000490d
c0d05c88:	000048ff 	.word	0x000048ff
c0d05c8c:	000048c0 	.word	0x000048c0
c0d05c90:	000048a5 	.word	0x000048a5
c0d05c94:	0000489f 	.word	0x0000489f

c0d05c98 <u2f_handle_cmd_init>:
}

#endif // U2F_PROXY_MAGIC

void u2f_handle_cmd_init(u2f_service_t *service, uint8_t *buffer,
                         uint16_t length, uint8_t *channelInit) {
c0d05c98:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05c9a:	b081      	sub	sp, #4
c0d05c9c:	461d      	mov	r5, r3
c0d05c9e:	460e      	mov	r6, r1
c0d05ca0:	4604      	mov	r4, r0
    // screen_printf("U2F init\n");
    uint8_t channel[4];
    (void)length;
    if (u2f_is_channel_broadcast(channelInit)) {
c0d05ca2:	4618      	mov	r0, r3
c0d05ca4:	f000 fbbe 	bl	c0d06424 <u2f_is_channel_broadcast>
c0d05ca8:	2800      	cmp	r0, #0
c0d05caa:	d00e      	beq.n	c0d05cca <u2f_handle_cmd_init+0x32>
        // cx_rng(channel, 4); // not available within the IO task
        U4BE_ENCODE(channel, 0, ++service->next_channel);
c0d05cac:	6820      	ldr	r0, [r4, #0]
c0d05cae:	1cc1      	adds	r1, r0, #3
c0d05cb0:	0a09      	lsrs	r1, r1, #8
c0d05cb2:	466a      	mov	r2, sp
c0d05cb4:	7091      	strb	r1, [r2, #2]
c0d05cb6:	1c81      	adds	r1, r0, #2
c0d05cb8:	0c09      	lsrs	r1, r1, #16
c0d05cba:	7051      	strb	r1, [r2, #1]
c0d05cbc:	1c41      	adds	r1, r0, #1
c0d05cbe:	0e09      	lsrs	r1, r1, #24
c0d05cc0:	7011      	strb	r1, [r2, #0]
c0d05cc2:	1d00      	adds	r0, r0, #4
c0d05cc4:	6020      	str	r0, [r4, #0]
c0d05cc6:	70d0      	strb	r0, [r2, #3]
c0d05cc8:	e004      	b.n	c0d05cd4 <u2f_handle_cmd_init+0x3c>
c0d05cca:	4668      	mov	r0, sp
c0d05ccc:	2204      	movs	r2, #4
    } else {
        os_memmove(channel, channelInit, 4);
c0d05cce:	4629      	mov	r1, r5
c0d05cd0:	f7fd fe63 	bl	c0d0399a <os_memmove>
    }
    os_memmove(G_io_apdu_buffer, buffer, 8);
c0d05cd4:	4f15      	ldr	r7, [pc, #84]	; (c0d05d2c <u2f_handle_cmd_init+0x94>)
c0d05cd6:	2208      	movs	r2, #8
c0d05cd8:	4638      	mov	r0, r7
c0d05cda:	4631      	mov	r1, r6
c0d05cdc:	f7fd fe5d 	bl	c0d0399a <os_memmove>
    os_memmove(G_io_apdu_buffer + 8, channel, 4);
c0d05ce0:	4638      	mov	r0, r7
c0d05ce2:	3008      	adds	r0, #8
c0d05ce4:	4669      	mov	r1, sp
c0d05ce6:	2204      	movs	r2, #4
c0d05ce8:	f7fd fe57 	bl	c0d0399a <os_memmove>
c0d05cec:	2000      	movs	r0, #0
    G_io_apdu_buffer[12] = INIT_U2F_VERSION;
    G_io_apdu_buffer[13] = INIT_DEVICE_VERSION_MAJOR;
    G_io_apdu_buffer[14] = INIT_DEVICE_VERSION_MINOR;
    G_io_apdu_buffer[15] = INIT_BUILD_VERSION;
    G_io_apdu_buffer[16] = INIT_CAPABILITIES;
c0d05cee:	7438      	strb	r0, [r7, #16]
    G_io_apdu_buffer[15] = INIT_BUILD_VERSION;
c0d05cf0:	73f8      	strb	r0, [r7, #15]
c0d05cf2:	2101      	movs	r1, #1
    G_io_apdu_buffer[14] = INIT_DEVICE_VERSION_MINOR;
c0d05cf4:	73b9      	strb	r1, [r7, #14]
    G_io_apdu_buffer[13] = INIT_DEVICE_VERSION_MAJOR;
c0d05cf6:	7378      	strb	r0, [r7, #13]
c0d05cf8:	2002      	movs	r0, #2
    G_io_apdu_buffer[12] = INIT_U2F_VERSION;
c0d05cfa:	7338      	strb	r0, [r7, #12]

    if (u2f_is_channel_broadcast(channelInit)) {
c0d05cfc:	4628      	mov	r0, r5
c0d05cfe:	f000 fb91 	bl	c0d06424 <u2f_is_channel_broadcast>
c0d05d02:	4601      	mov	r1, r0
c0d05d04:	1d20      	adds	r0, r4, #4
c0d05d06:	2900      	cmp	r1, #0
c0d05d08:	d004      	beq.n	c0d05d14 <u2f_handle_cmd_init+0x7c>
c0d05d0a:	21ff      	movs	r1, #255	; 0xff
c0d05d0c:	2204      	movs	r2, #4
        os_memset(service->channel, 0xff, 4);
c0d05d0e:	f7fd fe5a 	bl	c0d039c6 <os_memset>
c0d05d12:	e003      	b.n	c0d05d1c <u2f_handle_cmd_init+0x84>
c0d05d14:	4669      	mov	r1, sp
c0d05d16:	2204      	movs	r2, #4
    } else {
        os_memmove(service->channel, channel, 4);
c0d05d18:	f7fd fe3f 	bl	c0d0399a <os_memmove>
c0d05d1c:	2186      	movs	r1, #134	; 0x86
    }
    u2f_message_reply(service, U2F_CMD_INIT, G_io_apdu_buffer, 17);
c0d05d1e:	4a03      	ldr	r2, [pc, #12]	; (c0d05d2c <u2f_handle_cmd_init+0x94>)
c0d05d20:	2311      	movs	r3, #17
c0d05d22:	4620      	mov	r0, r4
c0d05d24:	f000 fb9e 	bl	c0d06464 <u2f_message_reply>
}
c0d05d28:	b001      	add	sp, #4
c0d05d2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05d2c:	20001e61 	.word	0x20001e61

c0d05d30 <u2f_handle_cmd_msg>:
    // screen_printf("U2F ping\n");
    u2f_message_reply(service, U2F_CMD_PING, buffer, length);
}

void u2f_handle_cmd_msg(u2f_service_t *service, uint8_t *buffer,
                        uint16_t length) {
c0d05d30:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05d32:	b083      	sub	sp, #12
c0d05d34:	9002      	str	r0, [sp, #8]
    uint8_t cla = buffer[0];
    uint8_t ins = buffer[1];
    uint8_t p1 = buffer[2];
    uint8_t p2 = buffer[3];
    // in extended length buffer[4] must be 0
    uint32_t dataLength = /*(buffer[4] << 16) |*/ (buffer[5] << 8) | (buffer[6]);
c0d05d36:	7988      	ldrb	r0, [r1, #6]
c0d05d38:	794b      	ldrb	r3, [r1, #5]
c0d05d3a:	021b      	lsls	r3, r3, #8
c0d05d3c:	181f      	adds	r7, r3, r0
    uint8_t p1 = buffer[2];
c0d05d3e:	7888      	ldrb	r0, [r1, #2]
    uint8_t ins = buffer[1];
c0d05d40:	9001      	str	r0, [sp, #4]
c0d05d42:	7848      	ldrb	r0, [r1, #1]
    uint8_t cla = buffer[0];
c0d05d44:	780e      	ldrb	r6, [r1, #0]
    if (dataLength == (uint16_t)(length - 9) || dataLength == (uint16_t)(length - 7)) {
c0d05d46:	4615      	mov	r5, r2
c0d05d48:	3d09      	subs	r5, #9
c0d05d4a:	b2ab      	uxth	r3, r5
c0d05d4c:	429f      	cmp	r7, r3
c0d05d4e:	d003      	beq.n	c0d05d58 <u2f_handle_cmd_msg+0x28>
c0d05d50:	1fd4      	subs	r4, r2, #7
c0d05d52:	b2a4      	uxth	r4, r4
c0d05d54:	42a7      	cmp	r7, r4
c0d05d56:	d11b      	bne.n	c0d05d90 <u2f_handle_cmd_msg+0x60>
c0d05d58:	463d      	mov	r5, r7
    G_io_app.apdu_media = IO_APDU_MEDIA_U2F; // the effective transport is managed by the U2F layer
    G_io_app.apdu_state = APDU_U2F;

#else // U2F_PROXY_MAGIC

    if (cla != FIDO_CLA) {
c0d05d5a:	2e00      	cmp	r6, #0
c0d05d5c:	d008      	beq.n	c0d05d70 <u2f_handle_cmd_msg+0x40>
c0d05d5e:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d05d60:	4a1c      	ldr	r2, [pc, #112]	; (c0d05dd4 <u2f_handle_cmd_msg+0xa4>)
c0d05d62:	447a      	add	r2, pc
c0d05d64:	2302      	movs	r3, #2
c0d05d66:	9802      	ldr	r0, [sp, #8]
c0d05d68:	f000 fb7c 	bl	c0d06464 <u2f_message_reply>
                 sizeof(SW_UNKNOWN_INSTRUCTION));
        return;
    }

#endif // U2F_PROXY_MAGIC
}
c0d05d6c:	b003      	add	sp, #12
c0d05d6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch (ins) {
c0d05d70:	2802      	cmp	r0, #2
c0d05d72:	dc15      	bgt.n	c0d05da0 <u2f_handle_cmd_msg+0x70>
c0d05d74:	2801      	cmp	r0, #1
c0d05d76:	d020      	beq.n	c0d05dba <u2f_handle_cmd_msg+0x8a>
c0d05d78:	2802      	cmp	r0, #2
c0d05d7a:	d11a      	bne.n	c0d05db2 <u2f_handle_cmd_msg+0x82>
        u2f_apdu_sign(service, p1, p2, buffer + 7, dataLength);
c0d05d7c:	b2a8      	uxth	r0, r5
c0d05d7e:	466a      	mov	r2, sp
c0d05d80:	6010      	str	r0, [r2, #0]
c0d05d82:	1dcb      	adds	r3, r1, #7
c0d05d84:	2200      	movs	r2, #0
c0d05d86:	9802      	ldr	r0, [sp, #8]
c0d05d88:	9901      	ldr	r1, [sp, #4]
c0d05d8a:	f7ff ff01 	bl	c0d05b90 <u2f_apdu_sign>
c0d05d8e:	e7ed      	b.n	c0d05d6c <u2f_handle_cmd_msg+0x3c>
    else if (dataLength == (uint16_t)(length - 9)%256) {
c0d05d90:	b2db      	uxtb	r3, r3
c0d05d92:	429f      	cmp	r7, r3
c0d05d94:	d0e1      	beq.n	c0d05d5a <u2f_handle_cmd_msg+0x2a>
    else if (dataLength == (uint16_t)(length - 7)%256) {
c0d05d96:	b2e3      	uxtb	r3, r4
c0d05d98:	429f      	cmp	r7, r3
c0d05d9a:	d112      	bne.n	c0d05dc2 <u2f_handle_cmd_msg+0x92>
c0d05d9c:	1fd5      	subs	r5, r2, #7
c0d05d9e:	e7dc      	b.n	c0d05d5a <u2f_handle_cmd_msg+0x2a>
    switch (ins) {
c0d05da0:	2803      	cmp	r0, #3
c0d05da2:	d012      	beq.n	c0d05dca <u2f_handle_cmd_msg+0x9a>
c0d05da4:	28c1      	cmp	r0, #193	; 0xc1
c0d05da6:	d104      	bne.n	c0d05db2 <u2f_handle_cmd_msg+0x82>
c0d05da8:	2183      	movs	r1, #131	; 0x83
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)INFO, sizeof(INFO));
c0d05daa:	4a0b      	ldr	r2, [pc, #44]	; (c0d05dd8 <u2f_handle_cmd_msg+0xa8>)
c0d05dac:	447a      	add	r2, pc
c0d05dae:	2304      	movs	r3, #4
c0d05db0:	e7d9      	b.n	c0d05d66 <u2f_handle_cmd_msg+0x36>
c0d05db2:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d05db4:	4a0b      	ldr	r2, [pc, #44]	; (c0d05de4 <u2f_handle_cmd_msg+0xb4>)
c0d05db6:	447a      	add	r2, pc
c0d05db8:	e7d4      	b.n	c0d05d64 <u2f_handle_cmd_msg+0x34>
c0d05dba:	2183      	movs	r1, #131	; 0x83
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)SW_INTERNAL, sizeof(SW_INTERNAL));
c0d05dbc:	4a07      	ldr	r2, [pc, #28]	; (c0d05ddc <u2f_handle_cmd_msg+0xac>)
c0d05dbe:	447a      	add	r2, pc
c0d05dc0:	e7d0      	b.n	c0d05d64 <u2f_handle_cmd_msg+0x34>
c0d05dc2:	2183      	movs	r1, #131	; 0x83
        u2f_message_reply(service, U2F_CMD_MSG,
c0d05dc4:	4a08      	ldr	r2, [pc, #32]	; (c0d05de8 <u2f_handle_cmd_msg+0xb8>)
c0d05dc6:	447a      	add	r2, pc
c0d05dc8:	e7cc      	b.n	c0d05d64 <u2f_handle_cmd_msg+0x34>
c0d05dca:	2183      	movs	r1, #131	; 0x83
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)U2F_VERSION, sizeof(U2F_VERSION));
c0d05dcc:	4a04      	ldr	r2, [pc, #16]	; (c0d05de0 <u2f_handle_cmd_msg+0xb0>)
c0d05dce:	447a      	add	r2, pc
c0d05dd0:	2308      	movs	r3, #8
c0d05dd2:	e7c8      	b.n	c0d05d66 <u2f_handle_cmd_msg+0x36>
c0d05dd4:	000047aa 	.word	0x000047aa
c0d05dd8:	0000475c 	.word	0x0000475c
c0d05ddc:	00004727 	.word	0x00004727
c0d05de0:	00004732 	.word	0x00004732
c0d05de4:	00004758 	.word	0x00004758
c0d05de8:	00004723 	.word	0x00004723

c0d05dec <u2f_message_complete>:

void u2f_message_complete(u2f_service_t *service) {
c0d05dec:	b580      	push	{r7, lr}
    uint8_t cmd = service->transportBuffer[0];
c0d05dee:	69c1      	ldr	r1, [r0, #28]
    uint16_t length = (service->transportBuffer[1] << 8) | (service->transportBuffer[2]);
c0d05df0:	788a      	ldrb	r2, [r1, #2]
c0d05df2:	784b      	ldrb	r3, [r1, #1]
c0d05df4:	021b      	lsls	r3, r3, #8
c0d05df6:	189b      	adds	r3, r3, r2
    uint8_t cmd = service->transportBuffer[0];
c0d05df8:	780a      	ldrb	r2, [r1, #0]
    switch (cmd) {
c0d05dfa:	2a81      	cmp	r2, #129	; 0x81
c0d05dfc:	d009      	beq.n	c0d05e12 <u2f_message_complete+0x26>
c0d05dfe:	2a83      	cmp	r2, #131	; 0x83
c0d05e00:	d00d      	beq.n	c0d05e1e <u2f_message_complete+0x32>
c0d05e02:	2a86      	cmp	r2, #134	; 0x86
c0d05e04:	d10f      	bne.n	c0d05e26 <u2f_message_complete+0x3a>
    case U2F_CMD_INIT:
        u2f_handle_cmd_init(service, service->transportBuffer + 3, length, service->channel);
c0d05e06:	1cc9      	adds	r1, r1, #3
c0d05e08:	1d03      	adds	r3, r0, #4
c0d05e0a:	2200      	movs	r2, #0
c0d05e0c:	f7ff ff44 	bl	c0d05c98 <u2f_handle_cmd_init>
        break;
    case U2F_CMD_MSG:
        u2f_handle_cmd_msg(service, service->transportBuffer + 3, length);
        break;
    }
}
c0d05e10:	bd80      	pop	{r7, pc}
        u2f_handle_cmd_ping(service, service->transportBuffer + 3, length);
c0d05e12:	1cca      	adds	r2, r1, #3
    u2f_message_reply(service, U2F_CMD_PING, buffer, length);
c0d05e14:	b29b      	uxth	r3, r3
c0d05e16:	2181      	movs	r1, #129	; 0x81
c0d05e18:	f000 fb24 	bl	c0d06464 <u2f_message_reply>
}
c0d05e1c:	bd80      	pop	{r7, pc}
        u2f_handle_cmd_msg(service, service->transportBuffer + 3, length);
c0d05e1e:	1cc9      	adds	r1, r1, #3
c0d05e20:	b29a      	uxth	r2, r3
c0d05e22:	f7ff ff85 	bl	c0d05d30 <u2f_handle_cmd_msg>
}
c0d05e26:	bd80      	pop	{r7, pc}

c0d05e28 <u2f_io_send>:
#include "u2f_processing.h"
#include "u2f_impl.h"

#include "os_io_seproxyhal.h"

void u2f_io_send(uint8_t *buffer, uint16_t length, u2f_transport_media_t media) {
c0d05e28:	b570      	push	{r4, r5, r6, lr}
    if (media == U2F_MEDIA_USB) {
c0d05e2a:	2a01      	cmp	r2, #1
c0d05e2c:	d113      	bne.n	c0d05e56 <u2f_io_send+0x2e>
c0d05e2e:	460d      	mov	r5, r1
c0d05e30:	4601      	mov	r1, r0
        os_memmove(G_io_usb_ep_buffer, buffer, length);
c0d05e32:	4c09      	ldr	r4, [pc, #36]	; (c0d05e58 <u2f_io_send+0x30>)
c0d05e34:	4620      	mov	r0, r4
c0d05e36:	462a      	mov	r2, r5
c0d05e38:	f7fd fdaf 	bl	c0d0399a <os_memmove>
        // wipe the remaining to avoid :
        // 1/ data leaks
        // 2/ invalid junk
        os_memset(G_io_usb_ep_buffer+length, 0, sizeof(G_io_usb_ep_buffer)-length);
c0d05e3c:	1960      	adds	r0, r4, r5
c0d05e3e:	2640      	movs	r6, #64	; 0x40
c0d05e40:	1b72      	subs	r2, r6, r5
c0d05e42:	2500      	movs	r5, #0
c0d05e44:	4629      	mov	r1, r5
c0d05e46:	f7fd fdbe 	bl	c0d039c6 <os_memset>
c0d05e4a:	2081      	movs	r0, #129	; 0x81
    }
    switch (media) {
    case U2F_MEDIA_USB:
        io_usb_send_ep(U2F_EPIN_ADDR, G_io_usb_ep_buffer, USB_SEGMENT_SIZE, 0);
c0d05e4c:	4621      	mov	r1, r4
c0d05e4e:	4632      	mov	r2, r6
c0d05e50:	462b      	mov	r3, r5
c0d05e52:	f7fd ff77 	bl	c0d03d44 <io_usb_send_ep>
#endif
    default:
        PRINTF("Request to send on unsupported media %d\n", media);
        break;
    }
}
c0d05e56:	bd70      	pop	{r4, r5, r6, pc}
c0d05e58:	20002018 	.word	0x20002018

c0d05e5c <u2f_transport_init>:
}

/**
 * Initialize the u2f transport and provide the buffer into which to store incoming message
 */
void u2f_transport_init(u2f_service_t *service, uint8_t* message_buffer, uint16_t message_buffer_length) {
c0d05e5c:	2300      	movs	r3, #0
    service->transportPacketIndex = 0;
c0d05e5e:	7683      	strb	r3, [r0, #26]
    service->transportOffset = 0;
c0d05e60:	82c3      	strh	r3, [r0, #22]
    service->transportReceiveBuffer = message_buffer;
    service->transportReceiveBufferLength = message_buffer_length;
c0d05e62:	8202      	strh	r2, [r0, #16]
    service->transportReceiveBuffer = message_buffer;
c0d05e64:	60c1      	str	r1, [r0, #12]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d05e66:	8543      	strh	r3, [r0, #42]	; 0x2a
    service->transportMedia = 0;
c0d05e68:	8483      	strh	r3, [r0, #36]	; 0x24
    service->transportBuffer = service->transportReceiveBuffer;
c0d05e6a:	61c1      	str	r1, [r0, #28]
    service->transportMedia = 0;
c0d05e6c:	6203      	str	r3, [r0, #32]
    u2f_transport_reset(service);
}
c0d05e6e:	4770      	bx	lr

c0d05e70 <u2f_transport_sent>:

/**
 * Function called when the previously scheduled message to be sent on the media is effectively sent.
 * And a new message can be scheduled.
 */
void u2f_transport_sent(u2f_service_t* service, u2f_transport_media_t media) {
c0d05e70:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05e72:	b083      	sub	sp, #12
c0d05e74:	4604      	mov	r4, r0
c0d05e76:	202a      	movs	r0, #42	; 0x2a

bool u2f_message_repliable(u2f_service_t* service) {
    // no more asynch replies
    // finished receiving the command
    // and not sending a user presence required status
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d05e78:	5c20      	ldrb	r0, [r4, r0]
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0d05e7a:	2801      	cmp	r0, #1
c0d05e7c:	d026      	beq.n	c0d05ecc <u2f_transport_sent+0x5c>
c0d05e7e:	460d      	mov	r5, r1
c0d05e80:	2800      	cmp	r0, #0
c0d05e82:	d118      	bne.n	c0d05eb6 <u2f_transport_sent+0x46>
c0d05e84:	202b      	movs	r0, #43	; 0x2b
c0d05e86:	2100      	movs	r1, #0
c0d05e88:	5421      	strb	r1, [r4, r0]
c0d05e8a:	4620      	mov	r0, r4
c0d05e8c:	302b      	adds	r0, #43	; 0x2b
c0d05e8e:	2120      	movs	r1, #32
    if (service->transportState != U2F_SENDING_RESPONSE 
c0d05e90:	5c62      	ldrb	r2, [r4, r1]
        && service->transportState != U2F_SENDING_ERROR) {
c0d05e92:	1ed2      	subs	r2, r2, #3
c0d05e94:	b2d2      	uxtb	r2, r2
c0d05e96:	2a01      	cmp	r2, #1
c0d05e98:	d81b      	bhi.n	c0d05ed2 <u2f_transport_sent+0x62>
c0d05e9a:	4626      	mov	r6, r4
c0d05e9c:	362a      	adds	r6, #42	; 0x2a
c0d05e9e:	4627      	mov	r7, r4
c0d05ea0:	3720      	adds	r7, #32
    if (service->transportOffset < service->transportLength) {
c0d05ea2:	8b22      	ldrh	r2, [r4, #24]
c0d05ea4:	8ae3      	ldrh	r3, [r4, #22]
c0d05ea6:	429a      	cmp	r2, r3
c0d05ea8:	d915      	bls.n	c0d05ed6 <u2f_transport_sent+0x66>
            (service->transportPacketIndex == 0 ? (channelHeader + 3)
c0d05eaa:	7ea0      	ldrb	r0, [r4, #26]
c0d05eac:	2800      	cmp	r0, #0
c0d05eae:	9001      	str	r0, [sp, #4]
c0d05eb0:	d01e      	beq.n	c0d05ef0 <u2f_transport_sent+0x80>
c0d05eb2:	2601      	movs	r6, #1
c0d05eb4:	e01d      	b.n	c0d05ef2 <u2f_transport_sent+0x82>
c0d05eb6:	2025      	movs	r0, #37	; 0x25
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0d05eb8:	5c20      	ldrb	r0, [r4, r0]
            && service->sending == false)
c0d05eba:	2806      	cmp	r0, #6
c0d05ebc:	d106      	bne.n	c0d05ecc <u2f_transport_sent+0x5c>
c0d05ebe:	202b      	movs	r0, #43	; 0x2b
c0d05ec0:	5c21      	ldrb	r1, [r4, r0]
c0d05ec2:	2200      	movs	r2, #0
c0d05ec4:	5422      	strb	r2, [r4, r0]
    if (!u2f_message_repliable(service)) {
c0d05ec6:	2900      	cmp	r1, #0
c0d05ec8:	d103      	bne.n	c0d05ed2 <u2f_transport_sent+0x62>
c0d05eca:	e7de      	b.n	c0d05e8a <u2f_transport_sent+0x1a>
c0d05ecc:	202b      	movs	r0, #43	; 0x2b
c0d05ece:	2100      	movs	r1, #0
c0d05ed0:	5421      	strb	r1, [r4, r0]
}
c0d05ed2:	b003      	add	sp, #12
c0d05ed4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    else if (service->transportOffset == service->transportLength) {
c0d05ed6:	d1fc      	bne.n	c0d05ed2 <u2f_transport_sent+0x62>
c0d05ed8:	2100      	movs	r1, #0
    service->transportPacketIndex = 0;
c0d05eda:	76a1      	strb	r1, [r4, #26]
    service->transportOffset = 0;
c0d05edc:	82e1      	strh	r1, [r4, #22]
    service->sending = false;
c0d05ede:	7001      	strb	r1, [r0, #0]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d05ee0:	7031      	strb	r1, [r6, #0]
    service->transportMedia = 0;
c0d05ee2:	80b9      	strh	r1, [r7, #4]
c0d05ee4:	6039      	str	r1, [r7, #0]
    service->transportBuffer = service->transportReceiveBuffer;
c0d05ee6:	68e0      	ldr	r0, [r4, #12]
c0d05ee8:	61e0      	str	r0, [r4, #28]
        G_io_app.apdu_state = APDU_IDLE;
c0d05eea:	4824      	ldr	r0, [pc, #144]	; (c0d05f7c <u2f_transport_sent+0x10c>)
c0d05eec:	7001      	strb	r1, [r0, #0]
c0d05eee:	e7f0      	b.n	c0d05ed2 <u2f_transport_sent+0x62>
c0d05ef0:	2603      	movs	r6, #3
        uint16_t mtu = (media == U2F_MEDIA_USB) ? USB_SEGMENT_SIZE : BLE_SEGMENT_SIZE;
c0d05ef2:	1e6f      	subs	r7, r5, #1
c0d05ef4:	4278      	negs	r0, r7
c0d05ef6:	4178      	adcs	r0, r7
c0d05ef8:	0080      	lsls	r0, r0, #2
            (service->transportPacketIndex == 0 ? (channelHeader + 3)
c0d05efa:	1830      	adds	r0, r6, r0
                                      (mtu - headerSize)
c0d05efc:	2d01      	cmp	r5, #1
c0d05efe:	d100      	bne.n	c0d05f02 <u2f_transport_sent+0x92>
c0d05f00:	2140      	movs	r1, #64	; 0x40
c0d05f02:	1a0f      	subs	r7, r1, r0
        uint16_t blockSize = ((service->transportLength - service->transportOffset) >
c0d05f04:	1ad1      	subs	r1, r2, r3
c0d05f06:	42b9      	cmp	r1, r7
c0d05f08:	dc00      	bgt.n	c0d05f0c <u2f_transport_sent+0x9c>
c0d05f0a:	460f      	mov	r7, r1
        if (media == U2F_MEDIA_USB) {
c0d05f0c:	2d01      	cmp	r5, #1
c0d05f0e:	9002      	str	r0, [sp, #8]
c0d05f10:	d107      	bne.n	c0d05f22 <u2f_transport_sent+0xb2>
            os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d05f12:	1d21      	adds	r1, r4, #4
c0d05f14:	481a      	ldr	r0, [pc, #104]	; (c0d05f80 <u2f_transport_sent+0x110>)
c0d05f16:	2604      	movs	r6, #4
c0d05f18:	4632      	mov	r2, r6
c0d05f1a:	f7fd fd3e 	bl	c0d0399a <os_memmove>
        if (service->transportPacketIndex == 0) {
c0d05f1e:	7ea0      	ldrb	r0, [r4, #26]
c0d05f20:	e001      	b.n	c0d05f26 <u2f_transport_sent+0xb6>
c0d05f22:	2600      	movs	r6, #0
c0d05f24:	9801      	ldr	r0, [sp, #4]
c0d05f26:	2800      	cmp	r0, #0
c0d05f28:	d001      	beq.n	c0d05f2e <u2f_transport_sent+0xbe>
            G_io_usb_ep_buffer[offset++] = (service->transportPacketIndex - 1);
c0d05f2a:	1e40      	subs	r0, r0, #1
c0d05f2c:	e009      	b.n	c0d05f42 <u2f_transport_sent+0xd2>
c0d05f2e:	2040      	movs	r0, #64	; 0x40
            G_io_usb_ep_buffer[offset++] = service->sendCmd;
c0d05f30:	5c20      	ldrb	r0, [r4, r0]
c0d05f32:	4913      	ldr	r1, [pc, #76]	; (c0d05f80 <u2f_transport_sent+0x110>)
c0d05f34:	5588      	strb	r0, [r1, r6]
c0d05f36:	2001      	movs	r0, #1
c0d05f38:	4330      	orrs	r0, r6
            G_io_usb_ep_buffer[offset++] = (service->transportLength >> 8);
c0d05f3a:	7e62      	ldrb	r2, [r4, #25]
c0d05f3c:	540a      	strb	r2, [r1, r0]
c0d05f3e:	1c46      	adds	r6, r0, #1
            G_io_usb_ep_buffer[offset++] = (service->transportLength & 0xff);
c0d05f40:	7e20      	ldrb	r0, [r4, #24]
c0d05f42:	9b02      	ldr	r3, [sp, #8]
c0d05f44:	18f9      	adds	r1, r7, r3
c0d05f46:	9101      	str	r1, [sp, #4]
c0d05f48:	4a0d      	ldr	r2, [pc, #52]	; (c0d05f80 <u2f_transport_sent+0x110>)
c0d05f4a:	5590      	strb	r0, [r2, r6]
        if (service->transportBuffer != NULL) {
c0d05f4c:	69e1      	ldr	r1, [r4, #28]
c0d05f4e:	2900      	cmp	r1, #0
c0d05f50:	d006      	beq.n	c0d05f60 <u2f_transport_sent+0xf0>
c0d05f52:	b2be      	uxth	r6, r7
            os_memmove(G_io_usb_ep_buffer + headerSize,
c0d05f54:	18d0      	adds	r0, r2, r3
                       service->transportBuffer + service->transportOffset, blockSize);
c0d05f56:	8ae3      	ldrh	r3, [r4, #22]
c0d05f58:	18c9      	adds	r1, r1, r3
            os_memmove(G_io_usb_ep_buffer + headerSize,
c0d05f5a:	4632      	mov	r2, r6
c0d05f5c:	f7fd fd1d 	bl	c0d0399a <os_memmove>
        service->transportOffset += blockSize;
c0d05f60:	8ae0      	ldrh	r0, [r4, #22]
c0d05f62:	19c0      	adds	r0, r0, r7
c0d05f64:	82e0      	strh	r0, [r4, #22]
        service->transportPacketIndex++;
c0d05f66:	7ea0      	ldrb	r0, [r4, #26]
c0d05f68:	1c40      	adds	r0, r0, #1
c0d05f6a:	76a0      	strb	r0, [r4, #26]
        u2f_io_send(G_io_usb_ep_buffer, dataSize, media);
c0d05f6c:	9801      	ldr	r0, [sp, #4]
c0d05f6e:	b281      	uxth	r1, r0
c0d05f70:	4803      	ldr	r0, [pc, #12]	; (c0d05f80 <u2f_transport_sent+0x110>)
c0d05f72:	462a      	mov	r2, r5
c0d05f74:	f7ff ff58 	bl	c0d05e28 <u2f_io_send>
c0d05f78:	e7ab      	b.n	c0d05ed2 <u2f_transport_sent+0x62>
c0d05f7a:	46c0      	nop			; (mov r8, r8)
c0d05f7c:	20001fb4 	.word	0x20001fb4
c0d05f80:	20002018 	.word	0x20002018

c0d05f84 <u2f_message_repliable>:
bool u2f_message_repliable(u2f_service_t* service) {
c0d05f84:	212a      	movs	r1, #42	; 0x2a
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d05f86:	5c41      	ldrb	r1, [r0, r1]
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0d05f88:	2900      	cmp	r1, #0
c0d05f8a:	d00c      	beq.n	c0d05fa6 <u2f_message_repliable+0x22>
c0d05f8c:	2901      	cmp	r1, #1
c0d05f8e:	d008      	beq.n	c0d05fa2 <u2f_message_repliable+0x1e>
c0d05f90:	2125      	movs	r1, #37	; 0x25
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0d05f92:	5c41      	ldrb	r1, [r0, r1]
            && service->sending == false)
c0d05f94:	2906      	cmp	r1, #6
c0d05f96:	d104      	bne.n	c0d05fa2 <u2f_message_repliable+0x1e>
c0d05f98:	212b      	movs	r1, #43	; 0x2b
c0d05f9a:	5c41      	ldrb	r1, [r0, r1]
c0d05f9c:	4248      	negs	r0, r1
c0d05f9e:	4148      	adcs	r0, r1
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d05fa0:	4770      	bx	lr
c0d05fa2:	2000      	movs	r0, #0
c0d05fa4:	4770      	bx	lr
c0d05fa6:	2001      	movs	r0, #1
c0d05fa8:	4770      	bx	lr
	...

c0d05fac <u2f_transport_send_usb_user_presence_required>:
void u2f_transport_send_usb_user_presence_required(u2f_service_t *service) {
c0d05fac:	b5b0      	push	{r4, r5, r7, lr}
c0d05fae:	212b      	movs	r1, #43	; 0x2b
c0d05fb0:	2401      	movs	r4, #1
    service->sending = true;
c0d05fb2:	5444      	strb	r4, [r0, r1]
    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d05fb4:	1d01      	adds	r1, r0, #4
c0d05fb6:	4d0a      	ldr	r5, [pc, #40]	; (c0d05fe0 <u2f_transport_send_usb_user_presence_required+0x34>)
c0d05fb8:	2204      	movs	r2, #4
c0d05fba:	4628      	mov	r0, r5
c0d05fbc:	f7fd fced 	bl	c0d0399a <os_memmove>
c0d05fc0:	2085      	movs	r0, #133	; 0x85
    G_io_usb_ep_buffer[offset++] = 0x85;
c0d05fc2:	7228      	strb	r0, [r5, #8]
c0d05fc4:	2069      	movs	r0, #105	; 0x69
    G_io_usb_ep_buffer[offset++] = 0x69;
c0d05fc6:	71e8      	strb	r0, [r5, #7]
c0d05fc8:	2002      	movs	r0, #2
    G_io_usb_ep_buffer[offset++] = 2;
c0d05fca:	71a8      	strb	r0, [r5, #6]
c0d05fcc:	2000      	movs	r0, #0
    G_io_usb_ep_buffer[offset++] = 0;
c0d05fce:	7168      	strb	r0, [r5, #5]
c0d05fd0:	2083      	movs	r0, #131	; 0x83
    G_io_usb_ep_buffer[offset++] = U2F_CMD_MSG;
c0d05fd2:	7128      	strb	r0, [r5, #4]
c0d05fd4:	2109      	movs	r1, #9
    u2f_io_send(G_io_usb_ep_buffer, offset, U2F_MEDIA_USB);
c0d05fd6:	4628      	mov	r0, r5
c0d05fd8:	4622      	mov	r2, r4
c0d05fda:	f7ff ff25 	bl	c0d05e28 <u2f_io_send>
}
c0d05fde:	bdb0      	pop	{r4, r5, r7, pc}
c0d05fe0:	20002018 	.word	0x20002018

c0d05fe4 <u2f_transport_send_wink>:
void u2f_transport_send_wink(u2f_service_t *service) {
c0d05fe4:	b5b0      	push	{r4, r5, r7, lr}
c0d05fe6:	212b      	movs	r1, #43	; 0x2b
c0d05fe8:	2401      	movs	r4, #1
    service->sending = true;
c0d05fea:	5444      	strb	r4, [r0, r1]
    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d05fec:	1d01      	adds	r1, r0, #4
c0d05fee:	4d08      	ldr	r5, [pc, #32]	; (c0d06010 <u2f_transport_send_wink+0x2c>)
c0d05ff0:	2204      	movs	r2, #4
c0d05ff2:	4628      	mov	r0, r5
c0d05ff4:	f7fd fcd1 	bl	c0d0399a <os_memmove>
c0d05ff8:	2000      	movs	r0, #0
    G_io_usb_ep_buffer[offset++] = 0;
c0d05ffa:	71a8      	strb	r0, [r5, #6]
    G_io_usb_ep_buffer[offset++] = 0;
c0d05ffc:	7168      	strb	r0, [r5, #5]
c0d05ffe:	2088      	movs	r0, #136	; 0x88
    G_io_usb_ep_buffer[offset++] = U2F_CMD_WINK;
c0d06000:	7128      	strb	r0, [r5, #4]
c0d06002:	2107      	movs	r1, #7
    u2f_io_send(G_io_usb_ep_buffer, offset, U2F_MEDIA_USB);
c0d06004:	4628      	mov	r0, r5
c0d06006:	4622      	mov	r2, r4
c0d06008:	f7ff ff0e 	bl	c0d05e28 <u2f_io_send>
}
c0d0600c:	bdb0      	pop	{r4, r5, r7, pc}
c0d0600e:	46c0      	nop			; (mov r8, r8)
c0d06010:	20002018 	.word	0x20002018

c0d06014 <u2f_transport_receive_fakeChannel>:
bool u2f_transport_receive_fakeChannel(u2f_service_t *service, uint8_t *buffer, uint16_t size) {
c0d06014:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06016:	b081      	sub	sp, #4
c0d06018:	4604      	mov	r4, r0
c0d0601a:	2025      	movs	r0, #37	; 0x25
    if (service->fakeChannelTransportState == U2F_INTERNAL_ERROR) {
c0d0601c:	5c20      	ldrb	r0, [r4, r0]
c0d0601e:	2805      	cmp	r0, #5
c0d06020:	d101      	bne.n	c0d06026 <u2f_transport_receive_fakeChannel+0x12>
c0d06022:	2500      	movs	r5, #0
c0d06024:	e065      	b.n	c0d060f2 <u2f_transport_receive_fakeChannel+0xde>
c0d06026:	4626      	mov	r6, r4
c0d06028:	3625      	adds	r6, #37	; 0x25
    if (memcmp(service->channel, buffer, 4) != 0) {
c0d0602a:	7808      	ldrb	r0, [r1, #0]
c0d0602c:	784b      	ldrb	r3, [r1, #1]
c0d0602e:	021b      	lsls	r3, r3, #8
c0d06030:	1818      	adds	r0, r3, r0
c0d06032:	788b      	ldrb	r3, [r1, #2]
c0d06034:	78cd      	ldrb	r5, [r1, #3]
c0d06036:	022d      	lsls	r5, r5, #8
c0d06038:	18eb      	adds	r3, r5, r3
c0d0603a:	041b      	lsls	r3, r3, #16
c0d0603c:	1818      	adds	r0, r3, r0
c0d0603e:	7923      	ldrb	r3, [r4, #4]
c0d06040:	7965      	ldrb	r5, [r4, #5]
c0d06042:	022d      	lsls	r5, r5, #8
c0d06044:	18eb      	adds	r3, r5, r3
c0d06046:	79a5      	ldrb	r5, [r4, #6]
c0d06048:	79e7      	ldrb	r7, [r4, #7]
c0d0604a:	023f      	lsls	r7, r7, #8
c0d0604c:	197d      	adds	r5, r7, r5
c0d0604e:	042d      	lsls	r5, r5, #16
c0d06050:	18eb      	adds	r3, r5, r3
c0d06052:	4283      	cmp	r3, r0
c0d06054:	d150      	bne.n	c0d060f8 <u2f_transport_receive_fakeChannel+0xe4>
c0d06056:	790b      	ldrb	r3, [r1, #4]
    if (service->fakeChannelTransportOffset == 0) {        
c0d06058:	8c60      	ldrh	r0, [r4, #34]	; 0x22
c0d0605a:	2800      	cmp	r0, #0
c0d0605c:	d013      	beq.n	c0d06086 <u2f_transport_receive_fakeChannel+0x72>
c0d0605e:	2524      	movs	r5, #36	; 0x24
        if (buffer[4] != service->fakeChannelTransportPacketIndex) {
c0d06060:	5d65      	ldrb	r5, [r4, r5]
c0d06062:	42ab      	cmp	r3, r5
c0d06064:	d148      	bne.n	c0d060f8 <u2f_transport_receive_fakeChannel+0xe4>
c0d06066:	4625      	mov	r5, r4
c0d06068:	3524      	adds	r5, #36	; 0x24
        uint16_t xfer_len = MIN(size - 5, service->transportLength - service->fakeChannelTransportOffset);
c0d0606a:	8b27      	ldrh	r7, [r4, #24]
        service->fakeChannelTransportPacketIndex++;
c0d0606c:	1c5b      	adds	r3, r3, #1
c0d0606e:	702b      	strb	r3, [r5, #0]
        uint16_t xfer_len = MIN(size - 5, service->transportLength - service->fakeChannelTransportOffset);
c0d06070:	1a3b      	subs	r3, r7, r0
c0d06072:	1f52      	subs	r2, r2, #5
c0d06074:	429a      	cmp	r2, r3
c0d06076:	db00      	blt.n	c0d0607a <u2f_transport_receive_fakeChannel+0x66>
c0d06078:	461a      	mov	r2, r3
        service->fakeChannelTransportOffset += xfer_len;
c0d0607a:	1880      	adds	r0, r0, r2
c0d0607c:	8460      	strh	r0, [r4, #34]	; 0x22
c0d0607e:	b292      	uxth	r2, r2
        service->fakeChannelCrc = cx_crc16_update(service->fakeChannelCrc, buffer + 5, xfer_len);   
c0d06080:	8d20      	ldrh	r0, [r4, #40]	; 0x28
c0d06082:	1d49      	adds	r1, r1, #5
c0d06084:	e01e      	b.n	c0d060c4 <u2f_transport_receive_fakeChannel+0xb0>
        if (buffer[4] == U2F_CMD_WINK) {
c0d06086:	2b88      	cmp	r3, #136	; 0x88
c0d06088:	d104      	bne.n	c0d06094 <u2f_transport_receive_fakeChannel+0x80>
            u2f_transport_send_wink(service);
c0d0608a:	4620      	mov	r0, r4
c0d0608c:	f7ff ffaa 	bl	c0d05fe4 <u2f_transport_send_wink>
c0d06090:	2501      	movs	r5, #1
c0d06092:	e02e      	b.n	c0d060f2 <u2f_transport_receive_fakeChannel+0xde>
        if (commandLength != service->transportLength) {
c0d06094:	2b83      	cmp	r3, #131	; 0x83
c0d06096:	d12f      	bne.n	c0d060f8 <u2f_transport_receive_fakeChannel+0xe4>
c0d06098:	7988      	ldrb	r0, [r1, #6]
c0d0609a:	794b      	ldrb	r3, [r1, #5]
c0d0609c:	021b      	lsls	r3, r3, #8
c0d0609e:	1818      	adds	r0, r3, r0
c0d060a0:	1cc0      	adds	r0, r0, #3
c0d060a2:	8b23      	ldrh	r3, [r4, #24]
c0d060a4:	b285      	uxth	r5, r0
c0d060a6:	42ab      	cmp	r3, r5
c0d060a8:	d126      	bne.n	c0d060f8 <u2f_transport_receive_fakeChannel+0xe4>
c0d060aa:	1d09      	adds	r1, r1, #4
c0d060ac:	b285      	uxth	r5, r0
c0d060ae:	4b15      	ldr	r3, [pc, #84]	; (c0d06104 <u2f_transport_receive_fakeChannel+0xf0>)
c0d060b0:	2724      	movs	r7, #36	; 0x24
c0d060b2:	2000      	movs	r0, #0
        service->fakeChannelTransportPacketIndex = 0;
c0d060b4:	55e0      	strb	r0, [r4, r7]
        service->fakeChannelTransportOffset = MIN(size - 4, service->transportLength);
c0d060b6:	1f12      	subs	r2, r2, #4
c0d060b8:	42aa      	cmp	r2, r5
c0d060ba:	db00      	blt.n	c0d060be <u2f_transport_receive_fakeChannel+0xaa>
c0d060bc:	462a      	mov	r2, r5
c0d060be:	8462      	strh	r2, [r4, #34]	; 0x22
        service->fakeChannelCrc = cx_crc16_update(0, buffer + 4, service->fakeChannelTransportOffset);
c0d060c0:	4013      	ands	r3, r2
c0d060c2:	461a      	mov	r2, r3
c0d060c4:	f7ff fc5e 	bl	c0d05984 <cx_crc16_update>
c0d060c8:	8520      	strh	r0, [r4, #40]	; 0x28
    if (service->fakeChannelTransportOffset >= service->transportLength) {
c0d060ca:	8b21      	ldrh	r1, [r4, #24]
c0d060cc:	8c62      	ldrh	r2, [r4, #34]	; 0x22
c0d060ce:	2501      	movs	r5, #1
c0d060d0:	428a      	cmp	r2, r1
c0d060d2:	d30e      	bcc.n	c0d060f2 <u2f_transport_receive_fakeChannel+0xde>
        if (service->fakeChannelCrc != service->commandCrc) {
c0d060d4:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
c0d060d6:	4288      	cmp	r0, r1
c0d060d8:	d10e      	bne.n	c0d060f8 <u2f_transport_receive_fakeChannel+0xe4>
c0d060da:	2006      	movs	r0, #6
        service->fakeChannelTransportState = U2F_FAKE_RECEIVED;
c0d060dc:	7030      	strb	r0, [r6, #0]
c0d060de:	2700      	movs	r7, #0
        service->fakeChannelTransportOffset = 0;
c0d060e0:	8467      	strh	r7, [r4, #34]	; 0x22
c0d060e2:	202a      	movs	r0, #42	; 0x2a
        if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
c0d060e4:	5c20      	ldrb	r0, [r4, r0]
c0d060e6:	2801      	cmp	r0, #1
c0d060e8:	d103      	bne.n	c0d060f2 <u2f_transport_receive_fakeChannel+0xde>
            u2f_transport_send_usb_user_presence_required(service);
c0d060ea:	4620      	mov	r0, r4
c0d060ec:	f7ff ff5e 	bl	c0d05fac <u2f_transport_send_usb_user_presence_required>
            service->fakeChannelTransportState = U2F_IDLE;
c0d060f0:	7037      	strb	r7, [r6, #0]
}
c0d060f2:	4628      	mov	r0, r5
c0d060f4:	b001      	add	sp, #4
c0d060f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d060f8:	2005      	movs	r0, #5
    service->fakeChannelTransportState = U2F_INTERNAL_ERROR;
c0d060fa:	7030      	strb	r0, [r6, #0]
c0d060fc:	2010      	movs	r0, #16
    THROW(EXCEPTION_IO_RESET);
c0d060fe:	f7fd fc80 	bl	c0d03a02 <os_longjmp>
c0d06102:	46c0      	nop			; (mov r8, r8)
c0d06104:	0000ffff 	.word	0x0000ffff

c0d06108 <u2f_transport_received>:
                          uint16_t size, u2f_transport_media_t media) {
c0d06108:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0610a:	b087      	sub	sp, #28
c0d0610c:	4604      	mov	r4, r0
    service->media = media;
c0d0610e:	7203      	strb	r3, [r0, #8]
c0d06110:	2020      	movs	r0, #32
    if (service->transportState == U2F_SENDING_RESPONSE) {
c0d06112:	5c20      	ldrb	r0, [r4, r0]
c0d06114:	4626      	mov	r6, r4
c0d06116:	3620      	adds	r6, #32
c0d06118:	2803      	cmp	r0, #3
c0d0611a:	d00a      	beq.n	c0d06132 <u2f_transport_received+0x2a>
c0d0611c:	460f      	mov	r7, r1
c0d0611e:	212a      	movs	r1, #42	; 0x2a
    if (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_IDLE) {
c0d06120:	5c61      	ldrb	r1, [r4, r1]
c0d06122:	2900      	cmp	r1, #0
c0d06124:	d01a      	beq.n	c0d0615c <u2f_transport_received+0x54>
        if (!u2f_transport_receive_fakeChannel(service, buffer, size)) {
c0d06126:	4620      	mov	r0, r4
c0d06128:	4639      	mov	r1, r7
c0d0612a:	f7ff ff73 	bl	c0d06014 <u2f_transport_receive_fakeChannel>
c0d0612e:	2800      	cmp	r0, #0
c0d06130:	d112      	bne.n	c0d06158 <u2f_transport_received+0x50>
c0d06132:	48b8      	ldr	r0, [pc, #736]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d06134:	2106      	movs	r1, #6
c0d06136:	7201      	strb	r1, [r0, #8]
c0d06138:	2104      	movs	r1, #4
c0d0613a:	7031      	strb	r1, [r6, #0]
c0d0613c:	2140      	movs	r1, #64	; 0x40
c0d0613e:	22bf      	movs	r2, #191	; 0xbf
c0d06140:	5462      	strb	r2, [r4, r1]
c0d06142:	3008      	adds	r0, #8
c0d06144:	61e0      	str	r0, [r4, #28]
c0d06146:	2000      	movs	r0, #0
c0d06148:	76a0      	strb	r0, [r4, #26]
c0d0614a:	2101      	movs	r1, #1
c0d0614c:	8321      	strh	r1, [r4, #24]
c0d0614e:	82e0      	strh	r0, [r4, #22]
c0d06150:	7a21      	ldrb	r1, [r4, #8]
c0d06152:	4620      	mov	r0, r4
c0d06154:	f7ff fe8c 	bl	c0d05e70 <u2f_transport_sent>
}
c0d06158:	b007      	add	sp, #28
c0d0615a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0615c:	461d      	mov	r5, r3
c0d0615e:	4623      	mov	r3, r4
c0d06160:	332a      	adds	r3, #42	; 0x2a
    if (service->transportState == U2F_SENDING_ERROR) {
c0d06162:	2804      	cmp	r0, #4
c0d06164:	d109      	bne.n	c0d0617a <u2f_transport_received+0x72>
c0d06166:	202b      	movs	r0, #43	; 0x2b
c0d06168:	2100      	movs	r1, #0
    service->sending = false;
c0d0616a:	5421      	strb	r1, [r4, r0]
    service->transportPacketIndex = 0;
c0d0616c:	76a1      	strb	r1, [r4, #26]
    service->transportOffset = 0;
c0d0616e:	82e1      	strh	r1, [r4, #22]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d06170:	7019      	strb	r1, [r3, #0]
    service->transportMedia = 0;
c0d06172:	80b1      	strh	r1, [r6, #4]
c0d06174:	6031      	str	r1, [r6, #0]
    service->transportBuffer = service->transportReceiveBuffer;
c0d06176:	68e0      	ldr	r0, [r4, #12]
c0d06178:	61e0      	str	r0, [r4, #28]
c0d0617a:	9306      	str	r3, [sp, #24]
    uint16_t channelHeader = (media == U2F_MEDIA_USB ? 4 : 0);
c0d0617c:	1e68      	subs	r0, r5, #1
c0d0617e:	4241      	negs	r1, r0
c0d06180:	4141      	adcs	r1, r0
    if (size < (1 + channelHeader)) {
c0d06182:	008b      	lsls	r3, r1, #2
c0d06184:	1c58      	adds	r0, r3, #1
c0d06186:	4290      	cmp	r0, r2
c0d06188:	d82c      	bhi.n	c0d061e4 <u2f_transport_received+0xdc>
c0d0618a:	9003      	str	r0, [sp, #12]
    if (media == U2F_MEDIA_USB) {
c0d0618c:	2d01      	cmp	r5, #1
c0d0618e:	d108      	bne.n	c0d061a2 <u2f_transport_received+0x9a>
        os_memmove(service->channel, buffer, 4);
c0d06190:	1d20      	adds	r0, r4, #4
c0d06192:	9205      	str	r2, [sp, #20]
c0d06194:	2204      	movs	r2, #4
c0d06196:	4639      	mov	r1, r7
c0d06198:	9304      	str	r3, [sp, #16]
c0d0619a:	f7fd fbfe 	bl	c0d0399a <os_memmove>
c0d0619e:	9b04      	ldr	r3, [sp, #16]
c0d061a0:	9a05      	ldr	r2, [sp, #20]
    if (service->transportOffset == 0
c0d061a2:	8ae0      	ldrh	r0, [r4, #22]
        || (media == U2F_MEDIA_USB && os_memcmp(service->transportChannel, service->channel, 4) != 0) ) {
c0d061a4:	2800      	cmp	r0, #0
c0d061a6:	d00d      	beq.n	c0d061c4 <u2f_transport_received+0xbc>
c0d061a8:	2d01      	cmp	r5, #1
c0d061aa:	d117      	bne.n	c0d061dc <u2f_transport_received+0xd4>
c0d061ac:	4620      	mov	r0, r4
c0d061ae:	3012      	adds	r0, #18
c0d061b0:	1d21      	adds	r1, r4, #4
c0d061b2:	9205      	str	r2, [sp, #20]
c0d061b4:	2204      	movs	r2, #4
c0d061b6:	9304      	str	r3, [sp, #16]
c0d061b8:	f7fd fc0e 	bl	c0d039d8 <os_memcmp>
c0d061bc:	9b04      	ldr	r3, [sp, #16]
c0d061be:	9a05      	ldr	r2, [sp, #20]
    if (service->transportOffset == 0
c0d061c0:	2800      	cmp	r0, #0
c0d061c2:	d00b      	beq.n	c0d061dc <u2f_transport_received+0xd4>
c0d061c4:	2103      	movs	r1, #3
        if (size < (channelHeader + 3)) {
c0d061c6:	4618      	mov	r0, r3
c0d061c8:	4308      	orrs	r0, r1
c0d061ca:	4290      	cmp	r0, r2
c0d061cc:	d80a      	bhi.n	c0d061e4 <u2f_transport_received+0xdc>
        if ((buffer[channelHeader+0]&U2F_MASK_COMMAND) == 0) {
c0d061ce:	56f8      	ldrsb	r0, [r7, r3]
c0d061d0:	2800      	cmp	r0, #0
c0d061d2:	db28      	blt.n	c0d06226 <u2f_transport_received+0x11e>
c0d061d4:	488f      	ldr	r0, [pc, #572]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d061d6:	2104      	movs	r1, #4
c0d061d8:	7201      	strb	r1, [r0, #8]
c0d061da:	e7ae      	b.n	c0d0613a <u2f_transport_received+0x32>
c0d061dc:	2002      	movs	r0, #2
        if (size < (channelHeader + 2)) {
c0d061de:	4318      	orrs	r0, r3
c0d061e0:	4290      	cmp	r0, r2
c0d061e2:	d902      	bls.n	c0d061ea <u2f_transport_received+0xe2>
c0d061e4:	488b      	ldr	r0, [pc, #556]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d061e6:	2185      	movs	r1, #133	; 0x85
c0d061e8:	e7a5      	b.n	c0d06136 <u2f_transport_received+0x2e>
c0d061ea:	2021      	movs	r0, #33	; 0x21
        if (media != service->transportMedia) {
c0d061ec:	5c20      	ldrb	r0, [r4, r0]
c0d061ee:	42a8      	cmp	r0, r5
c0d061f0:	d116      	bne.n	c0d06220 <u2f_transport_received+0x118>
        if (service->transportState != U2F_HANDLE_SEGMENTED) {
c0d061f2:	7830      	ldrb	r0, [r6, #0]
c0d061f4:	2801      	cmp	r0, #1
c0d061f6:	d146      	bne.n	c0d06286 <u2f_transport_received+0x17e>
        if (media == U2F_MEDIA_USB) {
c0d061f8:	2d01      	cmp	r5, #1
c0d061fa:	d152      	bne.n	c0d062a2 <u2f_transport_received+0x19a>
            if (os_memcmp(buffer, service->channel, 4) != 0) {
c0d061fc:	1d21      	adds	r1, r4, #4
c0d061fe:	2004      	movs	r0, #4
c0d06200:	9006      	str	r0, [sp, #24]
c0d06202:	4638      	mov	r0, r7
c0d06204:	9205      	str	r2, [sp, #20]
c0d06206:	9a06      	ldr	r2, [sp, #24]
c0d06208:	9304      	str	r3, [sp, #16]
c0d0620a:	f7fd fbe5 	bl	c0d039d8 <os_memcmp>
c0d0620e:	9b04      	ldr	r3, [sp, #16]
c0d06210:	9a05      	ldr	r2, [sp, #20]
c0d06212:	2800      	cmp	r0, #0
c0d06214:	d045      	beq.n	c0d062a2 <u2f_transport_received+0x19a>
    G_io_usb_ep_buffer[8] = errorCode;
c0d06216:	487f      	ldr	r0, [pc, #508]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d06218:	2106      	movs	r1, #6
c0d0621a:	7201      	strb	r1, [r0, #8]
    service->transportState = U2F_SENDING_ERROR;
c0d0621c:	9906      	ldr	r1, [sp, #24]
c0d0621e:	e78c      	b.n	c0d0613a <u2f_transport_received+0x32>
    G_io_usb_ep_buffer[8] = errorCode;
c0d06220:	487c      	ldr	r0, [pc, #496]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d06222:	218d      	movs	r1, #141	; 0x8d
c0d06224:	e787      	b.n	c0d06136 <u2f_transport_received+0x2e>
c0d06226:	9102      	str	r1, [sp, #8]
c0d06228:	18f8      	adds	r0, r7, r3
        if (media == U2F_MEDIA_USB) {
c0d0622a:	9006      	str	r0, [sp, #24]
c0d0622c:	2d01      	cmp	r5, #1
c0d0622e:	d114      	bne.n	c0d0625a <u2f_transport_received+0x152>
            if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d06230:	7830      	ldrb	r0, [r6, #0]
c0d06232:	2801      	cmp	r0, #1
c0d06234:	d11a      	bne.n	c0d0626c <u2f_transport_received+0x164>
                (os_memcmp(service->channel, service->transportChannel, 4) !=
c0d06236:	1d20      	adds	r0, r4, #4
c0d06238:	4621      	mov	r1, r4
c0d0623a:	3112      	adds	r1, #18
c0d0623c:	9205      	str	r2, [sp, #20]
c0d0623e:	2204      	movs	r2, #4
c0d06240:	9001      	str	r0, [sp, #4]
c0d06242:	9304      	str	r3, [sp, #16]
c0d06244:	f7fd fbc8 	bl	c0d039d8 <os_memcmp>
c0d06248:	9b04      	ldr	r3, [sp, #16]
c0d0624a:	9a05      	ldr	r2, [sp, #20]
                 0) &&
c0d0624c:	2800      	cmp	r0, #0
c0d0624e:	d004      	beq.n	c0d0625a <u2f_transport_received+0x152>
                (buffer[channelHeader] != U2F_CMD_INIT)) {
c0d06250:	9806      	ldr	r0, [sp, #24]
c0d06252:	7800      	ldrb	r0, [r0, #0]
            if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d06254:	2886      	cmp	r0, #134	; 0x86
c0d06256:	d000      	beq.n	c0d0625a <u2f_transport_received+0x152>
c0d06258:	e0c3      	b.n	c0d063e2 <u2f_transport_received+0x2da>
        if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d0625a:	7830      	ldrb	r0, [r6, #0]
c0d0625c:	2801      	cmp	r0, #1
c0d0625e:	d105      	bne.n	c0d0626c <u2f_transport_received+0x164>
            !((media == U2F_MEDIA_USB) &&
c0d06260:	2d01      	cmp	r5, #1
c0d06262:	d1b7      	bne.n	c0d061d4 <u2f_transport_received+0xcc>
              (buffer[channelHeader] == U2F_CMD_INIT))) {
c0d06264:	9806      	ldr	r0, [sp, #24]
c0d06266:	7800      	ldrb	r0, [r0, #0]
        if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d06268:	2886      	cmp	r0, #134	; 0x86
c0d0626a:	d1b3      	bne.n	c0d061d4 <u2f_transport_received+0xcc>
c0d0626c:	9903      	ldr	r1, [sp, #12]
        uint16_t commandLength = U2BE(buffer, channelHeader + 1);
c0d0626e:	1878      	adds	r0, r7, r1
c0d06270:	7840      	ldrb	r0, [r0, #1]
c0d06272:	5c79      	ldrb	r1, [r7, r1]
c0d06274:	0209      	lsls	r1, r1, #8
c0d06276:	180f      	adds	r7, r1, r0
        if (commandLength > (service->transportReceiveBufferLength - 3)) {
c0d06278:	8a20      	ldrh	r0, [r4, #16]
c0d0627a:	1ec0      	subs	r0, r0, #3
c0d0627c:	4287      	cmp	r7, r0
c0d0627e:	dd35      	ble.n	c0d062ec <u2f_transport_received+0x1e4>
    G_io_usb_ep_buffer[8] = errorCode;
c0d06280:	4864      	ldr	r0, [pc, #400]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d06282:	9902      	ldr	r1, [sp, #8]
c0d06284:	e757      	b.n	c0d06136 <u2f_transport_received+0x2e>
            if (media == U2F_MEDIA_USB) {
c0d06286:	2d01      	cmp	r5, #1
c0d06288:	d1a4      	bne.n	c0d061d4 <u2f_transport_received+0xcc>
c0d0628a:	202b      	movs	r0, #43	; 0x2b
c0d0628c:	2100      	movs	r1, #0
    service->sending = false;
c0d0628e:	5421      	strb	r1, [r4, r0]
    service->transportPacketIndex = 0;
c0d06290:	76a1      	strb	r1, [r4, #26]
    service->transportOffset = 0;
c0d06292:	82e1      	strh	r1, [r4, #22]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d06294:	9806      	ldr	r0, [sp, #24]
c0d06296:	7001      	strb	r1, [r0, #0]
    service->transportMedia = 0;
c0d06298:	80b1      	strh	r1, [r6, #4]
c0d0629a:	6031      	str	r1, [r6, #0]
    service->transportBuffer = service->transportReceiveBuffer;
c0d0629c:	68e0      	ldr	r0, [r4, #12]
c0d0629e:	61e0      	str	r0, [r4, #28]
c0d062a0:	e75a      	b.n	c0d06158 <u2f_transport_received+0x50>
        if (buffer[channelHeader] != service->transportPacketIndex) {
c0d062a2:	5cf8      	ldrb	r0, [r7, r3]
c0d062a4:	7ea1      	ldrb	r1, [r4, #26]
c0d062a6:	4288      	cmp	r0, r1
c0d062a8:	d194      	bne.n	c0d061d4 <u2f_transport_received+0xcc>
c0d062aa:	18f9      	adds	r1, r7, r3
        xfer_len = MIN(size - (channelHeader + 1), service->transportLength - service->transportOffset);
c0d062ac:	9803      	ldr	r0, [sp, #12]
c0d062ae:	1a17      	subs	r7, r2, r0
c0d062b0:	8ae0      	ldrh	r0, [r4, #22]
c0d062b2:	8b22      	ldrh	r2, [r4, #24]
c0d062b4:	1a12      	subs	r2, r2, r0
c0d062b6:	4297      	cmp	r7, r2
c0d062b8:	db00      	blt.n	c0d062bc <u2f_transport_received+0x1b4>
c0d062ba:	4617      	mov	r7, r2
        os_memmove(service->transportBuffer + service->transportOffset, buffer + channelHeader + 1, xfer_len);
c0d062bc:	b2ba      	uxth	r2, r7
c0d062be:	69e3      	ldr	r3, [r4, #28]
c0d062c0:	1818      	adds	r0, r3, r0
c0d062c2:	1c49      	adds	r1, r1, #1
c0d062c4:	9206      	str	r2, [sp, #24]
c0d062c6:	f7fd fb68 	bl	c0d0399a <os_memmove>
        if (media == U2F_MEDIA_USB) {
c0d062ca:	2d01      	cmp	r5, #1
c0d062cc:	d107      	bne.n	c0d062de <u2f_transport_received+0x1d6>
            service->commandCrc = cx_crc16_update(service->commandCrc, service->transportBuffer + service->transportOffset, xfer_len);
c0d062ce:	8ae0      	ldrh	r0, [r4, #22]
c0d062d0:	69e1      	ldr	r1, [r4, #28]
c0d062d2:	1809      	adds	r1, r1, r0
c0d062d4:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
c0d062d6:	9a06      	ldr	r2, [sp, #24]
c0d062d8:	f7ff fb54 	bl	c0d05984 <cx_crc16_update>
c0d062dc:	84e0      	strh	r0, [r4, #38]	; 0x26
        service->transportOffset += xfer_len;
c0d062de:	8ae0      	ldrh	r0, [r4, #22]
c0d062e0:	19c0      	adds	r0, r0, r7
c0d062e2:	82e0      	strh	r0, [r4, #22]
        service->transportPacketIndex++;
c0d062e4:	7ea0      	ldrb	r0, [r4, #26]
c0d062e6:	1c40      	adds	r0, r0, #1
c0d062e8:	76a0      	strb	r0, [r4, #26]
c0d062ea:	e054      	b.n	c0d06396 <u2f_transport_received+0x28e>
        switch (buffer[channelHeader]) {
c0d062ec:	9806      	ldr	r0, [sp, #24]
c0d062ee:	7800      	ldrb	r0, [r0, #0]
c0d062f0:	2881      	cmp	r0, #129	; 0x81
c0d062f2:	d003      	beq.n	c0d062fc <u2f_transport_received+0x1f4>
c0d062f4:	2886      	cmp	r0, #134	; 0x86
c0d062f6:	d01c      	beq.n	c0d06332 <u2f_transport_received+0x22a>
c0d062f8:	2883      	cmp	r0, #131	; 0x83
c0d062fa:	d15f      	bne.n	c0d063bc <u2f_transport_received+0x2b4>
c0d062fc:	9304      	str	r3, [sp, #16]
c0d062fe:	9205      	str	r2, [sp, #20]
            if (media == U2F_MEDIA_USB) {
c0d06300:	2d01      	cmp	r5, #1
c0d06302:	d123      	bne.n	c0d0634c <u2f_transport_received+0x244>
                if (u2f_is_channel_broadcast(service->channel) ||
c0d06304:	1d20      	adds	r0, r4, #4
    return (os_memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
c0d06306:	4944      	ldr	r1, [pc, #272]	; (c0d06418 <u2f_transport_received+0x310>)
c0d06308:	4479      	add	r1, pc
c0d0630a:	2204      	movs	r2, #4
c0d0630c:	9003      	str	r0, [sp, #12]
c0d0630e:	9202      	str	r2, [sp, #8]
c0d06310:	f7fd fb62 	bl	c0d039d8 <os_memcmp>
                if (u2f_is_channel_broadcast(service->channel) ||
c0d06314:	2800      	cmp	r0, #0
c0d06316:	d007      	beq.n	c0d06328 <u2f_transport_received+0x220>
    return (os_memcmp(channel, FORBIDDEN_CHANNEL, 4) == 0);
c0d06318:	4940      	ldr	r1, [pc, #256]	; (c0d0641c <u2f_transport_received+0x314>)
c0d0631a:	4479      	add	r1, pc
c0d0631c:	2204      	movs	r2, #4
c0d0631e:	9803      	ldr	r0, [sp, #12]
c0d06320:	f7fd fb5a 	bl	c0d039d8 <os_memcmp>
                if (u2f_is_channel_broadcast(service->channel) ||
c0d06324:	2800      	cmp	r0, #0
c0d06326:	d111      	bne.n	c0d0634c <u2f_transport_received+0x244>
    G_io_usb_ep_buffer[8] = errorCode;
c0d06328:	483a      	ldr	r0, [pc, #232]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d0632a:	210b      	movs	r1, #11
c0d0632c:	7201      	strb	r1, [r0, #8]
    service->transportState = U2F_SENDING_ERROR;
c0d0632e:	9902      	ldr	r1, [sp, #8]
c0d06330:	e703      	b.n	c0d0613a <u2f_transport_received+0x32>
            if (media != U2F_MEDIA_USB) {
c0d06332:	2d01      	cmp	r5, #1
c0d06334:	d142      	bne.n	c0d063bc <u2f_transport_received+0x2b4>
c0d06336:	9304      	str	r3, [sp, #16]
c0d06338:	9205      	str	r2, [sp, #20]
            if (u2f_is_channel_forbidden(service->channel)) {
c0d0633a:	1d20      	adds	r0, r4, #4
    return (os_memcmp(channel, FORBIDDEN_CHANNEL, 4) == 0);
c0d0633c:	4938      	ldr	r1, [pc, #224]	; (c0d06420 <u2f_transport_received+0x318>)
c0d0633e:	4479      	add	r1, pc
c0d06340:	2204      	movs	r2, #4
c0d06342:	9203      	str	r2, [sp, #12]
c0d06344:	f7fd fb48 	bl	c0d039d8 <os_memcmp>
            if (u2f_is_channel_forbidden(service->channel)) {
c0d06348:	2800      	cmp	r0, #0
c0d0634a:	d05d      	beq.n	c0d06408 <u2f_transport_received+0x300>
            xfer_len = MIN(size - (channelHeader), U2F_COMMAND_HEADER_SIZE+commandLength);
c0d0634c:	9805      	ldr	r0, [sp, #20]
c0d0634e:	9904      	ldr	r1, [sp, #16]
c0d06350:	1a40      	subs	r0, r0, r1
c0d06352:	1cf9      	adds	r1, r7, #3
c0d06354:	4288      	cmp	r0, r1
c0d06356:	db00      	blt.n	c0d0635a <u2f_transport_received+0x252>
c0d06358:	4608      	mov	r0, r1
c0d0635a:	9104      	str	r1, [sp, #16]
c0d0635c:	9005      	str	r0, [sp, #20]
            os_memmove(service->transportBuffer, buffer + channelHeader, xfer_len);
c0d0635e:	b287      	uxth	r7, r0
c0d06360:	69e0      	ldr	r0, [r4, #28]
c0d06362:	9906      	ldr	r1, [sp, #24]
c0d06364:	463a      	mov	r2, r7
c0d06366:	f7fd fb18 	bl	c0d0399a <os_memmove>
            if (media == U2F_MEDIA_USB) {
c0d0636a:	2d01      	cmp	r5, #1
c0d0636c:	d105      	bne.n	c0d0637a <u2f_transport_received+0x272>
                service->commandCrc = cx_crc16_update(0, service->transportBuffer, xfer_len);
c0d0636e:	69e1      	ldr	r1, [r4, #28]
c0d06370:	2000      	movs	r0, #0
c0d06372:	463a      	mov	r2, r7
c0d06374:	f7ff fb06 	bl	c0d05984 <cx_crc16_update>
c0d06378:	84e0      	strh	r0, [r4, #38]	; 0x26
c0d0637a:	2021      	movs	r0, #33	; 0x21
            service->transportMedia = media;
c0d0637c:	5425      	strb	r5, [r4, r0]
            service->transportLength = U2F_COMMAND_HEADER_SIZE+commandLength;
c0d0637e:	9804      	ldr	r0, [sp, #16]
c0d06380:	8320      	strh	r0, [r4, #24]
            service->transportOffset = xfer_len;
c0d06382:	9805      	ldr	r0, [sp, #20]
c0d06384:	82e0      	strh	r0, [r4, #22]
c0d06386:	2000      	movs	r0, #0
            service->transportPacketIndex = 0;
c0d06388:	76a0      	strb	r0, [r4, #26]
            os_memmove(service->transportChannel, service->channel, 4);
c0d0638a:	4620      	mov	r0, r4
c0d0638c:	3012      	adds	r0, #18
c0d0638e:	1d21      	adds	r1, r4, #4
c0d06390:	2204      	movs	r2, #4
c0d06392:	f7fd fb02 	bl	c0d0399a <os_memmove>
c0d06396:	8ae0      	ldrh	r0, [r4, #22]
    if ((media != U2F_MEDIA_USB) &&
c0d06398:	2d01      	cmp	r5, #1
c0d0639a:	d101      	bne.n	c0d063a0 <u2f_transport_received+0x298>
    } else if (service->transportOffset >= service->transportLength) {
c0d0639c:	8b21      	ldrh	r1, [r4, #24]
c0d0639e:	e006      	b.n	c0d063ae <u2f_transport_received+0x2a6>
         (service->transportLength + U2F_COMMAND_HEADER_SIZE))) {
c0d063a0:	8b21      	ldrh	r1, [r4, #24]
c0d063a2:	1cca      	adds	r2, r1, #3
    if ((media != U2F_MEDIA_USB) &&
c0d063a4:	4282      	cmp	r2, r0
c0d063a6:	d202      	bcs.n	c0d063ae <u2f_transport_received+0x2a6>
    G_io_usb_ep_buffer[8] = errorCode;
c0d063a8:	481a      	ldr	r0, [pc, #104]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d063aa:	2103      	movs	r1, #3
c0d063ac:	e6c3      	b.n	c0d06136 <u2f_transport_received+0x2e>
    } else if (service->transportOffset >= service->transportLength) {
c0d063ae:	4288      	cmp	r0, r1
c0d063b0:	d211      	bcs.n	c0d063d6 <u2f_transport_received+0x2ce>
c0d063b2:	2000      	movs	r0, #0
        service->seqTimeout = 0;
c0d063b4:	6360      	str	r0, [r4, #52]	; 0x34
c0d063b6:	2001      	movs	r0, #1
        service->transportState = U2F_HANDLE_SEGMENTED;
c0d063b8:	7030      	strb	r0, [r6, #0]
c0d063ba:	e6cd      	b.n	c0d06158 <u2f_transport_received+0x50>
c0d063bc:	4815      	ldr	r0, [pc, #84]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d063be:	2101      	movs	r1, #1
c0d063c0:	7201      	strb	r1, [r0, #8]
c0d063c2:	2204      	movs	r2, #4
c0d063c4:	7032      	strb	r2, [r6, #0]
c0d063c6:	2240      	movs	r2, #64	; 0x40
c0d063c8:	23bf      	movs	r3, #191	; 0xbf
c0d063ca:	54a3      	strb	r3, [r4, r2]
c0d063cc:	3008      	adds	r0, #8
c0d063ce:	61e0      	str	r0, [r4, #28]
c0d063d0:	2000      	movs	r0, #0
c0d063d2:	76a0      	strb	r0, [r4, #26]
c0d063d4:	e6ba      	b.n	c0d0614c <u2f_transport_received+0x44>
c0d063d6:	2002      	movs	r0, #2
        service->transportState = U2F_PROCESSING_COMMAND;
c0d063d8:	7030      	strb	r0, [r6, #0]
        u2f_message_complete(service);
c0d063da:	4620      	mov	r0, r4
c0d063dc:	f7ff fd06 	bl	c0d05dec <u2f_message_complete>
c0d063e0:	e6ba      	b.n	c0d06158 <u2f_transport_received+0x50>
                    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d063e2:	4c0c      	ldr	r4, [pc, #48]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d063e4:	2204      	movs	r2, #4
c0d063e6:	4620      	mov	r0, r4
c0d063e8:	9901      	ldr	r1, [sp, #4]
c0d063ea:	f7fd fad6 	bl	c0d0399a <os_memmove>
c0d063ee:	2006      	movs	r0, #6
                G_io_usb_ep_buffer[offset++] = ERROR_CHANNEL_BUSY;
c0d063f0:	71e0      	strb	r0, [r4, #7]
c0d063f2:	2201      	movs	r2, #1
                G_io_usb_ep_buffer[offset++] = 1;
c0d063f4:	71a2      	strb	r2, [r4, #6]
c0d063f6:	2000      	movs	r0, #0
                G_io_usb_ep_buffer[offset++] = 0;
c0d063f8:	7160      	strb	r0, [r4, #5]
c0d063fa:	20bf      	movs	r0, #191	; 0xbf
                G_io_usb_ep_buffer[offset++] = U2F_STATUS_ERROR;
c0d063fc:	7120      	strb	r0, [r4, #4]
c0d063fe:	2108      	movs	r1, #8
                u2f_io_send(G_io_usb_ep_buffer, offset, media);
c0d06400:	4620      	mov	r0, r4
c0d06402:	f7ff fd11 	bl	c0d05e28 <u2f_io_send>
c0d06406:	e6a7      	b.n	c0d06158 <u2f_transport_received+0x50>
    G_io_usb_ep_buffer[8] = errorCode;
c0d06408:	4802      	ldr	r0, [pc, #8]	; (c0d06414 <u2f_transport_received+0x30c>)
c0d0640a:	210b      	movs	r1, #11
c0d0640c:	7201      	strb	r1, [r0, #8]
    service->transportState = U2F_SENDING_ERROR;
c0d0640e:	9903      	ldr	r1, [sp, #12]
c0d06410:	e693      	b.n	c0d0613a <u2f_transport_received+0x32>
c0d06412:	46c0      	nop			; (mov r8, r8)
c0d06414:	20002018 	.word	0x20002018
c0d06418:	00004208 	.word	0x00004208
c0d0641c:	000041fa 	.word	0x000041fa
c0d06420:	000041d6 	.word	0x000041d6

c0d06424 <u2f_is_channel_broadcast>:
bool u2f_is_channel_broadcast(uint8_t *channel) {
c0d06424:	b580      	push	{r7, lr}
    return (os_memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
c0d06426:	4904      	ldr	r1, [pc, #16]	; (c0d06438 <u2f_is_channel_broadcast+0x14>)
c0d06428:	4479      	add	r1, pc
c0d0642a:	2204      	movs	r2, #4
c0d0642c:	f7fd fad4 	bl	c0d039d8 <os_memcmp>
c0d06430:	4241      	negs	r1, r0
c0d06432:	4148      	adcs	r0, r1
c0d06434:	bd80      	pop	{r7, pc}
c0d06436:	46c0      	nop			; (mov r8, r8)
c0d06438:	000040e8 	.word	0x000040e8

c0d0643c <u2f_message_set_autoreply_wait_user_presence>:
void u2f_message_set_autoreply_wait_user_presence(u2f_service_t* service, bool enabled) {
c0d0643c:	b580      	push	{r7, lr}
c0d0643e:	222a      	movs	r2, #42	; 0x2a
c0d06440:	5c83      	ldrb	r3, [r0, r2]
c0d06442:	4602      	mov	r2, r0
c0d06444:	322a      	adds	r2, #42	; 0x2a
    if (enabled) {
c0d06446:	2900      	cmp	r1, #0
c0d06448:	d006      	beq.n	c0d06458 <u2f_message_set_autoreply_wait_user_presence+0x1c>
        if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE) {
c0d0644a:	2b00      	cmp	r3, #0
c0d0644c:	d108      	bne.n	c0d06460 <u2f_message_set_autoreply_wait_user_presence+0x24>
c0d0644e:	2101      	movs	r1, #1
            service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_ON;
c0d06450:	7011      	strb	r1, [r2, #0]
            u2f_transport_send_usb_user_presence_required(service);
c0d06452:	f7ff fdab 	bl	c0d05fac <u2f_transport_send_usb_user_presence_required>
}
c0d06456:	bd80      	pop	{r7, pc}
    else if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
c0d06458:	2b01      	cmp	r3, #1
c0d0645a:	d101      	bne.n	c0d06460 <u2f_message_set_autoreply_wait_user_presence+0x24>
c0d0645c:	2002      	movs	r0, #2
        service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_REPLY_READY;
c0d0645e:	7010      	strb	r0, [r2, #0]
}
c0d06460:	bd80      	pop	{r7, pc}
	...

c0d06464 <u2f_message_reply>:
        ;
}

void u2f_message_reply(u2f_service_t *service, uint8_t cmd, uint8_t *buffer, uint16_t len) {
c0d06464:	b570      	push	{r4, r5, r6, lr}
c0d06466:	4604      	mov	r4, r0
c0d06468:	202a      	movs	r0, #42	; 0x2a
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d0646a:	5c20      	ldrb	r0, [r4, r0]
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0d0646c:	2800      	cmp	r0, #0
c0d0646e:	d009      	beq.n	c0d06484 <u2f_message_reply+0x20>
c0d06470:	2801      	cmp	r0, #1
c0d06472:	d029      	beq.n	c0d064c8 <u2f_message_reply+0x64>
c0d06474:	2025      	movs	r0, #37	; 0x25
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0d06476:	5c20      	ldrb	r0, [r4, r0]
            && service->sending == false)
c0d06478:	2806      	cmp	r0, #6
c0d0647a:	d125      	bne.n	c0d064c8 <u2f_message_reply+0x64>
c0d0647c:	202b      	movs	r0, #43	; 0x2b
c0d0647e:	5c20      	ldrb	r0, [r4, r0]

    // if U2F is not ready to reply, then gently avoid replying
    if (u2f_message_repliable(service)) 
c0d06480:	2800      	cmp	r0, #0
c0d06482:	d121      	bne.n	c0d064c8 <u2f_message_reply+0x64>
c0d06484:	2020      	movs	r0, #32
c0d06486:	2503      	movs	r5, #3
    {
        service->transportState = U2F_SENDING_RESPONSE;
c0d06488:	5425      	strb	r5, [r4, r0]
c0d0648a:	2040      	movs	r0, #64	; 0x40
        service->transportPacketIndex = 0;
        service->transportBuffer = buffer;
        service->transportOffset = 0;
        service->transportLength = len;
        service->sendCmd = cmd;
c0d0648c:	5421      	strb	r1, [r4, r0]
        service->transportBuffer = buffer;
c0d0648e:	61e2      	str	r2, [r4, #28]
c0d06490:	2000      	movs	r0, #0
        service->transportPacketIndex = 0;
c0d06492:	76a0      	strb	r0, [r4, #26]
        service->transportLength = len;
c0d06494:	8323      	strh	r3, [r4, #24]
        service->transportOffset = 0;
c0d06496:	82e0      	strh	r0, [r4, #22]
c0d06498:	2021      	movs	r0, #33	; 0x21
        if (service->transportMedia != U2F_MEDIA_BLE) {
c0d0649a:	5c21      	ldrb	r1, [r4, r0]
c0d0649c:	2903      	cmp	r1, #3
c0d0649e:	d114      	bne.n	c0d064ca <u2f_message_reply+0x66>
            // pump the first message
            u2f_transport_sent(service, service->transportMedia);
        }
        else {
            while (G_io_app.apdu_state != APDU_IDLE) {
c0d064a0:	4d0c      	ldr	r5, [pc, #48]	; (c0d064d4 <u2f_message_reply+0x70>)
c0d064a2:	7828      	ldrb	r0, [r5, #0]
c0d064a4:	2800      	cmp	r0, #0
c0d064a6:	d00f      	beq.n	c0d064c8 <u2f_message_reply+0x64>
c0d064a8:	2103      	movs	r1, #3
                u2f_transport_sent(service, service->transportMedia);       
c0d064aa:	4620      	mov	r0, r4
c0d064ac:	f7ff fce0 	bl	c0d05e70 <u2f_transport_sent>
            while (G_io_app.apdu_state != APDU_IDLE) {
c0d064b0:	7828      	ldrb	r0, [r5, #0]
c0d064b2:	2800      	cmp	r0, #0
c0d064b4:	d008      	beq.n	c0d064c8 <u2f_message_reply+0x64>
c0d064b6:	4626      	mov	r6, r4
c0d064b8:	3621      	adds	r6, #33	; 0x21
                u2f_transport_sent(service, service->transportMedia);       
c0d064ba:	7831      	ldrb	r1, [r6, #0]
c0d064bc:	4620      	mov	r0, r4
c0d064be:	f7ff fcd7 	bl	c0d05e70 <u2f_transport_sent>
            while (G_io_app.apdu_state != APDU_IDLE) {
c0d064c2:	7828      	ldrb	r0, [r5, #0]
c0d064c4:	2800      	cmp	r0, #0
c0d064c6:	d1f8      	bne.n	c0d064ba <u2f_message_reply+0x56>
            }
        }
    }
}
c0d064c8:	bd70      	pop	{r4, r5, r6, pc}
            u2f_transport_sent(service, service->transportMedia);
c0d064ca:	4620      	mov	r0, r4
c0d064cc:	f7ff fcd0 	bl	c0d05e70 <u2f_transport_sent>
}
c0d064d0:	bd70      	pop	{r4, r5, r6, pc}
c0d064d2:	46c0      	nop			; (mov r8, r8)
c0d064d4:	20001fb4 	.word	0x20001fb4

c0d064d8 <io_seproxyhal_touch_address_ok>:
#include "shared_context.h"
#include "feature_getPublicKey.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_address_ok(const bagl_element_t *e) {
c0d064d8:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = set_result_get_publicKey();
c0d064da:	f7fc f9d9 	bl	c0d02890 <set_result_get_publicKey>
c0d064de:	4604      	mov	r4, r0
    G_io_apdu_buffer[tx++] = 0x90;
c0d064e0:	4808      	ldr	r0, [pc, #32]	; (c0d06504 <io_seproxyhal_touch_address_ok+0x2c>)
c0d064e2:	2190      	movs	r1, #144	; 0x90
c0d064e4:	5501      	strb	r1, [r0, r4]
c0d064e6:	1900      	adds	r0, r0, r4
c0d064e8:	2500      	movs	r5, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0d064ea:	7045      	strb	r5, [r0, #1]
    reset_app_context();
c0d064ec:	f7fc fd28 	bl	c0d02f40 <reset_app_context>
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d064f0:	1ca0      	adds	r0, r4, #2
c0d064f2:	b281      	uxth	r1, r0
c0d064f4:	2020      	movs	r0, #32
c0d064f6:	f7fd fdcd 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d064fa:	f7fc fd41 	bl	c0d02f80 <ui_idle>
    return 0;  // do not redraw the widget
c0d064fe:	4628      	mov	r0, r5
c0d06500:	bdb0      	pop	{r4, r5, r7, pc}
c0d06502:	46c0      	nop			; (mov r8, r8)
c0d06504:	20001e61 	.word	0x20001e61

c0d06508 <io_seproxyhal_touch_address_cancel>:
}

unsigned int io_seproxyhal_touch_address_cancel(const bagl_element_t *e) {
c0d06508:	b580      	push	{r7, lr}
    G_io_apdu_buffer[0] = 0x69;
c0d0650a:	4807      	ldr	r0, [pc, #28]	; (c0d06528 <io_seproxyhal_touch_address_cancel+0x20>)
c0d0650c:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0d0650e:	7041      	strb	r1, [r0, #1]
c0d06510:	2169      	movs	r1, #105	; 0x69
    G_io_apdu_buffer[0] = 0x69;
c0d06512:	7001      	strb	r1, [r0, #0]
    reset_app_context();
c0d06514:	f7fc fd14 	bl	c0d02f40 <reset_app_context>
c0d06518:	2020      	movs	r0, #32
c0d0651a:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d0651c:	f7fd fdba 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d06520:	f7fc fd2e 	bl	c0d02f80 <ui_idle>
c0d06524:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d06526:	bd80      	pop	{r7, pc}
c0d06528:	20001e61 	.word	0x20001e61

c0d0652c <io_seproxyhal_touch_signMessage_ok>:
#include "shared_context.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_signMessage_ok(const bagl_element_t *e) {
c0d0652c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0652e:	b0b3      	sub	sp, #204	; 0xcc
    uint8_t privateKeyData[32];
    uint8_t signature[100];
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0d06530:	f7fd ff3a 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.messageSigningContext.bip32Path,
                               tmpCtx.messageSigningContext.pathLength,
c0d06534:	4e29      	ldr	r6, [pc, #164]	; (c0d065dc <io_seproxyhal_touch_signMessage_ok+0xb0>)
c0d06536:	7832      	ldrb	r2, [r6, #0]
c0d06538:	2100      	movs	r1, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d0653a:	9106      	str	r1, [sp, #24]
c0d0653c:	4668      	mov	r0, sp
c0d0653e:	6001      	str	r1, [r0, #0]
c0d06540:	1d31      	adds	r1, r6, #4
c0d06542:	2521      	movs	r5, #33	; 0x21
c0d06544:	af2b      	add	r7, sp, #172	; 0xac
c0d06546:	4628      	mov	r0, r5
c0d06548:	463b      	mov	r3, r7
c0d0654a:	f7ff fa61 	bl	c0d05a10 <os_perso_derive_node_bip32>
                               privateKeyData,
                               NULL);
    io_seproxyhal_io_heartbeat();
c0d0654e:	f7fd ff2b 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d06552:	2420      	movs	r4, #32
c0d06554:	ab08      	add	r3, sp, #32
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d06556:	9304      	str	r3, [sp, #16]
c0d06558:	4628      	mov	r0, r5
c0d0655a:	4639      	mov	r1, r7
c0d0655c:	4622      	mov	r2, r4
c0d0655e:	f7ff f9c3 	bl	c0d058e8 <cx_ecfp_init_private_key>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d06562:	4638      	mov	r0, r7
c0d06564:	4621      	mov	r1, r4
c0d06566:	f003 f855 	bl	c0d09614 <explicit_bzero>
    unsigned int info = 0;
c0d0656a:	9806      	ldr	r0, [sp, #24]
c0d0656c:	9007      	str	r0, [sp, #28]
    io_seproxyhal_io_heartbeat();
c0d0656e:	f7fd ff1b 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d06572:	a807      	add	r0, sp, #28
    signatureLength = cx_ecdsa_sign(&privateKey,
c0d06574:	4669      	mov	r1, sp
c0d06576:	60c8      	str	r0, [r1, #12]
c0d06578:	2064      	movs	r0, #100	; 0x64
c0d0657a:	6088      	str	r0, [r1, #8]
c0d0657c:	af12      	add	r7, sp, #72	; 0x48
c0d0657e:	604f      	str	r7, [r1, #4]
c0d06580:	9405      	str	r4, [sp, #20]
c0d06582:	600c      	str	r4, [r1, #0]
c0d06584:	362c      	adds	r6, #44	; 0x2c
c0d06586:	4916      	ldr	r1, [pc, #88]	; (c0d065e0 <io_seproxyhal_touch_signMessage_ok+0xb4>)
c0d06588:	2203      	movs	r2, #3
c0d0658a:	9c04      	ldr	r4, [sp, #16]
c0d0658c:	4620      	mov	r0, r4
c0d0658e:	4633      	mov	r3, r6
c0d06590:	f7ff f9ca 	bl	c0d05928 <cx_ecdsa_sign>
c0d06594:	2128      	movs	r1, #40	; 0x28
                                    tmpCtx.messageSigningContext.hash,
                                    sizeof(tmpCtx.messageSigningContext.hash),
                                    signature,
                                    sizeof(signature),
                                    &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d06596:	4620      	mov	r0, r4
c0d06598:	f003 f83c 	bl	c0d09614 <explicit_bzero>
    G_io_apdu_buffer[0] = 27;
    if (info & CX_ECCINFO_PARITY_ODD) {
c0d0659c:	9907      	ldr	r1, [sp, #28]
c0d0659e:	07c8      	lsls	r0, r1, #31
c0d065a0:	d001      	beq.n	c0d065a6 <io_seproxyhal_touch_signMessage_ok+0x7a>
c0d065a2:	201c      	movs	r0, #28
c0d065a4:	e000      	b.n	c0d065a8 <io_seproxyhal_touch_signMessage_ok+0x7c>
c0d065a6:	201b      	movs	r0, #27
        G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
c0d065a8:	0789      	lsls	r1, r1, #30
c0d065aa:	d500      	bpl.n	c0d065ae <io_seproxyhal_touch_signMessage_ok+0x82>
c0d065ac:	1c80      	adds	r0, r0, #2
c0d065ae:	4c0d      	ldr	r4, [pc, #52]	; (c0d065e4 <io_seproxyhal_touch_signMessage_ok+0xb8>)
c0d065b0:	7020      	strb	r0, [r4, #0]
        G_io_apdu_buffer[0] += 2;
    }
    format_signature_out(signature);
c0d065b2:	4638      	mov	r0, r7
c0d065b4:	f7fc fd02 	bl	c0d02fbc <format_signature_out>
c0d065b8:	2042      	movs	r0, #66	; 0x42
c0d065ba:	9d06      	ldr	r5, [sp, #24]
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d065bc:	5425      	strb	r5, [r4, r0]
c0d065be:	2041      	movs	r0, #65	; 0x41
c0d065c0:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d065c2:	5421      	strb	r1, [r4, r0]
    reset_app_context();
c0d065c4:	f7fc fcbc 	bl	c0d02f40 <reset_app_context>
c0d065c8:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d065ca:	9805      	ldr	r0, [sp, #20]
c0d065cc:	f7fd fd62 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d065d0:	f7fc fcd6 	bl	c0d02f80 <ui_idle>
    return 0;  // do not redraw the widget
c0d065d4:	4628      	mov	r0, r5
c0d065d6:	b033      	add	sp, #204	; 0xcc
c0d065d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d065da:	46c0      	nop			; (mov r8, r8)
c0d065dc:	20001804 	.word	0x20001804
c0d065e0:	00000601 	.word	0x00000601
c0d065e4:	20001e61 	.word	0x20001e61

c0d065e8 <io_seproxyhal_touch_signMessage_cancel>:
}

unsigned int io_seproxyhal_touch_signMessage_cancel(const bagl_element_t *e) {
c0d065e8:	b580      	push	{r7, lr}
    reset_app_context();
c0d065ea:	f7fc fca9 	bl	c0d02f40 <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0d065ee:	4806      	ldr	r0, [pc, #24]	; (c0d06608 <io_seproxyhal_touch_signMessage_cancel+0x20>)
c0d065f0:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0d065f2:	7041      	strb	r1, [r0, #1]
c0d065f4:	2169      	movs	r1, #105	; 0x69
    G_io_apdu_buffer[0] = 0x69;
c0d065f6:	7001      	strb	r1, [r0, #0]
c0d065f8:	2020      	movs	r0, #32
c0d065fa:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d065fc:	f7fd fd4a 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d06600:	f7fc fcbe 	bl	c0d02f80 <ui_idle>
c0d06604:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d06606:	bd80      	pop	{r7, pc}
c0d06608:	20001e61 	.word	0x20001e61

c0d0660c <io_seproxyhal_touch_signMessage712_v0_ok>:
#include "shared_context.h"
#include "ui_callbacks.h"

static const uint8_t const EIP_712_MAGIC[] = {0x19, 0x01};

unsigned int io_seproxyhal_touch_signMessage712_v0_ok(const bagl_element_t *e) {
c0d0660c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0660e:	b0bb      	sub	sp, #236	; 0xec
    uint8_t hash[32];
    uint8_t signature[100];
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0d06610:	f7fd feca 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d06614:	2701      	movs	r7, #1
c0d06616:	0239      	lsls	r1, r7, #8
    cx_keccak_init(&global_sha3, 256);
c0d06618:	4c3a      	ldr	r4, [pc, #232]	; (c0d06704 <io_seproxyhal_touch_signMessage712_v0_ok+0xf8>)
c0d0661a:	4620      	mov	r0, r4
c0d0661c:	f7ff f922 	bl	c0d05864 <cx_keccak_init>
c0d06620:	2500      	movs	r5, #0
    cx_hash((cx_hash_t *) &global_sha3,
c0d06622:	4668      	mov	r0, sp
c0d06624:	6005      	str	r5, [r0, #0]
c0d06626:	6045      	str	r5, [r0, #4]
c0d06628:	4a3a      	ldr	r2, [pc, #232]	; (c0d06714 <io_seproxyhal_touch_signMessage712_v0_ok+0x108>)
c0d0662a:	447a      	add	r2, pc
c0d0662c:	2302      	movs	r3, #2
c0d0662e:	4620      	mov	r0, r4
c0d06630:	4629      	mov	r1, r5
c0d06632:	f7ff f8e7 	bl	c0d05804 <cx_hash>
            0,
            (uint8_t *) EIP_712_MAGIC,
            sizeof(EIP_712_MAGIC),
            NULL,
            0);
    cx_hash((cx_hash_t *) &global_sha3,
c0d06636:	4668      	mov	r0, sp
c0d06638:	6005      	str	r5, [r0, #0]
c0d0663a:	6045      	str	r5, [r0, #4]
c0d0663c:	4e32      	ldr	r6, [pc, #200]	; (c0d06708 <io_seproxyhal_touch_signMessage712_v0_ok+0xfc>)
c0d0663e:	4632      	mov	r2, r6
c0d06640:	322c      	adds	r2, #44	; 0x2c
c0d06642:	2420      	movs	r4, #32
c0d06644:	482f      	ldr	r0, [pc, #188]	; (c0d06704 <io_seproxyhal_touch_signMessage712_v0_ok+0xf8>)
c0d06646:	4629      	mov	r1, r5
c0d06648:	4623      	mov	r3, r4
c0d0664a:	f7ff f8db 	bl	c0d05804 <cx_hash>
            0,
            tmpCtx.messageSigningContext712.domainHash,
            sizeof(tmpCtx.messageSigningContext712.domainHash),
            NULL,
            0);
    cx_hash((cx_hash_t *) &global_sha3,
c0d0664e:	4668      	mov	r0, sp
c0d06650:	6044      	str	r4, [r0, #4]
c0d06652:	a92b      	add	r1, sp, #172	; 0xac
c0d06654:	9105      	str	r1, [sp, #20]
c0d06656:	6001      	str	r1, [r0, #0]
c0d06658:	4632      	mov	r2, r6
c0d0665a:	324c      	adds	r2, #76	; 0x4c
c0d0665c:	4829      	ldr	r0, [pc, #164]	; (c0d06704 <io_seproxyhal_touch_signMessage712_v0_ok+0xf8>)
c0d0665e:	4639      	mov	r1, r7
c0d06660:	4623      	mov	r3, r4
c0d06662:	f7ff f8cf 	bl	c0d05804 <cx_hash>
            tmpCtx.messageSigningContext712.messageHash,
            sizeof(tmpCtx.messageSigningContext712.messageHash),
            hash,
            sizeof(hash));
    PRINTF("EIP712 hash to sign %.*H\n", 32, hash);
    io_seproxyhal_io_heartbeat();
c0d06666:	f7fd fe9f 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.messageSigningContext712.bip32Path,
                               tmpCtx.messageSigningContext712.pathLength,
c0d0666a:	7832      	ldrb	r2, [r6, #0]
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d0666c:	4668      	mov	r0, sp
c0d0666e:	6005      	str	r5, [r0, #0]
c0d06670:	1d31      	adds	r1, r6, #4
c0d06672:	2621      	movs	r6, #33	; 0x21
c0d06674:	af33      	add	r7, sp, #204	; 0xcc
c0d06676:	4630      	mov	r0, r6
c0d06678:	463b      	mov	r3, r7
c0d0667a:	f7ff f9c9 	bl	c0d05a10 <os_perso_derive_node_bip32>
                               privateKeyData,
                               NULL);
    io_seproxyhal_io_heartbeat();
c0d0667e:	f7fd fe93 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d06682:	ab08      	add	r3, sp, #32
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d06684:	4630      	mov	r0, r6
c0d06686:	4639      	mov	r1, r7
c0d06688:	4622      	mov	r2, r4
c0d0668a:	461e      	mov	r6, r3
c0d0668c:	f7ff f92c 	bl	c0d058e8 <cx_ecfp_init_private_key>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d06690:	4638      	mov	r0, r7
c0d06692:	4621      	mov	r1, r4
c0d06694:	f002 ffbe 	bl	c0d09614 <explicit_bzero>
c0d06698:	9504      	str	r5, [sp, #16]
    unsigned int info = 0;
c0d0669a:	9507      	str	r5, [sp, #28]
    io_seproxyhal_io_heartbeat();
c0d0669c:	f7fd fe84 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d066a0:	a807      	add	r0, sp, #28
    signatureLength = cx_ecdsa_sign(&privateKey,
c0d066a2:	4669      	mov	r1, sp
c0d066a4:	60c8      	str	r0, [r1, #12]
c0d066a6:	2064      	movs	r0, #100	; 0x64
c0d066a8:	6088      	str	r0, [r1, #8]
c0d066aa:	af12      	add	r7, sp, #72	; 0x48
c0d066ac:	604f      	str	r7, [r1, #4]
c0d066ae:	9406      	str	r4, [sp, #24]
c0d066b0:	600c      	str	r4, [r1, #0]
c0d066b2:	4916      	ldr	r1, [pc, #88]	; (c0d0670c <io_seproxyhal_touch_signMessage712_v0_ok+0x100>)
c0d066b4:	2203      	movs	r2, #3
c0d066b6:	4630      	mov	r0, r6
c0d066b8:	9b05      	ldr	r3, [sp, #20]
c0d066ba:	f7ff f935 	bl	c0d05928 <cx_ecdsa_sign>
c0d066be:	2128      	movs	r1, #40	; 0x28
                                    hash,
                                    sizeof(hash),
                                    signature,
                                    sizeof(signature),
                                    &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d066c0:	4630      	mov	r0, r6
c0d066c2:	f002 ffa7 	bl	c0d09614 <explicit_bzero>
    G_io_apdu_buffer[0] = 27;
    if (info & CX_ECCINFO_PARITY_ODD) {
c0d066c6:	9907      	ldr	r1, [sp, #28]
c0d066c8:	07c8      	lsls	r0, r1, #31
c0d066ca:	d001      	beq.n	c0d066d0 <io_seproxyhal_touch_signMessage712_v0_ok+0xc4>
c0d066cc:	201c      	movs	r0, #28
c0d066ce:	e000      	b.n	c0d066d2 <io_seproxyhal_touch_signMessage712_v0_ok+0xc6>
c0d066d0:	201b      	movs	r0, #27
        G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
c0d066d2:	0789      	lsls	r1, r1, #30
c0d066d4:	d500      	bpl.n	c0d066d8 <io_seproxyhal_touch_signMessage712_v0_ok+0xcc>
c0d066d6:	1c80      	adds	r0, r0, #2
c0d066d8:	4d0d      	ldr	r5, [pc, #52]	; (c0d06710 <io_seproxyhal_touch_signMessage712_v0_ok+0x104>)
c0d066da:	7028      	strb	r0, [r5, #0]
        G_io_apdu_buffer[0] += 2;
    }
    format_signature_out(signature);
c0d066dc:	4638      	mov	r0, r7
c0d066de:	f7fc fc6d 	bl	c0d02fbc <format_signature_out>
c0d066e2:	2042      	movs	r0, #66	; 0x42
c0d066e4:	9c04      	ldr	r4, [sp, #16]
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d066e6:	542c      	strb	r4, [r5, r0]
c0d066e8:	2041      	movs	r0, #65	; 0x41
c0d066ea:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d066ec:	5429      	strb	r1, [r5, r0]
    reset_app_context();
c0d066ee:	f7fc fc27 	bl	c0d02f40 <reset_app_context>
c0d066f2:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d066f4:	9806      	ldr	r0, [sp, #24]
c0d066f6:	f7fd fccd 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d066fa:	f7fc fc41 	bl	c0d02f80 <ui_idle>
    return 0;  // do not redraw the widget
c0d066fe:	4620      	mov	r0, r4
c0d06700:	b03b      	add	sp, #236	; 0xec
c0d06702:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d06704:	20001cb8 	.word	0x20001cb8
c0d06708:	20001804 	.word	0x20001804
c0d0670c:	00000601 	.word	0x00000601
c0d06710:	20001e61 	.word	0x20001e61
c0d06714:	00003eee 	.word	0x00003eee

c0d06718 <io_seproxyhal_touch_signMessage712_v0_cancel>:
}

unsigned int io_seproxyhal_touch_signMessage712_v0_cancel(const bagl_element_t *e) {
c0d06718:	b580      	push	{r7, lr}
    reset_app_context();
c0d0671a:	f7fc fc11 	bl	c0d02f40 <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0d0671e:	4806      	ldr	r0, [pc, #24]	; (c0d06738 <io_seproxyhal_touch_signMessage712_v0_cancel+0x20>)
c0d06720:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0d06722:	7041      	strb	r1, [r0, #1]
c0d06724:	2169      	movs	r1, #105	; 0x69
    G_io_apdu_buffer[0] = 0x69;
c0d06726:	7001      	strb	r1, [r0, #0]
c0d06728:	2020      	movs	r0, #32
c0d0672a:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d0672c:	f7fd fcb2 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d06730:	f7fc fc26 	bl	c0d02f80 <ui_idle>
c0d06734:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d06736:	bd80      	pop	{r7, pc}
c0d06738:	20001e61 	.word	0x20001e61

c0d0673c <io_seproxyhal_touch_tx_ok>:
#include "shared_context.h"
#include "utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_tx_ok(const bagl_element_t *e) {
c0d0673c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0673e:	b0b3      	sub	sp, #204	; 0xcc
    uint8_t privateKeyData[32];
    uint8_t signature[100];
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    uint32_t v = getV(&tmpContent.txContent);
c0d06740:	4833      	ldr	r0, [pc, #204]	; (c0d06810 <io_seproxyhal_touch_tx_ok+0xd4>)
c0d06742:	f002 f82f 	bl	c0d087a4 <getV>
c0d06746:	9005      	str	r0, [sp, #20]
    io_seproxyhal_io_heartbeat();
c0d06748:	f7fd fe2e 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    os_perso_derive_node_bip32(CX_CURVE_256K1,
                               tmpCtx.transactionContext.bip32Path,
                               tmpCtx.transactionContext.pathLength,
c0d0674c:	4e31      	ldr	r6, [pc, #196]	; (c0d06814 <io_seproxyhal_touch_tx_ok+0xd8>)
c0d0674e:	7832      	ldrb	r2, [r6, #0]
c0d06750:	2100      	movs	r1, #0
    os_perso_derive_node_bip32(CX_CURVE_256K1,
c0d06752:	9106      	str	r1, [sp, #24]
c0d06754:	4668      	mov	r0, sp
c0d06756:	6001      	str	r1, [r0, #0]
c0d06758:	1d31      	adds	r1, r6, #4
c0d0675a:	2721      	movs	r7, #33	; 0x21
c0d0675c:	ad2b      	add	r5, sp, #172	; 0xac
c0d0675e:	4638      	mov	r0, r7
c0d06760:	462b      	mov	r3, r5
c0d06762:	f7ff f955 	bl	c0d05a10 <os_perso_derive_node_bip32>
c0d06766:	2420      	movs	r4, #32
c0d06768:	ab08      	add	r3, sp, #32
                               privateKeyData,
                               NULL);
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d0676a:	4638      	mov	r0, r7
c0d0676c:	4629      	mov	r1, r5
c0d0676e:	4622      	mov	r2, r4
c0d06770:	461f      	mov	r7, r3
c0d06772:	f7ff f8b9 	bl	c0d058e8 <cx_ecfp_init_private_key>
    explicit_bzero(privateKeyData, sizeof(privateKeyData));
c0d06776:	4628      	mov	r0, r5
c0d06778:	9d06      	ldr	r5, [sp, #24]
c0d0677a:	4621      	mov	r1, r4
c0d0677c:	f002 ff4a 	bl	c0d09614 <explicit_bzero>
    unsigned int info = 0;
c0d06780:	9507      	str	r5, [sp, #28]
    io_seproxyhal_io_heartbeat();
c0d06782:	f7fd fe11 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d06786:	a807      	add	r0, sp, #28
    signatureLength = cx_ecdsa_sign(&privateKey,
c0d06788:	4669      	mov	r1, sp
c0d0678a:	60c8      	str	r0, [r1, #12]
c0d0678c:	2064      	movs	r0, #100	; 0x64
c0d0678e:	6088      	str	r0, [r1, #8]
c0d06790:	a812      	add	r0, sp, #72	; 0x48
c0d06792:	6048      	str	r0, [r1, #4]
c0d06794:	600c      	str	r4, [r1, #0]
c0d06796:	362c      	adds	r6, #44	; 0x2c
c0d06798:	491f      	ldr	r1, [pc, #124]	; (c0d06818 <io_seproxyhal_touch_tx_ok+0xdc>)
c0d0679a:	2203      	movs	r2, #3
c0d0679c:	463c      	mov	r4, r7
c0d0679e:	4638      	mov	r0, r7
c0d067a0:	4633      	mov	r3, r6
c0d067a2:	f7ff f8c1 	bl	c0d05928 <cx_ecdsa_sign>
c0d067a6:	2128      	movs	r1, #40	; 0x28
                                    tmpCtx.transactionContext.hash,
                                    sizeof(tmpCtx.transactionContext.hash),
                                    signature,
                                    sizeof(signature),
                                    &info);
    explicit_bzero(&privateKey, sizeof(privateKey));
c0d067a8:	4638      	mov	r0, r7
c0d067aa:	f002 ff33 	bl	c0d09614 <explicit_bzero>
c0d067ae:	207c      	movs	r0, #124	; 0x7c
    // Parity is present in the sequence tag in the legacy API
    if (tmpContent.txContent.vLength == 0) {
c0d067b0:	4917      	ldr	r1, [pc, #92]	; (c0d06810 <io_seproxyhal_touch_tx_ok+0xd4>)
c0d067b2:	5c08      	ldrb	r0, [r1, r0]
c0d067b4:	2800      	cmp	r0, #0
c0d067b6:	d003      	beq.n	c0d067c0 <io_seproxyhal_touch_tx_ok+0x84>
        // Legacy API
        G_io_apdu_buffer[0] = 27;
    } else {
        // New API
        // Note that this is wrong for a large v, but the client can always recover
        G_io_apdu_buffer[0] = (v * 2) + 35;
c0d067b8:	9805      	ldr	r0, [sp, #20]
c0d067ba:	0040      	lsls	r0, r0, #1
c0d067bc:	3023      	adds	r0, #35	; 0x23
c0d067be:	e000      	b.n	c0d067c2 <io_seproxyhal_touch_tx_ok+0x86>
c0d067c0:	201b      	movs	r0, #27
c0d067c2:	4c16      	ldr	r4, [pc, #88]	; (c0d0681c <io_seproxyhal_touch_tx_ok+0xe0>)
c0d067c4:	7020      	strb	r0, [r4, #0]
    }
    if (info & CX_ECCINFO_PARITY_ODD) {
c0d067c6:	9907      	ldr	r1, [sp, #28]
        G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
        G_io_apdu_buffer[0] += 2;
    }
    format_signature_out(signature);
c0d067c8:	078a      	lsls	r2, r1, #30
c0d067ca:	d006      	beq.n	c0d067da <io_seproxyhal_touch_tx_ok+0x9e>
c0d067cc:	2301      	movs	r3, #1
c0d067ce:	4019      	ands	r1, r3
c0d067d0:	1840      	adds	r0, r0, r1
    if (info & CX_ECCINFO_xGTn) {
c0d067d2:	2a00      	cmp	r2, #0
c0d067d4:	d500      	bpl.n	c0d067d8 <io_seproxyhal_touch_tx_ok+0x9c>
c0d067d6:	1c80      	adds	r0, r0, #2
    format_signature_out(signature);
c0d067d8:	7020      	strb	r0, [r4, #0]
c0d067da:	a812      	add	r0, sp, #72	; 0x48
c0d067dc:	f7fc fbee 	bl	c0d02fbc <format_signature_out>
c0d067e0:	2042      	movs	r0, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d067e2:	5425      	strb	r5, [r4, r0]
c0d067e4:	2041      	movs	r0, #65	; 0x41
c0d067e6:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d067e8:	5421      	strb	r1, [r4, r0]
c0d067ea:	2020      	movs	r0, #32
c0d067ec:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d067ee:	f7fd fc51 	bl	c0d04094 <io_exchange>
    if (called_from_swap) {
c0d067f2:	480b      	ldr	r0, [pc, #44]	; (c0d06820 <io_seproxyhal_touch_tx_ok+0xe4>)
c0d067f4:	7800      	ldrb	r0, [r0, #0]
c0d067f6:	2800      	cmp	r0, #0
c0d067f8:	d002      	beq.n	c0d06800 <io_seproxyhal_touch_tx_ok+0xc4>
c0d067fa:	2000      	movs	r0, #0
        os_sched_exit(0);
c0d067fc:	f7ff f96e 	bl	c0d05adc <os_sched_exit>
    }
    reset_app_context();
c0d06800:	f7fc fb9e 	bl	c0d02f40 <reset_app_context>
    // Display back the original UX
    ui_idle();
c0d06804:	f7fc fbbc 	bl	c0d02f80 <ui_idle>
c0d06808:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d0680a:	b033      	add	sp, #204	; 0xcc
c0d0680c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0680e:	46c0      	nop			; (mov r8, r8)
c0d06810:	200018dc 	.word	0x200018dc
c0d06814:	20001804 	.word	0x20001804
c0d06818:	00000601 	.word	0x00000601
c0d0681c:	20001e61 	.word	0x20001e61
c0d06820:	2000189c 	.word	0x2000189c

c0d06824 <io_seproxyhal_touch_tx_cancel>:
}

unsigned int io_seproxyhal_touch_tx_cancel(const bagl_element_t *e) {
c0d06824:	b580      	push	{r7, lr}
    reset_app_context();
c0d06826:	f7fc fb8b 	bl	c0d02f40 <reset_app_context>
    G_io_apdu_buffer[0] = 0x69;
c0d0682a:	4806      	ldr	r0, [pc, #24]	; (c0d06844 <io_seproxyhal_touch_tx_cancel+0x20>)
c0d0682c:	2185      	movs	r1, #133	; 0x85
    G_io_apdu_buffer[1] = 0x85;
c0d0682e:	7041      	strb	r1, [r0, #1]
c0d06830:	2169      	movs	r1, #105	; 0x69
    G_io_apdu_buffer[0] = 0x69;
c0d06832:	7001      	strb	r1, [r0, #0]
c0d06834:	2020      	movs	r0, #32
c0d06836:	2102      	movs	r1, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d06838:	f7fd fc2c 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d0683c:	f7fc fba0 	bl	c0d02f80 <ui_idle>
c0d06840:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d06842:	bd80      	pop	{r7, pc}
c0d06844:	20001e61 	.word	0x20001e61

c0d06848 <io_seproxyhal_touch_data_ok>:
}

unsigned int io_seproxyhal_touch_data_ok(const bagl_element_t *e) {
c0d06848:	b580      	push	{r7, lr}
    parserStatus_e txResult = USTREAM_FINISHED;
    txResult = continueTx(&txContext);
c0d0684a:	480f      	ldr	r0, [pc, #60]	; (c0d06888 <io_seproxyhal_touch_data_ok+0x40>)
c0d0684c:	f7fb faac 	bl	c0d01da8 <continueTx>
    switch (txResult) {
c0d06850:	2801      	cmp	r0, #1
c0d06852:	dc04      	bgt.n	c0d0685e <io_seproxyhal_touch_data_ok+0x16>
c0d06854:	2800      	cmp	r0, #0
c0d06856:	d00a      	beq.n	c0d0686e <io_seproxyhal_touch_data_ok+0x26>
c0d06858:	2801      	cmp	r0, #1
c0d0685a:	d012      	beq.n	c0d06882 <io_seproxyhal_touch_data_ok+0x3a>
c0d0685c:	e002      	b.n	c0d06864 <io_seproxyhal_touch_data_ok+0x1c>
c0d0685e:	2802      	cmp	r0, #2
c0d06860:	d00c      	beq.n	c0d0687c <io_seproxyhal_touch_data_ok+0x34>
c0d06862:	2803      	cmp	r0, #3
c0d06864:	f7fc fb6c 	bl	c0d02f40 <reset_app_context>
c0d06868:	20d5      	movs	r0, #213	; 0xd5
c0d0686a:	01c0      	lsls	r0, r0, #7
c0d0686c:	e001      	b.n	c0d06872 <io_seproxyhal_touch_data_ok+0x2a>
c0d0686e:	2009      	movs	r0, #9
c0d06870:	0300      	lsls	r0, r0, #12
c0d06872:	f7fc fb97 	bl	c0d02fa4 <io_seproxyhal_send_status>
c0d06876:	f7fc fb83 	bl	c0d02f80 <ui_idle>
c0d0687a:	e002      	b.n	c0d06882 <io_seproxyhal_touch_data_ok+0x3a>
c0d0687c:	2000      	movs	r0, #0
            io_seproxyhal_send_status(0x6A80);
            ui_idle();
    }

    if (txResult == USTREAM_FINISHED) {
        finalizeParsing(false);
c0d0687e:	f7fc f9ff 	bl	c0d02c80 <finalizeParsing>
c0d06882:	2000      	movs	r0, #0
    }

    return 0;
c0d06884:	bd80      	pop	{r7, pc}
c0d06886:	46c0      	nop			; (mov r8, r8)
c0d06888:	200018a0 	.word	0x200018a0

c0d0688c <io_seproxyhal_touch_data_cancel>:
}

unsigned int io_seproxyhal_touch_data_cancel(const bagl_element_t *e) {
c0d0688c:	b580      	push	{r7, lr}
    reset_app_context();
c0d0688e:	f7fc fb57 	bl	c0d02f40 <reset_app_context>
c0d06892:	4803      	ldr	r0, [pc, #12]	; (c0d068a0 <io_seproxyhal_touch_data_cancel+0x14>)
    io_seproxyhal_send_status(0x6985);
c0d06894:	f7fc fb86 	bl	c0d02fa4 <io_seproxyhal_send_status>
    // Display back the original UX
    ui_idle();
c0d06898:	f7fc fb72 	bl	c0d02f80 <ui_idle>
c0d0689c:	2000      	movs	r0, #0
    return 0;  // do not redraw the widget
c0d0689e:	bd80      	pop	{r7, pc}
c0d068a0:	00006985 	.word	0x00006985

c0d068a4 <io_seproxyhal_touch_stark_pubkey_ok>:

#include "shared_context.h"
#include "ui_callbacks.h"
#include "feature_stark_getPublicKey.h"

unsigned int io_seproxyhal_touch_stark_pubkey_ok(const bagl_element_t *e) {
c0d068a4:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = set_result_get_stark_publicKey();
c0d068a6:	f7fc fb3d 	bl	c0d02f24 <set_result_get_stark_publicKey>
c0d068aa:	4604      	mov	r4, r0
    G_io_apdu_buffer[tx++] = 0x90;
c0d068ac:	4808      	ldr	r0, [pc, #32]	; (c0d068d0 <io_seproxyhal_touch_stark_pubkey_ok+0x2c>)
c0d068ae:	2190      	movs	r1, #144	; 0x90
c0d068b0:	5501      	strb	r1, [r0, r4]
c0d068b2:	1900      	adds	r0, r0, r4
c0d068b4:	2500      	movs	r5, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0d068b6:	7045      	strb	r5, [r0, #1]
    reset_app_context();
c0d068b8:	f7fc fb42 	bl	c0d02f40 <reset_app_context>
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d068bc:	1ca0      	adds	r0, r4, #2
c0d068be:	b281      	uxth	r1, r0
c0d068c0:	2020      	movs	r0, #32
c0d068c2:	f7fd fbe7 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d068c6:	f7fc fb5b 	bl	c0d02f80 <ui_idle>
    return 0;  // do not redraw the widget
c0d068ca:	4628      	mov	r0, r5
c0d068cc:	bdb0      	pop	{r4, r5, r7, pc}
c0d068ce:	46c0      	nop			; (mov r8, r8)
c0d068d0:	20001e61 	.word	0x20001e61

c0d068d4 <io_seproxyhal_touch_stark_ok>:

#include "shared_context.h"
#include "stark_utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_stark_ok(const bagl_element_t *e) {
c0d068d4:	b570      	push	{r4, r5, r6, lr}
c0d068d6:	b09c      	sub	sp, #112	; 0x70
    uint8_t privateKeyData[32];
    uint8_t signature[72];
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0d068d8:	f7fd fd66 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
                          tmpCtx.transactionContext.pathLength,
c0d068dc:	4818      	ldr	r0, [pc, #96]	; (c0d06940 <io_seproxyhal_touch_stark_ok+0x6c>)
c0d068de:	7801      	ldrb	r1, [r0, #0]
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
c0d068e0:	1d00      	adds	r0, r0, #4
c0d068e2:	ac14      	add	r4, sp, #80	; 0x50
c0d068e4:	4622      	mov	r2, r4
c0d068e6:	f7fe f903 	bl	c0d04af0 <starkDerivePrivateKey>
                          privateKeyData);
    io_seproxyhal_io_heartbeat();
c0d068ea:	f7fd fd5d 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d068ee:	2080      	movs	r0, #128	; 0x80
    stark_sign(signature,
               privateKeyData,
               dataContext.starkContext.w1,
               dataContext.starkContext.w2,
               dataContext.starkContext.w3,
               (dataContext.starkContext.conditional ? dataContext.starkContext.w4 : NULL));
c0d068f0:	4a14      	ldr	r2, [pc, #80]	; (c0d06944 <io_seproxyhal_touch_stark_ok+0x70>)
c0d068f2:	5c10      	ldrb	r0, [r2, r0]
c0d068f4:	2800      	cmp	r0, #0
c0d068f6:	d001      	beq.n	c0d068fc <io_seproxyhal_touch_stark_ok+0x28>
c0d068f8:	4610      	mov	r0, r2
c0d068fa:	3060      	adds	r0, #96	; 0x60
    stark_sign(signature,
c0d068fc:	4669      	mov	r1, sp
c0d068fe:	4613      	mov	r3, r2
c0d06900:	3340      	adds	r3, #64	; 0x40
c0d06902:	600b      	str	r3, [r1, #0]
c0d06904:	6048      	str	r0, [r1, #4]
c0d06906:	4613      	mov	r3, r2
c0d06908:	3320      	adds	r3, #32
c0d0690a:	ad02      	add	r5, sp, #8
c0d0690c:	4628      	mov	r0, r5
c0d0690e:	4621      	mov	r1, r4
c0d06910:	f7fe f9ea 	bl	c0d04ce8 <stark_sign>
    G_io_apdu_buffer[0] = 0;
c0d06914:	4e0c      	ldr	r6, [pc, #48]	; (c0d06948 <io_seproxyhal_touch_stark_ok+0x74>)
c0d06916:	2400      	movs	r4, #0
c0d06918:	7034      	strb	r4, [r6, #0]
    format_signature_out(signature);
c0d0691a:	4628      	mov	r0, r5
c0d0691c:	f7fc fb4e 	bl	c0d02fbc <format_signature_out>
c0d06920:	2042      	movs	r0, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d06922:	5434      	strb	r4, [r6, r0]
c0d06924:	2041      	movs	r0, #65	; 0x41
c0d06926:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d06928:	5431      	strb	r1, [r6, r0]
    reset_app_context();
c0d0692a:	f7fc fb09 	bl	c0d02f40 <reset_app_context>
c0d0692e:	2020      	movs	r0, #32
c0d06930:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d06932:	f7fd fbaf 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d06936:	f7fc fb23 	bl	c0d02f80 <ui_idle>
    return 0;  // do not redraw the widget
c0d0693a:	4620      	mov	r0, r4
c0d0693c:	b01c      	add	sp, #112	; 0x70
c0d0693e:	bd70      	pop	{r4, r5, r6, pc}
c0d06940:	20001804 	.word	0x20001804
c0d06944:	20001b40 	.word	0x20001b40
c0d06948:	20001e61 	.word	0x20001e61

c0d0694c <io_seproxyhal_touch_stark_unsafe_sign_ok>:

#include "shared_context.h"
#include "stark_utils.h"
#include "ui_callbacks.h"

unsigned int io_seproxyhal_touch_stark_unsafe_sign_ok(const bagl_element_t *e) {
c0d0694c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0694e:	b0a9      	sub	sp, #164	; 0xa4
c0d06950:	2400      	movs	r4, #0
    cx_ecfp_private_key_t privateKey;
    uint8_t privateKeyData[32];
    uint8_t signature[72];
    unsigned int info = 0;
c0d06952:	9404      	str	r4, [sp, #16]
    uint32_t tx = 0;
    io_seproxyhal_io_heartbeat();
c0d06954:	f7fd fd28 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
                          tmpCtx.transactionContext.pathLength,
c0d06958:	4819      	ldr	r0, [pc, #100]	; (c0d069c0 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x74>)
c0d0695a:	7801      	ldrb	r1, [r0, #0]
    starkDerivePrivateKey(tmpCtx.transactionContext.bip32Path,
c0d0695c:	1d00      	adds	r0, r0, #4
c0d0695e:	af17      	add	r7, sp, #92	; 0x5c
c0d06960:	463a      	mov	r2, r7
c0d06962:	f7fe f8c5 	bl	c0d04af0 <starkDerivePrivateKey>
                          privateKeyData);
    io_seproxyhal_io_heartbeat();
c0d06966:	f7fd fd1f 	bl	c0d043a8 <io_seproxyhal_io_heartbeat>
c0d0696a:	202e      	movs	r0, #46	; 0x2e
c0d0696c:	2520      	movs	r5, #32
c0d0696e:	ae1f      	add	r6, sp, #124	; 0x7c
    cx_ecfp_init_private_key(CX_CURVE_Stark256, privateKeyData, 32, &privateKey);
c0d06970:	4639      	mov	r1, r7
c0d06972:	462a      	mov	r2, r5
c0d06974:	4633      	mov	r3, r6
c0d06976:	f7fe ffb7 	bl	c0d058e8 <cx_ecfp_init_private_key>
c0d0697a:	a804      	add	r0, sp, #16
    cx_ecdsa_sign(&privateKey,
c0d0697c:	4669      	mov	r1, sp
c0d0697e:	60c8      	str	r0, [r1, #12]
c0d06980:	2048      	movs	r0, #72	; 0x48
c0d06982:	6088      	str	r0, [r1, #8]
c0d06984:	af05      	add	r7, sp, #20
c0d06986:	c1a0      	stmia	r1!, {r5, r7}
c0d06988:	4b0e      	ldr	r3, [pc, #56]	; (c0d069c4 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x78>)
c0d0698a:	3320      	adds	r3, #32
c0d0698c:	490e      	ldr	r1, [pc, #56]	; (c0d069c8 <io_seproxyhal_touch_stark_unsafe_sign_ok+0x7c>)
c0d0698e:	2203      	movs	r2, #3
c0d06990:	4630      	mov	r0, r6
c0d06992:	f7fe ffc9 	bl	c0d05928 <cx_ecdsa_sign>
                  dataContext.starkContext.w2,
                  sizeof(dataContext.starkContext.w2),
                  signature,
                  sizeof(signature),
                  &info);
    G_io_apdu_buffer[0] = 0;
c0d06996:	4e0d      	ldr	r6, [pc, #52]	; (c0d069cc <io_seproxyhal_touch_stark_unsafe_sign_ok+0x80>)
c0d06998:	7034      	strb	r4, [r6, #0]
    format_signature_out(signature);
c0d0699a:	4638      	mov	r0, r7
c0d0699c:	f7fc fb0e 	bl	c0d02fbc <format_signature_out>
c0d069a0:	2042      	movs	r0, #66	; 0x42
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
    G_io_apdu_buffer[tx++] = 0x00;
c0d069a2:	5434      	strb	r4, [r6, r0]
c0d069a4:	2041      	movs	r0, #65	; 0x41
c0d069a6:	2190      	movs	r1, #144	; 0x90
    G_io_apdu_buffer[tx++] = 0x90;
c0d069a8:	5431      	strb	r1, [r6, r0]
    reset_app_context();
c0d069aa:	f7fc fac9 	bl	c0d02f40 <reset_app_context>
c0d069ae:	2143      	movs	r1, #67	; 0x43
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d069b0:	4628      	mov	r0, r5
c0d069b2:	f7fd fb6f 	bl	c0d04094 <io_exchange>
    // Display back the original UX
    ui_idle();
c0d069b6:	f7fc fae3 	bl	c0d02f80 <ui_idle>
    return 0;  // do not redraw the widget
c0d069ba:	4620      	mov	r0, r4
c0d069bc:	b029      	add	sp, #164	; 0xa4
c0d069be:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d069c0:	20001804 	.word	0x20001804
c0d069c4:	20001b40 	.word	0x20001b40
c0d069c8:	00000601 	.word	0x00000601
c0d069cc:	20001e61 	.word	0x20001e61

c0d069d0 <ux_idle_flow_3_step_validateinit>:
    bn,
    {
      "Version",
      APPVERSION,
    });
UX_STEP_CB(
c0d069d0:	b580      	push	{r7, lr}
c0d069d2:	f000 f801 	bl	c0d069d8 <display_settings>
c0d069d6:	bd80      	pop	{r7, pc}

c0d069d8 <display_settings>:
UX_FLOW(ux_settings_flow,
        &ux_settings_flow_1_step,
        &ux_settings_flow_2_step,
        &ux_settings_flow_3_step);

void display_settings() {
c0d069d8:	b5b0      	push	{r4, r5, r7, lr}
    strcpy(strings.common.fullAddress, (N_storage.dataAllowed ? "Allowed" : "NOT Allowed"));
c0d069da:	4d14      	ldr	r5, [pc, #80]	; (c0d06a2c <display_settings+0x54>)
c0d069dc:	447d      	add	r5, pc
c0d069de:	4628      	mov	r0, r5
c0d069e0:	f7fd fff8 	bl	c0d049d4 <pic>
c0d069e4:	7800      	ldrb	r0, [r0, #0]
c0d069e6:	2800      	cmp	r0, #0
c0d069e8:	d002      	beq.n	c0d069f0 <display_settings+0x18>
c0d069ea:	4912      	ldr	r1, [pc, #72]	; (c0d06a34 <display_settings+0x5c>)
c0d069ec:	4479      	add	r1, pc
c0d069ee:	e001      	b.n	c0d069f4 <display_settings+0x1c>
c0d069f0:	490f      	ldr	r1, [pc, #60]	; (c0d06a30 <display_settings+0x58>)
c0d069f2:	4479      	add	r1, pc
c0d069f4:	4c0c      	ldr	r4, [pc, #48]	; (c0d06a28 <display_settings+0x50>)
c0d069f6:	4620      	mov	r0, r4
c0d069f8:	f002 ffb4 	bl	c0d09964 <strcpy>
    strcpy(strings.common.fullAddress + 20,
           (N_storage.contractDetails ? "Displayed" : "NOT Displayed"));
c0d069fc:	4628      	mov	r0, r5
c0d069fe:	f7fd ffe9 	bl	c0d049d4 <pic>
c0d06a02:	7840      	ldrb	r0, [r0, #1]
c0d06a04:	2800      	cmp	r0, #0
c0d06a06:	d002      	beq.n	c0d06a0e <display_settings+0x36>
c0d06a08:	490c      	ldr	r1, [pc, #48]	; (c0d06a3c <display_settings+0x64>)
c0d06a0a:	4479      	add	r1, pc
c0d06a0c:	e001      	b.n	c0d06a12 <display_settings+0x3a>
c0d06a0e:	490a      	ldr	r1, [pc, #40]	; (c0d06a38 <display_settings+0x60>)
c0d06a10:	4479      	add	r1, pc
    strcpy(strings.common.fullAddress + 20,
c0d06a12:	3414      	adds	r4, #20
c0d06a14:	4620      	mov	r0, r4
c0d06a16:	f002 ffa5 	bl	c0d09964 <strcpy>
    ux_flow_init(0, ux_settings_flow, NULL);
c0d06a1a:	4909      	ldr	r1, [pc, #36]	; (c0d06a40 <display_settings+0x68>)
c0d06a1c:	4479      	add	r1, pc
c0d06a1e:	2000      	movs	r0, #0
c0d06a20:	4602      	mov	r2, r0
c0d06a22:	f002 f8b7 	bl	c0d08b94 <ux_flow_init>
}
c0d06a26:	bdb0      	pop	{r4, r5, r7, pc}
c0d06a28:	20001c26 	.word	0x20001c26
c0d06a2c:	00004d20 	.word	0x00004d20
c0d06a30:	00003b77 	.word	0x00003b77
c0d06a34:	00003b81 	.word	0x00003b81
c0d06a38:	00003b65 	.word	0x00003b65
c0d06a3c:	00003b6f 	.word	0x00003b6f
c0d06a40:	00003ca0 	.word	0x00003ca0

c0d06a44 <ux_idle_flow_4_step_validateinit>:
UX_STEP_CB(
c0d06a44:	b580      	push	{r7, lr}
c0d06a46:	20ff      	movs	r0, #255	; 0xff
c0d06a48:	f7ff f848 	bl	c0d05adc <os_sched_exit>
c0d06a4c:	bd80      	pop	{r7, pc}

c0d06a4e <ux_settings_flow_1_step_validateinit>:
UX_STEP_CB(
c0d06a4e:	b580      	push	{r7, lr}
c0d06a50:	f000 f802 	bl	c0d06a58 <switch_settings_contract_data>
c0d06a54:	bd80      	pop	{r7, pc}
	...

c0d06a58 <switch_settings_contract_data>:

void switch_settings_contract_data() {
c0d06a58:	b5b0      	push	{r4, r5, r7, lr}
c0d06a5a:	b082      	sub	sp, #8
    uint8_t value = (N_storage.dataAllowed ? 0 : 1);
c0d06a5c:	4c0a      	ldr	r4, [pc, #40]	; (c0d06a88 <switch_settings_contract_data+0x30>)
c0d06a5e:	447c      	add	r4, pc
c0d06a60:	4620      	mov	r0, r4
c0d06a62:	f7fd ffb7 	bl	c0d049d4 <pic>
c0d06a66:	7800      	ldrb	r0, [r0, #0]
c0d06a68:	4241      	negs	r1, r0
c0d06a6a:	4141      	adcs	r1, r0
c0d06a6c:	ad01      	add	r5, sp, #4
c0d06a6e:	7029      	strb	r1, [r5, #0]
    nvm_write((void*) &N_storage.dataAllowed, (void*) &value, sizeof(uint8_t));
c0d06a70:	4620      	mov	r0, r4
c0d06a72:	f7fd ffaf 	bl	c0d049d4 <pic>
c0d06a76:	2201      	movs	r2, #1
c0d06a78:	4629      	mov	r1, r5
c0d06a7a:	f7fe fea7 	bl	c0d057cc <nvm_write>
    display_settings();
c0d06a7e:	f7ff ffab 	bl	c0d069d8 <display_settings>
}
c0d06a82:	b002      	add	sp, #8
c0d06a84:	bdb0      	pop	{r4, r5, r7, pc}
c0d06a86:	46c0      	nop			; (mov r8, r8)
c0d06a88:	00004c9e 	.word	0x00004c9e

c0d06a8c <ux_settings_flow_2_step_validateinit>:
UX_STEP_CB(
c0d06a8c:	b580      	push	{r7, lr}
c0d06a8e:	f000 f801 	bl	c0d06a94 <switch_settings_display_data>
c0d06a92:	bd80      	pop	{r7, pc}

c0d06a94 <switch_settings_display_data>:

void switch_settings_display_data() {
c0d06a94:	b5b0      	push	{r4, r5, r7, lr}
c0d06a96:	b082      	sub	sp, #8
    uint8_t value = (N_storage.contractDetails ? 0 : 1);
c0d06a98:	4c0a      	ldr	r4, [pc, #40]	; (c0d06ac4 <switch_settings_display_data+0x30>)
c0d06a9a:	447c      	add	r4, pc
c0d06a9c:	4620      	mov	r0, r4
c0d06a9e:	f7fd ff99 	bl	c0d049d4 <pic>
c0d06aa2:	7840      	ldrb	r0, [r0, #1]
c0d06aa4:	4241      	negs	r1, r0
c0d06aa6:	4141      	adcs	r1, r0
c0d06aa8:	ad01      	add	r5, sp, #4
c0d06aaa:	7029      	strb	r1, [r5, #0]
    nvm_write((void*) &N_storage.contractDetails, (void*) &value, sizeof(uint8_t));
c0d06aac:	4620      	mov	r0, r4
c0d06aae:	f7fd ff91 	bl	c0d049d4 <pic>
c0d06ab2:	1c40      	adds	r0, r0, #1
c0d06ab4:	2201      	movs	r2, #1
c0d06ab6:	4629      	mov	r1, r5
c0d06ab8:	f7fe fe88 	bl	c0d057cc <nvm_write>
    display_settings();
c0d06abc:	f7ff ff8c 	bl	c0d069d8 <display_settings>
}
c0d06ac0:	b002      	add	sp, #8
c0d06ac2:	bdb0      	pop	{r4, r5, r7, pc}
c0d06ac4:	00004c62 	.word	0x00004c62

c0d06ac8 <ux_settings_flow_3_step_validateinit>:
UX_STEP_CB(
c0d06ac8:	b580      	push	{r7, lr}
c0d06aca:	f7fc fa59 	bl	c0d02f80 <ui_idle>
c0d06ace:	bd80      	pop	{r7, pc}

c0d06ad0 <ux_display_public_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Address",
      .text = strings.common.fullAddress,
    });
UX_STEP_CB(
c0d06ad0:	b580      	push	{r7, lr}
c0d06ad2:	2000      	movs	r0, #0
c0d06ad4:	f7ff fd00 	bl	c0d064d8 <io_seproxyhal_touch_address_ok>
c0d06ad8:	bd80      	pop	{r7, pc}

c0d06ada <ux_display_public_flow_4_step_validateinit>:
    io_seproxyhal_touch_address_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0d06ada:	b580      	push	{r7, lr}
c0d06adc:	2000      	movs	r0, #0
c0d06ade:	f7ff fd13 	bl	c0d06508 <io_seproxyhal_touch_address_cancel>
c0d06ae2:	bd80      	pop	{r7, pc}

c0d06ae4 <ux_sign_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Message hash",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0d06ae4:	b580      	push	{r7, lr}
c0d06ae6:	2000      	movs	r0, #0
c0d06ae8:	f7ff fd20 	bl	c0d0652c <io_seproxyhal_touch_signMessage_ok>
c0d06aec:	bd80      	pop	{r7, pc}

c0d06aee <ux_sign_flow_4_step_validateinit>:
    {
      &C_icon_validate_14,
      "Sign",
      "message",
    });
UX_STEP_CB(
c0d06aee:	b580      	push	{r7, lr}
c0d06af0:	2000      	movs	r0, #0
c0d06af2:	f7ff fd79 	bl	c0d065e8 <io_seproxyhal_touch_signMessage_cancel>
c0d06af6:	bd80      	pop	{r7, pc}

c0d06af8 <ux_sign_712_v0_flow_2_step_init>:
    {
      &C_icon_certificate,
      "Sign",
      "typed message",
    });
UX_STEP_NOCB_INIT(
c0d06af8:	b510      	push	{r4, lr}
c0d06afa:	b082      	sub	sp, #8
c0d06afc:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, 70, "0x%.*H", 32, tmpCtx.messageSigningContext712.domainHash);
c0d06afe:	4808      	ldr	r0, [pc, #32]	; (c0d06b20 <ux_sign_712_v0_flow_2_step_init+0x28>)
c0d06b00:	302c      	adds	r0, #44	; 0x2c
c0d06b02:	4669      	mov	r1, sp
c0d06b04:	6008      	str	r0, [r1, #0]
c0d06b06:	4807      	ldr	r0, [pc, #28]	; (c0d06b24 <ux_sign_712_v0_flow_2_step_init+0x2c>)
c0d06b08:	2146      	movs	r1, #70	; 0x46
c0d06b0a:	4a07      	ldr	r2, [pc, #28]	; (c0d06b28 <ux_sign_712_v0_flow_2_step_init+0x30>)
c0d06b0c:	447a      	add	r2, pc
c0d06b0e:	2320      	movs	r3, #32
c0d06b10:	f7fd fd8c 	bl	c0d0462c <snprintf>
UX_STEP_NOCB_INIT(
c0d06b14:	4620      	mov	r0, r4
c0d06b16:	f002 fa9b 	bl	c0d09050 <ux_layout_paging_init>
c0d06b1a:	b002      	add	sp, #8
c0d06b1c:	bd10      	pop	{r4, pc}
c0d06b1e:	46c0      	nop			; (mov r8, r8)
c0d06b20:	20001804 	.word	0x20001804
c0d06b24:	20001c26 	.word	0x20001c26
c0d06b28:	000030eb 	.word	0x000030eb

c0d06b2c <ux_sign_712_v0_flow_3_step_init>:
    prepare_domain_hash_v0(),
    {
      .title = "Domain hash",
      .text = strings.tmp.tmp,
    });
UX_STEP_NOCB_INIT(
c0d06b2c:	b510      	push	{r4, lr}
c0d06b2e:	b082      	sub	sp, #8
c0d06b30:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, 70, "0x%.*H", 32, tmpCtx.messageSigningContext712.messageHash);
c0d06b32:	4808      	ldr	r0, [pc, #32]	; (c0d06b54 <ux_sign_712_v0_flow_3_step_init+0x28>)
c0d06b34:	304c      	adds	r0, #76	; 0x4c
c0d06b36:	4669      	mov	r1, sp
c0d06b38:	6008      	str	r0, [r1, #0]
c0d06b3a:	4807      	ldr	r0, [pc, #28]	; (c0d06b58 <ux_sign_712_v0_flow_3_step_init+0x2c>)
c0d06b3c:	2146      	movs	r1, #70	; 0x46
c0d06b3e:	4a07      	ldr	r2, [pc, #28]	; (c0d06b5c <ux_sign_712_v0_flow_3_step_init+0x30>)
c0d06b40:	447a      	add	r2, pc
c0d06b42:	2320      	movs	r3, #32
c0d06b44:	f7fd fd72 	bl	c0d0462c <snprintf>
UX_STEP_NOCB_INIT(
c0d06b48:	4620      	mov	r0, r4
c0d06b4a:	f002 fa81 	bl	c0d09050 <ux_layout_paging_init>
c0d06b4e:	b002      	add	sp, #8
c0d06b50:	bd10      	pop	{r4, pc}
c0d06b52:	46c0      	nop			; (mov r8, r8)
c0d06b54:	20001804 	.word	0x20001804
c0d06b58:	20001c26 	.word	0x20001c26
c0d06b5c:	000030b7 	.word	0x000030b7

c0d06b60 <ux_sign_712_v0_flow_4_step_validateinit>:
    prepare_message_hash_v0(),
    {
      .title = "Message hash",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0d06b60:	b580      	push	{r7, lr}
c0d06b62:	2000      	movs	r0, #0
c0d06b64:	f7ff fd52 	bl	c0d0660c <io_seproxyhal_touch_signMessage712_v0_ok>
c0d06b68:	bd80      	pop	{r7, pc}

c0d06b6a <ux_sign_712_v0_flow_5_step_validateinit>:
    {
      &C_icon_validate_14,
      "Sign",
      "message",
    });
UX_STEP_CB(
c0d06b6a:	b580      	push	{r7, lr}
c0d06b6c:	2000      	movs	r0, #0
c0d06b6e:	f7ff fdd3 	bl	c0d06718 <io_seproxyhal_touch_signMessage712_v0_cancel>
c0d06b72:	bd80      	pop	{r7, pc}

c0d06b74 <ux_confirm_selector_flow_3_step_validateinit>:
    bn,
    {
      "Selector",
      strings.tmp.tmp
    });
UX_STEP_CB(
c0d06b74:	b580      	push	{r7, lr}
c0d06b76:	2000      	movs	r0, #0
c0d06b78:	f7ff fe66 	bl	c0d06848 <io_seproxyhal_touch_data_ok>
c0d06b7c:	bd80      	pop	{r7, pc}

c0d06b7e <ux_confirm_selector_flow_4_step_validateinit>:
    io_seproxyhal_touch_data_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0d06b7e:	b580      	push	{r7, lr}
c0d06b80:	2000      	movs	r0, #0
c0d06b82:	f7ff fe83 	bl	c0d0688c <io_seproxyhal_touch_data_cancel>
c0d06b86:	bd80      	pop	{r7, pc}

c0d06b88 <ux_confirm_parameter_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Parameter",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0d06b88:	b580      	push	{r7, lr}
c0d06b8a:	2000      	movs	r0, #0
c0d06b8c:	f7ff fe5c 	bl	c0d06848 <io_seproxyhal_touch_data_ok>
c0d06b90:	bd80      	pop	{r7, pc}

c0d06b92 <ux_confirm_parameter_flow_4_step_validateinit>:
    io_seproxyhal_touch_data_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0d06b92:	b580      	push	{r7, lr}
c0d06b94:	2000      	movs	r0, #0
c0d06b96:	f7ff fe79 	bl	c0d0688c <io_seproxyhal_touch_data_cancel>
c0d06b9a:	bd80      	pop	{r7, pc}

c0d06b9c <ux_approval_tx_5_step_validateinit>:
    bnnn_paging,
    {
      .title = "Max Fees",
      .text = strings.common.maxFee,
    });
UX_STEP_CB(
c0d06b9c:	b580      	push	{r7, lr}
c0d06b9e:	2000      	movs	r0, #0
c0d06ba0:	f7ff fdcc 	bl	c0d0673c <io_seproxyhal_touch_tx_ok>
c0d06ba4:	bd80      	pop	{r7, pc}

c0d06ba6 <ux_approval_tx_6_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0d06ba6:	b580      	push	{r7, lr}
c0d06ba8:	2000      	movs	r0, #0
c0d06baa:	f7ff fe3b 	bl	c0d06824 <io_seproxyhal_touch_tx_cancel>
c0d06bae:	bd80      	pop	{r7, pc}

c0d06bb0 <ux_display_stark_public_flow_3_step_validateinit>:
    bnnn_paging,
    {
      .title = "Stark Key",
      .text = strings.tmp.tmp,
    });
UX_STEP_CB(
c0d06bb0:	b580      	push	{r7, lr}
c0d06bb2:	2000      	movs	r0, #0
c0d06bb4:	f7ff fe76 	bl	c0d068a4 <io_seproxyhal_touch_stark_pubkey_ok>
c0d06bb8:	bd80      	pop	{r7, pc}

c0d06bba <ux_display_stark_public_flow_4_step_validateinit>:
    io_seproxyhal_touch_stark_pubkey_ok(NULL),
    {
      &C_icon_validate_14,
      "Approve",
    });
UX_STEP_CB(
c0d06bba:	b580      	push	{r7, lr}
c0d06bbc:	2000      	movs	r0, #0
c0d06bbe:	f7ff fca3 	bl	c0d06508 <io_seproxyhal_touch_address_cancel>
c0d06bc2:	bd80      	pop	{r7, pc}

c0d06bc4 <ux_stark_limit_order_7_step_validateinit>:
    {
      .title = "Token Account",
      .text = strings.common.fullAddress
    });

UX_STEP_CB(
c0d06bc4:	b580      	push	{r7, lr}
c0d06bc6:	2000      	movs	r0, #0
c0d06bc8:	f7ff fe84 	bl	c0d068d4 <io_seproxyhal_touch_stark_ok>
c0d06bcc:	bd80      	pop	{r7, pc}

c0d06bce <ux_stark_limit_order_8_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0d06bce:	b580      	push	{r7, lr}
c0d06bd0:	2000      	movs	r0, #0
c0d06bd2:	f7ff fe27 	bl	c0d06824 <io_seproxyhal_touch_tx_cancel>
c0d06bd6:	bd80      	pop	{r7, pc}

c0d06bd8 <ux_stark_transfer_6_step_validateinit>:
    {
      .title = "Token Account",
      .text = strings.tmp.tmp2
    });

UX_STEP_CB(
c0d06bd8:	b580      	push	{r7, lr}
c0d06bda:	2000      	movs	r0, #0
c0d06bdc:	f7ff fe7a 	bl	c0d068d4 <io_seproxyhal_touch_stark_ok>
c0d06be0:	bd80      	pop	{r7, pc}

c0d06be2 <ux_stark_transfer_7_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0d06be2:	b580      	push	{r7, lr}
c0d06be4:	2000      	movs	r0, #0
c0d06be6:	f7ff fe1d 	bl	c0d06824 <io_seproxyhal_touch_tx_cancel>
c0d06bea:	bd80      	pop	{r7, pc}

c0d06bec <ux_stark_conditional_transfer_4_step_init>:
    {
      &C_icon_crossmark,
      "Reject",
    });

UX_STEP_NOCB_INIT(
c0d06bec:	b510      	push	{r4, lr}
c0d06bee:	b082      	sub	sp, #8
c0d06bf0:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp,
c0d06bf2:	4808      	ldr	r0, [pc, #32]	; (c0d06c14 <ux_stark_conditional_transfer_4_step_init+0x28>)
c0d06bf4:	3081      	adds	r0, #129	; 0x81
c0d06bf6:	4669      	mov	r1, sp
c0d06bf8:	6008      	str	r0, [r1, #0]
c0d06bfa:	4807      	ldr	r0, [pc, #28]	; (c0d06c18 <ux_stark_conditional_transfer_4_step_init+0x2c>)
c0d06bfc:	2164      	movs	r1, #100	; 0x64
c0d06bfe:	4a07      	ldr	r2, [pc, #28]	; (c0d06c1c <ux_stark_conditional_transfer_4_step_init+0x30>)
c0d06c00:	447a      	add	r2, pc
c0d06c02:	2320      	movs	r3, #32
c0d06c04:	f7fd fd12 	bl	c0d0462c <snprintf>
UX_STEP_NOCB_INIT(
c0d06c08:	4620      	mov	r0, r4
c0d06c0a:	f002 fa21 	bl	c0d09050 <ux_layout_paging_init>
c0d06c0e:	b002      	add	sp, #8
c0d06c10:	bd10      	pop	{r4, pc}
c0d06c12:	46c0      	nop			; (mov r8, r8)
c0d06c14:	20001b40 	.word	0x20001b40
c0d06c18:	20001c26 	.word	0x20001c26
c0d06c1c:	00002ff7 	.word	0x00002ff7

c0d06c20 <ux_stark_conditional_transfer_8_step_init>:
    {
      .title = "Master Account",
      .text = strings.tmp.tmp
    });

UX_STEP_NOCB_INIT(
c0d06c20:	b5b0      	push	{r4, r5, r7, lr}
c0d06c22:	4604      	mov	r4, r0
    strings.tmp.tmp[0] = '0';
c0d06c24:	4d09      	ldr	r5, [pc, #36]	; (c0d06c4c <ux_stark_conditional_transfer_8_step_init+0x2c>)
c0d06c26:	2078      	movs	r0, #120	; 0x78
    strings.tmp.tmp[1] = 'x';
c0d06c28:	7068      	strb	r0, [r5, #1]
c0d06c2a:	2030      	movs	r0, #48	; 0x30
    strings.tmp.tmp[0] = '0';
c0d06c2c:	7028      	strb	r0, [r5, #0]
                                  chainConfig);
c0d06c2e:	4808      	ldr	r0, [pc, #32]	; (c0d06c50 <ux_stark_conditional_transfer_8_step_init+0x30>)
c0d06c30:	6803      	ldr	r3, [r0, #0]
    getEthAddressStringFromBinary(dataContext.starkContext.conditionAddress,
c0d06c32:	4808      	ldr	r0, [pc, #32]	; (c0d06c54 <ux_stark_conditional_transfer_8_step_init+0x34>)
c0d06c34:	30c1      	adds	r0, #193	; 0xc1
c0d06c36:	1ca9      	adds	r1, r5, #2
c0d06c38:	4a07      	ldr	r2, [pc, #28]	; (c0d06c58 <ux_stark_conditional_transfer_8_step_init+0x38>)
c0d06c3a:	f7fb f99b 	bl	c0d01f74 <getEthAddressStringFromBinary>
c0d06c3e:	202a      	movs	r0, #42	; 0x2a
c0d06c40:	2100      	movs	r1, #0
    strings.tmp.tmp[42] = '\0';
c0d06c42:	5429      	strb	r1, [r5, r0]
UX_STEP_NOCB_INIT(
c0d06c44:	4620      	mov	r0, r4
c0d06c46:	f002 fa03 	bl	c0d09050 <ux_layout_paging_init>
c0d06c4a:	bdb0      	pop	{r4, r5, r7, pc}
c0d06c4c:	20001c26 	.word	0x20001c26
c0d06c50:	20001b3c 	.word	0x20001b3c
c0d06c54:	20001b40 	.word	0x20001b40
c0d06c58:	20001cb8 	.word	0x20001cb8

c0d06c5c <ux_stark_conditional_transfer_9_step_init>:
    {
      .title = "Cond. Address",
      .text = strings.tmp.tmp
    });

UX_STEP_NOCB_INIT(
c0d06c5c:	b510      	push	{r4, lr}
c0d06c5e:	b082      	sub	sp, #8
c0d06c60:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.fact);
c0d06c62:	4808      	ldr	r0, [pc, #32]	; (c0d06c84 <ux_stark_conditional_transfer_9_step_init+0x28>)
c0d06c64:	30a1      	adds	r0, #161	; 0xa1
c0d06c66:	4669      	mov	r1, sp
c0d06c68:	6008      	str	r0, [r1, #0]
c0d06c6a:	4807      	ldr	r0, [pc, #28]	; (c0d06c88 <ux_stark_conditional_transfer_9_step_init+0x2c>)
c0d06c6c:	2164      	movs	r1, #100	; 0x64
c0d06c6e:	4a07      	ldr	r2, [pc, #28]	; (c0d06c8c <ux_stark_conditional_transfer_9_step_init+0x30>)
c0d06c70:	447a      	add	r2, pc
c0d06c72:	2320      	movs	r3, #32
c0d06c74:	f7fd fcda 	bl	c0d0462c <snprintf>
UX_STEP_NOCB_INIT(
c0d06c78:	4620      	mov	r0, r4
c0d06c7a:	f002 f9e9 	bl	c0d09050 <ux_layout_paging_init>
c0d06c7e:	b002      	add	sp, #8
c0d06c80:	bd10      	pop	{r4, pc}
c0d06c82:	46c0      	nop			; (mov r8, r8)
c0d06c84:	20001b40 	.word	0x20001b40
c0d06c88:	20001c26 	.word	0x20001c26
c0d06c8c:	00002f87 	.word	0x00002f87

c0d06c90 <ux_stark_unsafe_sign_2_step_init>:
      &C_icon_warning,
      "Unsafe",
      "Stark Sign",
    });

UX_STEP_NOCB_INIT(
c0d06c90:	b510      	push	{r4, lr}
c0d06c92:	b082      	sub	sp, #8
c0d06c94:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.w1);
c0d06c96:	4807      	ldr	r0, [pc, #28]	; (c0d06cb4 <ux_stark_unsafe_sign_2_step_init+0x24>)
c0d06c98:	4669      	mov	r1, sp
c0d06c9a:	6008      	str	r0, [r1, #0]
c0d06c9c:	4806      	ldr	r0, [pc, #24]	; (c0d06cb8 <ux_stark_unsafe_sign_2_step_init+0x28>)
c0d06c9e:	2164      	movs	r1, #100	; 0x64
c0d06ca0:	4a06      	ldr	r2, [pc, #24]	; (c0d06cbc <ux_stark_unsafe_sign_2_step_init+0x2c>)
c0d06ca2:	447a      	add	r2, pc
c0d06ca4:	2320      	movs	r3, #32
c0d06ca6:	f7fd fcc1 	bl	c0d0462c <snprintf>
UX_STEP_NOCB_INIT(
c0d06caa:	4620      	mov	r0, r4
c0d06cac:	f002 f9d0 	bl	c0d09050 <ux_layout_paging_init>
c0d06cb0:	b002      	add	sp, #8
c0d06cb2:	bd10      	pop	{r4, pc}
c0d06cb4:	20001b40 	.word	0x20001b40
c0d06cb8:	20001c26 	.word	0x20001c26
c0d06cbc:	00002f55 	.word	0x00002f55

c0d06cc0 <ux_stark_unsafe_sign_3_step_init>:
  {
    .title = "From Account",
    .text = strings.tmp.tmp
  });

UX_STEP_NOCB_INIT(
c0d06cc0:	b510      	push	{r4, lr}
c0d06cc2:	b082      	sub	sp, #8
c0d06cc4:	4604      	mov	r4, r0
    snprintf(strings.tmp.tmp, sizeof(strings.tmp.tmp), "0x%.*H", 32, dataContext.starkContext.w2);
c0d06cc6:	4808      	ldr	r0, [pc, #32]	; (c0d06ce8 <ux_stark_unsafe_sign_3_step_init+0x28>)
c0d06cc8:	3020      	adds	r0, #32
c0d06cca:	4669      	mov	r1, sp
c0d06ccc:	6008      	str	r0, [r1, #0]
c0d06cce:	4807      	ldr	r0, [pc, #28]	; (c0d06cec <ux_stark_unsafe_sign_3_step_init+0x2c>)
c0d06cd0:	2164      	movs	r1, #100	; 0x64
c0d06cd2:	4a07      	ldr	r2, [pc, #28]	; (c0d06cf0 <ux_stark_unsafe_sign_3_step_init+0x30>)
c0d06cd4:	447a      	add	r2, pc
c0d06cd6:	2320      	movs	r3, #32
c0d06cd8:	f7fd fca8 	bl	c0d0462c <snprintf>
UX_STEP_NOCB_INIT(
c0d06cdc:	4620      	mov	r0, r4
c0d06cde:	f002 f9b7 	bl	c0d09050 <ux_layout_paging_init>
c0d06ce2:	b002      	add	sp, #8
c0d06ce4:	bd10      	pop	{r4, pc}
c0d06ce6:	46c0      	nop			; (mov r8, r8)
c0d06ce8:	20001b40 	.word	0x20001b40
c0d06cec:	20001c26 	.word	0x20001c26
c0d06cf0:	00002f23 	.word	0x00002f23

c0d06cf4 <ux_stark_unsafe_sign_4_step_validateinit>:
    .title = "Hash",
    .text = strings.tmp.tmp
  });


UX_STEP_CB(
c0d06cf4:	b580      	push	{r7, lr}
c0d06cf6:	2000      	movs	r0, #0
c0d06cf8:	f7ff fe28 	bl	c0d0694c <io_seproxyhal_touch_stark_unsafe_sign_ok>
c0d06cfc:	bd80      	pop	{r7, pc}

c0d06cfe <ux_stark_unsafe_sign_5_step_validateinit>:
    {
      &C_icon_validate_14,
      "Accept",
      "and send",
    });
UX_STEP_CB(
c0d06cfe:	b580      	push	{r7, lr}
c0d06d00:	2000      	movs	r0, #0
c0d06d02:	f7ff fd8f 	bl	c0d06824 <io_seproxyhal_touch_tx_cancel>
c0d06d06:	bd80      	pop	{r7, pc}

c0d06d08 <readUint64BE>:
static const char HEXDIGITS[] = "0123456789abcdef";

static uint64_t readUint64BE(uint8_t *buffer) {
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
           (((uint64_t) buffer[4]) << 24) | (((uint64_t) buffer[5]) << 16) |
c0d06d08:	7941      	ldrb	r1, [r0, #5]
c0d06d0a:	0409      	lsls	r1, r1, #16
c0d06d0c:	7902      	ldrb	r2, [r0, #4]
c0d06d0e:	0612      	lsls	r2, r2, #24
c0d06d10:	1851      	adds	r1, r2, r1
           (((uint64_t) buffer[6]) << 8) | (((uint64_t) buffer[7]));
c0d06d12:	7982      	ldrb	r2, [r0, #6]
c0d06d14:	0212      	lsls	r2, r2, #8
           (((uint64_t) buffer[4]) << 24) | (((uint64_t) buffer[5]) << 16) |
c0d06d16:	1889      	adds	r1, r1, r2
           (((uint64_t) buffer[6]) << 8) | (((uint64_t) buffer[7]));
c0d06d18:	79c2      	ldrb	r2, [r0, #7]
c0d06d1a:	188a      	adds	r2, r1, r2
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0d06d1c:	7801      	ldrb	r1, [r0, #0]
c0d06d1e:	0609      	lsls	r1, r1, #24
c0d06d20:	7843      	ldrb	r3, [r0, #1]
c0d06d22:	041b      	lsls	r3, r3, #16
c0d06d24:	1859      	adds	r1, r3, r1
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
c0d06d26:	7883      	ldrb	r3, [r0, #2]
c0d06d28:	021b      	lsls	r3, r3, #8
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0d06d2a:	18c9      	adds	r1, r1, r3
           (((uint64_t) buffer[2]) << 40) | (((uint64_t) buffer[3]) << 32) |
c0d06d2c:	78c0      	ldrb	r0, [r0, #3]
c0d06d2e:	1809      	adds	r1, r1, r0
    return (((uint64_t) buffer[0]) << 56) | (((uint64_t) buffer[1]) << 48) |
c0d06d30:	4610      	mov	r0, r2
c0d06d32:	4770      	bx	lr

c0d06d34 <readu256BE>:
void readu128BE(uint8_t *buffer, uint128_t *target) {
    UPPER_P(target) = readUint64BE(buffer);
    LOWER_P(target) = readUint64BE(buffer + 8);
}

void readu256BE(uint8_t *buffer, uint256_t *target) {
c0d06d34:	b5b0      	push	{r4, r5, r7, lr}
c0d06d36:	460c      	mov	r4, r1
c0d06d38:	4605      	mov	r5, r0
    UPPER_P(target) = readUint64BE(buffer);
c0d06d3a:	f7ff ffe5 	bl	c0d06d08 <readUint64BE>
c0d06d3e:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d06d40:	4628      	mov	r0, r5
c0d06d42:	3008      	adds	r0, #8
    UPPER_P(target) = readUint64BE(buffer);
c0d06d44:	3c08      	subs	r4, #8
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d06d46:	f7ff ffdf 	bl	c0d06d08 <readUint64BE>
c0d06d4a:	60a0      	str	r0, [r4, #8]
c0d06d4c:	60e1      	str	r1, [r4, #12]
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
c0d06d4e:	4628      	mov	r0, r5
c0d06d50:	3010      	adds	r0, #16
    UPPER_P(target) = readUint64BE(buffer);
c0d06d52:	f7ff ffd9 	bl	c0d06d08 <readUint64BE>
c0d06d56:	6120      	str	r0, [r4, #16]
c0d06d58:	6161      	str	r1, [r4, #20]
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d06d5a:	3518      	adds	r5, #24
c0d06d5c:	4628      	mov	r0, r5
c0d06d5e:	f7ff ffd3 	bl	c0d06d08 <readUint64BE>
c0d06d62:	61a0      	str	r0, [r4, #24]
c0d06d64:	61e1      	str	r1, [r4, #28]
}
c0d06d66:	bdb0      	pop	{r4, r5, r7, pc}

c0d06d68 <shiftl128>:
void clear256(uint256_t *target) {
    clear128(&UPPER_P(target));
    clear128(&LOWER_P(target));
}

void shiftl128(uint128_t *number, uint32_t value, uint128_t *target) {
c0d06d68:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06d6a:	b081      	sub	sp, #4
c0d06d6c:	4614      	mov	r4, r2
    if (value >= 128) {
c0d06d6e:	2980      	cmp	r1, #128	; 0x80
c0d06d70:	d305      	bcc.n	c0d06d7e <shiftl128+0x16>
c0d06d72:	2000      	movs	r0, #0
c0d06d74:	6020      	str	r0, [r4, #0]
c0d06d76:	6060      	str	r0, [r4, #4]
c0d06d78:	60a0      	str	r0, [r4, #8]
c0d06d7a:	60e0      	str	r0, [r4, #12]
c0d06d7c:	e03a      	b.n	c0d06df4 <shiftl128+0x8c>
c0d06d7e:	460d      	mov	r5, r1
c0d06d80:	4606      	mov	r6, r0
        clear128(target);
    } else if (value == 64) {
c0d06d82:	2900      	cmp	r1, #0
c0d06d84:	d007      	beq.n	c0d06d96 <shiftl128+0x2e>
c0d06d86:	2d40      	cmp	r5, #64	; 0x40
c0d06d88:	d10c      	bne.n	c0d06da4 <shiftl128+0x3c>
        UPPER_P(target) = LOWER_P(number);
c0d06d8a:	68b0      	ldr	r0, [r6, #8]
c0d06d8c:	68f1      	ldr	r1, [r6, #12]
c0d06d8e:	2200      	movs	r2, #0
c0d06d90:	c407      	stmia	r4!, {r0, r1, r2}
        LOWER_P(target) = 0;
c0d06d92:	6022      	str	r2, [r4, #0]
c0d06d94:	e02e      	b.n	c0d06df4 <shiftl128+0x8c>
    UPPER_P(target) = UPPER_P(number);
c0d06d96:	ce03      	ldmia	r6!, {r0, r1}
c0d06d98:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d06d9a:	6830      	ldr	r0, [r6, #0]
c0d06d9c:	6871      	ldr	r1, [r6, #4]
c0d06d9e:	6061      	str	r1, [r4, #4]
c0d06da0:	6020      	str	r0, [r4, #0]
c0d06da2:	e027      	b.n	c0d06df4 <shiftl128+0x8c>
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
c0d06da4:	2d3f      	cmp	r5, #63	; 0x3f
c0d06da6:	d819      	bhi.n	c0d06ddc <shiftl128+0x74>
        UPPER_P(target) = (UPPER_P(number) << value) + (LOWER_P(number) >> (64 - value));
c0d06da8:	ce03      	ldmia	r6!, {r0, r1}
c0d06daa:	462a      	mov	r2, r5
c0d06dac:	3e08      	subs	r6, #8
c0d06dae:	f002 fc0f 	bl	c0d095d0 <__aeabi_llsl>
c0d06db2:	4607      	mov	r7, r0
c0d06db4:	9100      	str	r1, [sp, #0]
c0d06db6:	2040      	movs	r0, #64	; 0x40
c0d06db8:	1b42      	subs	r2, r0, r5
c0d06dba:	68b0      	ldr	r0, [r6, #8]
c0d06dbc:	68f1      	ldr	r1, [r6, #12]
c0d06dbe:	f002 fbfb 	bl	c0d095b8 <__aeabi_llsr>
c0d06dc2:	19c0      	adds	r0, r0, r7
c0d06dc4:	6020      	str	r0, [r4, #0]
c0d06dc6:	9800      	ldr	r0, [sp, #0]
c0d06dc8:	4141      	adcs	r1, r0
c0d06dca:	6061      	str	r1, [r4, #4]
        LOWER_P(target) = (LOWER_P(number) << value);
c0d06dcc:	68b0      	ldr	r0, [r6, #8]
c0d06dce:	68f1      	ldr	r1, [r6, #12]
c0d06dd0:	462a      	mov	r2, r5
c0d06dd2:	f002 fbfd 	bl	c0d095d0 <__aeabi_llsl>
c0d06dd6:	60a0      	str	r0, [r4, #8]
c0d06dd8:	60e1      	str	r1, [r4, #12]
c0d06dda:	e00b      	b.n	c0d06df4 <shiftl128+0x8c>
    } else if ((128 > value) && (value > 64)) {
c0d06ddc:	2d40      	cmp	r5, #64	; 0x40
c0d06dde:	d0c8      	beq.n	c0d06d72 <shiftl128+0xa>
        UPPER_P(target) = LOWER_P(number) << (value - 64);
c0d06de0:	68b0      	ldr	r0, [r6, #8]
c0d06de2:	68f1      	ldr	r1, [r6, #12]
c0d06de4:	2200      	movs	r2, #0
        LOWER_P(target) = 0;
c0d06de6:	60a2      	str	r2, [r4, #8]
c0d06de8:	60e2      	str	r2, [r4, #12]
        UPPER_P(target) = LOWER_P(number) << (value - 64);
c0d06dea:	3d40      	subs	r5, #64	; 0x40
c0d06dec:	462a      	mov	r2, r5
c0d06dee:	f002 fbef 	bl	c0d095d0 <__aeabi_llsl>
c0d06df2:	c403      	stmia	r4!, {r0, r1}
    } else {
        clear128(target);
    }
}
c0d06df4:	b001      	add	sp, #4
c0d06df6:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d06df8 <shiftl256>:

void shiftl256(uint256_t *number, uint32_t value, uint256_t *target) {
c0d06df8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06dfa:	b097      	sub	sp, #92	; 0x5c
c0d06dfc:	4614      	mov	r4, r2
c0d06dfe:	4605      	mov	r5, r0
    if (value >= 256) {
c0d06e00:	0a08      	lsrs	r0, r1, #8
c0d06e02:	d004      	beq.n	c0d06e0e <shiftl256+0x16>
c0d06e04:	2120      	movs	r1, #32
c0d06e06:	4620      	mov	r0, r4
c0d06e08:	f002 fbee 	bl	c0d095e8 <__aeabi_memclr>
c0d06e0c:	e079      	b.n	c0d06f02 <shiftl256+0x10a>
c0d06e0e:	460e      	mov	r6, r1
        clear256(target);
    } else if (value == 128) {
c0d06e10:	2900      	cmp	r1, #0
c0d06e12:	d00e      	beq.n	c0d06e32 <shiftl256+0x3a>
c0d06e14:	2e80      	cmp	r6, #128	; 0x80
c0d06e16:	d11b      	bne.n	c0d06e50 <shiftl256+0x58>
    UPPER_P(target) = UPPER_P(number);
c0d06e18:	6928      	ldr	r0, [r5, #16]
c0d06e1a:	6969      	ldr	r1, [r5, #20]
c0d06e1c:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d06e1e:	69a8      	ldr	r0, [r5, #24]
c0d06e20:	69e9      	ldr	r1, [r5, #28]
c0d06e22:	6061      	str	r1, [r4, #4]
c0d06e24:	6020      	str	r0, [r4, #0]
c0d06e26:	2000      	movs	r0, #0
    UPPER_P(target) = UPPER_P(number);
c0d06e28:	3c08      	subs	r4, #8
    LOWER_P(target) = 0;
c0d06e2a:	61e0      	str	r0, [r4, #28]
c0d06e2c:	6160      	str	r0, [r4, #20]
c0d06e2e:	61a0      	str	r0, [r4, #24]
c0d06e30:	e00c      	b.n	c0d06e4c <shiftl256+0x54>
    UPPER_P(target) = UPPER_P(number);
c0d06e32:	cd03      	ldmia	r5!, {r0, r1}
c0d06e34:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d06e36:	6828      	ldr	r0, [r5, #0]
c0d06e38:	6869      	ldr	r1, [r5, #4]
c0d06e3a:	6061      	str	r1, [r4, #4]
c0d06e3c:	6020      	str	r0, [r4, #0]
    UPPER_P(target) = UPPER_P(number);
c0d06e3e:	68a8      	ldr	r0, [r5, #8]
c0d06e40:	68e9      	ldr	r1, [r5, #12]
c0d06e42:	60e1      	str	r1, [r4, #12]
c0d06e44:	60a0      	str	r0, [r4, #8]
    LOWER_P(target) = LOWER_P(number);
c0d06e46:	6928      	ldr	r0, [r5, #16]
c0d06e48:	6969      	ldr	r1, [r5, #20]
c0d06e4a:	6161      	str	r1, [r4, #20]
c0d06e4c:	6120      	str	r0, [r4, #16]
c0d06e4e:	e058      	b.n	c0d06f02 <shiftl256+0x10a>
        copy128(&UPPER_P(target), &LOWER_P(number));
        clear128(&LOWER_P(target));
    } else if (value == 0) {
        copy256(target, number);
    } else if (value < 128) {
c0d06e50:	2e7f      	cmp	r6, #127	; 0x7f
c0d06e52:	d848      	bhi.n	c0d06ee6 <shiftl256+0xee>
c0d06e54:	aa12      	add	r2, sp, #72	; 0x48
        uint128_t tmp1;
        uint128_t tmp2;
        uint256_t result;
        shiftl128(&UPPER_P(number), value, &tmp1);
c0d06e56:	4628      	mov	r0, r5
c0d06e58:	4631      	mov	r1, r6
c0d06e5a:	f7ff ff85 	bl	c0d06d68 <shiftl128>
c0d06e5e:	2080      	movs	r0, #128	; 0x80
        shiftr128(&LOWER_P(number), (128 - value), &tmp2);
c0d06e60:	1b81      	subs	r1, r0, r6
c0d06e62:	3510      	adds	r5, #16
c0d06e64:	aa0e      	add	r2, sp, #56	; 0x38
c0d06e66:	4628      	mov	r0, r5
c0d06e68:	f000 f84d 	bl	c0d06f06 <shiftr128>
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d06e6c:	9914      	ldr	r1, [sp, #80]	; 0x50
c0d06e6e:	9103      	str	r1, [sp, #12]
c0d06e70:	9810      	ldr	r0, [sp, #64]	; 0x40
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d06e72:	9004      	str	r0, [sp, #16]
c0d06e74:	1840      	adds	r0, r0, r1
c0d06e76:	9008      	str	r0, [sp, #32]
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d06e78:	9815      	ldr	r0, [sp, #84]	; 0x54
c0d06e7a:	9a11      	ldr	r2, [sp, #68]	; 0x44
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d06e7c:	9202      	str	r2, [sp, #8]
c0d06e7e:	4142      	adcs	r2, r0
c0d06e80:	9209      	str	r2, [sp, #36]	; 0x24
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0d06e82:	9913      	ldr	r1, [sp, #76]	; 0x4c
c0d06e84:	9105      	str	r1, [sp, #20]
c0d06e86:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d06e88:	9f12      	ldr	r7, [sp, #72]	; 0x48
c0d06e8a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
c0d06e8c:	19d9      	adds	r1, r3, r7
c0d06e8e:	9b05      	ldr	r3, [sp, #20]
c0d06e90:	415a      	adcs	r2, r3
c0d06e92:	2300      	movs	r3, #0
c0d06e94:	9101      	str	r1, [sp, #4]
c0d06e96:	1c49      	adds	r1, r1, #1
c0d06e98:	9105      	str	r1, [sp, #20]
c0d06e9a:	9200      	str	r2, [sp, #0]
c0d06e9c:	4617      	mov	r7, r2
c0d06e9e:	415f      	adcs	r7, r3
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d06ea0:	43c0      	mvns	r0, r0
c0d06ea2:	9903      	ldr	r1, [sp, #12]
c0d06ea4:	43c9      	mvns	r1, r1
c0d06ea6:	9a04      	ldr	r2, [sp, #16]
c0d06ea8:	1a89      	subs	r1, r1, r2
c0d06eaa:	9902      	ldr	r1, [sp, #8]
c0d06eac:	4188      	sbcs	r0, r1
c0d06eae:	d200      	bcs.n	c0d06eb2 <shiftl256+0xba>
c0d06eb0:	2301      	movs	r3, #1
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0d06eb2:	2b00      	cmp	r3, #0
c0d06eb4:	9805      	ldr	r0, [sp, #20]
c0d06eb6:	d100      	bne.n	c0d06eba <shiftl256+0xc2>
c0d06eb8:	9f00      	ldr	r7, [sp, #0]
c0d06eba:	9707      	str	r7, [sp, #28]
c0d06ebc:	2b00      	cmp	r3, #0
c0d06ebe:	d100      	bne.n	c0d06ec2 <shiftl256+0xca>
c0d06ec0:	9801      	ldr	r0, [sp, #4]
c0d06ec2:	9006      	str	r0, [sp, #24]
c0d06ec4:	aa06      	add	r2, sp, #24
        shiftl128(&LOWER_P(number), value, &LOWER(result));
c0d06ec6:	3210      	adds	r2, #16
c0d06ec8:	4628      	mov	r0, r5
c0d06eca:	4631      	mov	r1, r6
c0d06ecc:	f7ff ff4c 	bl	c0d06d68 <shiftl128>
    UPPER_P(target) = UPPER_P(number);
c0d06ed0:	9806      	ldr	r0, [sp, #24]
c0d06ed2:	9004      	str	r0, [sp, #16]
c0d06ed4:	af07      	add	r7, sp, #28
c0d06ed6:	cfee      	ldmia	r7, {r1, r2, r3, r5, r6, r7}
    LOWER_P(target) = LOWER_P(number);
c0d06ed8:	980d      	ldr	r0, [sp, #52]	; 0x34
    UPPER_P(target) = UPPER_P(number);
c0d06eda:	9005      	str	r0, [sp, #20]
c0d06edc:	9804      	ldr	r0, [sp, #16]
c0d06ede:	c4ef      	stmia	r4!, {r0, r1, r2, r3, r5, r6, r7}
    LOWER_P(target) = LOWER_P(number);
c0d06ee0:	9805      	ldr	r0, [sp, #20]
c0d06ee2:	6020      	str	r0, [r4, #0]
c0d06ee4:	e00d      	b.n	c0d06f02 <shiftl256+0x10a>
    } else if ((256 > value) && (value > 128)) {
c0d06ee6:	2e80      	cmp	r6, #128	; 0x80
c0d06ee8:	d08c      	beq.n	c0d06e04 <shiftl256+0xc>
        shiftl128(&LOWER_P(number), (value - 128), &UPPER_P(target));
c0d06eea:	3510      	adds	r5, #16
c0d06eec:	3e80      	subs	r6, #128	; 0x80
c0d06eee:	4628      	mov	r0, r5
c0d06ef0:	4631      	mov	r1, r6
c0d06ef2:	4622      	mov	r2, r4
c0d06ef4:	f7ff ff38 	bl	c0d06d68 <shiftl128>
c0d06ef8:	2000      	movs	r0, #0
    LOWER_P(target) = 0;
c0d06efa:	6120      	str	r0, [r4, #16]
c0d06efc:	6160      	str	r0, [r4, #20]
c0d06efe:	61a0      	str	r0, [r4, #24]
c0d06f00:	61e0      	str	r0, [r4, #28]
}
c0d06f02:	b017      	add	sp, #92	; 0x5c
c0d06f04:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d06f06 <shiftr128>:
void shiftr128(uint128_t *number, uint32_t value, uint128_t *target) {
c0d06f06:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06f08:	b083      	sub	sp, #12
c0d06f0a:	4614      	mov	r4, r2
    if (value >= 128) {
c0d06f0c:	2980      	cmp	r1, #128	; 0x80
c0d06f0e:	d305      	bcc.n	c0d06f1c <shiftr128+0x16>
c0d06f10:	2000      	movs	r0, #0
c0d06f12:	6020      	str	r0, [r4, #0]
c0d06f14:	6060      	str	r0, [r4, #4]
c0d06f16:	60a0      	str	r0, [r4, #8]
c0d06f18:	60e0      	str	r0, [r4, #12]
c0d06f1a:	e03d      	b.n	c0d06f98 <shiftr128+0x92>
c0d06f1c:	460d      	mov	r5, r1
c0d06f1e:	4606      	mov	r6, r0
    } else if (value == 64) {
c0d06f20:	2900      	cmp	r1, #0
c0d06f22:	d006      	beq.n	c0d06f32 <shiftr128+0x2c>
c0d06f24:	2d40      	cmp	r5, #64	; 0x40
c0d06f26:	d10c      	bne.n	c0d06f42 <shiftr128+0x3c>
c0d06f28:	2000      	movs	r0, #0
        UPPER_P(target) = 0;
c0d06f2a:	6060      	str	r0, [r4, #4]
c0d06f2c:	6020      	str	r0, [r4, #0]
        LOWER_P(target) = UPPER_P(number);
c0d06f2e:	ce03      	ldmia	r6!, {r0, r1}
c0d06f30:	e004      	b.n	c0d06f3c <shiftr128+0x36>
    UPPER_P(target) = UPPER_P(number);
c0d06f32:	ce03      	ldmia	r6!, {r0, r1}
c0d06f34:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d06f36:	6830      	ldr	r0, [r6, #0]
c0d06f38:	6871      	ldr	r1, [r6, #4]
    UPPER_P(target) = UPPER_P(number);
c0d06f3a:	3c08      	subs	r4, #8
c0d06f3c:	60e1      	str	r1, [r4, #12]
c0d06f3e:	60a0      	str	r0, [r4, #8]
c0d06f40:	e02a      	b.n	c0d06f98 <shiftr128+0x92>
    } else if (value < 64) {
c0d06f42:	2d3f      	cmp	r5, #63	; 0x3f
c0d06f44:	d81c      	bhi.n	c0d06f80 <shiftr128+0x7a>
        UPPER(result) = UPPER_P(number) >> value;
c0d06f46:	6837      	ldr	r7, [r6, #0]
c0d06f48:	6871      	ldr	r1, [r6, #4]
c0d06f4a:	9102      	str	r1, [sp, #8]
c0d06f4c:	4638      	mov	r0, r7
c0d06f4e:	462a      	mov	r2, r5
c0d06f50:	f002 fb32 	bl	c0d095b8 <__aeabi_llsr>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d06f54:	68b2      	ldr	r2, [r6, #8]
c0d06f56:	68f3      	ldr	r3, [r6, #12]
    UPPER_P(target) = UPPER_P(number);
c0d06f58:	c403      	stmia	r4!, {r0, r1}
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d06f5a:	4610      	mov	r0, r2
c0d06f5c:	4619      	mov	r1, r3
c0d06f5e:	462a      	mov	r2, r5
    UPPER_P(target) = UPPER_P(number);
c0d06f60:	3c08      	subs	r4, #8
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d06f62:	f002 fb29 	bl	c0d095b8 <__aeabi_llsr>
c0d06f66:	4606      	mov	r6, r0
c0d06f68:	9101      	str	r1, [sp, #4]
c0d06f6a:	2040      	movs	r0, #64	; 0x40
c0d06f6c:	1b42      	subs	r2, r0, r5
c0d06f6e:	4638      	mov	r0, r7
c0d06f70:	9902      	ldr	r1, [sp, #8]
c0d06f72:	f002 fb2d 	bl	c0d095d0 <__aeabi_llsl>
c0d06f76:	1830      	adds	r0, r6, r0
    LOWER_P(target) = LOWER_P(number);
c0d06f78:	60a0      	str	r0, [r4, #8]
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d06f7a:	9801      	ldr	r0, [sp, #4]
c0d06f7c:	4141      	adcs	r1, r0
c0d06f7e:	e00a      	b.n	c0d06f96 <shiftr128+0x90>
    } else if ((128 > value) && (value > 64)) {
c0d06f80:	2d40      	cmp	r5, #64	; 0x40
c0d06f82:	d0c5      	beq.n	c0d06f10 <shiftr128+0xa>
        LOWER_P(target) = UPPER_P(number) >> (value - 64);
c0d06f84:	ce03      	ldmia	r6!, {r0, r1}
c0d06f86:	2200      	movs	r2, #0
        UPPER_P(target) = 0;
c0d06f88:	6022      	str	r2, [r4, #0]
c0d06f8a:	6062      	str	r2, [r4, #4]
        LOWER_P(target) = UPPER_P(number) >> (value - 64);
c0d06f8c:	3d40      	subs	r5, #64	; 0x40
c0d06f8e:	462a      	mov	r2, r5
c0d06f90:	f002 fb12 	bl	c0d095b8 <__aeabi_llsr>
c0d06f94:	60a0      	str	r0, [r4, #8]
c0d06f96:	60e1      	str	r1, [r4, #12]
}
c0d06f98:	b003      	add	sp, #12
c0d06f9a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d06f9c <shiftr256>:
void shiftr256(uint256_t *number, uint32_t value, uint256_t *target) {
c0d06f9c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06f9e:	b095      	sub	sp, #84	; 0x54
c0d06fa0:	4614      	mov	r4, r2
c0d06fa2:	4605      	mov	r5, r0
    if (value >= 256) {
c0d06fa4:	0a08      	lsrs	r0, r1, #8
c0d06fa6:	d004      	beq.n	c0d06fb2 <shiftr256+0x16>
c0d06fa8:	2120      	movs	r1, #32
c0d06faa:	4620      	mov	r0, r4
c0d06fac:	f002 fb1c 	bl	c0d095e8 <__aeabi_memclr>
c0d06fb0:	e072      	b.n	c0d07098 <shiftr256+0xfc>
c0d06fb2:	460e      	mov	r6, r1
    } else if (value == 128) {
c0d06fb4:	2900      	cmp	r1, #0
c0d06fb6:	d00e      	beq.n	c0d06fd6 <shiftr256+0x3a>
c0d06fb8:	2e80      	cmp	r6, #128	; 0x80
c0d06fba:	d11b      	bne.n	c0d06ff4 <shiftr256+0x58>
    UPPER_P(target) = UPPER_P(number);
c0d06fbc:	cd03      	ldmia	r5!, {r0, r1}
c0d06fbe:	6161      	str	r1, [r4, #20]
c0d06fc0:	6120      	str	r0, [r4, #16]
    LOWER_P(target) = LOWER_P(number);
c0d06fc2:	6828      	ldr	r0, [r5, #0]
c0d06fc4:	6869      	ldr	r1, [r5, #4]
c0d06fc6:	61e1      	str	r1, [r4, #28]
c0d06fc8:	61a0      	str	r0, [r4, #24]
c0d06fca:	2000      	movs	r0, #0
    LOWER_P(target) = 0;
c0d06fcc:	60e0      	str	r0, [r4, #12]
c0d06fce:	6060      	str	r0, [r4, #4]
c0d06fd0:	60a0      	str	r0, [r4, #8]
c0d06fd2:	6020      	str	r0, [r4, #0]
c0d06fd4:	e060      	b.n	c0d07098 <shiftr256+0xfc>
    UPPER_P(target) = UPPER_P(number);
c0d06fd6:	cd03      	ldmia	r5!, {r0, r1}
c0d06fd8:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d06fda:	6828      	ldr	r0, [r5, #0]
c0d06fdc:	6869      	ldr	r1, [r5, #4]
c0d06fde:	6061      	str	r1, [r4, #4]
c0d06fe0:	6020      	str	r0, [r4, #0]
    UPPER_P(target) = UPPER_P(number);
c0d06fe2:	68a8      	ldr	r0, [r5, #8]
c0d06fe4:	68e9      	ldr	r1, [r5, #12]
c0d06fe6:	60e1      	str	r1, [r4, #12]
c0d06fe8:	60a0      	str	r0, [r4, #8]
    LOWER_P(target) = LOWER_P(number);
c0d06fea:	6928      	ldr	r0, [r5, #16]
c0d06fec:	6969      	ldr	r1, [r5, #20]
c0d06fee:	6161      	str	r1, [r4, #20]
c0d06ff0:	6120      	str	r0, [r4, #16]
c0d06ff2:	e051      	b.n	c0d07098 <shiftr256+0xfc>
    } else if (value < 128) {
c0d06ff4:	2e7f      	cmp	r6, #127	; 0x7f
c0d06ff6:	d841      	bhi.n	c0d0707c <shiftr256+0xe0>
c0d06ff8:	aa04      	add	r2, sp, #16
        shiftr128(&UPPER_P(number), value, &UPPER(result));
c0d06ffa:	4628      	mov	r0, r5
c0d06ffc:	4631      	mov	r1, r6
c0d06ffe:	f7ff ff82 	bl	c0d06f06 <shiftr128>
        shiftr128(&LOWER_P(number), value, &tmp1);
c0d07002:	4628      	mov	r0, r5
c0d07004:	3010      	adds	r0, #16
c0d07006:	aa10      	add	r2, sp, #64	; 0x40
c0d07008:	4631      	mov	r1, r6
c0d0700a:	f7ff ff7c 	bl	c0d06f06 <shiftr128>
c0d0700e:	2080      	movs	r0, #128	; 0x80
        shiftl128(&UPPER_P(number), (128 - value), &tmp2);
c0d07010:	1b81      	subs	r1, r0, r6
c0d07012:	aa0c      	add	r2, sp, #48	; 0x30
c0d07014:	4628      	mov	r0, r5
c0d07016:	f7ff fea7 	bl	c0d06d68 <shiftl128>
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d0701a:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d0701c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d0701e:	1829      	adds	r1, r5, r0
c0d07020:	9103      	str	r1, [sp, #12]
c0d07022:	910a      	str	r1, [sp, #40]	; 0x28
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d07024:	9b13      	ldr	r3, [sp, #76]	; 0x4c
c0d07026:	990f      	ldr	r1, [sp, #60]	; 0x3c
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d07028:	460a      	mov	r2, r1
c0d0702a:	415a      	adcs	r2, r3
c0d0702c:	9202      	str	r2, [sp, #8]
c0d0702e:	920b      	str	r2, [sp, #44]	; 0x2c
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0d07030:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d07032:	9201      	str	r2, [sp, #4]
c0d07034:	9e0d      	ldr	r6, [sp, #52]	; 0x34
c0d07036:	9f10      	ldr	r7, [sp, #64]	; 0x40
c0d07038:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0d0703a:	19d2      	adds	r2, r2, r7
c0d0703c:	9f01      	ldr	r7, [sp, #4]
c0d0703e:	417e      	adcs	r6, r7
c0d07040:	2700      	movs	r7, #0
c0d07042:	9200      	str	r2, [sp, #0]
c0d07044:	1c52      	adds	r2, r2, #1
c0d07046:	9201      	str	r2, [sp, #4]
c0d07048:	4632      	mov	r2, r6
c0d0704a:	417a      	adcs	r2, r7
                      ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d0704c:	43db      	mvns	r3, r3
c0d0704e:	43c0      	mvns	r0, r0
c0d07050:	1b40      	subs	r0, r0, r5
c0d07052:	418b      	sbcs	r3, r1
c0d07054:	d200      	bcs.n	c0d07058 <shiftr256+0xbc>
c0d07056:	2701      	movs	r7, #1
    UPPER_P(target) = UPPER_P(number1) + UPPER_P(number2) +
c0d07058:	2f00      	cmp	r7, #0
c0d0705a:	d100      	bne.n	c0d0705e <shiftr256+0xc2>
c0d0705c:	4632      	mov	r2, r6
c0d0705e:	9209      	str	r2, [sp, #36]	; 0x24
c0d07060:	2f00      	cmp	r7, #0
c0d07062:	9e01      	ldr	r6, [sp, #4]
c0d07064:	d100      	bne.n	c0d07068 <shiftr256+0xcc>
c0d07066:	9e00      	ldr	r6, [sp, #0]
c0d07068:	9608      	str	r6, [sp, #32]
    UPPER_P(target) = UPPER_P(number);
c0d0706a:	ad04      	add	r5, sp, #16
c0d0706c:	cd2b      	ldmia	r5, {r0, r1, r3, r5}
c0d0706e:	c46b      	stmia	r4!, {r0, r1, r3, r5, r6}
c0d07070:	6022      	str	r2, [r4, #0]
    LOWER_P(target) = LOWER_P(number);
c0d07072:	9803      	ldr	r0, [sp, #12]
c0d07074:	6060      	str	r0, [r4, #4]
c0d07076:	9802      	ldr	r0, [sp, #8]
c0d07078:	60a0      	str	r0, [r4, #8]
c0d0707a:	e00d      	b.n	c0d07098 <shiftr256+0xfc>
    } else if ((256 > value) && (value > 128)) {
c0d0707c:	2e80      	cmp	r6, #128	; 0x80
c0d0707e:	d093      	beq.n	c0d06fa8 <shiftr256+0xc>
        shiftr128(&UPPER_P(number), (value - 128), &LOWER_P(target));
c0d07080:	3e80      	subs	r6, #128	; 0x80
c0d07082:	4622      	mov	r2, r4
c0d07084:	3210      	adds	r2, #16
c0d07086:	4628      	mov	r0, r5
c0d07088:	4631      	mov	r1, r6
c0d0708a:	f7ff ff3c 	bl	c0d06f06 <shiftr128>
c0d0708e:	2000      	movs	r0, #0
    LOWER_P(target) = 0;
c0d07090:	6020      	str	r0, [r4, #0]
c0d07092:	6060      	str	r0, [r4, #4]
c0d07094:	60a0      	str	r0, [r4, #8]
c0d07096:	60e0      	str	r0, [r4, #12]
}
c0d07098:	b015      	add	sp, #84	; 0x54
c0d0709a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d0709c <bits256>:
uint32_t bits256(uint256_t *number) {
c0d0709c:	b570      	push	{r4, r5, r6, lr}
c0d0709e:	6804      	ldr	r4, [r0, #0]
c0d070a0:	1d03      	adds	r3, r0, #4
c0d070a2:	cb0e      	ldmia	r3, {r1, r2, r3}
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d070a4:	461e      	mov	r6, r3
c0d070a6:	430e      	orrs	r6, r1
c0d070a8:	4615      	mov	r5, r2
c0d070aa:	4325      	orrs	r5, r4
c0d070ac:	4335      	orrs	r5, r6
c0d070ae:	2d00      	cmp	r5, #0
c0d070b0:	d016      	beq.n	c0d070e0 <bits256+0x44>
c0d070b2:	2080      	movs	r0, #128	; 0x80
c0d070b4:	2d00      	cmp	r5, #0
c0d070b6:	d032      	beq.n	c0d0711e <bits256+0x82>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d070b8:	0852      	lsrs	r2, r2, #1
c0d070ba:	07dd      	lsls	r5, r3, #31
c0d070bc:	1952      	adds	r2, r2, r5
        UPPER(result) = UPPER_P(number) >> value;
c0d070be:	0865      	lsrs	r5, r4, #1
c0d070c0:	07ce      	lsls	r6, r1, #31
c0d070c2:	19ad      	adds	r5, r5, r6
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d070c4:	462e      	mov	r6, r5
c0d070c6:	4316      	orrs	r6, r2
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d070c8:	07e4      	lsls	r4, r4, #31
c0d070ca:	085b      	lsrs	r3, r3, #1
c0d070cc:	18e3      	adds	r3, r4, r3
        UPPER(result) = UPPER_P(number) >> value;
c0d070ce:	0849      	lsrs	r1, r1, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d070d0:	460c      	mov	r4, r1
c0d070d2:	431c      	orrs	r4, r3
c0d070d4:	4334      	orrs	r4, r6
            result++;
c0d070d6:	1c40      	adds	r0, r0, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d070d8:	2c00      	cmp	r4, #0
c0d070da:	462c      	mov	r4, r5
c0d070dc:	d1ec      	bne.n	c0d070b8 <bits256+0x1c>
c0d070de:	e01e      	b.n	c0d0711e <bits256+0x82>
    UPPER_P(target) = UPPER_P(number);
c0d070e0:	6904      	ldr	r4, [r0, #16]
c0d070e2:	4603      	mov	r3, r0
c0d070e4:	3314      	adds	r3, #20
c0d070e6:	cb0e      	ldmia	r3, {r1, r2, r3}
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d070e8:	4608      	mov	r0, r1
c0d070ea:	4318      	orrs	r0, r3
c0d070ec:	4625      	mov	r5, r4
c0d070ee:	4315      	orrs	r5, r2
c0d070f0:	4305      	orrs	r5, r0
c0d070f2:	2000      	movs	r0, #0
c0d070f4:	2d00      	cmp	r5, #0
c0d070f6:	d012      	beq.n	c0d0711e <bits256+0x82>
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d070f8:	0852      	lsrs	r2, r2, #1
c0d070fa:	07dd      	lsls	r5, r3, #31
c0d070fc:	1952      	adds	r2, r2, r5
        UPPER(result) = UPPER_P(number) >> value;
c0d070fe:	0865      	lsrs	r5, r4, #1
c0d07100:	07ce      	lsls	r6, r1, #31
c0d07102:	19ad      	adds	r5, r5, r6
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d07104:	462e      	mov	r6, r5
c0d07106:	4316      	orrs	r6, r2
        LOWER(result) = (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d07108:	07e4      	lsls	r4, r4, #31
c0d0710a:	085b      	lsrs	r3, r3, #1
c0d0710c:	18e3      	adds	r3, r4, r3
        UPPER(result) = UPPER_P(number) >> value;
c0d0710e:	0849      	lsrs	r1, r1, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d07110:	460c      	mov	r4, r1
c0d07112:	431c      	orrs	r4, r3
c0d07114:	4334      	orrs	r4, r6
            result++;
c0d07116:	1c40      	adds	r0, r0, #1
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d07118:	2c00      	cmp	r4, #0
c0d0711a:	462c      	mov	r4, r5
c0d0711c:	d1ec      	bne.n	c0d070f8 <bits256+0x5c>
    return result;
c0d0711e:	bd70      	pop	{r4, r5, r6, pc}

c0d07120 <gt256>:
bool gt256(uint256_t *number1, uint256_t *number2) {
c0d07120:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0d07122:	680b      	ldr	r3, [r1, #0]
c0d07124:	684a      	ldr	r2, [r1, #4]
c0d07126:	6805      	ldr	r5, [r0, #0]
c0d07128:	6844      	ldr	r4, [r0, #4]
c0d0712a:	4626      	mov	r6, r4
c0d0712c:	4056      	eors	r6, r2
c0d0712e:	462f      	mov	r7, r5
c0d07130:	405f      	eors	r7, r3
c0d07132:	4337      	orrs	r7, r6
c0d07134:	2f00      	cmp	r7, #0
c0d07136:	d11e      	bne.n	c0d07176 <gt256+0x56>
c0d07138:	688b      	ldr	r3, [r1, #8]
c0d0713a:	68ca      	ldr	r2, [r1, #12]
c0d0713c:	6885      	ldr	r5, [r0, #8]
c0d0713e:	68c4      	ldr	r4, [r0, #12]
c0d07140:	4626      	mov	r6, r4
c0d07142:	4056      	eors	r6, r2
c0d07144:	462f      	mov	r7, r5
c0d07146:	405f      	eors	r7, r3
c0d07148:	4337      	orrs	r7, r6
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
c0d0714a:	2f00      	cmp	r7, #0
c0d0714c:	d113      	bne.n	c0d07176 <gt256+0x56>
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d0714e:	690b      	ldr	r3, [r1, #16]
c0d07150:	694a      	ldr	r2, [r1, #20]
c0d07152:	6905      	ldr	r5, [r0, #16]
c0d07154:	6944      	ldr	r4, [r0, #20]
c0d07156:	4626      	mov	r6, r4
c0d07158:	4056      	eors	r6, r2
c0d0715a:	462f      	mov	r7, r5
c0d0715c:	405f      	eors	r7, r3
c0d0715e:	4337      	orrs	r7, r6
c0d07160:	2f00      	cmp	r7, #0
c0d07162:	d108      	bne.n	c0d07176 <gt256+0x56>
        return (LOWER_P(number1) > LOWER_P(number2));
c0d07164:	6982      	ldr	r2, [r0, #24]
c0d07166:	69c0      	ldr	r0, [r0, #28]
c0d07168:	698b      	ldr	r3, [r1, #24]
c0d0716a:	69c9      	ldr	r1, [r1, #28]
c0d0716c:	1a9a      	subs	r2, r3, r2
c0d0716e:	4181      	sbcs	r1, r0
c0d07170:	d204      	bcs.n	c0d0717c <gt256+0x5c>
c0d07172:	2001      	movs	r0, #1
}
c0d07174:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d07176:	1b58      	subs	r0, r3, r5
c0d07178:	41a2      	sbcs	r2, r4
c0d0717a:	d3fa      	bcc.n	c0d07172 <gt256+0x52>
c0d0717c:	2000      	movs	r0, #0
c0d0717e:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07180 <gte256>:
bool gte256(uint256_t *number1, uint256_t *number2) {
c0d07180:	b570      	push	{r4, r5, r6, lr}
c0d07182:	460d      	mov	r5, r1
c0d07184:	4604      	mov	r4, r0
    return gt256(number1, number2) || equal256(number1, number2);
c0d07186:	f7ff ffcb 	bl	c0d07120 <gt256>
c0d0718a:	2800      	cmp	r0, #0
c0d0718c:	d001      	beq.n	c0d07192 <gte256+0x12>
c0d0718e:	2001      	movs	r0, #1
c0d07190:	bd70      	pop	{r4, r5, r6, pc}
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0d07192:	cd03      	ldmia	r5!, {r0, r1}
c0d07194:	cc0c      	ldmia	r4!, {r2, r3}
c0d07196:	404b      	eors	r3, r1
c0d07198:	4042      	eors	r2, r0
c0d0719a:	431a      	orrs	r2, r3
c0d0719c:	2000      	movs	r0, #0
c0d0719e:	3c08      	subs	r4, #8
c0d071a0:	3d08      	subs	r5, #8
c0d071a2:	2a00      	cmp	r2, #0
c0d071a4:	d11a      	bne.n	c0d071dc <gte256+0x5c>
c0d071a6:	68a9      	ldr	r1, [r5, #8]
c0d071a8:	68ea      	ldr	r2, [r5, #12]
c0d071aa:	68a3      	ldr	r3, [r4, #8]
c0d071ac:	68e6      	ldr	r6, [r4, #12]
c0d071ae:	4056      	eors	r6, r2
c0d071b0:	404b      	eors	r3, r1
c0d071b2:	4333      	orrs	r3, r6
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
c0d071b4:	2b00      	cmp	r3, #0
c0d071b6:	d111      	bne.n	c0d071dc <gte256+0x5c>
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0d071b8:	6929      	ldr	r1, [r5, #16]
c0d071ba:	696a      	ldr	r2, [r5, #20]
c0d071bc:	6923      	ldr	r3, [r4, #16]
c0d071be:	6966      	ldr	r6, [r4, #20]
c0d071c0:	4056      	eors	r6, r2
c0d071c2:	404b      	eors	r3, r1
c0d071c4:	4333      	orrs	r3, r6
c0d071c6:	2b00      	cmp	r3, #0
c0d071c8:	d108      	bne.n	c0d071dc <gte256+0x5c>
c0d071ca:	69a8      	ldr	r0, [r5, #24]
c0d071cc:	69e9      	ldr	r1, [r5, #28]
c0d071ce:	69a2      	ldr	r2, [r4, #24]
c0d071d0:	69e3      	ldr	r3, [r4, #28]
c0d071d2:	404b      	eors	r3, r1
c0d071d4:	4042      	eors	r2, r0
c0d071d6:	431a      	orrs	r2, r3
c0d071d8:	4250      	negs	r0, r2
c0d071da:	4150      	adcs	r0, r2
    return gt256(number1, number2) || equal256(number1, number2);
c0d071dc:	bd70      	pop	{r4, r5, r6, pc}

c0d071de <minus256>:
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
}

void minus256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0d071de:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d071e0:	b090      	sub	sp, #64	; 0x40
c0d071e2:	920e      	str	r2, [sp, #56]	; 0x38
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d071e4:	684c      	ldr	r4, [r1, #4]
c0d071e6:	6843      	ldr	r3, [r0, #4]
c0d071e8:	680a      	ldr	r2, [r1, #0]
c0d071ea:	6805      	ldr	r5, [r0, #0]
c0d071ec:	1aaa      	subs	r2, r5, r2
c0d071ee:	41a3      	sbcs	r3, r4
c0d071f0:	2400      	movs	r4, #0
c0d071f2:	920f      	str	r2, [sp, #60]	; 0x3c
c0d071f4:	1e52      	subs	r2, r2, #1
c0d071f6:	920c      	str	r2, [sp, #48]	; 0x30
c0d071f8:	461a      	mov	r2, r3
c0d071fa:	940a      	str	r4, [sp, #40]	; 0x28
c0d071fc:	41a2      	sbcs	r2, r4
c0d071fe:	920d      	str	r2, [sp, #52]	; 0x34
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d07200:	68cc      	ldr	r4, [r1, #12]
c0d07202:	68c6      	ldr	r6, [r0, #12]
c0d07204:	688f      	ldr	r7, [r1, #8]
c0d07206:	6882      	ldr	r2, [r0, #8]
c0d07208:	2501      	movs	r5, #1
c0d0720a:	1bd2      	subs	r2, r2, r7
c0d0720c:	41a6      	sbcs	r6, r4
c0d0720e:	462c      	mov	r4, r5
c0d07210:	d300      	bcc.n	c0d07214 <minus256+0x36>
c0d07212:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d07214:	2c00      	cmp	r4, #0
c0d07216:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0d07218:	d100      	bne.n	c0d0721c <minus256+0x3e>
c0d0721a:	461a      	mov	r2, r3
c0d0721c:	9509      	str	r5, [sp, #36]	; 0x24
c0d0721e:	9e0e      	ldr	r6, [sp, #56]	; 0x38
c0d07220:	920d      	str	r2, [sp, #52]	; 0x34
c0d07222:	6072      	str	r2, [r6, #4]
c0d07224:	2c00      	cmp	r4, #0
c0d07226:	d101      	bne.n	c0d0722c <minus256+0x4e>
c0d07228:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d0722a:	920c      	str	r2, [sp, #48]	; 0x30
c0d0722c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0d0722e:	6032      	str	r2, [r6, #0]
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d07230:	68ca      	ldr	r2, [r1, #12]
c0d07232:	68c7      	ldr	r7, [r0, #12]
c0d07234:	688b      	ldr	r3, [r1, #8]
c0d07236:	6884      	ldr	r4, [r0, #8]
c0d07238:	1ae3      	subs	r3, r4, r3
c0d0723a:	9306      	str	r3, [sp, #24]
c0d0723c:	60b3      	str	r3, [r6, #8]
c0d0723e:	4197      	sbcs	r7, r2
c0d07240:	9707      	str	r7, [sp, #28]
c0d07242:	60f7      	str	r7, [r6, #12]
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d07244:	694c      	ldr	r4, [r1, #20]
c0d07246:	6942      	ldr	r2, [r0, #20]
c0d07248:	690b      	ldr	r3, [r1, #16]
c0d0724a:	6905      	ldr	r5, [r0, #16]
c0d0724c:	9508      	str	r5, [sp, #32]
c0d0724e:	1aef      	subs	r7, r5, r3
c0d07250:	9200      	str	r2, [sp, #0]
c0d07252:	41a2      	sbcs	r2, r4
c0d07254:	970f      	str	r7, [sp, #60]	; 0x3c
c0d07256:	1e7b      	subs	r3, r7, #1
c0d07258:	930b      	str	r3, [sp, #44]	; 0x2c
c0d0725a:	9201      	str	r2, [sp, #4]
c0d0725c:	4617      	mov	r7, r2
c0d0725e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
c0d07260:	419f      	sbcs	r7, r3
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d07262:	69ca      	ldr	r2, [r1, #28]
c0d07264:	69c5      	ldr	r5, [r0, #28]
c0d07266:	698c      	ldr	r4, [r1, #24]
c0d07268:	6986      	ldr	r6, [r0, #24]
c0d0726a:	9403      	str	r4, [sp, #12]
c0d0726c:	9602      	str	r6, [sp, #8]
c0d0726e:	1b34      	subs	r4, r6, r4
c0d07270:	9504      	str	r5, [sp, #16]
c0d07272:	9205      	str	r2, [sp, #20]
c0d07274:	4195      	sbcs	r5, r2
c0d07276:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0d07278:	d300      	bcc.n	c0d0727c <minus256+0x9e>
c0d0727a:	461a      	mov	r2, r3
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d0727c:	2a00      	cmp	r2, #0
c0d0727e:	d101      	bne.n	c0d07284 <minus256+0xa6>
c0d07280:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0d07282:	930b      	str	r3, [sp, #44]	; 0x2c
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d07284:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
c0d07286:	9b08      	ldr	r3, [sp, #32]
c0d07288:	405c      	eors	r4, r3
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d0728a:	2a00      	cmp	r2, #0
c0d0728c:	9a02      	ldr	r2, [sp, #8]
c0d0728e:	9b01      	ldr	r3, [sp, #4]
c0d07290:	9e00      	ldr	r6, [sp, #0]
c0d07292:	d100      	bne.n	c0d07296 <minus256+0xb8>
c0d07294:	461f      	mov	r7, r3
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d07296:	463d      	mov	r5, r7
c0d07298:	4075      	eors	r5, r6
c0d0729a:	432c      	orrs	r4, r5
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d0729c:	460d      	mov	r5, r1
c0d0729e:	3518      	adds	r5, #24
c0d072a0:	950a      	str	r5, [sp, #40]	; 0x28
c0d072a2:	4605      	mov	r5, r0
c0d072a4:	3518      	adds	r5, #24
c0d072a6:	9509      	str	r5, [sp, #36]	; 0x24
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d072a8:	2c00      	cmp	r4, #0
c0d072aa:	d109      	bne.n	c0d072c0 <minus256+0xe2>
c0d072ac:	9c03      	ldr	r4, [sp, #12]
c0d072ae:	4615      	mov	r5, r2
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d072b0:	1b12      	subs	r2, r2, r4
c0d072b2:	9e04      	ldr	r6, [sp, #16]
c0d072b4:	4632      	mov	r2, r6
c0d072b6:	9f05      	ldr	r7, [sp, #20]
c0d072b8:	41ba      	sbcs	r2, r7
c0d072ba:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    uint128_t tmp;
    minus128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    minus128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
    if (gt128(&tmp, &LOWER_P(number1))) {
c0d072bc:	d30a      	bcc.n	c0d072d4 <minus256+0xf6>
c0d072be:	e02e      	b.n	c0d0731e <minus256+0x140>
c0d072c0:	4615      	mov	r5, r2
    return (UPPER_P(number1) > UPPER_P(number2));
c0d072c2:	9a08      	ldr	r2, [sp, #32]
c0d072c4:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
c0d072c6:	1b12      	subs	r2, r2, r4
c0d072c8:	41be      	sbcs	r6, r7
c0d072ca:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d072cc:	9f05      	ldr	r7, [sp, #20]
c0d072ce:	9e04      	ldr	r6, [sp, #16]
c0d072d0:	9c03      	ldr	r4, [sp, #12]
    if (gt128(&tmp, &LOWER_P(number1))) {
c0d072d2:	d224      	bcs.n	c0d0731e <minus256+0x140>
c0d072d4:	2500      	movs	r5, #0
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d072d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
c0d072d8:	1e53      	subs	r3, r2, #1
c0d072da:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0d072dc:	4616      	mov	r6, r2
c0d072de:	41ae      	sbcs	r6, r5
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d072e0:	9c06      	ldr	r4, [sp, #24]
c0d072e2:	9f07      	ldr	r7, [sp, #28]
c0d072e4:	433c      	orrs	r4, r7
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d072e6:	2c00      	cmp	r4, #0
c0d072e8:	d000      	beq.n	c0d072ec <minus256+0x10e>
c0d072ea:	4616      	mov	r6, r2
c0d072ec:	3110      	adds	r1, #16
c0d072ee:	3010      	adds	r0, #16
c0d072f0:	9f0e      	ldr	r7, [sp, #56]	; 0x38
c0d072f2:	463a      	mov	r2, r7
c0d072f4:	3208      	adds	r2, #8
c0d072f6:	607e      	str	r6, [r7, #4]
c0d072f8:	2c00      	cmp	r4, #0
c0d072fa:	d000      	beq.n	c0d072fe <minus256+0x120>
c0d072fc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
c0d072fe:	603b      	str	r3, [r7, #0]
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d07300:	9b06      	ldr	r3, [sp, #24]
c0d07302:	1e5b      	subs	r3, r3, #1
c0d07304:	9c07      	ldr	r4, [sp, #28]
c0d07306:	41ac      	sbcs	r4, r5
c0d07308:	c218      	stmia	r2!, {r3, r4}
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d0730a:	680a      	ldr	r2, [r1, #0]
c0d0730c:	6849      	ldr	r1, [r1, #4]
c0d0730e:	6804      	ldr	r4, [r0, #0]
c0d07310:	6843      	ldr	r3, [r0, #4]
c0d07312:	1aa2      	subs	r2, r4, r2
c0d07314:	418b      	sbcs	r3, r1
c0d07316:	980a      	ldr	r0, [sp, #40]	; 0x28
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d07318:	c890      	ldmia	r0!, {r4, r7}
c0d0731a:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d0731c:	c860      	ldmia	r0!, {r5, r6}
c0d0731e:	2100      	movs	r1, #0
c0d07320:	920f      	str	r2, [sp, #60]	; 0x3c
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d07322:	1e50      	subs	r0, r2, #1
c0d07324:	461a      	mov	r2, r3
c0d07326:	418a      	sbcs	r2, r1
                      ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d07328:	1b2c      	subs	r4, r5, r4
c0d0732a:	41be      	sbcs	r6, r7
c0d0732c:	9c0e      	ldr	r4, [sp, #56]	; 0x38
c0d0732e:	d200      	bcs.n	c0d07332 <minus256+0x154>
c0d07330:	2101      	movs	r1, #1
    UPPER_P(target) = UPPER_P(number1) - UPPER_P(number2) -
c0d07332:	2900      	cmp	r1, #0
c0d07334:	d100      	bne.n	c0d07338 <minus256+0x15a>
c0d07336:	461a      	mov	r2, r3
c0d07338:	6162      	str	r2, [r4, #20]
c0d0733a:	2900      	cmp	r1, #0
c0d0733c:	d100      	bne.n	c0d07340 <minus256+0x162>
c0d0733e:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0d07340:	6120      	str	r0, [r4, #16]
c0d07342:	990a      	ldr	r1, [sp, #40]	; 0x28
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d07344:	c903      	ldmia	r1, {r0, r1}
c0d07346:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0d07348:	cb0c      	ldmia	r3, {r2, r3}
c0d0734a:	1a10      	subs	r0, r2, r0
c0d0734c:	61a0      	str	r0, [r4, #24]
c0d0734e:	418b      	sbcs	r3, r1
c0d07350:	61e3      	str	r3, [r4, #28]
        UPPER(one) = 0;
        LOWER(one) = 1;
        minus128(&UPPER_P(target), &one, &UPPER_P(target));
    }
    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}
c0d07352:	b010      	add	sp, #64	; 0x40
c0d07354:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07356 <write_u64_be>:
    buffer[2] = ((value >> 40) & 0xff);
    buffer[3] = ((value >> 32) & 0xff);
    buffer[4] = ((value >> 24) & 0xff);
    buffer[5] = ((value >> 16) & 0xff);
    buffer[6] = ((value >> 8) & 0xff);
    buffer[7] = (value & 0xff);
c0d07356:	71c2      	strb	r2, [r0, #7]
    buffer[3] = ((value >> 32) & 0xff);
c0d07358:	70c3      	strb	r3, [r0, #3]
    buffer[6] = ((value >> 8) & 0xff);
c0d0735a:	0a11      	lsrs	r1, r2, #8
c0d0735c:	7181      	strb	r1, [r0, #6]
    buffer[5] = ((value >> 16) & 0xff);
c0d0735e:	0c11      	lsrs	r1, r2, #16
c0d07360:	7141      	strb	r1, [r0, #5]
    buffer[4] = ((value >> 24) & 0xff);
c0d07362:	0e11      	lsrs	r1, r2, #24
c0d07364:	7101      	strb	r1, [r0, #4]
    buffer[2] = ((value >> 40) & 0xff);
c0d07366:	0a19      	lsrs	r1, r3, #8
c0d07368:	7081      	strb	r1, [r0, #2]
    buffer[1] = ((value >> 48) & 0xff);
c0d0736a:	0c19      	lsrs	r1, r3, #16
c0d0736c:	7041      	strb	r1, [r0, #1]
    buffer[0] = ((value >> 56) & 0xff);
c0d0736e:	0e19      	lsrs	r1, r3, #24
c0d07370:	7001      	strb	r1, [r0, #0]
}
c0d07372:	4770      	bx	lr

c0d07374 <mul256>:
    *out_ptr++ = in[2];
    *out_ptr++ = in[1];
    *out_ptr = in[0];
}

void mul256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0d07374:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07376:	b0a5      	sub	sp, #148	; 0x94
c0d07378:	9201      	str	r2, [sp, #4]
c0d0737a:	9103      	str	r1, [sp, #12]
c0d0737c:	9002      	str	r0, [sp, #8]
c0d0737e:	a805      	add	r0, sp, #20
c0d07380:	2140      	movs	r1, #64	; 0x40
c0d07382:	9100      	str	r1, [sp, #0]
    uint8_t num1[32], num2[32], result[64];
    memset(&result, 0, sizeof(result));
c0d07384:	f002 f930 	bl	c0d095e8 <__aeabi_memclr>
c0d07388:	2600      	movs	r6, #0
c0d0738a:	ac15      	add	r4, sp, #84	; 0x54
c0d0738c:	ad1d      	add	r5, sp, #116	; 0x74
c0d0738e:	9404      	str	r4, [sp, #16]
    for (uint8_t i = 0; i < 4; i++) {
        write_u64_be(num1 + i * sizeof(uint64_t), number1->elements[i / 2].elements[i % 2]);
c0d07390:	00f4      	lsls	r4, r6, #3
c0d07392:	2008      	movs	r0, #8
c0d07394:	4627      	mov	r7, r4
c0d07396:	4007      	ands	r7, r0
c0d07398:	4384      	bics	r4, r0
c0d0739a:	9802      	ldr	r0, [sp, #8]
c0d0739c:	1900      	adds	r0, r0, r4
c0d0739e:	59c2      	ldr	r2, [r0, r7]
c0d073a0:	19c0      	adds	r0, r0, r7
c0d073a2:	6843      	ldr	r3, [r0, #4]
c0d073a4:	4628      	mov	r0, r5
c0d073a6:	f7ff ffd6 	bl	c0d07356 <write_u64_be>
        write_u64_be(num2 + i * sizeof(uint64_t), number2->elements[i / 2].elements[i % 2]);
c0d073aa:	9803      	ldr	r0, [sp, #12]
c0d073ac:	1900      	adds	r0, r0, r4
c0d073ae:	9c04      	ldr	r4, [sp, #16]
c0d073b0:	59c2      	ldr	r2, [r0, r7]
c0d073b2:	19c0      	adds	r0, r0, r7
c0d073b4:	6843      	ldr	r3, [r0, #4]
c0d073b6:	4620      	mov	r0, r4
c0d073b8:	f7ff ffcd 	bl	c0d07356 <write_u64_be>
    for (uint8_t i = 0; i < 4; i++) {
c0d073bc:	3508      	adds	r5, #8
c0d073be:	3408      	adds	r4, #8
c0d073c0:	1c76      	adds	r6, r6, #1
c0d073c2:	2e04      	cmp	r6, #4
c0d073c4:	d1e3      	bne.n	c0d0738e <mul256+0x1a>
c0d073c6:	a805      	add	r0, sp, #20
c0d073c8:	a91d      	add	r1, sp, #116	; 0x74
c0d073ca:	aa15      	add	r2, sp, #84	; 0x54
c0d073cc:	2320      	movs	r3, #32
    }
    cx_math_mult(result, num1, num2, sizeof(num1));
c0d073ce:	f7fe faf7 	bl	c0d059c0 <cx_math_mult>
c0d073d2:	201f      	movs	r0, #31
c0d073d4:	43c0      	mvns	r0, r0
c0d073d6:	2100      	movs	r1, #0
c0d073d8:	9e01      	ldr	r6, [sp, #4]
c0d073da:	9f00      	ldr	r7, [sp, #0]
c0d073dc:	aa05      	add	r2, sp, #20
    for (uint8_t i = 0; i < 4; i++) {
        read_u64_be(result + 32 + i * sizeof(uint64_t), &target->elements[i / 2].elements[i % 2]);
c0d073de:	1812      	adds	r2, r2, r0
c0d073e0:	2347      	movs	r3, #71	; 0x47
    *out_ptr++ = in[7];
c0d073e2:	5cd3      	ldrb	r3, [r2, r3]
        read_u64_be(result + 32 + i * sizeof(uint64_t), &target->elements[i / 2].elements[i % 2]);
c0d073e4:	084c      	lsrs	r4, r1, #1
c0d073e6:	0124      	lsls	r4, r4, #4
c0d073e8:	1934      	adds	r4, r6, r4
c0d073ea:	2501      	movs	r5, #1
c0d073ec:	400d      	ands	r5, r1
c0d073ee:	00ed      	lsls	r5, r5, #3
    *out_ptr++ = in[7];
c0d073f0:	5563      	strb	r3, [r4, r5]
        read_u64_be(result + 32 + i * sizeof(uint64_t), &target->elements[i / 2].elements[i % 2]);
c0d073f2:	1963      	adds	r3, r4, r5
c0d073f4:	2446      	movs	r4, #70	; 0x46
    *out_ptr++ = in[6];
c0d073f6:	5d14      	ldrb	r4, [r2, r4]
c0d073f8:	705c      	strb	r4, [r3, #1]
c0d073fa:	2445      	movs	r4, #69	; 0x45
    *out_ptr++ = in[5];
c0d073fc:	5d14      	ldrb	r4, [r2, r4]
c0d073fe:	709c      	strb	r4, [r3, #2]
c0d07400:	2444      	movs	r4, #68	; 0x44
    *out_ptr++ = in[4];
c0d07402:	5d14      	ldrb	r4, [r2, r4]
c0d07404:	70dc      	strb	r4, [r3, #3]
c0d07406:	2443      	movs	r4, #67	; 0x43
    *out_ptr++ = in[3];
c0d07408:	5d14      	ldrb	r4, [r2, r4]
c0d0740a:	711c      	strb	r4, [r3, #4]
c0d0740c:	2442      	movs	r4, #66	; 0x42
    *out_ptr++ = in[2];
c0d0740e:	5d14      	ldrb	r4, [r2, r4]
c0d07410:	715c      	strb	r4, [r3, #5]
c0d07412:	2441      	movs	r4, #65	; 0x41
    *out_ptr++ = in[1];
c0d07414:	5d14      	ldrb	r4, [r2, r4]
c0d07416:	719c      	strb	r4, [r3, #6]
    *out_ptr = in[0];
c0d07418:	5dd2      	ldrb	r2, [r2, r7]
c0d0741a:	71da      	strb	r2, [r3, #7]
    for (uint8_t i = 0; i < 4; i++) {
c0d0741c:	3008      	adds	r0, #8
c0d0741e:	1c49      	adds	r1, r1, #1
c0d07420:	2800      	cmp	r0, #0
c0d07422:	d1db      	bne.n	c0d073dc <mul256+0x68>
    }
}
c0d07424:	b025      	add	sp, #148	; 0x94
c0d07426:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07428 <divmod256>:
        copy128(retDiv, &resDiv);
        copy128(retMod, &resMod);
    }
}

void divmod256(uint256_t *l, uint256_t *r, uint256_t *retDiv, uint256_t *retMod) {
c0d07428:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0742a:	b0b5      	sub	sp, #212	; 0xd4
c0d0742c:	9306      	str	r3, [sp, #24]
c0d0742e:	9205      	str	r2, [sp, #20]
c0d07430:	460c      	mov	r4, r1
c0d07432:	9113      	str	r1, [sp, #76]	; 0x4c
c0d07434:	4607      	mov	r7, r0
c0d07436:	a814      	add	r0, sp, #80	; 0x50
c0d07438:	2118      	movs	r1, #24
    uint256_t copyd, adder, resDiv, resMod;
    uint256_t one;
    clear256(&one);
    UPPER(LOWER(one)) = 0;
c0d0743a:	f002 f8d5 	bl	c0d095e8 <__aeabi_memclr>
c0d0743e:	2000      	movs	r0, #0
c0d07440:	9012      	str	r0, [sp, #72]	; 0x48
    LOWER(LOWER(one)) = 1;
c0d07442:	901b      	str	r0, [sp, #108]	; 0x6c
c0d07444:	2001      	movs	r0, #1
c0d07446:	901a      	str	r0, [sp, #104]	; 0x68
    uint32_t diffBits = bits256(l) - bits256(r);
c0d07448:	4638      	mov	r0, r7
c0d0744a:	f7ff fe27 	bl	c0d0709c <bits256>
c0d0744e:	9011      	str	r0, [sp, #68]	; 0x44
c0d07450:	4620      	mov	r0, r4
c0d07452:	f7ff fe23 	bl	c0d0709c <bits256>
c0d07456:	9010      	str	r0, [sp, #64]	; 0x40
    UPPER_P(target) = UPPER_P(number);
c0d07458:	683c      	ldr	r4, [r7, #0]
c0d0745a:	6879      	ldr	r1, [r7, #4]
    LOWER_P(target) = LOWER_P(number);
c0d0745c:	68b8      	ldr	r0, [r7, #8]
c0d0745e:	900a      	str	r0, [sp, #40]	; 0x28
c0d07460:	68fb      	ldr	r3, [r7, #12]
    UPPER_P(target) = UPPER_P(number);
c0d07462:	693d      	ldr	r5, [r7, #16]
c0d07464:	6978      	ldr	r0, [r7, #20]
    LOWER_P(target) = LOWER_P(number);
c0d07466:	69be      	ldr	r6, [r7, #24]
c0d07468:	69fa      	ldr	r2, [r7, #28]
c0d0746a:	9209      	str	r2, [sp, #36]	; 0x24
c0d0746c:	9108      	str	r1, [sp, #32]
    UPPER_P(target) = UPPER_P(number);
c0d0746e:	911d      	str	r1, [sp, #116]	; 0x74
c0d07470:	9407      	str	r4, [sp, #28]
c0d07472:	941c      	str	r4, [sp, #112]	; 0x70
c0d07474:	9304      	str	r3, [sp, #16]
    LOWER_P(target) = LOWER_P(number);
c0d07476:	931f      	str	r3, [sp, #124]	; 0x7c
c0d07478:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d0747a:	911e      	str	r1, [sp, #120]	; 0x78
c0d0747c:	9002      	str	r0, [sp, #8]
    UPPER_P(target) = UPPER_P(number);
c0d0747e:	9021      	str	r0, [sp, #132]	; 0x84
c0d07480:	9503      	str	r5, [sp, #12]
c0d07482:	9520      	str	r5, [sp, #128]	; 0x80
c0d07484:	9809      	ldr	r0, [sp, #36]	; 0x24
    LOWER_P(target) = LOWER_P(number);
c0d07486:	9023      	str	r0, [sp, #140]	; 0x8c
c0d07488:	9601      	str	r6, [sp, #4]
c0d0748a:	9622      	str	r6, [sp, #136]	; 0x88
    clear256(&resDiv);
    copy256(&resMod, l);
    if (gt256(r, l)) {
c0d0748c:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d0748e:	4639      	mov	r1, r7
c0d07490:	f7ff fe46 	bl	c0d07120 <gt256>
c0d07494:	a91c      	add	r1, sp, #112	; 0x70
c0d07496:	aa24      	add	r2, sp, #144	; 0x90
c0d07498:	2800      	cmp	r0, #0
c0d0749a:	d019      	beq.n	c0d074d0 <divmod256+0xa8>
c0d0749c:	4638      	mov	r0, r7
c0d0749e:	3018      	adds	r0, #24
c0d074a0:	4639      	mov	r1, r7
c0d074a2:	3110      	adds	r1, #16
c0d074a4:	3708      	adds	r7, #8
    UPPER_P(target) = UPPER_P(number);
c0d074a6:	9a07      	ldr	r2, [sp, #28]
c0d074a8:	9c06      	ldr	r4, [sp, #24]
c0d074aa:	6022      	str	r2, [r4, #0]
c0d074ac:	9a08      	ldr	r2, [sp, #32]
c0d074ae:	6062      	str	r2, [r4, #4]
    LOWER_P(target) = LOWER_P(number);
c0d074b0:	cf0c      	ldmia	r7!, {r2, r3}
c0d074b2:	60e3      	str	r3, [r4, #12]
c0d074b4:	60a2      	str	r2, [r4, #8]
    UPPER_P(target) = UPPER_P(number);
c0d074b6:	680a      	ldr	r2, [r1, #0]
c0d074b8:	6849      	ldr	r1, [r1, #4]
c0d074ba:	6161      	str	r1, [r4, #20]
c0d074bc:	6122      	str	r2, [r4, #16]
    LOWER_P(target) = LOWER_P(number);
c0d074be:	6801      	ldr	r1, [r0, #0]
c0d074c0:	6840      	ldr	r0, [r0, #4]
c0d074c2:	61e0      	str	r0, [r4, #28]
c0d074c4:	61a1      	str	r1, [r4, #24]
c0d074c6:	2120      	movs	r1, #32
    LOWER_P(target) = 0;
c0d074c8:	9805      	ldr	r0, [sp, #20]
c0d074ca:	f002 f88d 	bl	c0d095e8 <__aeabi_memclr>
c0d074ce:	e0dc      	b.n	c0d0768a <divmod256+0x262>
c0d074d0:	920b      	str	r2, [sp, #44]	; 0x2c
c0d074d2:	9100      	str	r1, [sp, #0]
c0d074d4:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d074d6:	9910      	ldr	r1, [sp, #64]	; 0x40
c0d074d8:	1a45      	subs	r5, r0, r1
c0d074da:	aa2c      	add	r2, sp, #176	; 0xb0
c0d074dc:	9f13      	ldr	r7, [sp, #76]	; 0x4c
        copy256(retMod, l);
        clear256(retDiv);
    } else {
        shiftl256(r, diffBits, &copyd);
c0d074de:	4638      	mov	r0, r7
c0d074e0:	4629      	mov	r1, r5
c0d074e2:	f7ff fc89 	bl	c0d06df8 <shiftl256>
c0d074e6:	a814      	add	r0, sp, #80	; 0x50
c0d074e8:	aa24      	add	r2, sp, #144	; 0x90
        shiftl256(&one, diffBits, &adder);
c0d074ea:	4629      	mov	r1, r5
c0d074ec:	f7ff fc84 	bl	c0d06df8 <shiftl256>
    return (UPPER_P(number1) == UPPER_P(number2)) && (LOWER_P(number1) == LOWER_P(number2));
c0d074f0:	982d      	ldr	r0, [sp, #180]	; 0xb4
c0d074f2:	4602      	mov	r2, r0
c0d074f4:	9d08      	ldr	r5, [sp, #32]
c0d074f6:	406a      	eors	r2, r5
c0d074f8:	992c      	ldr	r1, [sp, #176]	; 0xb0
c0d074fa:	460b      	mov	r3, r1
c0d074fc:	9c07      	ldr	r4, [sp, #28]
c0d074fe:	4063      	eors	r3, r4
c0d07500:	4313      	orrs	r3, r2
c0d07502:	2b00      	cmp	r3, #0
c0d07504:	d11e      	bne.n	c0d07544 <divmod256+0x11c>
c0d07506:	982e      	ldr	r0, [sp, #184]	; 0xb8
c0d07508:	4602      	mov	r2, r0
c0d0750a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
c0d0750c:	4072      	eors	r2, r6
c0d0750e:	992f      	ldr	r1, [sp, #188]	; 0xbc
c0d07510:	460b      	mov	r3, r1
c0d07512:	9f04      	ldr	r7, [sp, #16]
c0d07514:	407b      	eors	r3, r7
c0d07516:	4313      	orrs	r3, r2
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
c0d07518:	2b00      	cmp	r3, #0
c0d0751a:	d000      	beq.n	c0d0751e <divmod256+0xf6>
c0d0751c:	e0b7      	b.n	c0d0768e <divmod256+0x266>
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d0751e:	9830      	ldr	r0, [sp, #192]	; 0xc0
c0d07520:	4602      	mov	r2, r0
c0d07522:	9e03      	ldr	r6, [sp, #12]
c0d07524:	4072      	eors	r2, r6
c0d07526:	9931      	ldr	r1, [sp, #196]	; 0xc4
c0d07528:	460b      	mov	r3, r1
c0d0752a:	9f02      	ldr	r7, [sp, #8]
c0d0752c:	407b      	eors	r3, r7
c0d0752e:	4313      	orrs	r3, r2
c0d07530:	2b00      	cmp	r3, #0
c0d07532:	d000      	beq.n	c0d07536 <divmod256+0x10e>
c0d07534:	e0af      	b.n	c0d07696 <divmod256+0x26e>
        return (LOWER_P(number1) > LOWER_P(number2));
c0d07536:	9833      	ldr	r0, [sp, #204]	; 0xcc
c0d07538:	9932      	ldr	r1, [sp, #200]	; 0xc8
c0d0753a:	9a01      	ldr	r2, [sp, #4]
c0d0753c:	1a51      	subs	r1, r2, r1
c0d0753e:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d07540:	4181      	sbcs	r1, r0
c0d07542:	e0aa      	b.n	c0d0769a <divmod256+0x272>
    return (UPPER_P(number1) > UPPER_P(number2));
c0d07544:	1a61      	subs	r1, r4, r1
c0d07546:	4629      	mov	r1, r5
c0d07548:	4181      	sbcs	r1, r0
        if (gt256(&copyd, &resMod)) {
c0d0754a:	d20a      	bcs.n	c0d07562 <divmod256+0x13a>
c0d0754c:	2401      	movs	r4, #1
c0d0754e:	a82c      	add	r0, sp, #176	; 0xb0
            shiftr256(&copyd, 1, &copyd);
c0d07550:	4621      	mov	r1, r4
c0d07552:	4602      	mov	r2, r0
c0d07554:	f7ff fd22 	bl	c0d06f9c <shiftr256>
c0d07558:	a824      	add	r0, sp, #144	; 0x90
            shiftr256(&adder, 1, &adder);
c0d0755a:	4621      	mov	r1, r4
c0d0755c:	4602      	mov	r2, r0
c0d0755e:	f7ff fd1d 	bl	c0d06f9c <shiftr256>
c0d07562:	a81c      	add	r0, sp, #112	; 0x70
        }
        while (gte256(&resMod, r)) {
c0d07564:	4639      	mov	r1, r7
c0d07566:	f7ff fe0b 	bl	c0d07180 <gte256>
c0d0756a:	2800      	cmp	r0, #0
c0d0756c:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d0756e:	4605      	mov	r5, r0
c0d07570:	4606      	mov	r6, r0
c0d07572:	4604      	mov	r4, r0
c0d07574:	9010      	str	r0, [sp, #64]	; 0x40
c0d07576:	900f      	str	r0, [sp, #60]	; 0x3c
c0d07578:	4607      	mov	r7, r0
c0d0757a:	9011      	str	r0, [sp, #68]	; 0x44
c0d0757c:	9905      	ldr	r1, [sp, #20]
c0d0757e:	9a06      	ldr	r2, [sp, #24]
c0d07580:	d06a      	beq.n	c0d07658 <divmod256+0x230>
c0d07582:	9800      	ldr	r0, [sp, #0]
c0d07584:	4601      	mov	r1, r0
c0d07586:	3118      	adds	r1, #24
c0d07588:	9109      	str	r1, [sp, #36]	; 0x24
c0d0758a:	4601      	mov	r1, r0
c0d0758c:	3110      	adds	r1, #16
c0d0758e:	910a      	str	r1, [sp, #40]	; 0x28
c0d07590:	3008      	adds	r0, #8
c0d07592:	9000      	str	r0, [sp, #0]
c0d07594:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d07596:	4605      	mov	r5, r0
c0d07598:	3508      	adds	r5, #8
c0d0759a:	4606      	mov	r6, r0
c0d0759c:	3610      	adds	r6, #16
c0d0759e:	3018      	adds	r0, #24
c0d075a0:	900b      	str	r0, [sp, #44]	; 0x2c
c0d075a2:	2700      	movs	r7, #0
c0d075a4:	9711      	str	r7, [sp, #68]	; 0x44
c0d075a6:	9710      	str	r7, [sp, #64]	; 0x40
c0d075a8:	970f      	str	r7, [sp, #60]	; 0x3c
c0d075aa:	970e      	str	r7, [sp, #56]	; 0x38
c0d075ac:	970d      	str	r7, [sp, #52]	; 0x34
c0d075ae:	9712      	str	r7, [sp, #72]	; 0x48
c0d075b0:	970c      	str	r7, [sp, #48]	; 0x30
c0d075b2:	a81c      	add	r0, sp, #112	; 0x70
c0d075b4:	a92c      	add	r1, sp, #176	; 0xb0
            if (gte256(&resMod, &copyd)) {
c0d075b6:	f7ff fde3 	bl	c0d07180 <gte256>
c0d075ba:	2800      	cmp	r0, #0
c0d075bc:	d022      	beq.n	c0d07604 <divmod256+0x1dc>
c0d075be:	a92c      	add	r1, sp, #176	; 0xb0
c0d075c0:	a81c      	add	r0, sp, #112	; 0x70
                minus256(&resMod, &copyd, &resMod);
c0d075c2:	4602      	mov	r2, r0
c0d075c4:	f7ff fe0b 	bl	c0d071de <minus256>
c0d075c8:	990b      	ldr	r1, [sp, #44]	; 0x2c
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d075ca:	c903      	ldmia	r1, {r0, r1}
c0d075cc:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d075ce:	430a      	orrs	r2, r1
c0d075d0:	9211      	str	r2, [sp, #68]	; 0x44
c0d075d2:	4307      	orrs	r7, r0
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d075d4:	ce03      	ldmia	r6!, {r0, r1}
c0d075d6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d075d8:	430a      	orrs	r2, r1
c0d075da:	920f      	str	r2, [sp, #60]	; 0x3c
c0d075dc:	9910      	ldr	r1, [sp, #64]	; 0x40
c0d075de:	4301      	orrs	r1, r0
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d075e0:	9110      	str	r1, [sp, #64]	; 0x40
c0d075e2:	cd03      	ldmia	r5!, {r0, r1}
c0d075e4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0d075e6:	430a      	orrs	r2, r1
c0d075e8:	920d      	str	r2, [sp, #52]	; 0x34
c0d075ea:	990e      	ldr	r1, [sp, #56]	; 0x38
c0d075ec:	4301      	orrs	r1, r0
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d075ee:	910e      	str	r1, [sp, #56]	; 0x38
c0d075f0:	9825      	ldr	r0, [sp, #148]	; 0x94
c0d075f2:	990c      	ldr	r1, [sp, #48]	; 0x30
c0d075f4:	4301      	orrs	r1, r0
c0d075f6:	910c      	str	r1, [sp, #48]	; 0x30
c0d075f8:	9824      	ldr	r0, [sp, #144]	; 0x90
c0d075fa:	9912      	ldr	r1, [sp, #72]	; 0x48
c0d075fc:	4301      	orrs	r1, r0
c0d075fe:	9112      	str	r1, [sp, #72]	; 0x48
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d07600:	3d08      	subs	r5, #8
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d07602:	3e08      	subs	r6, #8
c0d07604:	2401      	movs	r4, #1
c0d07606:	a82c      	add	r0, sp, #176	; 0xb0
                or256(&resDiv, &adder, &resDiv);
            }
            shiftr256(&copyd, 1, &copyd);
c0d07608:	4621      	mov	r1, r4
c0d0760a:	4602      	mov	r2, r0
c0d0760c:	f7ff fcc6 	bl	c0d06f9c <shiftr256>
c0d07610:	a824      	add	r0, sp, #144	; 0x90
            shiftr256(&adder, 1, &adder);
c0d07612:	4621      	mov	r1, r4
c0d07614:	4602      	mov	r2, r0
c0d07616:	f7ff fcc1 	bl	c0d06f9c <shiftr256>
c0d0761a:	a81c      	add	r0, sp, #112	; 0x70
        while (gte256(&resMod, r)) {
c0d0761c:	9913      	ldr	r1, [sp, #76]	; 0x4c
c0d0761e:	f7ff fdaf 	bl	c0d07180 <gte256>
c0d07622:	2800      	cmp	r0, #0
c0d07624:	d1c5      	bne.n	c0d075b2 <divmod256+0x18a>
c0d07626:	9809      	ldr	r0, [sp, #36]	; 0x24
    LOWER_P(target) = LOWER_P(number);
c0d07628:	6801      	ldr	r1, [r0, #0]
c0d0762a:	9101      	str	r1, [sp, #4]
c0d0762c:	6840      	ldr	r0, [r0, #4]
c0d0762e:	9009      	str	r0, [sp, #36]	; 0x24
c0d07630:	990a      	ldr	r1, [sp, #40]	; 0x28
    UPPER_P(target) = UPPER_P(number);
c0d07632:	6808      	ldr	r0, [r1, #0]
c0d07634:	9003      	str	r0, [sp, #12]
c0d07636:	6848      	ldr	r0, [r1, #4]
c0d07638:	9002      	str	r0, [sp, #8]
c0d0763a:	9800      	ldr	r0, [sp, #0]
    LOWER_P(target) = LOWER_P(number);
c0d0763c:	6801      	ldr	r1, [r0, #0]
c0d0763e:	910a      	str	r1, [sp, #40]	; 0x28
c0d07640:	6840      	ldr	r0, [r0, #4]
    UPPER_P(target) = UPPER_P(number);
c0d07642:	9004      	str	r0, [sp, #16]
c0d07644:	981d      	ldr	r0, [sp, #116]	; 0x74
c0d07646:	9008      	str	r0, [sp, #32]
c0d07648:	981c      	ldr	r0, [sp, #112]	; 0x70
c0d0764a:	9007      	str	r0, [sp, #28]
c0d0764c:	9a06      	ldr	r2, [sp, #24]
c0d0764e:	9905      	ldr	r1, [sp, #20]
c0d07650:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d07652:	9e0e      	ldr	r6, [sp, #56]	; 0x38
c0d07654:	9c0d      	ldr	r4, [sp, #52]	; 0x34
c0d07656:	9d0c      	ldr	r5, [sp, #48]	; 0x30
c0d07658:	c161      	stmia	r1!, {r0, r5, r6}
    LOWER_P(target) = LOWER_P(number);
c0d0765a:	600c      	str	r4, [r1, #0]
    UPPER_P(target) = UPPER_P(number);
c0d0765c:	9810      	ldr	r0, [sp, #64]	; 0x40
c0d0765e:	6048      	str	r0, [r1, #4]
c0d07660:	980f      	ldr	r0, [sp, #60]	; 0x3c
c0d07662:	6088      	str	r0, [r1, #8]
    LOWER_P(target) = LOWER_P(number);
c0d07664:	60cf      	str	r7, [r1, #12]
c0d07666:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d07668:	6108      	str	r0, [r1, #16]
    UPPER_P(target) = UPPER_P(number);
c0d0766a:	9807      	ldr	r0, [sp, #28]
c0d0766c:	6010      	str	r0, [r2, #0]
c0d0766e:	9808      	ldr	r0, [sp, #32]
c0d07670:	6050      	str	r0, [r2, #4]
    LOWER_P(target) = LOWER_P(number);
c0d07672:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d07674:	6090      	str	r0, [r2, #8]
c0d07676:	9804      	ldr	r0, [sp, #16]
c0d07678:	60d0      	str	r0, [r2, #12]
    UPPER_P(target) = UPPER_P(number);
c0d0767a:	9803      	ldr	r0, [sp, #12]
c0d0767c:	6110      	str	r0, [r2, #16]
c0d0767e:	9802      	ldr	r0, [sp, #8]
c0d07680:	6150      	str	r0, [r2, #20]
    LOWER_P(target) = LOWER_P(number);
c0d07682:	9801      	ldr	r0, [sp, #4]
c0d07684:	6190      	str	r0, [r2, #24]
c0d07686:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d07688:	61d0      	str	r0, [r2, #28]
        }
        copy256(retDiv, &resDiv);
        copy256(retMod, &resMod);
    }
}
c0d0768a:	b035      	add	sp, #212	; 0xd4
c0d0768c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return (LOWER_P(number1) > LOWER_P(number2));
c0d0768e:	1a30      	subs	r0, r6, r0
c0d07690:	4638      	mov	r0, r7
c0d07692:	4188      	sbcs	r0, r1
c0d07694:	e001      	b.n	c0d0769a <divmod256+0x272>
    return (UPPER_P(number1) > UPPER_P(number2));
c0d07696:	1a30      	subs	r0, r6, r0
c0d07698:	418f      	sbcs	r7, r1
c0d0769a:	9f13      	ldr	r7, [sp, #76]	; 0x4c
c0d0769c:	d200      	bcs.n	c0d076a0 <divmod256+0x278>
c0d0769e:	e755      	b.n	c0d0754c <divmod256+0x124>
        if (gt256(&copyd, &resMod)) {
c0d076a0:	e75f      	b.n	c0d07562 <divmod256+0x13a>
	...

c0d076a4 <tostring256>:
    out[offset] = '\0';
    reverseString(out, offset);
    return true;
}

bool tostring256(uint256_t *number, uint32_t baseParam, char *out, uint32_t outLength) {
c0d076a4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d076a6:	b0a1      	sub	sp, #132	; 0x84
c0d076a8:	9301      	str	r3, [sp, #4]
c0d076aa:	9207      	str	r2, [sp, #28]
c0d076ac:	9106      	str	r1, [sp, #24]
    UPPER_P(target) = UPPER_P(number);
c0d076ae:	c8fe      	ldmia	r0!, {r1, r2, r3, r4, r5, r6, r7}
    LOWER_P(target) = LOWER_P(number);
c0d076b0:	6800      	ldr	r0, [r0, #0]
c0d076b2:	901f      	str	r0, [sp, #124]	; 0x7c
    UPPER_P(target) = UPPER_P(number);
c0d076b4:	a818      	add	r0, sp, #96	; 0x60
c0d076b6:	c0fe      	stmia	r0!, {r1, r2, r3, r4, r5, r6, r7}
c0d076b8:	a810      	add	r0, sp, #64	; 0x40
c0d076ba:	2120      	movs	r1, #32
    LOWER_P(target) = 0;
c0d076bc:	f001 ff94 	bl	c0d095e8 <__aeabi_memclr>
c0d076c0:	a808      	add	r0, sp, #32
c0d076c2:	2118      	movs	r1, #24
    uint256_t rMod;
    uint256_t base;
    copy256(&rDiv, number);
    clear256(&rMod);
    clear256(&base);
    UPPER(LOWER(base)) = 0;
c0d076c4:	f001 ff90 	bl	c0d095e8 <__aeabi_memclr>
c0d076c8:	2000      	movs	r0, #0
    LOWER(LOWER(base)) = baseParam;
c0d076ca:	900f      	str	r0, [sp, #60]	; 0x3c
c0d076cc:	aa18      	add	r2, sp, #96	; 0x60
c0d076ce:	9906      	ldr	r1, [sp, #24]
c0d076d0:	910e      	str	r1, [sp, #56]	; 0x38
    uint32_t offset = 0;
    if ((baseParam < 2) || (baseParam > 16)) {
c0d076d2:	1e89      	subs	r1, r1, #2
c0d076d4:	290e      	cmp	r1, #14
c0d076d6:	d84e      	bhi.n	c0d07776 <tostring256+0xd2>
c0d076d8:	9000      	str	r0, [sp, #0]
c0d076da:	4610      	mov	r0, r2
c0d076dc:	3018      	adds	r0, #24
c0d076de:	9004      	str	r0, [sp, #16]
c0d076e0:	4610      	mov	r0, r2
c0d076e2:	3010      	adds	r0, #16
c0d076e4:	9003      	str	r0, [sp, #12]
c0d076e6:	3208      	adds	r2, #8
c0d076e8:	9205      	str	r2, [sp, #20]
c0d076ea:	a810      	add	r0, sp, #64	; 0x40
c0d076ec:	3018      	adds	r0, #24
c0d076ee:	9002      	str	r0, [sp, #8]
c0d076f0:	9801      	ldr	r0, [sp, #4]
c0d076f2:	1e40      	subs	r0, r0, #1
c0d076f4:	9006      	str	r0, [sp, #24]
c0d076f6:	2001      	movs	r0, #1
c0d076f8:	9001      	str	r0, [sp, #4]
c0d076fa:	43c7      	mvns	r7, r0
c0d076fc:	1c7c      	adds	r4, r7, #1
        return false;
    }
    do {
        if (offset > (outLength - 1)) {
c0d076fe:	1cb8      	adds	r0, r7, #2
c0d07700:	9906      	ldr	r1, [sp, #24]
c0d07702:	4288      	cmp	r0, r1
c0d07704:	d836      	bhi.n	c0d07774 <tostring256+0xd0>
c0d07706:	a908      	add	r1, sp, #32
c0d07708:	a818      	add	r0, sp, #96	; 0x60
c0d0770a:	ab10      	add	r3, sp, #64	; 0x40
            return false;
        }
        divmod256(&rDiv, &base, &rDiv, &rMod);
c0d0770c:	4602      	mov	r2, r0
c0d0770e:	f7ff fe8b 	bl	c0d07428 <divmod256>
        out[offset++] = HEXDIGITS[(uint8_t) LOWER(LOWER(rMod))];
c0d07712:	9807      	ldr	r0, [sp, #28]
c0d07714:	19c1      	adds	r1, r0, r7
c0d07716:	9802      	ldr	r0, [sp, #8]
c0d07718:	7800      	ldrb	r0, [r0, #0]
c0d0771a:	4a18      	ldr	r2, [pc, #96]	; (c0d0777c <tostring256+0xd8>)
c0d0771c:	447a      	add	r2, pc
c0d0771e:	5c10      	ldrb	r0, [r2, r0]
c0d07720:	7088      	strb	r0, [r1, #2]
c0d07722:	9904      	ldr	r1, [sp, #16]
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d07724:	c90c      	ldmia	r1!, {r2, r3}
c0d07726:	9d03      	ldr	r5, [sp, #12]
c0d07728:	cd22      	ldmia	r5, {r1, r5}
c0d0772a:	431d      	orrs	r5, r3
c0d0772c:	9e05      	ldr	r6, [sp, #20]
c0d0772e:	ce48      	ldmia	r6, {r3, r6}
c0d07730:	432e      	orrs	r6, r5
c0d07732:	9d19      	ldr	r5, [sp, #100]	; 0x64
c0d07734:	4335      	orrs	r5, r6
c0d07736:	4311      	orrs	r1, r2
c0d07738:	4319      	orrs	r1, r3
c0d0773a:	9a18      	ldr	r2, [sp, #96]	; 0x60
c0d0773c:	430a      	orrs	r2, r1
c0d0773e:	432a      	orrs	r2, r5
c0d07740:	1c7f      	adds	r7, r7, #1
c0d07742:	1c64      	adds	r4, r4, #1
c0d07744:	2a00      	cmp	r2, #0
c0d07746:	d1da      	bne.n	c0d076fe <tostring256+0x5a>
c0d07748:	9b07      	ldr	r3, [sp, #28]
    } while (!zero256(&rDiv));
    out[offset] = '\0';
c0d0774a:	19d9      	adds	r1, r3, r7
c0d0774c:	2200      	movs	r2, #0
c0d0774e:	708a      	strb	r2, [r1, #2]
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d07750:	2c00      	cmp	r4, #0
c0d07752:	d00d      	beq.n	c0d07770 <tostring256+0xcc>
        c = str[i];
c0d07754:	7819      	ldrb	r1, [r3, #0]
        str[i] = str[j];
c0d07756:	7018      	strb	r0, [r3, #0]
        str[j] = c;
c0d07758:	5519      	strb	r1, [r3, r4]
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d0775a:	2f02      	cmp	r7, #2
c0d0775c:	d308      	bcc.n	c0d07770 <tostring256+0xcc>
c0d0775e:	2001      	movs	r0, #1
        c = str[i];
c0d07760:	5c19      	ldrb	r1, [r3, r0]
        str[i] = str[j];
c0d07762:	5dda      	ldrb	r2, [r3, r7]
c0d07764:	541a      	strb	r2, [r3, r0]
        str[j] = c;
c0d07766:	55d9      	strb	r1, [r3, r7]
c0d07768:	1e7f      	subs	r7, r7, #1
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d0776a:	1c40      	adds	r0, r0, #1
c0d0776c:	42b8      	cmp	r0, r7
c0d0776e:	d3f7      	bcc.n	c0d07760 <tostring256+0xbc>
c0d07770:	9801      	ldr	r0, [sp, #4]
c0d07772:	e000      	b.n	c0d07776 <tostring256+0xd2>
c0d07774:	9800      	ldr	r0, [sp, #0]
    reverseString(out, offset);
    return true;
}
c0d07776:	b021      	add	sp, #132	; 0x84
c0d07778:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0777a:	46c0      	nop			; (mov r8, r8)
c0d0777c:	00002692 	.word	0x00002692

c0d07780 <USBD_LL_Init>:
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  UNUSED(pdev);
  ep_in_stall = 0;
  ep_out_stall = 0;
c0d07780:	4902      	ldr	r1, [pc, #8]	; (c0d0778c <USBD_LL_Init+0xc>)
c0d07782:	2000      	movs	r0, #0
c0d07784:	6008      	str	r0, [r1, #0]
  ep_in_stall = 0;
c0d07786:	4902      	ldr	r1, [pc, #8]	; (c0d07790 <USBD_LL_Init+0x10>)
c0d07788:	6008      	str	r0, [r1, #0]
  return USBD_OK;
c0d0778a:	4770      	bx	lr
c0d0778c:	20002070 	.word	0x20002070
c0d07790:	2000206c 	.word	0x2000206c

c0d07794 <USBD_LL_DeInit>:
  * @brief  De-Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_DeInit (USBD_HandleTypeDef *pdev)
{
c0d07794:	b510      	push	{r4, lr}
  UNUSED(pdev);
  // usb off
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d07796:	4807      	ldr	r0, [pc, #28]	; (c0d077b4 <USBD_LL_DeInit+0x20>)
c0d07798:	2102      	movs	r1, #2
  G_io_seproxyhal_spi_buffer[1] = 0;
  G_io_seproxyhal_spi_buffer[2] = 1;
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT;
c0d0779a:	70c1      	strb	r1, [r0, #3]
c0d0779c:	2101      	movs	r1, #1
  G_io_seproxyhal_spi_buffer[2] = 1;
c0d0779e:	7081      	strb	r1, [r0, #2]
c0d077a0:	2400      	movs	r4, #0
  G_io_seproxyhal_spi_buffer[1] = 0;
c0d077a2:	7044      	strb	r4, [r0, #1]
c0d077a4:	214f      	movs	r1, #79	; 0x4f
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d077a6:	7001      	strb	r1, [r0, #0]
c0d077a8:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 4);
c0d077aa:	f7fe f9a3 	bl	c0d05af4 <io_seph_send>

  return USBD_OK; 
c0d077ae:	4620      	mov	r0, r4
c0d077b0:	bd10      	pop	{r4, pc}
c0d077b2:	46c0      	nop			; (mov r8, r8)
c0d077b4:	20001a5c 	.word	0x20001a5c

c0d077b8 <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
c0d077b8:	b570      	push	{r4, r5, r6, lr}
c0d077ba:	b082      	sub	sp, #8
c0d077bc:	466d      	mov	r5, sp
c0d077be:	2400      	movs	r4, #0
  // reset address
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 2;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
  buffer[4] = 0;
c0d077c0:	712c      	strb	r4, [r5, #4]
c0d077c2:	2003      	movs	r0, #3
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
c0d077c4:	70e8      	strb	r0, [r5, #3]
c0d077c6:	2002      	movs	r0, #2
  buffer[2] = 2;
c0d077c8:	70a8      	strb	r0, [r5, #2]
  buffer[1] = 0;
c0d077ca:	706c      	strb	r4, [r5, #1]
c0d077cc:	264f      	movs	r6, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d077ce:	702e      	strb	r6, [r5, #0]
c0d077d0:	2105      	movs	r1, #5
  io_seproxyhal_spi_send(buffer, 5);
c0d077d2:	4628      	mov	r0, r5
c0d077d4:	f7fe f98e 	bl	c0d05af4 <io_seph_send>
c0d077d8:	2001      	movs	r0, #1
  
  // start usb operation
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 1;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_CONNECT;
c0d077da:	70e8      	strb	r0, [r5, #3]
  buffer[2] = 1;
c0d077dc:	70a8      	strb	r0, [r5, #2]
  buffer[1] = 0;
c0d077de:	706c      	strb	r4, [r5, #1]
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d077e0:	702e      	strb	r6, [r5, #0]
c0d077e2:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(buffer, 4);
c0d077e4:	4628      	mov	r0, r5
c0d077e6:	f7fe f985 	bl	c0d05af4 <io_seph_send>
  return USBD_OK; 
c0d077ea:	4620      	mov	r0, r4
c0d077ec:	b002      	add	sp, #8
c0d077ee:	bd70      	pop	{r4, r5, r6, pc}

c0d077f0 <USBD_LL_Stop>:
  * @brief  Stops the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev)
{
c0d077f0:	b510      	push	{r4, lr}
c0d077f2:	b082      	sub	sp, #8
c0d077f4:	a801      	add	r0, sp, #4
c0d077f6:	2102      	movs	r1, #2
  UNUSED(pdev);
  uint8_t buffer[4];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 1;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT;
c0d077f8:	70c1      	strb	r1, [r0, #3]
c0d077fa:	2101      	movs	r1, #1
  buffer[2] = 1;
c0d077fc:	7081      	strb	r1, [r0, #2]
c0d077fe:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d07800:	7044      	strb	r4, [r0, #1]
c0d07802:	214f      	movs	r1, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d07804:	7001      	strb	r1, [r0, #0]
c0d07806:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(buffer, 4);
c0d07808:	f7fe f974 	bl	c0d05af4 <io_seph_send>
  return USBD_OK; 
c0d0780c:	4620      	mov	r0, r4
c0d0780e:	b002      	add	sp, #8
c0d07810:	bd10      	pop	{r4, pc}
	...

c0d07814 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
c0d07814:	b570      	push	{r4, r5, r6, lr}
c0d07816:	b082      	sub	sp, #8
  uint8_t buffer[8];
  UNUSED(pdev);

  ep_in_stall = 0;
  ep_out_stall = 0;
c0d07818:	4814      	ldr	r0, [pc, #80]	; (c0d0786c <USBD_LL_OpenEP+0x58>)
c0d0781a:	2400      	movs	r4, #0
c0d0781c:	6004      	str	r4, [r0, #0]
  ep_in_stall = 0;
c0d0781e:	4814      	ldr	r0, [pc, #80]	; (c0d07870 <USBD_LL_OpenEP+0x5c>)
c0d07820:	6004      	str	r4, [r0, #0]
c0d07822:	466d      	mov	r5, sp
  buffer[1] = 0;
  buffer[2] = 5;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
  buffer[4] = 1;
  buffer[5] = ep_addr;
  buffer[6] = 0;
c0d07824:	71ac      	strb	r4, [r5, #6]
  buffer[5] = ep_addr;
c0d07826:	7169      	strb	r1, [r5, #5]
c0d07828:	2001      	movs	r0, #1
  buffer[4] = 1;
c0d0782a:	7128      	strb	r0, [r5, #4]
c0d0782c:	2104      	movs	r1, #4
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
c0d0782e:	70e9      	strb	r1, [r5, #3]
c0d07830:	2605      	movs	r6, #5
  buffer[2] = 5;
c0d07832:	70ae      	strb	r6, [r5, #2]
  buffer[1] = 0;
c0d07834:	706c      	strb	r4, [r5, #1]
c0d07836:	244f      	movs	r4, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d07838:	702c      	strb	r4, [r5, #0]
  switch(ep_type) {
c0d0783a:	2a01      	cmp	r2, #1
c0d0783c:	dc05      	bgt.n	c0d0784a <USBD_LL_OpenEP+0x36>
c0d0783e:	2a00      	cmp	r2, #0
c0d07840:	d00a      	beq.n	c0d07858 <USBD_LL_OpenEP+0x44>
c0d07842:	2a01      	cmp	r2, #1
c0d07844:	d10a      	bne.n	c0d0785c <USBD_LL_OpenEP+0x48>
c0d07846:	4608      	mov	r0, r1
c0d07848:	e006      	b.n	c0d07858 <USBD_LL_OpenEP+0x44>
c0d0784a:	2a02      	cmp	r2, #2
c0d0784c:	d003      	beq.n	c0d07856 <USBD_LL_OpenEP+0x42>
c0d0784e:	2a03      	cmp	r2, #3
c0d07850:	d104      	bne.n	c0d0785c <USBD_LL_OpenEP+0x48>
c0d07852:	2002      	movs	r0, #2
c0d07854:	e000      	b.n	c0d07858 <USBD_LL_OpenEP+0x44>
c0d07856:	2003      	movs	r0, #3
c0d07858:	4669      	mov	r1, sp
c0d0785a:	7188      	strb	r0, [r1, #6]
c0d0785c:	4668      	mov	r0, sp
      break;
    case USBD_EP_TYPE_INTR:
      buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT;
      break;
  }
  buffer[7] = ep_mps;
c0d0785e:	71c3      	strb	r3, [r0, #7]
c0d07860:	2108      	movs	r1, #8
  io_seproxyhal_spi_send(buffer, 8);
c0d07862:	f7fe f947 	bl	c0d05af4 <io_seph_send>
c0d07866:	2000      	movs	r0, #0
  return USBD_OK; 
c0d07868:	b002      	add	sp, #8
c0d0786a:	bd70      	pop	{r4, r5, r6, pc}
c0d0786c:	20002070 	.word	0x20002070
c0d07870:	2000206c 	.word	0x2000206c

c0d07874 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
c0d07874:	b510      	push	{r4, lr}
c0d07876:	b082      	sub	sp, #8
c0d07878:	4668      	mov	r0, sp
c0d0787a:	2400      	movs	r4, #0
  buffer[2] = 5;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
  buffer[4] = 1;
  buffer[5] = ep_addr;
  buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED;
  buffer[7] = 0;
c0d0787c:	71c4      	strb	r4, [r0, #7]
  buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED;
c0d0787e:	7184      	strb	r4, [r0, #6]
  buffer[5] = ep_addr;
c0d07880:	7141      	strb	r1, [r0, #5]
c0d07882:	2101      	movs	r1, #1
  buffer[4] = 1;
c0d07884:	7101      	strb	r1, [r0, #4]
c0d07886:	2104      	movs	r1, #4
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
c0d07888:	70c1      	strb	r1, [r0, #3]
c0d0788a:	2105      	movs	r1, #5
  buffer[2] = 5;
c0d0788c:	7081      	strb	r1, [r0, #2]
  buffer[1] = 0;
c0d0788e:	7044      	strb	r4, [r0, #1]
c0d07890:	214f      	movs	r1, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d07892:	7001      	strb	r1, [r0, #0]
c0d07894:	2108      	movs	r1, #8
  io_seproxyhal_spi_send(buffer, 8);
c0d07896:	f7fe f92d 	bl	c0d05af4 <io_seph_send>
  return USBD_OK; 
c0d0789a:	4620      	mov	r0, r4
c0d0789c:	b002      	add	sp, #8
c0d0789e:	bd10      	pop	{r4, pc}

c0d078a0 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{ 
c0d078a0:	b5b0      	push	{r4, r5, r7, lr}
c0d078a2:	b082      	sub	sp, #8
c0d078a4:	460d      	mov	r5, r1
c0d078a6:	4668      	mov	r0, sp
c0d078a8:	2400      	movs	r4, #0
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = 0;
  buffer[2] = 3;
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL;
  buffer[5] = 0;
c0d078aa:	7144      	strb	r4, [r0, #5]
c0d078ac:	2140      	movs	r1, #64	; 0x40
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL;
c0d078ae:	7101      	strb	r1, [r0, #4]
  buffer[3] = ep_addr;
c0d078b0:	70c5      	strb	r5, [r0, #3]
c0d078b2:	2103      	movs	r1, #3
  buffer[2] = 3;
c0d078b4:	7081      	strb	r1, [r0, #2]
  buffer[1] = 0;
c0d078b6:	7044      	strb	r4, [r0, #1]
c0d078b8:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d078ba:	7001      	strb	r1, [r0, #0]
c0d078bc:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0d078be:	f7fe f919 	bl	c0d05af4 <io_seph_send>
  if (ep_addr & 0x80) {
c0d078c2:	0628      	lsls	r0, r5, #24
c0d078c4:	d501      	bpl.n	c0d078ca <USBD_LL_StallEP+0x2a>
c0d078c6:	4807      	ldr	r0, [pc, #28]	; (c0d078e4 <USBD_LL_StallEP+0x44>)
c0d078c8:	e000      	b.n	c0d078cc <USBD_LL_StallEP+0x2c>
c0d078ca:	4805      	ldr	r0, [pc, #20]	; (c0d078e0 <USBD_LL_StallEP+0x40>)
c0d078cc:	6801      	ldr	r1, [r0, #0]
c0d078ce:	227f      	movs	r2, #127	; 0x7f
c0d078d0:	4015      	ands	r5, r2
c0d078d2:	2201      	movs	r2, #1
c0d078d4:	40aa      	lsls	r2, r5
c0d078d6:	430a      	orrs	r2, r1
c0d078d8:	6002      	str	r2, [r0, #0]
    ep_in_stall |= (1<<(ep_addr&0x7F));
  }
  else {
    ep_out_stall |= (1<<(ep_addr&0x7F)); 
  }
  return USBD_OK; 
c0d078da:	4620      	mov	r0, r4
c0d078dc:	b002      	add	sp, #8
c0d078de:	bdb0      	pop	{r4, r5, r7, pc}
c0d078e0:	20002070 	.word	0x20002070
c0d078e4:	2000206c 	.word	0x2000206c

c0d078e8 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
c0d078e8:	b5b0      	push	{r4, r5, r7, lr}
c0d078ea:	b082      	sub	sp, #8
c0d078ec:	460d      	mov	r5, r1
c0d078ee:	4668      	mov	r0, sp
c0d078f0:	2400      	movs	r4, #0
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = 0;
  buffer[2] = 3;
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL;
  buffer[5] = 0;
c0d078f2:	7144      	strb	r4, [r0, #5]
c0d078f4:	2180      	movs	r1, #128	; 0x80
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL;
c0d078f6:	7101      	strb	r1, [r0, #4]
  buffer[3] = ep_addr;
c0d078f8:	70c5      	strb	r5, [r0, #3]
c0d078fa:	2103      	movs	r1, #3
  buffer[2] = 3;
c0d078fc:	7081      	strb	r1, [r0, #2]
  buffer[1] = 0;
c0d078fe:	7044      	strb	r4, [r0, #1]
c0d07900:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d07902:	7001      	strb	r1, [r0, #0]
c0d07904:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0d07906:	f7fe f8f5 	bl	c0d05af4 <io_seph_send>
  if (ep_addr & 0x80) {
c0d0790a:	0628      	lsls	r0, r5, #24
c0d0790c:	d501      	bpl.n	c0d07912 <USBD_LL_ClearStallEP+0x2a>
c0d0790e:	4807      	ldr	r0, [pc, #28]	; (c0d0792c <USBD_LL_ClearStallEP+0x44>)
c0d07910:	e000      	b.n	c0d07914 <USBD_LL_ClearStallEP+0x2c>
c0d07912:	4805      	ldr	r0, [pc, #20]	; (c0d07928 <USBD_LL_ClearStallEP+0x40>)
c0d07914:	6801      	ldr	r1, [r0, #0]
c0d07916:	227f      	movs	r2, #127	; 0x7f
c0d07918:	4015      	ands	r5, r2
c0d0791a:	2201      	movs	r2, #1
c0d0791c:	40aa      	lsls	r2, r5
c0d0791e:	4391      	bics	r1, r2
c0d07920:	6001      	str	r1, [r0, #0]
    ep_in_stall &= ~(1<<(ep_addr&0x7F));
  }
  else {
    ep_out_stall &= ~(1<<(ep_addr&0x7F)); 
  }
  return USBD_OK; 
c0d07922:	4620      	mov	r0, r4
c0d07924:	b002      	add	sp, #8
c0d07926:	bdb0      	pop	{r4, r5, r7, pc}
c0d07928:	20002070 	.word	0x20002070
c0d0792c:	2000206c 	.word	0x2000206c

c0d07930 <USBD_LL_IsStallEP>:
c0d07930:	0608      	lsls	r0, r1, #24
c0d07932:	d501      	bpl.n	c0d07938 <USBD_LL_IsStallEP+0x8>
c0d07934:	4805      	ldr	r0, [pc, #20]	; (c0d0794c <USBD_LL_IsStallEP+0x1c>)
c0d07936:	e000      	b.n	c0d0793a <USBD_LL_IsStallEP+0xa>
c0d07938:	4803      	ldr	r0, [pc, #12]	; (c0d07948 <USBD_LL_IsStallEP+0x18>)
c0d0793a:	7802      	ldrb	r2, [r0, #0]
c0d0793c:	207f      	movs	r0, #127	; 0x7f
c0d0793e:	4001      	ands	r1, r0
c0d07940:	2001      	movs	r0, #1
c0d07942:	4088      	lsls	r0, r1
c0d07944:	4010      	ands	r0, r2
  }
  else
  {
    return ep_out_stall & (1<<(ep_addr&0x7F));
  }
}
c0d07946:	4770      	bx	lr
c0d07948:	20002070 	.word	0x20002070
c0d0794c:	2000206c 	.word	0x2000206c

c0d07950 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
c0d07950:	b510      	push	{r4, lr}
c0d07952:	b082      	sub	sp, #8
c0d07954:	4668      	mov	r0, sp
  uint8_t buffer[5];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
  buffer[1] = 0;
  buffer[2] = 2;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
  buffer[4] = dev_addr;
c0d07956:	7101      	strb	r1, [r0, #4]
c0d07958:	2103      	movs	r1, #3
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
c0d0795a:	70c1      	strb	r1, [r0, #3]
c0d0795c:	2102      	movs	r1, #2
  buffer[2] = 2;
c0d0795e:	7081      	strb	r1, [r0, #2]
c0d07960:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d07962:	7044      	strb	r4, [r0, #1]
c0d07964:	214f      	movs	r1, #79	; 0x4f
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d07966:	7001      	strb	r1, [r0, #0]
c0d07968:	2105      	movs	r1, #5
  io_seproxyhal_spi_send(buffer, 5);
c0d0796a:	f7fe f8c3 	bl	c0d05af4 <io_seph_send>
  return USBD_OK; 
c0d0796e:	4620      	mov	r0, r4
c0d07970:	b002      	add	sp, #8
c0d07972:	bd10      	pop	{r4, pc}

c0d07974 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
c0d07974:	b5b0      	push	{r4, r5, r7, lr}
c0d07976:	b082      	sub	sp, #8
c0d07978:	461c      	mov	r4, r3
c0d0797a:	4615      	mov	r5, r2
c0d0797c:	4668      	mov	r0, sp
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = (3+size)>>8;
  buffer[2] = (3+size);
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
  buffer[5] = size;
c0d0797e:	7143      	strb	r3, [r0, #5]
c0d07980:	2220      	movs	r2, #32
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
c0d07982:	7102      	strb	r2, [r0, #4]
  buffer[3] = ep_addr;
c0d07984:	70c1      	strb	r1, [r0, #3]
c0d07986:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d07988:	7001      	strb	r1, [r0, #0]
  buffer[1] = (3+size)>>8;
c0d0798a:	1cd9      	adds	r1, r3, #3
  buffer[2] = (3+size);
c0d0798c:	7081      	strb	r1, [r0, #2]
  buffer[1] = (3+size)>>8;
c0d0798e:	0a09      	lsrs	r1, r1, #8
c0d07990:	7041      	strb	r1, [r0, #1]
c0d07992:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0d07994:	f7fe f8ae 	bl	c0d05af4 <io_seph_send>
  io_seproxyhal_spi_send(pbuf, size);
c0d07998:	4628      	mov	r0, r5
c0d0799a:	4621      	mov	r1, r4
c0d0799c:	f7fe f8aa 	bl	c0d05af4 <io_seph_send>
c0d079a0:	2000      	movs	r0, #0
  return USBD_OK;   
c0d079a2:	b002      	add	sp, #8
c0d079a4:	bdb0      	pop	{r4, r5, r7, pc}

c0d079a6 <USBD_LL_PrepareReceive>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,
                                           uint16_t  size)
{
c0d079a6:	b510      	push	{r4, lr}
c0d079a8:	b082      	sub	sp, #8
c0d079aa:	4668      	mov	r0, sp
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
  buffer[1] = (3/*+size*/)>>8;
  buffer[2] = (3/*+size*/);
  buffer[3] = ep_addr;
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT;
  buffer[5] = size; // expected size, not transmitted here !
c0d079ac:	7142      	strb	r2, [r0, #5]
c0d079ae:	2230      	movs	r2, #48	; 0x30
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT;
c0d079b0:	7102      	strb	r2, [r0, #4]
  buffer[3] = ep_addr;
c0d079b2:	70c1      	strb	r1, [r0, #3]
c0d079b4:	2103      	movs	r1, #3
  buffer[2] = (3/*+size*/);
c0d079b6:	7081      	strb	r1, [r0, #2]
c0d079b8:	2400      	movs	r4, #0
  buffer[1] = (3/*+size*/)>>8;
c0d079ba:	7044      	strb	r4, [r0, #1]
c0d079bc:	2150      	movs	r1, #80	; 0x50
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d079be:	7001      	strb	r1, [r0, #0]
c0d079c0:	2106      	movs	r1, #6
  io_seproxyhal_spi_send(buffer, 6);
c0d079c2:	f7fe f897 	bl	c0d05af4 <io_seph_send>
  return USBD_OK;   
c0d079c6:	4620      	mov	r0, r4
c0d079c8:	b002      	add	sp, #8
c0d079ca:	bd10      	pop	{r4, pc}

c0d079cc <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
c0d079cc:	b570      	push	{r4, r5, r6, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
c0d079ce:	2800      	cmp	r0, #0
c0d079d0:	d012      	beq.n	c0d079f8 <USBD_Init+0x2c>
c0d079d2:	4615      	mov	r5, r2
c0d079d4:	460e      	mov	r6, r1
c0d079d6:	4604      	mov	r4, r0
c0d079d8:	21d4      	movs	r1, #212	; 0xd4
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }

  memset(pdev, 0, sizeof(USBD_HandleTypeDef));
c0d079da:	f001 fe05 	bl	c0d095e8 <__aeabi_memclr>
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
c0d079de:	2e00      	cmp	r6, #0
c0d079e0:	d001      	beq.n	c0d079e6 <USBD_Init+0x1a>
c0d079e2:	20b0      	movs	r0, #176	; 0xb0
  {
    pdev->pDesc = pdesc;
c0d079e4:	5026      	str	r6, [r4, r0]
c0d079e6:	209c      	movs	r0, #156	; 0x9c
c0d079e8:	2101      	movs	r1, #1
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
c0d079ea:	5421      	strb	r1, [r4, r0]
  pdev->id = id;
c0d079ec:	7025      	strb	r5, [r4, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
c0d079ee:	4620      	mov	r0, r4
c0d079f0:	f7ff fec6 	bl	c0d07780 <USBD_LL_Init>
c0d079f4:	2000      	movs	r0, #0
  
  return USBD_OK; 
}
c0d079f6:	bd70      	pop	{r4, r5, r6, pc}
c0d079f8:	2002      	movs	r0, #2
c0d079fa:	bd70      	pop	{r4, r5, r6, pc}

c0d079fc <USBD_DeInit>:
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
c0d079fc:	b5b0      	push	{r4, r5, r7, lr}
c0d079fe:	4604      	mov	r4, r0
c0d07a00:	209c      	movs	r0, #156	; 0x9c
c0d07a02:	2101      	movs	r1, #1
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
c0d07a04:	5421      	strb	r1, [r4, r0]
c0d07a06:	25b4      	movs	r5, #180	; 0xb4
  
  /* Free Class Resources */
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(pdev->interfacesClass[intf].pClass != NULL) {
c0d07a08:	5960      	ldr	r0, [r4, r5]
c0d07a0a:	2800      	cmp	r0, #0
c0d07a0c:	d006      	beq.n	c0d07a1c <USBD_DeInit+0x20>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config);  
c0d07a0e:	6840      	ldr	r0, [r0, #4]
c0d07a10:	f7fc ffe0 	bl	c0d049d4 <pic>
c0d07a14:	4602      	mov	r2, r0
c0d07a16:	7921      	ldrb	r1, [r4, #4]
c0d07a18:	4620      	mov	r0, r4
c0d07a1a:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07a1c:	3508      	adds	r5, #8
c0d07a1e:	2dcc      	cmp	r5, #204	; 0xcc
c0d07a20:	d1f2      	bne.n	c0d07a08 <USBD_DeInit+0xc>
    }
  }
  
    /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
c0d07a22:	4620      	mov	r0, r4
c0d07a24:	f7ff fee4 	bl	c0d077f0 <USBD_LL_Stop>
  
  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
c0d07a28:	4620      	mov	r0, r4
c0d07a2a:	f7ff feb3 	bl	c0d07794 <USBD_LL_DeInit>
c0d07a2e:	2000      	movs	r0, #0
  
  return USBD_OK;
c0d07a30:	bdb0      	pop	{r4, r5, r7, pc}

c0d07a32 <USBD_RegisterClassForInterface>:
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClassForInterface(uint8_t interfaceidx, USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
c0d07a32:	2a00      	cmp	r2, #0
c0d07a34:	d008      	beq.n	c0d07a48 <USBD_RegisterClassForInterface+0x16>
c0d07a36:	4603      	mov	r3, r0
c0d07a38:	2000      	movs	r0, #0
  {
    if (interfaceidx < USBD_MAX_NUM_INTERFACES) {
c0d07a3a:	2b02      	cmp	r3, #2
c0d07a3c:	d803      	bhi.n	c0d07a46 <USBD_RegisterClassForInterface+0x14>
      /* link the class to the USB Device handle */
      pdev->interfacesClass[interfaceidx].pClass = pclass;
c0d07a3e:	00db      	lsls	r3, r3, #3
c0d07a40:	18c9      	adds	r1, r1, r3
c0d07a42:	23b4      	movs	r3, #180	; 0xb4
c0d07a44:	50ca      	str	r2, [r1, r3]
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
  }
  
  return status;
c0d07a46:	4770      	bx	lr
c0d07a48:	2002      	movs	r0, #2
c0d07a4a:	4770      	bx	lr

c0d07a4c <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
c0d07a4c:	b580      	push	{r7, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
c0d07a4e:	f7ff feb3 	bl	c0d077b8 <USBD_LL_Start>
c0d07a52:	2000      	movs	r0, #0
  
  return USBD_OK;  
c0d07a54:	bd80      	pop	{r7, pc}

c0d07a56 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
c0d07a56:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07a58:	b081      	sub	sp, #4
c0d07a5a:	460c      	mov	r4, r1
c0d07a5c:	4605      	mov	r5, r0
c0d07a5e:	2600      	movs	r6, #0
c0d07a60:	27b4      	movs	r7, #180	; 0xb4
  /* Set configuration  and Start the Class*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(usbd_is_valid_intf(pdev, intf)) {
c0d07a62:	4628      	mov	r0, r5
c0d07a64:	4631      	mov	r1, r6
c0d07a66:	f000 f965 	bl	c0d07d34 <usbd_is_valid_intf>
c0d07a6a:	2800      	cmp	r0, #0
c0d07a6c:	d007      	beq.n	c0d07a7e <USBD_SetClassConfig+0x28>
      ((Init_t)PIC(pdev->interfacesClass[intf].pClass->Init))(pdev, cfgidx);
c0d07a6e:	59e8      	ldr	r0, [r5, r7]
c0d07a70:	6800      	ldr	r0, [r0, #0]
c0d07a72:	f7fc ffaf 	bl	c0d049d4 <pic>
c0d07a76:	4602      	mov	r2, r0
c0d07a78:	4628      	mov	r0, r5
c0d07a7a:	4621      	mov	r1, r4
c0d07a7c:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07a7e:	3708      	adds	r7, #8
c0d07a80:	1c76      	adds	r6, r6, #1
c0d07a82:	2e03      	cmp	r6, #3
c0d07a84:	d1ed      	bne.n	c0d07a62 <USBD_SetClassConfig+0xc>
c0d07a86:	2000      	movs	r0, #0
    }
  }

  return USBD_OK; 
c0d07a88:	b001      	add	sp, #4
c0d07a8a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07a8c <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
c0d07a8c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07a8e:	b081      	sub	sp, #4
c0d07a90:	460c      	mov	r4, r1
c0d07a92:	4605      	mov	r5, r0
c0d07a94:	2600      	movs	r6, #0
c0d07a96:	27b4      	movs	r7, #180	; 0xb4
  /* Clear configuration  and De-initialize the Class process*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(usbd_is_valid_intf(pdev, intf)) {
c0d07a98:	4628      	mov	r0, r5
c0d07a9a:	4631      	mov	r1, r6
c0d07a9c:	f000 f94a 	bl	c0d07d34 <usbd_is_valid_intf>
c0d07aa0:	2800      	cmp	r0, #0
c0d07aa2:	d007      	beq.n	c0d07ab4 <USBD_ClrClassConfig+0x28>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, cfgidx);  
c0d07aa4:	59e8      	ldr	r0, [r5, r7]
c0d07aa6:	6840      	ldr	r0, [r0, #4]
c0d07aa8:	f7fc ff94 	bl	c0d049d4 <pic>
c0d07aac:	4602      	mov	r2, r0
c0d07aae:	4628      	mov	r0, r5
c0d07ab0:	4621      	mov	r1, r4
c0d07ab2:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07ab4:	3708      	adds	r7, #8
c0d07ab6:	1c76      	adds	r6, r6, #1
c0d07ab8:	2e03      	cmp	r6, #3
c0d07aba:	d1ed      	bne.n	c0d07a98 <USBD_ClrClassConfig+0xc>
c0d07abc:	2000      	movs	r0, #0
    }
  }
  return USBD_OK;
c0d07abe:	b001      	add	sp, #4
c0d07ac0:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07ac2 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
c0d07ac2:	b5b0      	push	{r4, r5, r7, lr}
c0d07ac4:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
c0d07ac6:	4605      	mov	r5, r0
c0d07ac8:	35a8      	adds	r5, #168	; 0xa8
c0d07aca:	4628      	mov	r0, r5
c0d07acc:	f000 fb74 	bl	c0d081b8 <USBD_ParseSetupRequest>
c0d07ad0:	2094      	movs	r0, #148	; 0x94
c0d07ad2:	2101      	movs	r1, #1
  
  pdev->ep0_state = USBD_EP0_SETUP;
c0d07ad4:	5021      	str	r1, [r4, r0]
c0d07ad6:	20ae      	movs	r0, #174	; 0xae
  pdev->ep0_data_len = pdev->request.wLength;
c0d07ad8:	5a20      	ldrh	r0, [r4, r0]
c0d07ada:	2198      	movs	r1, #152	; 0x98
c0d07adc:	5060      	str	r0, [r4, r1]
c0d07ade:	20a8      	movs	r0, #168	; 0xa8
  
  switch (pdev->request.bmRequest & 0x1F) 
c0d07ae0:	5c21      	ldrb	r1, [r4, r0]
c0d07ae2:	201f      	movs	r0, #31
c0d07ae4:	4008      	ands	r0, r1
c0d07ae6:	2802      	cmp	r0, #2
c0d07ae8:	d008      	beq.n	c0d07afc <USBD_LL_SetupStage+0x3a>
c0d07aea:	2801      	cmp	r0, #1
c0d07aec:	d00b      	beq.n	c0d07b06 <USBD_LL_SetupStage+0x44>
c0d07aee:	2800      	cmp	r0, #0
c0d07af0:	d10e      	bne.n	c0d07b10 <USBD_LL_SetupStage+0x4e>
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
c0d07af2:	4620      	mov	r0, r4
c0d07af4:	4629      	mov	r1, r5
c0d07af6:	f000 f929 	bl	c0d07d4c <USBD_StdDevReq>
c0d07afa:	e00e      	b.n	c0d07b1a <USBD_LL_SetupStage+0x58>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
c0d07afc:	4620      	mov	r0, r4
c0d07afe:	4629      	mov	r1, r5
c0d07b00:	f000 fad8 	bl	c0d080b4 <USBD_StdEPReq>
c0d07b04:	e009      	b.n	c0d07b1a <USBD_LL_SetupStage+0x58>
    USBD_StdItfReq(pdev, &pdev->request);
c0d07b06:	4620      	mov	r0, r4
c0d07b08:	4629      	mov	r1, r5
c0d07b0a:	f000 faaf 	bl	c0d0806c <USBD_StdItfReq>
c0d07b0e:	e004      	b.n	c0d07b1a <USBD_LL_SetupStage+0x58>
c0d07b10:	2080      	movs	r0, #128	; 0x80
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
c0d07b12:	4001      	ands	r1, r0
c0d07b14:	4620      	mov	r0, r4
c0d07b16:	f7ff fec3 	bl	c0d078a0 <USBD_LL_StallEP>
c0d07b1a:	2000      	movs	r0, #0
    break;
  }  
  return USBD_OK;  
c0d07b1c:	bdb0      	pop	{r4, r5, r7, pc}

c0d07b1e <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
c0d07b1e:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07b20:	b083      	sub	sp, #12
c0d07b22:	9202      	str	r2, [sp, #8]
c0d07b24:	4604      	mov	r4, r0
c0d07b26:	9101      	str	r1, [sp, #4]
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
c0d07b28:	2900      	cmp	r1, #0
c0d07b2a:	d01c      	beq.n	c0d07b66 <USBD_LL_DataOutStage+0x48>
c0d07b2c:	4625      	mov	r5, r4
c0d07b2e:	359c      	adds	r5, #156	; 0x9c
c0d07b30:	2700      	movs	r7, #0
c0d07b32:	26b4      	movs	r6, #180	; 0xb4
  }
  else {

    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->DataOut != NULL)&&
c0d07b34:	4620      	mov	r0, r4
c0d07b36:	4639      	mov	r1, r7
c0d07b38:	f000 f8fc 	bl	c0d07d34 <usbd_is_valid_intf>
c0d07b3c:	2800      	cmp	r0, #0
c0d07b3e:	d00d      	beq.n	c0d07b5c <USBD_LL_DataOutStage+0x3e>
c0d07b40:	59a0      	ldr	r0, [r4, r6]
c0d07b42:	6980      	ldr	r0, [r0, #24]
c0d07b44:	2800      	cmp	r0, #0
c0d07b46:	d009      	beq.n	c0d07b5c <USBD_LL_DataOutStage+0x3e>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d07b48:	7829      	ldrb	r1, [r5, #0]
      if( usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->DataOut != NULL)&&
c0d07b4a:	2903      	cmp	r1, #3
c0d07b4c:	d106      	bne.n	c0d07b5c <USBD_LL_DataOutStage+0x3e>
      {
        ((DataOut_t)PIC(pdev->interfacesClass[intf].pClass->DataOut))(pdev, epnum, pdata); 
c0d07b4e:	f7fc ff41 	bl	c0d049d4 <pic>
c0d07b52:	4603      	mov	r3, r0
c0d07b54:	4620      	mov	r0, r4
c0d07b56:	9901      	ldr	r1, [sp, #4]
c0d07b58:	9a02      	ldr	r2, [sp, #8]
c0d07b5a:	4798      	blx	r3
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07b5c:	3608      	adds	r6, #8
c0d07b5e:	1c7f      	adds	r7, r7, #1
c0d07b60:	2f03      	cmp	r7, #3
c0d07b62:	d1e7      	bne.n	c0d07b34 <USBD_LL_DataOutStage+0x16>
c0d07b64:	e02f      	b.n	c0d07bc6 <USBD_LL_DataOutStage+0xa8>
c0d07b66:	2094      	movs	r0, #148	; 0x94
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
c0d07b68:	5820      	ldr	r0, [r4, r0]
c0d07b6a:	2803      	cmp	r0, #3
c0d07b6c:	d12b      	bne.n	c0d07bc6 <USBD_LL_DataOutStage+0xa8>
      if(pep->rem_length > pep->maxpacket)
c0d07b6e:	6de1      	ldr	r1, [r4, #92]	; 0x5c
c0d07b70:	6e20      	ldr	r0, [r4, #96]	; 0x60
c0d07b72:	4281      	cmp	r1, r0
c0d07b74:	d90a      	bls.n	c0d07b8c <USBD_LL_DataOutStage+0x6e>
        pep->rem_length -=  pep->maxpacket;
c0d07b76:	1a09      	subs	r1, r1, r0
c0d07b78:	65e1      	str	r1, [r4, #92]	; 0x5c
                            MIN(pep->rem_length ,pep->maxpacket));
c0d07b7a:	4281      	cmp	r1, r0
c0d07b7c:	d300      	bcc.n	c0d07b80 <USBD_LL_DataOutStage+0x62>
c0d07b7e:	4601      	mov	r1, r0
        USBD_CtlContinueRx (pdev, 
c0d07b80:	b28a      	uxth	r2, r1
c0d07b82:	4620      	mov	r0, r4
c0d07b84:	9902      	ldr	r1, [sp, #8]
c0d07b86:	f000 fdc0 	bl	c0d0870a <USBD_CtlContinueRx>
c0d07b8a:	e01c      	b.n	c0d07bc6 <USBD_LL_DataOutStage+0xa8>
c0d07b8c:	4626      	mov	r6, r4
c0d07b8e:	369c      	adds	r6, #156	; 0x9c
c0d07b90:	2500      	movs	r5, #0
c0d07b92:	27b4      	movs	r7, #180	; 0xb4
          if(usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->EP0_RxReady != NULL)&&
c0d07b94:	4620      	mov	r0, r4
c0d07b96:	4629      	mov	r1, r5
c0d07b98:	f000 f8cc 	bl	c0d07d34 <usbd_is_valid_intf>
c0d07b9c:	2800      	cmp	r0, #0
c0d07b9e:	d00b      	beq.n	c0d07bb8 <USBD_LL_DataOutStage+0x9a>
c0d07ba0:	59e0      	ldr	r0, [r4, r7]
c0d07ba2:	6900      	ldr	r0, [r0, #16]
c0d07ba4:	2800      	cmp	r0, #0
c0d07ba6:	d007      	beq.n	c0d07bb8 <USBD_LL_DataOutStage+0x9a>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d07ba8:	7831      	ldrb	r1, [r6, #0]
          if(usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->EP0_RxReady != NULL)&&
c0d07baa:	2903      	cmp	r1, #3
c0d07bac:	d104      	bne.n	c0d07bb8 <USBD_LL_DataOutStage+0x9a>
            ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_RxReady))(pdev); 
c0d07bae:	f7fc ff11 	bl	c0d049d4 <pic>
c0d07bb2:	4601      	mov	r1, r0
c0d07bb4:	4620      	mov	r0, r4
c0d07bb6:	4788      	blx	r1
        for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07bb8:	3708      	adds	r7, #8
c0d07bba:	1c6d      	adds	r5, r5, #1
c0d07bbc:	2d03      	cmp	r5, #3
c0d07bbe:	d1e9      	bne.n	c0d07b94 <USBD_LL_DataOutStage+0x76>
        USBD_CtlSendStatus(pdev);
c0d07bc0:	4620      	mov	r0, r4
c0d07bc2:	f000 fda9 	bl	c0d08718 <USBD_CtlSendStatus>
c0d07bc6:	2000      	movs	r0, #0
      }
    }
  }  
  return USBD_OK;
c0d07bc8:	b003      	add	sp, #12
c0d07bca:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07bcc <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
c0d07bcc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d07bce:	b081      	sub	sp, #4
c0d07bd0:	4604      	mov	r4, r0
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
c0d07bd2:	3098      	adds	r0, #152	; 0x98
c0d07bd4:	9000      	str	r0, [sp, #0]
  USBD_EndpointTypeDef    *pep;
  UNUSED(pdata);
    
  if(epnum == 0) 
c0d07bd6:	2900      	cmp	r1, #0
c0d07bd8:	d01b      	beq.n	c0d07c12 <USBD_LL_DataInStage+0x46>
c0d07bda:	460d      	mov	r5, r1
c0d07bdc:	2600      	movs	r6, #0
c0d07bde:	27b4      	movs	r7, #180	; 0xb4
    }
  }
  else {
    uint8_t intf;
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->DataIn != NULL)&&
c0d07be0:	4620      	mov	r0, r4
c0d07be2:	4631      	mov	r1, r6
c0d07be4:	f000 f8a6 	bl	c0d07d34 <usbd_is_valid_intf>
c0d07be8:	2800      	cmp	r0, #0
c0d07bea:	d00d      	beq.n	c0d07c08 <USBD_LL_DataInStage+0x3c>
c0d07bec:	59e0      	ldr	r0, [r4, r7]
c0d07bee:	6940      	ldr	r0, [r0, #20]
c0d07bf0:	2800      	cmp	r0, #0
c0d07bf2:	d009      	beq.n	c0d07c08 <USBD_LL_DataInStage+0x3c>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d07bf4:	9900      	ldr	r1, [sp, #0]
c0d07bf6:	7909      	ldrb	r1, [r1, #4]
      if( usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->DataIn != NULL)&&
c0d07bf8:	2903      	cmp	r1, #3
c0d07bfa:	d105      	bne.n	c0d07c08 <USBD_LL_DataInStage+0x3c>
      {
        ((DataIn_t)PIC(pdev->interfacesClass[intf].pClass->DataIn))(pdev, epnum); 
c0d07bfc:	f7fc feea 	bl	c0d049d4 <pic>
c0d07c00:	4602      	mov	r2, r0
c0d07c02:	4620      	mov	r0, r4
c0d07c04:	4629      	mov	r1, r5
c0d07c06:	4790      	blx	r2
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07c08:	3708      	adds	r7, #8
c0d07c0a:	1c76      	adds	r6, r6, #1
c0d07c0c:	2e03      	cmp	r6, #3
c0d07c0e:	d1e7      	bne.n	c0d07be0 <USBD_LL_DataInStage+0x14>
c0d07c10:	e04b      	b.n	c0d07caa <USBD_LL_DataInStage+0xde>
c0d07c12:	2094      	movs	r0, #148	; 0x94
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
c0d07c14:	5820      	ldr	r0, [r4, r0]
c0d07c16:	2802      	cmp	r0, #2
c0d07c18:	d140      	bne.n	c0d07c9c <USBD_LL_DataInStage+0xd0>
      if(pep->rem_length > pep->maxpacket)
c0d07c1a:	69e0      	ldr	r0, [r4, #28]
c0d07c1c:	6a25      	ldr	r5, [r4, #32]
c0d07c1e:	42a8      	cmp	r0, r5
c0d07c20:	d90a      	bls.n	c0d07c38 <USBD_LL_DataInStage+0x6c>
c0d07c22:	22d0      	movs	r2, #208	; 0xd0
        pdev->pData += pep->maxpacket;
c0d07c24:	58a1      	ldr	r1, [r4, r2]
c0d07c26:	1949      	adds	r1, r1, r5
c0d07c28:	50a1      	str	r1, [r4, r2]
        pep->rem_length -=  pep->maxpacket;
c0d07c2a:	1b40      	subs	r0, r0, r5
c0d07c2c:	61e0      	str	r0, [r4, #28]
        USBD_CtlContinueSendData (pdev, 
c0d07c2e:	b282      	uxth	r2, r0
c0d07c30:	4620      	mov	r0, r4
c0d07c32:	f000 fd5c 	bl	c0d086ee <USBD_CtlContinueSendData>
c0d07c36:	e031      	b.n	c0d07c9c <USBD_LL_DataInStage+0xd0>
        if((pep->total_length % pep->maxpacket == 0) &&
c0d07c38:	69a6      	ldr	r6, [r4, #24]
c0d07c3a:	4630      	mov	r0, r6
c0d07c3c:	4629      	mov	r1, r5
c0d07c3e:	f001 fcb5 	bl	c0d095ac <__aeabi_uidivmod>
c0d07c42:	42ae      	cmp	r6, r5
c0d07c44:	d30e      	bcc.n	c0d07c64 <USBD_LL_DataInStage+0x98>
c0d07c46:	2900      	cmp	r1, #0
c0d07c48:	d10c      	bne.n	c0d07c64 <USBD_LL_DataInStage+0x98>
             (pep->total_length < pdev->ep0_data_len ))
c0d07c4a:	9800      	ldr	r0, [sp, #0]
c0d07c4c:	6800      	ldr	r0, [r0, #0]
        if((pep->total_length % pep->maxpacket == 0) &&
c0d07c4e:	4286      	cmp	r6, r0
c0d07c50:	d208      	bcs.n	c0d07c64 <USBD_LL_DataInStage+0x98>
c0d07c52:	2500      	movs	r5, #0
          USBD_CtlContinueSendData(pdev , NULL, 0);
c0d07c54:	4620      	mov	r0, r4
c0d07c56:	4629      	mov	r1, r5
c0d07c58:	462a      	mov	r2, r5
c0d07c5a:	f000 fd48 	bl	c0d086ee <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
c0d07c5e:	9800      	ldr	r0, [sp, #0]
c0d07c60:	6005      	str	r5, [r0, #0]
c0d07c62:	e01b      	b.n	c0d07c9c <USBD_LL_DataInStage+0xd0>
c0d07c64:	2500      	movs	r5, #0
c0d07c66:	26b4      	movs	r6, #180	; 0xb4
            if(usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->EP0_TxSent != NULL)&&
c0d07c68:	4620      	mov	r0, r4
c0d07c6a:	4629      	mov	r1, r5
c0d07c6c:	f000 f862 	bl	c0d07d34 <usbd_is_valid_intf>
c0d07c70:	2800      	cmp	r0, #0
c0d07c72:	d00c      	beq.n	c0d07c8e <USBD_LL_DataInStage+0xc2>
c0d07c74:	59a0      	ldr	r0, [r4, r6]
c0d07c76:	68c0      	ldr	r0, [r0, #12]
c0d07c78:	2800      	cmp	r0, #0
c0d07c7a:	d008      	beq.n	c0d07c8e <USBD_LL_DataInStage+0xc2>
               (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d07c7c:	9900      	ldr	r1, [sp, #0]
c0d07c7e:	7909      	ldrb	r1, [r1, #4]
            if(usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->EP0_TxSent != NULL)&&
c0d07c80:	2903      	cmp	r1, #3
c0d07c82:	d104      	bne.n	c0d07c8e <USBD_LL_DataInStage+0xc2>
              ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_TxSent))(pdev); 
c0d07c84:	f7fc fea6 	bl	c0d049d4 <pic>
c0d07c88:	4601      	mov	r1, r0
c0d07c8a:	4620      	mov	r0, r4
c0d07c8c:	4788      	blx	r1
          for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07c8e:	3608      	adds	r6, #8
c0d07c90:	1c6d      	adds	r5, r5, #1
c0d07c92:	2d03      	cmp	r5, #3
c0d07c94:	d1e8      	bne.n	c0d07c68 <USBD_LL_DataInStage+0x9c>
          USBD_CtlReceiveStatus(pdev);
c0d07c96:	4620      	mov	r0, r4
c0d07c98:	f000 fd4a 	bl	c0d08730 <USBD_CtlReceiveStatus>
    if (pdev->dev_test_mode == 1)
c0d07c9c:	9800      	ldr	r0, [sp, #0]
c0d07c9e:	7a00      	ldrb	r0, [r0, #8]
c0d07ca0:	2801      	cmp	r0, #1
c0d07ca2:	d102      	bne.n	c0d07caa <USBD_LL_DataInStage+0xde>
c0d07ca4:	2000      	movs	r0, #0
      pdev->dev_test_mode = 0;
c0d07ca6:	9900      	ldr	r1, [sp, #0]
c0d07ca8:	7208      	strb	r0, [r1, #8]
c0d07caa:	2000      	movs	r0, #0
      }
    }
  }
  return USBD_OK;
c0d07cac:	b001      	add	sp, #4
c0d07cae:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d07cb0 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
c0d07cb0:	b570      	push	{r4, r5, r6, lr}
c0d07cb2:	4604      	mov	r4, r0
c0d07cb4:	209c      	movs	r0, #156	; 0x9c
c0d07cb6:	2101      	movs	r1, #1
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
c0d07cb8:	5421      	strb	r1, [r4, r0]
c0d07cba:	2040      	movs	r0, #64	; 0x40
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
c0d07cbc:	6220      	str	r0, [r4, #32]
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
c0d07cbe:	6620      	str	r0, [r4, #96]	; 0x60
c0d07cc0:	2500      	movs	r5, #0
c0d07cc2:	26b4      	movs	r6, #180	; 0xb4
 
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if( usbd_is_valid_intf(pdev, intf))
c0d07cc4:	4620      	mov	r0, r4
c0d07cc6:	4629      	mov	r1, r5
c0d07cc8:	f000 f834 	bl	c0d07d34 <usbd_is_valid_intf>
c0d07ccc:	2800      	cmp	r0, #0
c0d07cce:	d007      	beq.n	c0d07ce0 <USBD_LL_Reset+0x30>
    {
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config); 
c0d07cd0:	59a0      	ldr	r0, [r4, r6]
c0d07cd2:	6840      	ldr	r0, [r0, #4]
c0d07cd4:	f7fc fe7e 	bl	c0d049d4 <pic>
c0d07cd8:	4602      	mov	r2, r0
c0d07cda:	7921      	ldrb	r1, [r4, #4]
c0d07cdc:	4620      	mov	r0, r4
c0d07cde:	4790      	blx	r2
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07ce0:	3608      	adds	r6, #8
c0d07ce2:	1c6d      	adds	r5, r5, #1
c0d07ce4:	2d03      	cmp	r5, #3
c0d07ce6:	d1ed      	bne.n	c0d07cc4 <USBD_LL_Reset+0x14>
c0d07ce8:	2000      	movs	r0, #0
    }
  }
  
  return USBD_OK;
c0d07cea:	bd70      	pop	{r4, r5, r6, pc}

c0d07cec <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
c0d07cec:	7401      	strb	r1, [r0, #16]
c0d07cee:	2000      	movs	r0, #0
  return USBD_OK;
c0d07cf0:	4770      	bx	lr

c0d07cf2 <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
c0d07cf2:	2000      	movs	r0, #0
  UNUSED(pdev);
  // Ignored, gently
  //pdev->dev_old_state =  pdev->dev_state;
  //pdev->dev_state  = USBD_STATE_SUSPENDED;
  return USBD_OK;
c0d07cf4:	4770      	bx	lr

c0d07cf6 <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
c0d07cf6:	2000      	movs	r0, #0
  UNUSED(pdev);
  // Ignored, gently
  //pdev->dev_state = pdev->dev_old_state;  
  return USBD_OK;
c0d07cf8:	4770      	bx	lr

c0d07cfa <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
c0d07cfa:	b570      	push	{r4, r5, r6, lr}
c0d07cfc:	4604      	mov	r4, r0
c0d07cfe:	209c      	movs	r0, #156	; 0x9c
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
c0d07d00:	5c20      	ldrb	r0, [r4, r0]
c0d07d02:	2803      	cmp	r0, #3
c0d07d04:	d114      	bne.n	c0d07d30 <USBD_LL_SOF+0x36>
c0d07d06:	2500      	movs	r5, #0
c0d07d08:	26b4      	movs	r6, #180	; 0xb4
  {
    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) && pdev->interfacesClass[intf].pClass->SOF != NULL)
c0d07d0a:	4620      	mov	r0, r4
c0d07d0c:	4629      	mov	r1, r5
c0d07d0e:	f000 f811 	bl	c0d07d34 <usbd_is_valid_intf>
c0d07d12:	2800      	cmp	r0, #0
c0d07d14:	d008      	beq.n	c0d07d28 <USBD_LL_SOF+0x2e>
c0d07d16:	59a0      	ldr	r0, [r4, r6]
c0d07d18:	69c0      	ldr	r0, [r0, #28]
c0d07d1a:	2800      	cmp	r0, #0
c0d07d1c:	d004      	beq.n	c0d07d28 <USBD_LL_SOF+0x2e>
      {
        ((SOF_t)PIC(pdev->interfacesClass[intf].pClass->SOF))(pdev); 
c0d07d1e:	f7fc fe59 	bl	c0d049d4 <pic>
c0d07d22:	4601      	mov	r1, r0
c0d07d24:	4620      	mov	r0, r4
c0d07d26:	4788      	blx	r1
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d07d28:	3608      	adds	r6, #8
c0d07d2a:	1c6d      	adds	r5, r5, #1
c0d07d2c:	2d03      	cmp	r5, #3
c0d07d2e:	d1ec      	bne.n	c0d07d0a <USBD_LL_SOF+0x10>
c0d07d30:	2000      	movs	r0, #0
      }
    }
  }
  return USBD_OK;
c0d07d32:	bd70      	pop	{r4, r5, r6, pc}

c0d07d34 <usbd_is_valid_intf>:
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d07d34:	2902      	cmp	r1, #2
c0d07d36:	d807      	bhi.n	c0d07d48 <usbd_is_valid_intf+0x14>
c0d07d38:	00c9      	lsls	r1, r1, #3
c0d07d3a:	1840      	adds	r0, r0, r1
c0d07d3c:	21b4      	movs	r1, #180	; 0xb4
c0d07d3e:	5840      	ldr	r0, [r0, r1]
c0d07d40:	2800      	cmp	r0, #0
c0d07d42:	d000      	beq.n	c0d07d46 <usbd_is_valid_intf+0x12>
c0d07d44:	2001      	movs	r0, #1
c0d07d46:	4770      	bx	lr
c0d07d48:	2000      	movs	r0, #0
c0d07d4a:	4770      	bx	lr

c0d07d4c <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
c0d07d4c:	b580      	push	{r7, lr}
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
c0d07d4e:	784a      	ldrb	r2, [r1, #1]
c0d07d50:	2a04      	cmp	r2, #4
c0d07d52:	dd08      	ble.n	c0d07d66 <USBD_StdDevReq+0x1a>
c0d07d54:	2a07      	cmp	r2, #7
c0d07d56:	dc0f      	bgt.n	c0d07d78 <USBD_StdDevReq+0x2c>
c0d07d58:	2a05      	cmp	r2, #5
c0d07d5a:	d014      	beq.n	c0d07d86 <USBD_StdDevReq+0x3a>
c0d07d5c:	2a06      	cmp	r2, #6
c0d07d5e:	d11b      	bne.n	c0d07d98 <USBD_StdDevReq+0x4c>
  {
  case USB_REQ_GET_DESCRIPTOR: 
    
    USBD_GetDescriptor (pdev, req) ;
c0d07d60:	f000 f821 	bl	c0d07da6 <USBD_GetDescriptor>
c0d07d64:	e01d      	b.n	c0d07da2 <USBD_StdDevReq+0x56>
  switch (req->bRequest) 
c0d07d66:	2a00      	cmp	r2, #0
c0d07d68:	d010      	beq.n	c0d07d8c <USBD_StdDevReq+0x40>
c0d07d6a:	2a01      	cmp	r2, #1
c0d07d6c:	d017      	beq.n	c0d07d9e <USBD_StdDevReq+0x52>
c0d07d6e:	2a03      	cmp	r2, #3
c0d07d70:	d112      	bne.n	c0d07d98 <USBD_StdDevReq+0x4c>
    USBD_GetStatus (pdev , req);
    break;
    
    
  case USB_REQ_SET_FEATURE:   
    USBD_SetFeature (pdev , req);    
c0d07d72:	f000 f936 	bl	c0d07fe2 <USBD_SetFeature>
c0d07d76:	e014      	b.n	c0d07da2 <USBD_StdDevReq+0x56>
  switch (req->bRequest) 
c0d07d78:	2a08      	cmp	r2, #8
c0d07d7a:	d00a      	beq.n	c0d07d92 <USBD_StdDevReq+0x46>
c0d07d7c:	2a09      	cmp	r2, #9
c0d07d7e:	d10b      	bne.n	c0d07d98 <USBD_StdDevReq+0x4c>
    USBD_SetConfig (pdev , req);
c0d07d80:	f000 f8bd 	bl	c0d07efe <USBD_SetConfig>
c0d07d84:	e00d      	b.n	c0d07da2 <USBD_StdDevReq+0x56>
    USBD_SetAddress(pdev, req);
c0d07d86:	f000 f894 	bl	c0d07eb2 <USBD_SetAddress>
c0d07d8a:	e00a      	b.n	c0d07da2 <USBD_StdDevReq+0x56>
    USBD_GetStatus (pdev , req);
c0d07d8c:	f000 f906 	bl	c0d07f9c <USBD_GetStatus>
c0d07d90:	e007      	b.n	c0d07da2 <USBD_StdDevReq+0x56>
    USBD_GetConfig (pdev , req);
c0d07d92:	f000 f8ec 	bl	c0d07f6e <USBD_GetConfig>
c0d07d96:	e004      	b.n	c0d07da2 <USBD_StdDevReq+0x56>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
c0d07d98:	f000 fbe2 	bl	c0d08560 <USBD_CtlError>
c0d07d9c:	e001      	b.n	c0d07da2 <USBD_StdDevReq+0x56>
    USBD_ClrFeature (pdev , req);
c0d07d9e:	f000 f93d 	bl	c0d0801c <USBD_ClrFeature>
c0d07da2:	2000      	movs	r0, #0
    break;
  }
  
  return ret;
c0d07da4:	bd80      	pop	{r7, pc}

c0d07da6 <USBD_GetDescriptor>:
* @param  req: usb request
* @retval status
*/
void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
                               USBD_SetupReqTypedef *req)
{
c0d07da6:	b5b0      	push	{r4, r5, r7, lr}
c0d07da8:	b082      	sub	sp, #8
c0d07daa:	460d      	mov	r5, r1
c0d07dac:	4604      	mov	r4, r0
c0d07dae:	a801      	add	r0, sp, #4
c0d07db0:	2100      	movs	r1, #0
  uint16_t len = 0;
c0d07db2:	8001      	strh	r1, [r0, #0]
  uint8_t *pbuf = NULL;
  
    
  switch (req->wValue >> 8)
c0d07db4:	886a      	ldrh	r2, [r5, #2]
c0d07db6:	0a10      	lsrs	r0, r2, #8
c0d07db8:	2805      	cmp	r0, #5
c0d07dba:	dc12      	bgt.n	c0d07de2 <USBD_GetDescriptor+0x3c>
c0d07dbc:	2801      	cmp	r0, #1
c0d07dbe:	d01c      	beq.n	c0d07dfa <USBD_GetDescriptor+0x54>
c0d07dc0:	2802      	cmp	r0, #2
c0d07dc2:	d024      	beq.n	c0d07e0e <USBD_GetDescriptor+0x68>
c0d07dc4:	2803      	cmp	r0, #3
c0d07dc6:	d137      	bne.n	c0d07e38 <USBD_GetDescriptor+0x92>
      }
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
c0d07dc8:	b2d0      	uxtb	r0, r2
c0d07dca:	2802      	cmp	r0, #2
c0d07dcc:	dc39      	bgt.n	c0d07e42 <USBD_GetDescriptor+0x9c>
c0d07dce:	2800      	cmp	r0, #0
c0d07dd0:	d05f      	beq.n	c0d07e92 <USBD_GetDescriptor+0xec>
c0d07dd2:	2801      	cmp	r0, #1
c0d07dd4:	d065      	beq.n	c0d07ea2 <USBD_GetDescriptor+0xfc>
c0d07dd6:	2802      	cmp	r0, #2
c0d07dd8:	d12e      	bne.n	c0d07e38 <USBD_GetDescriptor+0x92>
c0d07dda:	20b0      	movs	r0, #176	; 0xb0
    case USBD_IDX_MFC_STR:
      pbuf = ((GetManufacturerStrDescriptor_t)PIC(pdev->pDesc->GetManufacturerStrDescriptor))(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = ((GetProductStrDescriptor_t)PIC(pdev->pDesc->GetProductStrDescriptor))(pdev->dev_speed, &len);
c0d07ddc:	5820      	ldr	r0, [r4, r0]
c0d07dde:	68c0      	ldr	r0, [r0, #12]
c0d07de0:	e00e      	b.n	c0d07e00 <USBD_GetDescriptor+0x5a>
  switch (req->wValue >> 8)
c0d07de2:	2806      	cmp	r0, #6
c0d07de4:	d01c      	beq.n	c0d07e20 <USBD_GetDescriptor+0x7a>
c0d07de6:	2807      	cmp	r0, #7
c0d07de8:	d023      	beq.n	c0d07e32 <USBD_GetDescriptor+0x8c>
c0d07dea:	280f      	cmp	r0, #15
c0d07dec:	d124      	bne.n	c0d07e38 <USBD_GetDescriptor+0x92>
c0d07dee:	20b0      	movs	r0, #176	; 0xb0
    if(pdev->pDesc->GetBOSDescriptor != NULL) {
c0d07df0:	5820      	ldr	r0, [r4, r0]
c0d07df2:	69c0      	ldr	r0, [r0, #28]
c0d07df4:	2800      	cmp	r0, #0
c0d07df6:	d103      	bne.n	c0d07e00 <USBD_GetDescriptor+0x5a>
c0d07df8:	e01e      	b.n	c0d07e38 <USBD_GetDescriptor+0x92>
c0d07dfa:	20b0      	movs	r0, #176	; 0xb0
    pbuf = ((GetDeviceDescriptor_t)PIC(pdev->pDesc->GetDeviceDescriptor))(pdev->dev_speed, &len);
c0d07dfc:	5820      	ldr	r0, [r4, r0]
c0d07dfe:	6800      	ldr	r0, [r0, #0]
c0d07e00:	f7fc fde8 	bl	c0d049d4 <pic>
c0d07e04:	4602      	mov	r2, r0
c0d07e06:	7c20      	ldrb	r0, [r4, #16]
c0d07e08:	a901      	add	r1, sp, #4
c0d07e0a:	4790      	blx	r2
c0d07e0c:	e02f      	b.n	c0d07e6e <USBD_GetDescriptor+0xc8>
c0d07e0e:	20b4      	movs	r0, #180	; 0xb4
    if(pdev->interfacesClass[0].pClass != NULL) {
c0d07e10:	5820      	ldr	r0, [r4, r0]
c0d07e12:	2800      	cmp	r0, #0
c0d07e14:	d02c      	beq.n	c0d07e70 <USBD_GetDescriptor+0xca>
      if(pdev->dev_speed == USBD_SPEED_HIGH )   
c0d07e16:	7c21      	ldrb	r1, [r4, #16]
c0d07e18:	2900      	cmp	r1, #0
c0d07e1a:	d022      	beq.n	c0d07e62 <USBD_GetDescriptor+0xbc>
        pbuf   = (uint8_t *)((GetFSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetFSConfigDescriptor))(&len);
c0d07e1c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
c0d07e1e:	e021      	b.n	c0d07e64 <USBD_GetDescriptor+0xbe>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL )   
c0d07e20:	7c20      	ldrb	r0, [r4, #16]
c0d07e22:	2800      	cmp	r0, #0
c0d07e24:	d108      	bne.n	c0d07e38 <USBD_GetDescriptor+0x92>
c0d07e26:	20b4      	movs	r0, #180	; 0xb4
c0d07e28:	5820      	ldr	r0, [r4, r0]
c0d07e2a:	2800      	cmp	r0, #0
c0d07e2c:	d004      	beq.n	c0d07e38 <USBD_GetDescriptor+0x92>
    {
      pbuf   = (uint8_t *)((GetDeviceQualifierDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetDeviceQualifierDescriptor))(&len);
c0d07e2e:	6b40      	ldr	r0, [r0, #52]	; 0x34
c0d07e30:	e018      	b.n	c0d07e64 <USBD_GetDescriptor+0xbe>
    {
      goto default_error;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL)   
c0d07e32:	7c20      	ldrb	r0, [r4, #16]
c0d07e34:	2800      	cmp	r0, #0
c0d07e36:	d00e      	beq.n	c0d07e56 <USBD_GetDescriptor+0xb0>
      goto default_error;
    }

  default: 
  default_error:
     USBD_CtlError(pdev , req);
c0d07e38:	4620      	mov	r0, r4
c0d07e3a:	4629      	mov	r1, r5
c0d07e3c:	f000 fb90 	bl	c0d08560 <USBD_CtlError>
c0d07e40:	e025      	b.n	c0d07e8e <USBD_GetDescriptor+0xe8>
    switch ((uint8_t)(req->wValue))
c0d07e42:	2803      	cmp	r0, #3
c0d07e44:	d029      	beq.n	c0d07e9a <USBD_GetDescriptor+0xf4>
c0d07e46:	2804      	cmp	r0, #4
c0d07e48:	d02f      	beq.n	c0d07eaa <USBD_GetDescriptor+0x104>
c0d07e4a:	2805      	cmp	r0, #5
c0d07e4c:	d1f4      	bne.n	c0d07e38 <USBD_GetDescriptor+0x92>
c0d07e4e:	20b0      	movs	r0, #176	; 0xb0
      pbuf = ((GetInterfaceStrDescriptor_t)PIC(pdev->pDesc->GetInterfaceStrDescriptor))(pdev->dev_speed, &len);
c0d07e50:	5820      	ldr	r0, [r4, r0]
c0d07e52:	6980      	ldr	r0, [r0, #24]
c0d07e54:	e7d4      	b.n	c0d07e00 <USBD_GetDescriptor+0x5a>
c0d07e56:	20b4      	movs	r0, #180	; 0xb4
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL)   
c0d07e58:	5820      	ldr	r0, [r4, r0]
c0d07e5a:	2800      	cmp	r0, #0
c0d07e5c:	d0ec      	beq.n	c0d07e38 <USBD_GetDescriptor+0x92>
      pbuf   = (uint8_t *)((GetOtherSpeedConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetOtherSpeedConfigDescriptor))(&len);
c0d07e5e:	6b00      	ldr	r0, [r0, #48]	; 0x30
c0d07e60:	e000      	b.n	c0d07e64 <USBD_GetDescriptor+0xbe>
        pbuf   = (uint8_t *)((GetHSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetHSConfigDescriptor))(&len);
c0d07e62:	6a80      	ldr	r0, [r0, #40]	; 0x28
c0d07e64:	f7fc fdb6 	bl	c0d049d4 <pic>
c0d07e68:	4601      	mov	r1, r0
c0d07e6a:	a801      	add	r0, sp, #4
c0d07e6c:	4788      	blx	r1
c0d07e6e:	4601      	mov	r1, r0
c0d07e70:	a801      	add	r0, sp, #4
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
c0d07e72:	8802      	ldrh	r2, [r0, #0]
c0d07e74:	2a00      	cmp	r2, #0
c0d07e76:	d00a      	beq.n	c0d07e8e <USBD_GetDescriptor+0xe8>
c0d07e78:	88e8      	ldrh	r0, [r5, #6]
c0d07e7a:	2800      	cmp	r0, #0
c0d07e7c:	d007      	beq.n	c0d07e8e <USBD_GetDescriptor+0xe8>
  {
    
    len = MIN(len , req->wLength);
c0d07e7e:	4282      	cmp	r2, r0
c0d07e80:	d300      	bcc.n	c0d07e84 <USBD_GetDescriptor+0xde>
c0d07e82:	4602      	mov	r2, r0
c0d07e84:	a801      	add	r0, sp, #4
c0d07e86:	8002      	strh	r2, [r0, #0]
    
    // prepare abort if host does not read the whole data
    //USBD_CtlReceiveStatus(pdev);

    // start transfer
    USBD_CtlSendData (pdev, 
c0d07e88:	4620      	mov	r0, r4
c0d07e8a:	f000 fc1b 	bl	c0d086c4 <USBD_CtlSendData>
                      pbuf,
                      len);
  }
  
}
c0d07e8e:	b002      	add	sp, #8
c0d07e90:	bdb0      	pop	{r4, r5, r7, pc}
c0d07e92:	20b0      	movs	r0, #176	; 0xb0
     pbuf = ((GetLangIDStrDescriptor_t)PIC(pdev->pDesc->GetLangIDStrDescriptor))(pdev->dev_speed, &len);        
c0d07e94:	5820      	ldr	r0, [r4, r0]
c0d07e96:	6840      	ldr	r0, [r0, #4]
c0d07e98:	e7b2      	b.n	c0d07e00 <USBD_GetDescriptor+0x5a>
c0d07e9a:	20b0      	movs	r0, #176	; 0xb0
      pbuf = ((GetSerialStrDescriptor_t)PIC(pdev->pDesc->GetSerialStrDescriptor))(pdev->dev_speed, &len);
c0d07e9c:	5820      	ldr	r0, [r4, r0]
c0d07e9e:	6900      	ldr	r0, [r0, #16]
c0d07ea0:	e7ae      	b.n	c0d07e00 <USBD_GetDescriptor+0x5a>
c0d07ea2:	20b0      	movs	r0, #176	; 0xb0
      pbuf = ((GetManufacturerStrDescriptor_t)PIC(pdev->pDesc->GetManufacturerStrDescriptor))(pdev->dev_speed, &len);
c0d07ea4:	5820      	ldr	r0, [r4, r0]
c0d07ea6:	6880      	ldr	r0, [r0, #8]
c0d07ea8:	e7aa      	b.n	c0d07e00 <USBD_GetDescriptor+0x5a>
c0d07eaa:	20b0      	movs	r0, #176	; 0xb0
      pbuf = ((GetConfigurationStrDescriptor_t)PIC(pdev->pDesc->GetConfigurationStrDescriptor))(pdev->dev_speed, &len);
c0d07eac:	5820      	ldr	r0, [r4, r0]
c0d07eae:	6940      	ldr	r0, [r0, #20]
c0d07eb0:	e7a6      	b.n	c0d07e00 <USBD_GetDescriptor+0x5a>

c0d07eb2 <USBD_SetAddress>:
* @param  req: usb request
* @retval status
*/
void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d07eb2:	b570      	push	{r4, r5, r6, lr}
c0d07eb4:	4604      	mov	r4, r0
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
c0d07eb6:	8888      	ldrh	r0, [r1, #4]
c0d07eb8:	2800      	cmp	r0, #0
c0d07eba:	d106      	bne.n	c0d07eca <USBD_SetAddress+0x18>
c0d07ebc:	88c8      	ldrh	r0, [r1, #6]
c0d07ebe:	2800      	cmp	r0, #0
c0d07ec0:	d103      	bne.n	c0d07eca <USBD_SetAddress+0x18>
c0d07ec2:	209c      	movs	r0, #156	; 0x9c
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
c0d07ec4:	5c20      	ldrb	r0, [r4, r0]
c0d07ec6:	2803      	cmp	r0, #3
c0d07ec8:	d103      	bne.n	c0d07ed2 <USBD_SetAddress+0x20>
c0d07eca:	4620      	mov	r0, r4
c0d07ecc:	f000 fb48 	bl	c0d08560 <USBD_CtlError>
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
  } 
}
c0d07ed0:	bd70      	pop	{r4, r5, r6, pc}
c0d07ed2:	8848      	ldrh	r0, [r1, #2]
c0d07ed4:	257f      	movs	r5, #127	; 0x7f
c0d07ed6:	4005      	ands	r5, r0
c0d07ed8:	4626      	mov	r6, r4
c0d07eda:	369c      	adds	r6, #156	; 0x9c
c0d07edc:	209e      	movs	r0, #158	; 0x9e
      pdev->dev_address = dev_addr;
c0d07ede:	5425      	strb	r5, [r4, r0]
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
c0d07ee0:	4620      	mov	r0, r4
c0d07ee2:	4629      	mov	r1, r5
c0d07ee4:	f7ff fd34 	bl	c0d07950 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
c0d07ee8:	4620      	mov	r0, r4
c0d07eea:	f000 fc15 	bl	c0d08718 <USBD_CtlSendStatus>
      if (dev_addr != 0) 
c0d07eee:	2d00      	cmp	r5, #0
c0d07ef0:	d002      	beq.n	c0d07ef8 <USBD_SetAddress+0x46>
c0d07ef2:	2002      	movs	r0, #2
        pdev->dev_state  = USBD_STATE_ADDRESSED;
c0d07ef4:	7030      	strb	r0, [r6, #0]
}
c0d07ef6:	bd70      	pop	{r4, r5, r6, pc}
c0d07ef8:	2001      	movs	r0, #1
        pdev->dev_state  = USBD_STATE_DEFAULT; 
c0d07efa:	7030      	strb	r0, [r6, #0]
}
c0d07efc:	bd70      	pop	{r4, r5, r6, pc}

c0d07efe <USBD_SetConfig>:
* @param  req: usb request
* @retval status
*/
void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d07efe:	b570      	push	{r4, r5, r6, lr}
c0d07f00:	460d      	mov	r5, r1
c0d07f02:	4604      	mov	r4, r0
  
  uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
c0d07f04:	788e      	ldrb	r6, [r1, #2]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
c0d07f06:	2e02      	cmp	r6, #2
c0d07f08:	d21d      	bcs.n	c0d07f46 <USBD_SetConfig+0x48>
c0d07f0a:	209c      	movs	r0, #156	; 0x9c
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
c0d07f0c:	5c21      	ldrb	r1, [r4, r0]
c0d07f0e:	4620      	mov	r0, r4
c0d07f10:	309c      	adds	r0, #156	; 0x9c
c0d07f12:	2903      	cmp	r1, #3
c0d07f14:	d007      	beq.n	c0d07f26 <USBD_SetConfig+0x28>
c0d07f16:	2902      	cmp	r1, #2
c0d07f18:	d115      	bne.n	c0d07f46 <USBD_SetConfig+0x48>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
c0d07f1a:	2e00      	cmp	r6, #0
c0d07f1c:	d023      	beq.n	c0d07f66 <USBD_SetConfig+0x68>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
c0d07f1e:	6066      	str	r6, [r4, #4]
c0d07f20:	2103      	movs	r1, #3
        pdev->dev_state = USBD_STATE_CONFIGURED;
c0d07f22:	7001      	strb	r1, [r0, #0]
c0d07f24:	e009      	b.n	c0d07f3a <USBD_SetConfig+0x3c>
      }
      USBD_CtlSendStatus(pdev);
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
c0d07f26:	2e00      	cmp	r6, #0
c0d07f28:	d012      	beq.n	c0d07f50 <USBD_SetConfig+0x52>
        pdev->dev_state = USBD_STATE_ADDRESSED;
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
      } 
      else  if (cfgidx != pdev->dev_config) 
c0d07f2a:	6860      	ldr	r0, [r4, #4]
c0d07f2c:	42b0      	cmp	r0, r6
c0d07f2e:	d01a      	beq.n	c0d07f66 <USBD_SetConfig+0x68>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
c0d07f30:	b2c1      	uxtb	r1, r0
c0d07f32:	4620      	mov	r0, r4
c0d07f34:	f7ff fdaa 	bl	c0d07a8c <USBD_ClrClassConfig>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
c0d07f38:	6066      	str	r6, [r4, #4]
c0d07f3a:	4620      	mov	r0, r4
c0d07f3c:	4631      	mov	r1, r6
c0d07f3e:	f7ff fd8a 	bl	c0d07a56 <USBD_SetClassConfig>
c0d07f42:	2802      	cmp	r0, #2
c0d07f44:	d10f      	bne.n	c0d07f66 <USBD_SetConfig+0x68>
c0d07f46:	4620      	mov	r0, r4
c0d07f48:	4629      	mov	r1, r5
c0d07f4a:	f000 fb09 	bl	c0d08560 <USBD_CtlError>
    default:					
       USBD_CtlError(pdev , req);                     
      break;
    }
  }
}
c0d07f4e:	bd70      	pop	{r4, r5, r6, pc}
c0d07f50:	2102      	movs	r1, #2
        pdev->dev_state = USBD_STATE_ADDRESSED;
c0d07f52:	7001      	strb	r1, [r0, #0]
c0d07f54:	2000      	movs	r0, #0
        pdev->dev_config = cfgidx;          
c0d07f56:	6060      	str	r0, [r4, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
c0d07f58:	4620      	mov	r0, r4
c0d07f5a:	4631      	mov	r1, r6
c0d07f5c:	f7ff fd96 	bl	c0d07a8c <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
c0d07f60:	4620      	mov	r0, r4
c0d07f62:	f000 fbd9 	bl	c0d08718 <USBD_CtlSendStatus>
c0d07f66:	4620      	mov	r0, r4
c0d07f68:	f000 fbd6 	bl	c0d08718 <USBD_CtlSendStatus>
}
c0d07f6c:	bd70      	pop	{r4, r5, r6, pc}

c0d07f6e <USBD_GetConfig>:
* @param  req: usb request
* @retval status
*/
void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d07f6e:	b580      	push	{r7, lr}

  if (req->wLength != 1) 
c0d07f70:	88ca      	ldrh	r2, [r1, #6]
c0d07f72:	2a01      	cmp	r2, #1
c0d07f74:	d10a      	bne.n	c0d07f8c <USBD_GetConfig+0x1e>
c0d07f76:	229c      	movs	r2, #156	; 0x9c
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
c0d07f78:	5c82      	ldrb	r2, [r0, r2]
c0d07f7a:	2a03      	cmp	r2, #3
c0d07f7c:	d009      	beq.n	c0d07f92 <USBD_GetConfig+0x24>
c0d07f7e:	2a02      	cmp	r2, #2
c0d07f80:	d104      	bne.n	c0d07f8c <USBD_GetConfig+0x1e>
c0d07f82:	2100      	movs	r1, #0
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
c0d07f84:	6081      	str	r1, [r0, #8]
c0d07f86:	4601      	mov	r1, r0
c0d07f88:	3108      	adds	r1, #8
c0d07f8a:	e003      	b.n	c0d07f94 <USBD_GetConfig+0x26>
c0d07f8c:	f000 fae8 	bl	c0d08560 <USBD_CtlError>
    default:
       USBD_CtlError(pdev , req);
      break;
    }
  }
}
c0d07f90:	bd80      	pop	{r7, pc}
                        (uint8_t *)&pdev->dev_config,
c0d07f92:	1d01      	adds	r1, r0, #4
c0d07f94:	2201      	movs	r2, #1
c0d07f96:	f000 fb95 	bl	c0d086c4 <USBD_CtlSendData>
}
c0d07f9a:	bd80      	pop	{r7, pc}

c0d07f9c <USBD_GetStatus>:
* @param  req: usb request
* @retval status
*/
void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d07f9c:	b5b0      	push	{r4, r5, r7, lr}
c0d07f9e:	4604      	mov	r4, r0
c0d07fa0:	209c      	movs	r0, #156	; 0x9c
  
    
  switch (pdev->dev_state) 
c0d07fa2:	5c20      	ldrb	r0, [r4, r0]
c0d07fa4:	22fe      	movs	r2, #254	; 0xfe
c0d07fa6:	4002      	ands	r2, r0
c0d07fa8:	2a02      	cmp	r2, #2
c0d07faa:	d10e      	bne.n	c0d07fca <USBD_GetStatus+0x2e>
c0d07fac:	2001      	movs	r0, #1
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
c0d07fae:	60e0      	str	r0, [r4, #12]
c0d07fb0:	20a4      	movs	r0, #164	; 0xa4
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0d07fb2:	5820      	ldr	r0, [r4, r0]
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
c0d07fb4:	4625      	mov	r5, r4
c0d07fb6:	350c      	adds	r5, #12
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0d07fb8:	2800      	cmp	r0, #0
c0d07fba:	d00a      	beq.n	c0d07fd2 <USBD_GetStatus+0x36>
c0d07fbc:	4620      	mov	r0, r4
c0d07fbe:	f000 fbb7 	bl	c0d08730 <USBD_CtlReceiveStatus>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
c0d07fc2:	68e1      	ldr	r1, [r4, #12]
c0d07fc4:	2002      	movs	r0, #2
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0d07fc6:	4308      	orrs	r0, r1
c0d07fc8:	e004      	b.n	c0d07fd4 <USBD_GetStatus+0x38>
                      (uint8_t *)& pdev->dev_config_status,
                      2);
    break;
    
  default :
    USBD_CtlError(pdev , req);                        
c0d07fca:	4620      	mov	r0, r4
c0d07fcc:	f000 fac8 	bl	c0d08560 <USBD_CtlError>
    break;
  }
}
c0d07fd0:	bdb0      	pop	{r4, r5, r7, pc}
c0d07fd2:	2003      	movs	r0, #3
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
c0d07fd4:	60e0      	str	r0, [r4, #12]
c0d07fd6:	2202      	movs	r2, #2
    USBD_CtlSendData (pdev, 
c0d07fd8:	4620      	mov	r0, r4
c0d07fda:	4629      	mov	r1, r5
c0d07fdc:	f000 fb72 	bl	c0d086c4 <USBD_CtlSendData>
}
c0d07fe0:	bdb0      	pop	{r4, r5, r7, pc}

c0d07fe2 <USBD_SetFeature>:
* @param  req: usb request
* @retval status
*/
void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d07fe2:	b5b0      	push	{r4, r5, r7, lr}
c0d07fe4:	4604      	mov	r4, r0

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
c0d07fe6:	8848      	ldrh	r0, [r1, #2]
c0d07fe8:	2801      	cmp	r0, #1
c0d07fea:	d116      	bne.n	c0d0801a <USBD_SetFeature+0x38>
c0d07fec:	460d      	mov	r5, r1
c0d07fee:	20a4      	movs	r0, #164	; 0xa4
c0d07ff0:	2101      	movs	r1, #1
  {
    pdev->dev_remote_wakeup = 1;  
c0d07ff2:	5021      	str	r1, [r4, r0]
    if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d07ff4:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d07ff6:	2802      	cmp	r0, #2
c0d07ff8:	d80c      	bhi.n	c0d08014 <USBD_SetFeature+0x32>
c0d07ffa:	00c0      	lsls	r0, r0, #3
c0d07ffc:	1820      	adds	r0, r4, r0
c0d07ffe:	21b4      	movs	r1, #180	; 0xb4
c0d08000:	5840      	ldr	r0, [r0, r1]
    if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d08002:	2800      	cmp	r0, #0
c0d08004:	d006      	beq.n	c0d08014 <USBD_SetFeature+0x32>
      ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);   
c0d08006:	6880      	ldr	r0, [r0, #8]
c0d08008:	f7fc fce4 	bl	c0d049d4 <pic>
c0d0800c:	4602      	mov	r2, r0
c0d0800e:	4620      	mov	r0, r4
c0d08010:	4629      	mov	r1, r5
c0d08012:	4790      	blx	r2
    }
    USBD_CtlSendStatus(pdev);
c0d08014:	4620      	mov	r0, r4
c0d08016:	f000 fb7f 	bl	c0d08718 <USBD_CtlSendStatus>
  }

}
c0d0801a:	bdb0      	pop	{r4, r5, r7, pc}

c0d0801c <USBD_ClrFeature>:
* @param  req: usb request
* @retval status
*/
void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d0801c:	b5b0      	push	{r4, r5, r7, lr}
c0d0801e:	460d      	mov	r5, r1
c0d08020:	4604      	mov	r4, r0
c0d08022:	209c      	movs	r0, #156	; 0x9c
  switch (pdev->dev_state)
c0d08024:	5c20      	ldrb	r0, [r4, r0]
c0d08026:	21fe      	movs	r1, #254	; 0xfe
c0d08028:	4001      	ands	r1, r0
c0d0802a:	2902      	cmp	r1, #2
c0d0802c:	d119      	bne.n	c0d08062 <USBD_ClrFeature+0x46>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
c0d0802e:	8868      	ldrh	r0, [r5, #2]
c0d08030:	2801      	cmp	r0, #1
c0d08032:	d11a      	bne.n	c0d0806a <USBD_ClrFeature+0x4e>
c0d08034:	20a4      	movs	r0, #164	; 0xa4
c0d08036:	2100      	movs	r1, #0
    {
      pdev->dev_remote_wakeup = 0; 
c0d08038:	5021      	str	r1, [r4, r0]
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d0803a:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d0803c:	2802      	cmp	r0, #2
c0d0803e:	d80c      	bhi.n	c0d0805a <USBD_ClrFeature+0x3e>
c0d08040:	00c0      	lsls	r0, r0, #3
c0d08042:	1820      	adds	r0, r4, r0
c0d08044:	21b4      	movs	r1, #180	; 0xb4
c0d08046:	5840      	ldr	r0, [r0, r1]
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d08048:	2800      	cmp	r0, #0
c0d0804a:	d006      	beq.n	c0d0805a <USBD_ClrFeature+0x3e>
        ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);   
c0d0804c:	6880      	ldr	r0, [r0, #8]
c0d0804e:	f7fc fcc1 	bl	c0d049d4 <pic>
c0d08052:	4602      	mov	r2, r0
c0d08054:	4620      	mov	r0, r4
c0d08056:	4629      	mov	r1, r5
c0d08058:	4790      	blx	r2
      }
      USBD_CtlSendStatus(pdev);
c0d0805a:	4620      	mov	r0, r4
c0d0805c:	f000 fb5c 	bl	c0d08718 <USBD_CtlSendStatus>
    
  default :
     USBD_CtlError(pdev , req);
    break;
  }
}
c0d08060:	bdb0      	pop	{r4, r5, r7, pc}
     USBD_CtlError(pdev , req);
c0d08062:	4620      	mov	r0, r4
c0d08064:	4629      	mov	r1, r5
c0d08066:	f000 fa7b 	bl	c0d08560 <USBD_CtlError>
}
c0d0806a:	bdb0      	pop	{r4, r5, r7, pc}

c0d0806c <USBD_StdItfReq>:
{
c0d0806c:	b5b0      	push	{r4, r5, r7, lr}
c0d0806e:	460d      	mov	r5, r1
c0d08070:	4604      	mov	r4, r0
c0d08072:	209c      	movs	r0, #156	; 0x9c
  switch (pdev->dev_state) 
c0d08074:	5c20      	ldrb	r0, [r4, r0]
c0d08076:	2803      	cmp	r0, #3
c0d08078:	d116      	bne.n	c0d080a8 <USBD_StdItfReq+0x3c>
    if (usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) 
c0d0807a:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d0807c:	2802      	cmp	r0, #2
c0d0807e:	d813      	bhi.n	c0d080a8 <USBD_StdItfReq+0x3c>
c0d08080:	00c0      	lsls	r0, r0, #3
c0d08082:	1820      	adds	r0, r4, r0
c0d08084:	21b4      	movs	r1, #180	; 0xb4
c0d08086:	5840      	ldr	r0, [r0, r1]
    if (usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) 
c0d08088:	2800      	cmp	r0, #0
c0d0808a:	d00d      	beq.n	c0d080a8 <USBD_StdItfReq+0x3c>
      ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);
c0d0808c:	6880      	ldr	r0, [r0, #8]
c0d0808e:	f7fc fca1 	bl	c0d049d4 <pic>
c0d08092:	4602      	mov	r2, r0
c0d08094:	4620      	mov	r0, r4
c0d08096:	4629      	mov	r1, r5
c0d08098:	4790      	blx	r2
      if((req->wLength == 0)&& (ret == USBD_OK))
c0d0809a:	88e8      	ldrh	r0, [r5, #6]
c0d0809c:	2800      	cmp	r0, #0
c0d0809e:	d107      	bne.n	c0d080b0 <USBD_StdItfReq+0x44>
         USBD_CtlSendStatus(pdev);
c0d080a0:	4620      	mov	r0, r4
c0d080a2:	f000 fb39 	bl	c0d08718 <USBD_CtlSendStatus>
c0d080a6:	e003      	b.n	c0d080b0 <USBD_StdItfReq+0x44>
c0d080a8:	4620      	mov	r0, r4
c0d080aa:	4629      	mov	r1, r5
c0d080ac:	f000 fa58 	bl	c0d08560 <USBD_CtlError>
c0d080b0:	2000      	movs	r0, #0
  return USBD_OK;
c0d080b2:	bdb0      	pop	{r4, r5, r7, pc}

c0d080b4 <USBD_StdEPReq>:
{
c0d080b4:	b5b0      	push	{r4, r5, r7, lr}
c0d080b6:	460d      	mov	r5, r1
c0d080b8:	4604      	mov	r4, r0
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d080ba:	7808      	ldrb	r0, [r1, #0]
c0d080bc:	2260      	movs	r2, #96	; 0x60
c0d080be:	4002      	ands	r2, r0
  ep_addr  = LOBYTE(req->wIndex);   
c0d080c0:	7909      	ldrb	r1, [r1, #4]
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d080c2:	2a20      	cmp	r2, #32
c0d080c4:	d10f      	bne.n	c0d080e6 <USBD_StdEPReq+0x32>
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d080c6:	2902      	cmp	r1, #2
c0d080c8:	d80d      	bhi.n	c0d080e6 <USBD_StdEPReq+0x32>
c0d080ca:	00c8      	lsls	r0, r1, #3
c0d080cc:	1820      	adds	r0, r4, r0
c0d080ce:	22b4      	movs	r2, #180	; 0xb4
c0d080d0:	5880      	ldr	r0, [r0, r2]
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d080d2:	2800      	cmp	r0, #0
c0d080d4:	d007      	beq.n	c0d080e6 <USBD_StdEPReq+0x32>
    ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);
c0d080d6:	6880      	ldr	r0, [r0, #8]
c0d080d8:	f7fc fc7c 	bl	c0d049d4 <pic>
c0d080dc:	4602      	mov	r2, r0
c0d080de:	4620      	mov	r0, r4
c0d080e0:	4629      	mov	r1, r5
c0d080e2:	4790      	blx	r2
c0d080e4:	e066      	b.n	c0d081b4 <USBD_StdEPReq+0x100>
  switch (req->bRequest) 
c0d080e6:	7868      	ldrb	r0, [r5, #1]
c0d080e8:	2800      	cmp	r0, #0
c0d080ea:	d016      	beq.n	c0d0811a <USBD_StdEPReq+0x66>
c0d080ec:	2801      	cmp	r0, #1
c0d080ee:	d01d      	beq.n	c0d0812c <USBD_StdEPReq+0x78>
c0d080f0:	2803      	cmp	r0, #3
c0d080f2:	d15f      	bne.n	c0d081b4 <USBD_StdEPReq+0x100>
c0d080f4:	209c      	movs	r0, #156	; 0x9c
    switch (pdev->dev_state) 
c0d080f6:	5c20      	ldrb	r0, [r4, r0]
c0d080f8:	2803      	cmp	r0, #3
c0d080fa:	d11b      	bne.n	c0d08134 <USBD_StdEPReq+0x80>
      if (req->wValue == USB_FEATURE_EP_HALT)
c0d080fc:	8868      	ldrh	r0, [r5, #2]
c0d080fe:	2800      	cmp	r0, #0
c0d08100:	d107      	bne.n	c0d08112 <USBD_StdEPReq+0x5e>
c0d08102:	2080      	movs	r0, #128	; 0x80
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
c0d08104:	4308      	orrs	r0, r1
c0d08106:	2880      	cmp	r0, #128	; 0x80
c0d08108:	d003      	beq.n	c0d08112 <USBD_StdEPReq+0x5e>
          USBD_LL_StallEP(pdev , ep_addr);
c0d0810a:	4620      	mov	r0, r4
c0d0810c:	f7ff fbc8 	bl	c0d078a0 <USBD_LL_StallEP>
        }
c0d08110:	7929      	ldrb	r1, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d08112:	2902      	cmp	r1, #2
c0d08114:	d83d      	bhi.n	c0d08192 <USBD_StdEPReq+0xde>
c0d08116:	00c8      	lsls	r0, r1, #3
c0d08118:	e02f      	b.n	c0d0817a <USBD_StdEPReq+0xc6>
c0d0811a:	209c      	movs	r0, #156	; 0x9c
    switch (pdev->dev_state) 
c0d0811c:	5c20      	ldrb	r0, [r4, r0]
c0d0811e:	2803      	cmp	r0, #3
c0d08120:	d017      	beq.n	c0d08152 <USBD_StdEPReq+0x9e>
c0d08122:	2802      	cmp	r0, #2
c0d08124:	d110      	bne.n	c0d08148 <USBD_StdEPReq+0x94>
      if ((ep_addr & 0x7F) != 0x00) 
c0d08126:	0648      	lsls	r0, r1, #25
c0d08128:	d10a      	bne.n	c0d08140 <USBD_StdEPReq+0x8c>
c0d0812a:	e043      	b.n	c0d081b4 <USBD_StdEPReq+0x100>
c0d0812c:	209c      	movs	r0, #156	; 0x9c
    switch (pdev->dev_state) 
c0d0812e:	5c20      	ldrb	r0, [r4, r0]
c0d08130:	2803      	cmp	r0, #3
c0d08132:	d016      	beq.n	c0d08162 <USBD_StdEPReq+0xae>
c0d08134:	2802      	cmp	r0, #2
c0d08136:	d107      	bne.n	c0d08148 <USBD_StdEPReq+0x94>
c0d08138:	2080      	movs	r0, #128	; 0x80
c0d0813a:	4308      	orrs	r0, r1
c0d0813c:	2880      	cmp	r0, #128	; 0x80
c0d0813e:	d039      	beq.n	c0d081b4 <USBD_StdEPReq+0x100>
c0d08140:	4620      	mov	r0, r4
c0d08142:	f7ff fbad 	bl	c0d078a0 <USBD_LL_StallEP>
c0d08146:	e035      	b.n	c0d081b4 <USBD_StdEPReq+0x100>
c0d08148:	4620      	mov	r0, r4
c0d0814a:	4629      	mov	r1, r5
c0d0814c:	f000 fa08 	bl	c0d08560 <USBD_CtlError>
c0d08150:	e030      	b.n	c0d081b4 <USBD_StdEPReq+0x100>
c0d08152:	207f      	movs	r0, #127	; 0x7f
c0d08154:	4008      	ands	r0, r1
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
c0d08156:	0100      	lsls	r0, r0, #4
c0d08158:	1825      	adds	r5, r4, r0
c0d0815a:	0608      	lsls	r0, r1, #24
c0d0815c:	d51d      	bpl.n	c0d0819a <USBD_StdEPReq+0xe6>
c0d0815e:	3514      	adds	r5, #20
c0d08160:	e01c      	b.n	c0d0819c <USBD_StdEPReq+0xe8>
      if (req->wValue == USB_FEATURE_EP_HALT)
c0d08162:	8868      	ldrh	r0, [r5, #2]
c0d08164:	2800      	cmp	r0, #0
c0d08166:	d125      	bne.n	c0d081b4 <USBD_StdEPReq+0x100>
        if ((ep_addr & 0x7F) != 0x00) 
c0d08168:	0648      	lsls	r0, r1, #25
c0d0816a:	d012      	beq.n	c0d08192 <USBD_StdEPReq+0xde>
          USBD_LL_ClearStallEP(pdev , ep_addr);
c0d0816c:	4620      	mov	r0, r4
c0d0816e:	f7ff fbbb 	bl	c0d078e8 <USBD_LL_ClearStallEP>
          if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d08172:	7928      	ldrb	r0, [r5, #4]
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d08174:	2802      	cmp	r0, #2
c0d08176:	d80c      	bhi.n	c0d08192 <USBD_StdEPReq+0xde>
c0d08178:	00c0      	lsls	r0, r0, #3
c0d0817a:	1820      	adds	r0, r4, r0
c0d0817c:	21b4      	movs	r1, #180	; 0xb4
c0d0817e:	5840      	ldr	r0, [r0, r1]
c0d08180:	2800      	cmp	r0, #0
c0d08182:	d006      	beq.n	c0d08192 <USBD_StdEPReq+0xde>
c0d08184:	6880      	ldr	r0, [r0, #8]
c0d08186:	f7fc fc25 	bl	c0d049d4 <pic>
c0d0818a:	4602      	mov	r2, r0
c0d0818c:	4620      	mov	r0, r4
c0d0818e:	4629      	mov	r1, r5
c0d08190:	4790      	blx	r2
c0d08192:	4620      	mov	r0, r4
c0d08194:	f000 fac0 	bl	c0d08718 <USBD_CtlSendStatus>
c0d08198:	e00c      	b.n	c0d081b4 <USBD_StdEPReq+0x100>
c0d0819a:	3554      	adds	r5, #84	; 0x54
      if(USBD_LL_IsStallEP(pdev, ep_addr))
c0d0819c:	4620      	mov	r0, r4
c0d0819e:	f7ff fbc7 	bl	c0d07930 <USBD_LL_IsStallEP>
c0d081a2:	2800      	cmp	r0, #0
c0d081a4:	d000      	beq.n	c0d081a8 <USBD_StdEPReq+0xf4>
c0d081a6:	2001      	movs	r0, #1
c0d081a8:	6028      	str	r0, [r5, #0]
c0d081aa:	2202      	movs	r2, #2
      USBD_CtlSendData (pdev,
c0d081ac:	4620      	mov	r0, r4
c0d081ae:	4629      	mov	r1, r5
c0d081b0:	f000 fa88 	bl	c0d086c4 <USBD_CtlSendData>
c0d081b4:	2000      	movs	r0, #0
}
c0d081b6:	bdb0      	pop	{r4, r5, r7, pc}

c0d081b8 <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
c0d081b8:	780a      	ldrb	r2, [r1, #0]
c0d081ba:	7002      	strb	r2, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
c0d081bc:	784a      	ldrb	r2, [r1, #1]
c0d081be:	7042      	strb	r2, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
c0d081c0:	788a      	ldrb	r2, [r1, #2]
c0d081c2:	78cb      	ldrb	r3, [r1, #3]
c0d081c4:	021b      	lsls	r3, r3, #8
c0d081c6:	189a      	adds	r2, r3, r2
c0d081c8:	8042      	strh	r2, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
c0d081ca:	790a      	ldrb	r2, [r1, #4]
c0d081cc:	794b      	ldrb	r3, [r1, #5]
c0d081ce:	021b      	lsls	r3, r3, #8
c0d081d0:	189a      	adds	r2, r3, r2
c0d081d2:	8082      	strh	r2, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
c0d081d4:	798a      	ldrb	r2, [r1, #6]
c0d081d6:	79c9      	ldrb	r1, [r1, #7]
c0d081d8:	0209      	lsls	r1, r1, #8
c0d081da:	1889      	adds	r1, r1, r2
c0d081dc:	80c1      	strh	r1, [r0, #6]

}
c0d081de:	4770      	bx	lr

c0d081e0 <USBD_CtlStall>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/
void USBD_CtlStall( USBD_HandleTypeDef *pdev)
{
c0d081e0:	b510      	push	{r4, lr}
c0d081e2:	4604      	mov	r4, r0
c0d081e4:	2180      	movs	r1, #128	; 0x80
  USBD_LL_StallEP(pdev , 0x80);
c0d081e6:	f7ff fb5b 	bl	c0d078a0 <USBD_LL_StallEP>
c0d081ea:	2100      	movs	r1, #0
  USBD_LL_StallEP(pdev , 0);
c0d081ec:	4620      	mov	r0, r4
c0d081ee:	f7ff fb57 	bl	c0d078a0 <USBD_LL_StallEP>
}
c0d081f2:	bd10      	pop	{r4, pc}

c0d081f4 <USBD_HID_Setup>:
  * @param  req: usb requests
  * @retval status
  */
uint8_t  USBD_HID_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
c0d081f4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d081f6:	b083      	sub	sp, #12
c0d081f8:	460e      	mov	r6, r1
c0d081fa:	4605      	mov	r5, r0
c0d081fc:	a802      	add	r0, sp, #8
c0d081fe:	2400      	movs	r4, #0
  uint16_t len = 0;
c0d08200:	8004      	strh	r4, [r0, #0]
c0d08202:	a801      	add	r0, sp, #4
  uint8_t  *pbuf = NULL;

  uint8_t val = 0;
c0d08204:	7004      	strb	r4, [r0, #0]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
c0d08206:	7809      	ldrb	r1, [r1, #0]
c0d08208:	2060      	movs	r0, #96	; 0x60
c0d0820a:	4008      	ands	r0, r1
c0d0820c:	2800      	cmp	r0, #0
c0d0820e:	d010      	beq.n	c0d08232 <USBD_HID_Setup+0x3e>
c0d08210:	2820      	cmp	r0, #32
c0d08212:	d137      	bne.n	c0d08284 <USBD_HID_Setup+0x90>
  {
  case USB_REQ_TYPE_CLASS :  
    switch (req->bRequest)
c0d08214:	7870      	ldrb	r0, [r6, #1]
c0d08216:	4601      	mov	r1, r0
c0d08218:	390a      	subs	r1, #10
c0d0821a:	2902      	cmp	r1, #2
c0d0821c:	d332      	bcc.n	c0d08284 <USBD_HID_Setup+0x90>
c0d0821e:	2802      	cmp	r0, #2
c0d08220:	d01b      	beq.n	c0d0825a <USBD_HID_Setup+0x66>
c0d08222:	2803      	cmp	r0, #3
c0d08224:	d019      	beq.n	c0d0825a <USBD_HID_Setup+0x66>
                        (uint8_t *)&val,
                        1);      
      break;      
      
    default:
      USBD_CtlError (pdev, req);
c0d08226:	4628      	mov	r0, r5
c0d08228:	4631      	mov	r1, r6
c0d0822a:	f000 f999 	bl	c0d08560 <USBD_CtlError>
c0d0822e:	2402      	movs	r4, #2
c0d08230:	e028      	b.n	c0d08284 <USBD_HID_Setup+0x90>
      return USBD_FAIL; 
    }
    break;
    
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
c0d08232:	7870      	ldrb	r0, [r6, #1]
c0d08234:	280b      	cmp	r0, #11
c0d08236:	d013      	beq.n	c0d08260 <USBD_HID_Setup+0x6c>
c0d08238:	280a      	cmp	r0, #10
c0d0823a:	d00e      	beq.n	c0d0825a <USBD_HID_Setup+0x66>
c0d0823c:	2806      	cmp	r0, #6
c0d0823e:	d121      	bne.n	c0d08284 <USBD_HID_Setup+0x90>
    {
    case USB_REQ_GET_DESCRIPTOR: 
      // 0x22
      if( req->wValue >> 8 == HID_REPORT_DESC)
c0d08240:	78f0      	ldrb	r0, [r6, #3]
c0d08242:	2400      	movs	r4, #0
c0d08244:	2821      	cmp	r0, #33	; 0x21
c0d08246:	d00f      	beq.n	c0d08268 <USBD_HID_Setup+0x74>
c0d08248:	2822      	cmp	r0, #34	; 0x22
      
      //USBD_CtlReceiveStatus(pdev);
      
      USBD_CtlSendData (pdev, 
                        pbuf,
                        len);
c0d0824a:	4622      	mov	r2, r4
c0d0824c:	4621      	mov	r1, r4
      if( req->wValue >> 8 == HID_REPORT_DESC)
c0d0824e:	d116      	bne.n	c0d0827e <USBD_HID_Setup+0x8a>
c0d08250:	af02      	add	r7, sp, #8
        pbuf =  USBD_HID_GetReportDescriptor_impl(&len);
c0d08252:	4638      	mov	r0, r7
c0d08254:	f000 f858 	bl	c0d08308 <USBD_HID_GetReportDescriptor_impl>
c0d08258:	e00a      	b.n	c0d08270 <USBD_HID_Setup+0x7c>
c0d0825a:	a901      	add	r1, sp, #4
c0d0825c:	2201      	movs	r2, #1
c0d0825e:	e00e      	b.n	c0d0827e <USBD_HID_Setup+0x8a>
      break;

    case USB_REQ_SET_INTERFACE :
      //hhid->AltSetting = (uint8_t)(req->wValue);
      USBD_CtlSendStatus(pdev);
c0d08260:	4628      	mov	r0, r5
c0d08262:	f000 fa59 	bl	c0d08718 <USBD_CtlSendStatus>
c0d08266:	e00d      	b.n	c0d08284 <USBD_HID_Setup+0x90>
c0d08268:	af02      	add	r7, sp, #8
        pbuf = USBD_HID_GetHidDescriptor_impl(&len);
c0d0826a:	4638      	mov	r0, r7
c0d0826c:	f000 f832 	bl	c0d082d4 <USBD_HID_GetHidDescriptor_impl>
c0d08270:	4601      	mov	r1, r0
c0d08272:	883a      	ldrh	r2, [r7, #0]
c0d08274:	88f0      	ldrh	r0, [r6, #6]
c0d08276:	4282      	cmp	r2, r0
c0d08278:	d300      	bcc.n	c0d0827c <USBD_HID_Setup+0x88>
c0d0827a:	4602      	mov	r2, r0
c0d0827c:	803a      	strh	r2, [r7, #0]
c0d0827e:	4628      	mov	r0, r5
c0d08280:	f000 fa20 	bl	c0d086c4 <USBD_CtlSendData>
      
    }
  }

  return USBD_OK;
}
c0d08284:	4620      	mov	r0, r4
c0d08286:	b003      	add	sp, #12
c0d08288:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d0828a <USBD_HID_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_HID_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d0828a:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0828c:	b081      	sub	sp, #4
c0d0828e:	4604      	mov	r4, r0
c0d08290:	2182      	movs	r1, #130	; 0x82
c0d08292:	2603      	movs	r6, #3
c0d08294:	2540      	movs	r5, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d08296:	4632      	mov	r2, r6
c0d08298:	462b      	mov	r3, r5
c0d0829a:	f7ff fabb 	bl	c0d07814 <USBD_LL_OpenEP>
c0d0829e:	2702      	movs	r7, #2
                 HID_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 HID_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d082a0:	4620      	mov	r0, r4
c0d082a2:	4639      	mov	r1, r7
c0d082a4:	4632      	mov	r2, r6
c0d082a6:	462b      	mov	r3, r5
c0d082a8:	f7ff fab4 	bl	c0d07814 <USBD_LL_OpenEP>
                 HID_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 HID_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR, HID_EPOUT_SIZE);
c0d082ac:	4620      	mov	r0, r4
c0d082ae:	4639      	mov	r1, r7
c0d082b0:	462a      	mov	r2, r5
c0d082b2:	f7ff fb78 	bl	c0d079a6 <USBD_LL_PrepareReceive>
c0d082b6:	2000      	movs	r0, #0
  USBD_LL_Transmit (pdev, 
                    HID_EPIN_ADDR,                                      
                    NULL,
                    0);
  */
  return USBD_OK;
c0d082b8:	b001      	add	sp, #4
c0d082ba:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d082bc <USBD_HID_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_HID_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
c0d082bc:	b510      	push	{r4, lr}
c0d082be:	4604      	mov	r4, r0
c0d082c0:	2182      	movs	r1, #130	; 0x82
  UNUSED(cfgidx);
  /* Close HID EP IN */
  USBD_LL_CloseEP(pdev,
c0d082c2:	f7ff fad7 	bl	c0d07874 <USBD_LL_CloseEP>
c0d082c6:	2102      	movs	r1, #2
                  HID_EPIN_ADDR);
  
  /* Close HID EP OUT */
  USBD_LL_CloseEP(pdev,
c0d082c8:	4620      	mov	r0, r4
c0d082ca:	f7ff fad3 	bl	c0d07874 <USBD_LL_CloseEP>
c0d082ce:	2000      	movs	r0, #0
                  HID_EPOUT_ADDR);
  
  return USBD_OK;
c0d082d0:	bd10      	pop	{r4, pc}
	...

c0d082d4 <USBD_HID_GetHidDescriptor_impl>:
{
  *length = sizeof (USBD_CfgDesc);
  return (uint8_t*)USBD_CfgDesc;
}

uint8_t* USBD_HID_GetHidDescriptor_impl(uint16_t* len) {
c0d082d4:	21ac      	movs	r1, #172	; 0xac
  switch (USBD_Device.request.wIndex&0xFF) {
c0d082d6:	4a09      	ldr	r2, [pc, #36]	; (c0d082fc <USBD_HID_GetHidDescriptor_impl+0x28>)
c0d082d8:	5c51      	ldrb	r1, [r2, r1]
c0d082da:	2209      	movs	r2, #9
c0d082dc:	2901      	cmp	r1, #1
c0d082de:	d004      	beq.n	c0d082ea <USBD_HID_GetHidDescriptor_impl+0x16>
c0d082e0:	2900      	cmp	r1, #0
c0d082e2:	d105      	bne.n	c0d082f0 <USBD_HID_GetHidDescriptor_impl+0x1c>
c0d082e4:	4907      	ldr	r1, [pc, #28]	; (c0d08304 <USBD_HID_GetHidDescriptor_impl+0x30>)
c0d082e6:	4479      	add	r1, pc
c0d082e8:	e004      	b.n	c0d082f4 <USBD_HID_GetHidDescriptor_impl+0x20>
c0d082ea:	4905      	ldr	r1, [pc, #20]	; (c0d08300 <USBD_HID_GetHidDescriptor_impl+0x2c>)
c0d082ec:	4479      	add	r1, pc
c0d082ee:	e001      	b.n	c0d082f4 <USBD_HID_GetHidDescriptor_impl+0x20>
c0d082f0:	2200      	movs	r2, #0
c0d082f2:	4611      	mov	r1, r2
c0d082f4:	8002      	strh	r2, [r0, #0]
      return (uint8_t*)USBD_HID_Desc_kbd; 
#endif // HAVE_USB_HIDKBD
  }
  *len = 0;
  return 0;
}
c0d082f6:	4608      	mov	r0, r1
c0d082f8:	4770      	bx	lr
c0d082fa:	46c0      	nop			; (mov r8, r8)
c0d082fc:	20002074 	.word	0x20002074
c0d08300:	00002e38 	.word	0x00002e38
c0d08304:	00002e4a 	.word	0x00002e4a

c0d08308 <USBD_HID_GetReportDescriptor_impl>:

uint8_t* USBD_HID_GetReportDescriptor_impl(uint16_t* len) {
c0d08308:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0830a:	b081      	sub	sp, #4
c0d0830c:	4602      	mov	r2, r0
c0d0830e:	20ac      	movs	r0, #172	; 0xac
  switch (USBD_Device.request.wIndex&0xFF) {
c0d08310:	4913      	ldr	r1, [pc, #76]	; (c0d08360 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d08312:	5c08      	ldrb	r0, [r1, r0]
c0d08314:	2422      	movs	r4, #34	; 0x22
c0d08316:	2800      	cmp	r0, #0
c0d08318:	d01a      	beq.n	c0d08350 <USBD_HID_GetReportDescriptor_impl+0x48>
c0d0831a:	2801      	cmp	r0, #1
c0d0831c:	d11b      	bne.n	c0d08356 <USBD_HID_GetReportDescriptor_impl+0x4e>
#ifdef HAVE_IO_U2F
  case U2F_INTF:

    // very dirty work due to lack of callback when USB_HID_Init is called
    USBD_LL_OpenEP(&USBD_Device,
c0d0831e:	4810      	ldr	r0, [pc, #64]	; (c0d08360 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d08320:	2181      	movs	r1, #129	; 0x81
c0d08322:	2703      	movs	r7, #3
c0d08324:	2640      	movs	r6, #64	; 0x40
c0d08326:	9200      	str	r2, [sp, #0]
c0d08328:	463a      	mov	r2, r7
c0d0832a:	4633      	mov	r3, r6
c0d0832c:	f7ff fa72 	bl	c0d07814 <USBD_LL_OpenEP>
c0d08330:	2501      	movs	r5, #1
                   U2F_EPIN_ADDR,
                   USBD_EP_TYPE_INTR,
                   U2F_EPIN_SIZE);
    
    USBD_LL_OpenEP(&USBD_Device,
c0d08332:	480b      	ldr	r0, [pc, #44]	; (c0d08360 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d08334:	4629      	mov	r1, r5
c0d08336:	463a      	mov	r2, r7
c0d08338:	4633      	mov	r3, r6
c0d0833a:	f7ff fa6b 	bl	c0d07814 <USBD_LL_OpenEP>
                   U2F_EPOUT_ADDR,
                   USBD_EP_TYPE_INTR,
                   U2F_EPOUT_SIZE);

    /* Prepare Out endpoint to receive 1st packet */ 
    USBD_LL_PrepareReceive(&USBD_Device, U2F_EPOUT_ADDR, U2F_EPOUT_SIZE);
c0d0833e:	4808      	ldr	r0, [pc, #32]	; (c0d08360 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d08340:	4629      	mov	r1, r5
c0d08342:	4632      	mov	r2, r6
c0d08344:	f7ff fb2f 	bl	c0d079a6 <USBD_LL_PrepareReceive>
c0d08348:	9a00      	ldr	r2, [sp, #0]
c0d0834a:	4807      	ldr	r0, [pc, #28]	; (c0d08368 <USBD_HID_GetReportDescriptor_impl+0x60>)
c0d0834c:	4478      	add	r0, pc
c0d0834e:	e004      	b.n	c0d0835a <USBD_HID_GetReportDescriptor_impl+0x52>
c0d08350:	4804      	ldr	r0, [pc, #16]	; (c0d08364 <USBD_HID_GetReportDescriptor_impl+0x5c>)
c0d08352:	4478      	add	r0, pc
c0d08354:	e001      	b.n	c0d0835a <USBD_HID_GetReportDescriptor_impl+0x52>
c0d08356:	2400      	movs	r4, #0
c0d08358:	4620      	mov	r0, r4
c0d0835a:	8014      	strh	r4, [r2, #0]
    return (uint8_t*)HID_ReportDesc_kbd;
#endif // HAVE_USB_HIDKBD
  }
  *len = 0;
  return 0;
}
c0d0835c:	b001      	add	sp, #4
c0d0835e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d08360:	20002074 	.word	0x20002074
c0d08364:	00002e09 	.word	0x00002e09
c0d08368:	00002ded 	.word	0x00002ded

c0d0836c <USBD_U2F_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_U2F_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d0836c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0836e:	b081      	sub	sp, #4
c0d08370:	4604      	mov	r4, r0
c0d08372:	2181      	movs	r1, #129	; 0x81
c0d08374:	2603      	movs	r6, #3
c0d08376:	2540      	movs	r5, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d08378:	4632      	mov	r2, r6
c0d0837a:	462b      	mov	r3, r5
c0d0837c:	f7ff fa4a 	bl	c0d07814 <USBD_LL_OpenEP>
c0d08380:	2701      	movs	r7, #1
                 U2F_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 U2F_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d08382:	4620      	mov	r0, r4
c0d08384:	4639      	mov	r1, r7
c0d08386:	4632      	mov	r2, r6
c0d08388:	462b      	mov	r3, r5
c0d0838a:	f7ff fa43 	bl	c0d07814 <USBD_LL_OpenEP>
                 U2F_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 U2F_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, U2F_EPOUT_ADDR, U2F_EPOUT_SIZE);
c0d0838e:	4620      	mov	r0, r4
c0d08390:	4639      	mov	r1, r7
c0d08392:	462a      	mov	r2, r5
c0d08394:	f7ff fb07 	bl	c0d079a6 <USBD_LL_PrepareReceive>
c0d08398:	2000      	movs	r0, #0

  return USBD_OK;
c0d0839a:	b001      	add	sp, #4
c0d0839c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d083a0 <USBD_U2F_DataIn_impl>:
}

uint8_t  USBD_U2F_DataIn_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d083a0:	b580      	push	{r7, lr}
  UNUSED(pdev);
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d083a2:	2901      	cmp	r1, #1
c0d083a4:	d103      	bne.n	c0d083ae <USBD_U2F_DataIn_impl+0xe>
  // FIDO endpoint
  case (U2F_EPIN_ADDR&0x7F):
    // advance the u2f sending machine state
    u2f_transport_sent(&G_io_u2f, U2F_MEDIA_USB);
c0d083a6:	4803      	ldr	r0, [pc, #12]	; (c0d083b4 <USBD_U2F_DataIn_impl+0x14>)
c0d083a8:	2101      	movs	r1, #1
c0d083aa:	f7fd fd61 	bl	c0d05e70 <u2f_transport_sent>
c0d083ae:	2000      	movs	r0, #0
    break;
  } 
  return USBD_OK;
c0d083b0:	bd80      	pop	{r7, pc}
c0d083b2:	46c0      	nop			; (mov r8, r8)
c0d083b4:	20001fd4 	.word	0x20001fd4

c0d083b8 <USBD_U2F_DataOut_impl>:
}

uint8_t  USBD_U2F_DataOut_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d083b8:	b5b0      	push	{r4, r5, r7, lr}
  switch (epnum) {
c0d083ba:	2901      	cmp	r1, #1
c0d083bc:	d10e      	bne.n	c0d083dc <USBD_U2F_DataOut_impl+0x24>
c0d083be:	4614      	mov	r4, r2
c0d083c0:	2501      	movs	r5, #1
c0d083c2:	2240      	movs	r2, #64	; 0x40
  // FIDO endpoint
  case (U2F_EPOUT_ADDR&0x7F):
      USBD_LL_PrepareReceive(pdev, U2F_EPOUT_ADDR , U2F_EPOUT_SIZE);
c0d083c4:	4629      	mov	r1, r5
c0d083c6:	f7ff faee 	bl	c0d079a6 <USBD_LL_PrepareReceive>
      u2f_transport_received(&G_io_u2f, buffer, io_seproxyhal_get_ep_rx_size(U2F_EPOUT_ADDR), U2F_MEDIA_USB);
c0d083ca:	4628      	mov	r0, r5
c0d083cc:	f7fb fc7c 	bl	c0d03cc8 <io_seproxyhal_get_ep_rx_size>
c0d083d0:	4602      	mov	r2, r0
c0d083d2:	4803      	ldr	r0, [pc, #12]	; (c0d083e0 <USBD_U2F_DataOut_impl+0x28>)
c0d083d4:	4621      	mov	r1, r4
c0d083d6:	462b      	mov	r3, r5
c0d083d8:	f7fd fe96 	bl	c0d06108 <u2f_transport_received>
c0d083dc:	2000      	movs	r0, #0
    break;
  }

  return USBD_OK;
c0d083de:	bdb0      	pop	{r4, r5, r7, pc}
c0d083e0:	20001fd4 	.word	0x20001fd4

c0d083e4 <USBD_HID_DataIn_impl>:
}
#endif // HAVE_IO_U2F

uint8_t  USBD_HID_DataIn_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d083e4:	b580      	push	{r7, lr}
  UNUSED(pdev);
  switch (epnum) {
c0d083e6:	2902      	cmp	r1, #2
c0d083e8:	d103      	bne.n	c0d083f2 <USBD_HID_DataIn_impl+0xe>
    // HID gen endpoint
    case (HID_EPIN_ADDR&0x7F):
      io_usb_hid_sent(io_usb_send_apdu_data);
c0d083ea:	4803      	ldr	r0, [pc, #12]	; (c0d083f8 <USBD_HID_DataIn_impl+0x14>)
c0d083ec:	4478      	add	r0, pc
c0d083ee:	f7fc f89f 	bl	c0d04530 <io_usb_hid_sent>
c0d083f2:	2000      	movs	r0, #0
      break;
  }

  return USBD_OK;
c0d083f4:	bd80      	pop	{r7, pc}
c0d083f6:	46c0      	nop			; (mov r8, r8)
c0d083f8:	ffffb9a5 	.word	0xffffb9a5

c0d083fc <USBD_HID_DataOut_impl>:
}

uint8_t  USBD_HID_DataOut_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d083fc:	b5b0      	push	{r4, r5, r7, lr}
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d083fe:	2902      	cmp	r1, #2
c0d08400:	d11a      	bne.n	c0d08438 <USBD_HID_DataOut_impl+0x3c>
c0d08402:	4614      	mov	r4, r2
c0d08404:	2102      	movs	r1, #2
c0d08406:	2240      	movs	r2, #64	; 0x40

  // HID gen endpoint
  case (HID_EPOUT_ADDR&0x7F):
    // prepare receiving the next chunk (masked time)
    USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR , HID_EPOUT_SIZE);
c0d08408:	f7ff facd 	bl	c0d079a6 <USBD_LL_PrepareReceive>

#ifndef HAVE_USB_HIDKBD
    // avoid troubles when an apdu has not been replied yet
    if (G_io_app.apdu_media == IO_APDU_MEDIA_NONE) {      
c0d0840c:	4d0b      	ldr	r5, [pc, #44]	; (c0d0843c <USBD_HID_DataOut_impl+0x40>)
c0d0840e:	79a8      	ldrb	r0, [r5, #6]
c0d08410:	2800      	cmp	r0, #0
c0d08412:	d111      	bne.n	c0d08438 <USBD_HID_DataOut_impl+0x3c>
c0d08414:	2002      	movs	r0, #2
      // add to the hid transport
      switch(io_usb_hid_receive(io_usb_send_apdu_data, buffer, io_seproxyhal_get_ep_rx_size(HID_EPOUT_ADDR))) {
c0d08416:	f7fb fc57 	bl	c0d03cc8 <io_seproxyhal_get_ep_rx_size>
c0d0841a:	4602      	mov	r2, r0
c0d0841c:	4809      	ldr	r0, [pc, #36]	; (c0d08444 <USBD_HID_DataOut_impl+0x48>)
c0d0841e:	4478      	add	r0, pc
c0d08420:	4621      	mov	r1, r4
c0d08422:	f7fb ffd7 	bl	c0d043d4 <io_usb_hid_receive>
c0d08426:	2802      	cmp	r0, #2
c0d08428:	d106      	bne.n	c0d08438 <USBD_HID_DataOut_impl+0x3c>
c0d0842a:	2007      	movs	r0, #7
        default:
          break;

        case IO_USB_APDU_RECEIVED:
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_HID; // for application code
          G_io_app.apdu_state = APDU_USB_HID; // for next call to io_exchange
c0d0842c:	7028      	strb	r0, [r5, #0]
c0d0842e:	2001      	movs	r0, #1
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_HID; // for application code
c0d08430:	71a8      	strb	r0, [r5, #6]
          G_io_app.apdu_length = G_io_usb_hid_total_length;
c0d08432:	4803      	ldr	r0, [pc, #12]	; (c0d08440 <USBD_HID_DataOut_impl+0x44>)
c0d08434:	6800      	ldr	r0, [r0, #0]
c0d08436:	8068      	strh	r0, [r5, #2]
c0d08438:	2000      	movs	r0, #0
    }
#endif // HAVE_USB_HIDKBD
    break;
  }

  return USBD_OK;
c0d0843a:	bdb0      	pop	{r4, r5, r7, pc}
c0d0843c:	20001fb4 	.word	0x20001fb4
c0d08440:	2000205c 	.word	0x2000205c
c0d08444:	ffffb973 	.word	0xffffb973

c0d08448 <USBD_WEBUSB_Init>:

#ifdef HAVE_WEBUSB

uint8_t  USBD_WEBUSB_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d08448:	b570      	push	{r4, r5, r6, lr}
c0d0844a:	4604      	mov	r4, r0
c0d0844c:	2183      	movs	r1, #131	; 0x83
c0d0844e:	2503      	movs	r5, #3
c0d08450:	2640      	movs	r6, #64	; 0x40
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d08452:	462a      	mov	r2, r5
c0d08454:	4633      	mov	r3, r6
c0d08456:	f7ff f9dd 	bl	c0d07814 <USBD_LL_OpenEP>
                 WEBUSB_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 WEBUSB_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d0845a:	4620      	mov	r0, r4
c0d0845c:	4629      	mov	r1, r5
c0d0845e:	462a      	mov	r2, r5
c0d08460:	4633      	mov	r3, r6
c0d08462:	f7ff f9d7 	bl	c0d07814 <USBD_LL_OpenEP>
                 WEBUSB_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 WEBUSB_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, WEBUSB_EPOUT_ADDR, WEBUSB_EPOUT_SIZE);
c0d08466:	4620      	mov	r0, r4
c0d08468:	4629      	mov	r1, r5
c0d0846a:	4632      	mov	r2, r6
c0d0846c:	f7ff fa9b 	bl	c0d079a6 <USBD_LL_PrepareReceive>
c0d08470:	2000      	movs	r0, #0

  return USBD_OK;
c0d08472:	bd70      	pop	{r4, r5, r6, pc}

c0d08474 <USBD_WEBUSB_DeInit>:
}

uint8_t  USBD_WEBUSB_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx) {
c0d08474:	2000      	movs	r0, #0
  UNUSED(pdev);
  UNUSED(cfgidx);
  return USBD_OK;
c0d08476:	4770      	bx	lr

c0d08478 <USBD_WEBUSB_Setup>:
}

uint8_t  USBD_WEBUSB_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
c0d08478:	2000      	movs	r0, #0
  UNUSED(pdev);
  UNUSED(req);
  return USBD_OK;
c0d0847a:	4770      	bx	lr

c0d0847c <USBD_WEBUSB_DataIn>:
}

uint8_t  USBD_WEBUSB_DataIn (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d0847c:	b580      	push	{r7, lr}
  UNUSED(pdev);
  switch (epnum) {
c0d0847e:	2903      	cmp	r1, #3
c0d08480:	d103      	bne.n	c0d0848a <USBD_WEBUSB_DataIn+0xe>
    // HID gen endpoint
    case (WEBUSB_EPIN_ADDR&0x7F):
      io_usb_hid_sent(io_usb_send_apdu_data_ep0x83);
c0d08482:	4803      	ldr	r0, [pc, #12]	; (c0d08490 <USBD_WEBUSB_DataIn+0x14>)
c0d08484:	4478      	add	r0, pc
c0d08486:	f7fc f853 	bl	c0d04530 <io_usb_hid_sent>
c0d0848a:	2000      	movs	r0, #0
      break;
  }
  return USBD_OK;
c0d0848c:	bd80      	pop	{r7, pc}
c0d0848e:	46c0      	nop			; (mov r8, r8)
c0d08490:	ffffb91d 	.word	0xffffb91d

c0d08494 <USBD_WEBUSB_DataOut>:
}

uint8_t USBD_WEBUSB_DataOut (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d08494:	b5b0      	push	{r4, r5, r7, lr}
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d08496:	2903      	cmp	r1, #3
c0d08498:	d11a      	bne.n	c0d084d0 <USBD_WEBUSB_DataOut+0x3c>
c0d0849a:	4614      	mov	r4, r2
c0d0849c:	2103      	movs	r1, #3
c0d0849e:	2240      	movs	r2, #64	; 0x40

  // HID gen endpoint
  case (WEBUSB_EPOUT_ADDR&0x7F):
    // prepare receiving the next chunk (masked time)
    USBD_LL_PrepareReceive(pdev, WEBUSB_EPOUT_ADDR, WEBUSB_EPOUT_SIZE);
c0d084a0:	f7ff fa81 	bl	c0d079a6 <USBD_LL_PrepareReceive>

    // avoid troubles when an apdu has not been replied yet
    if (G_io_app.apdu_media == IO_APDU_MEDIA_NONE) {      
c0d084a4:	4d0b      	ldr	r5, [pc, #44]	; (c0d084d4 <USBD_WEBUSB_DataOut+0x40>)
c0d084a6:	79a8      	ldrb	r0, [r5, #6]
c0d084a8:	2800      	cmp	r0, #0
c0d084aa:	d111      	bne.n	c0d084d0 <USBD_WEBUSB_DataOut+0x3c>
c0d084ac:	2003      	movs	r0, #3
      // add to the hid transport
      switch(io_usb_hid_receive(io_usb_send_apdu_data_ep0x83, buffer, io_seproxyhal_get_ep_rx_size(WEBUSB_EPOUT_ADDR))) {
c0d084ae:	f7fb fc0b 	bl	c0d03cc8 <io_seproxyhal_get_ep_rx_size>
c0d084b2:	4602      	mov	r2, r0
c0d084b4:	4809      	ldr	r0, [pc, #36]	; (c0d084dc <USBD_WEBUSB_DataOut+0x48>)
c0d084b6:	4478      	add	r0, pc
c0d084b8:	4621      	mov	r1, r4
c0d084ba:	f7fb ff8b 	bl	c0d043d4 <io_usb_hid_receive>
c0d084be:	2802      	cmp	r0, #2
c0d084c0:	d106      	bne.n	c0d084d0 <USBD_WEBUSB_DataOut+0x3c>
c0d084c2:	200b      	movs	r0, #11
        default:
          break;

        case IO_USB_APDU_RECEIVED:
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_WEBUSB; // for application code
          G_io_app.apdu_state = APDU_USB_WEBUSB; // for next call to io_exchange
c0d084c4:	7028      	strb	r0, [r5, #0]
c0d084c6:	2005      	movs	r0, #5
          G_io_app.apdu_media = IO_APDU_MEDIA_USB_WEBUSB; // for application code
c0d084c8:	71a8      	strb	r0, [r5, #6]
          G_io_app.apdu_length = G_io_usb_hid_total_length;
c0d084ca:	4803      	ldr	r0, [pc, #12]	; (c0d084d8 <USBD_WEBUSB_DataOut+0x44>)
c0d084cc:	6800      	ldr	r0, [r0, #0]
c0d084ce:	8068      	strh	r0, [r5, #2]
c0d084d0:	2000      	movs	r0, #0
      }
    }
    break;
  }

  return USBD_OK;
c0d084d2:	bdb0      	pop	{r4, r5, r7, pc}
c0d084d4:	20001fb4 	.word	0x20001fb4
c0d084d8:	2000205c 	.word	0x2000205c
c0d084dc:	ffffb8eb 	.word	0xffffb8eb

c0d084e0 <USBD_DeviceDescriptor>:
{
c0d084e0:	2012      	movs	r0, #18
  *length = sizeof(USBD_DeviceDesc);
c0d084e2:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_DeviceDesc;
c0d084e4:	4801      	ldr	r0, [pc, #4]	; (c0d084ec <USBD_DeviceDescriptor+0xc>)
c0d084e6:	4478      	add	r0, pc
c0d084e8:	4770      	bx	lr
c0d084ea:	46c0      	nop			; (mov r8, r8)
c0d084ec:	00002ef2 	.word	0x00002ef2

c0d084f0 <USBD_LangIDStrDescriptor>:
{
c0d084f0:	2004      	movs	r0, #4
  *length = sizeof(USBD_LangIDDesc);  
c0d084f2:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_LangIDDesc;
c0d084f4:	4801      	ldr	r0, [pc, #4]	; (c0d084fc <USBD_LangIDStrDescriptor+0xc>)
c0d084f6:	4478      	add	r0, pc
c0d084f8:	4770      	bx	lr
c0d084fa:	46c0      	nop			; (mov r8, r8)
c0d084fc:	00002ef4 	.word	0x00002ef4

c0d08500 <USBD_ManufacturerStrDescriptor>:
{
c0d08500:	200e      	movs	r0, #14
  *length = sizeof(USBD_MANUFACTURER_STRING);
c0d08502:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_MANUFACTURER_STRING;
c0d08504:	4801      	ldr	r0, [pc, #4]	; (c0d0850c <USBD_ManufacturerStrDescriptor+0xc>)
c0d08506:	4478      	add	r0, pc
c0d08508:	4770      	bx	lr
c0d0850a:	46c0      	nop			; (mov r8, r8)
c0d0850c:	00002ee8 	.word	0x00002ee8

c0d08510 <USBD_ProductStrDescriptor>:
{
c0d08510:	200e      	movs	r0, #14
  *length = sizeof(USBD_PRODUCT_FS_STRING);
c0d08512:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_PRODUCT_FS_STRING;
c0d08514:	4801      	ldr	r0, [pc, #4]	; (c0d0851c <USBD_ProductStrDescriptor+0xc>)
c0d08516:	4478      	add	r0, pc
c0d08518:	4770      	bx	lr
c0d0851a:	46c0      	nop			; (mov r8, r8)
c0d0851c:	00002ee6 	.word	0x00002ee6

c0d08520 <USBD_SerialStrDescriptor>:
{
c0d08520:	200a      	movs	r0, #10
  *length = sizeof(USB_SERIAL_STRING);
c0d08522:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USB_SERIAL_STRING;
c0d08524:	4801      	ldr	r0, [pc, #4]	; (c0d0852c <USBD_SerialStrDescriptor+0xc>)
c0d08526:	4478      	add	r0, pc
c0d08528:	4770      	bx	lr
c0d0852a:	46c0      	nop			; (mov r8, r8)
c0d0852c:	00002ee4 	.word	0x00002ee4

c0d08530 <USBD_ConfigStrDescriptor>:
{
c0d08530:	200e      	movs	r0, #14
  *length = sizeof(USBD_CONFIGURATION_FS_STRING);
c0d08532:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_CONFIGURATION_FS_STRING;
c0d08534:	4801      	ldr	r0, [pc, #4]	; (c0d0853c <USBD_ConfigStrDescriptor+0xc>)
c0d08536:	4478      	add	r0, pc
c0d08538:	4770      	bx	lr
c0d0853a:	46c0      	nop			; (mov r8, r8)
c0d0853c:	00002ec6 	.word	0x00002ec6

c0d08540 <USBD_InterfaceStrDescriptor>:
{
c0d08540:	200e      	movs	r0, #14
  *length = sizeof(USBD_INTERFACE_FS_STRING);
c0d08542:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_INTERFACE_FS_STRING;
c0d08544:	4801      	ldr	r0, [pc, #4]	; (c0d0854c <USBD_InterfaceStrDescriptor+0xc>)
c0d08546:	4478      	add	r0, pc
c0d08548:	4770      	bx	lr
c0d0854a:	46c0      	nop			; (mov r8, r8)
c0d0854c:	00002eb6 	.word	0x00002eb6

c0d08550 <USBD_BOSDescriptor>:
};

#endif // HAVE_WEBUSB

static uint8_t *USBD_BOSDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
c0d08550:	2039      	movs	r0, #57	; 0x39
  UNUSED(speed);
#ifdef HAVE_WEBUSB
  *length = sizeof(C_usb_bos);
c0d08552:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)C_usb_bos;
c0d08554:	4801      	ldr	r0, [pc, #4]	; (c0d0855c <USBD_BOSDescriptor+0xc>)
c0d08556:	4478      	add	r0, pc
c0d08558:	4770      	bx	lr
c0d0855a:	46c0      	nop			; (mov r8, r8)
c0d0855c:	00002c27 	.word	0x00002c27

c0d08560 <USBD_CtlError>:
  '4', 0x00, '6', 0x00, '7', 0x00, '6', 0x00, '5', 0x00, '7', 0x00,
  '2', 0x00, '}', 0x00, 0x00, 0x00, 0x00, 0x00 // propertyData, double unicode nul terminated
};

// upon unsupported request, check for webusb request
void USBD_CtlError( USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef *req) {
c0d08560:	b580      	push	{r7, lr}
    USBD_CtlSendData (pdev, (unsigned char*)C_webusb_url_descriptor, MIN(req->wLength, sizeof(C_webusb_url_descriptor)));
  }
  else 
#endif // WEBUSB_URL_SIZE_B
    // SETUP (LE): 0x80 0x06 0x03 0x77 0x00 0x00 0xXX 0xXX
    if ((req->bmRequest & 0x80) 
c0d08562:	780a      	ldrb	r2, [r1, #0]
c0d08564:	b252      	sxtb	r2, r2
    && req->bRequest == USB_REQ_GET_DESCRIPTOR 
c0d08566:	2a00      	cmp	r2, #0
c0d08568:	db02      	blt.n	c0d08570 <USBD_CtlError+0x10>
      && req->bRequest == WINUSB_VENDOR_CODE
      && req->wIndex == MS_OS_20_DESCRIPTOR_INDEX) {
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_request_descriptor, MIN(req->wLength, sizeof(C_winusb_request_descriptor)));
  }
  else {
    USBD_CtlStall(pdev);
c0d0856a:	f7ff fe39 	bl	c0d081e0 <USBD_CtlStall>
  }
}
c0d0856e:	bd80      	pop	{r7, pc}
    && req->bRequest == USB_REQ_GET_DESCRIPTOR 
c0d08570:	784a      	ldrb	r2, [r1, #1]
    && (req->wValue>>8) == USB_DESC_TYPE_STRING 
c0d08572:	2a77      	cmp	r2, #119	; 0x77
c0d08574:	d00e      	beq.n	c0d08594 <USBD_CtlError+0x34>
c0d08576:	2a06      	cmp	r2, #6
c0d08578:	d1f7      	bne.n	c0d0856a <USBD_CtlError+0xa>
c0d0857a:	884a      	ldrh	r2, [r1, #2]
c0d0857c:	4b17      	ldr	r3, [pc, #92]	; (c0d085dc <USBD_CtlError+0x7c>)
    && (req->wValue & 0xFF) == 0xEE) {
c0d0857e:	429a      	cmp	r2, r3
c0d08580:	d1f3      	bne.n	c0d0856a <USBD_CtlError+0xa>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_string_descriptor, MIN(req->wLength, sizeof(C_winusb_string_descriptor)));
c0d08582:	88ca      	ldrh	r2, [r1, #6]
c0d08584:	2a12      	cmp	r2, #18
c0d08586:	d300      	bcc.n	c0d0858a <USBD_CtlError+0x2a>
c0d08588:	2212      	movs	r2, #18
c0d0858a:	4915      	ldr	r1, [pc, #84]	; (c0d085e0 <USBD_CtlError+0x80>)
c0d0858c:	4479      	add	r1, pc
c0d0858e:	f000 f899 	bl	c0d086c4 <USBD_CtlSendData>
}
c0d08592:	bd80      	pop	{r7, pc}
    && req->wIndex == WINUSB_GET_COMPATIBLE_ID_FEATURE) {
c0d08594:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80) 
c0d08596:	2a04      	cmp	r2, #4
c0d08598:	d108      	bne.n	c0d085ac <USBD_CtlError+0x4c>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_wcid, MIN(req->wLength, sizeof(C_winusb_wcid)));
c0d0859a:	88ca      	ldrh	r2, [r1, #6]
c0d0859c:	2a28      	cmp	r2, #40	; 0x28
c0d0859e:	d300      	bcc.n	c0d085a2 <USBD_CtlError+0x42>
c0d085a0:	2228      	movs	r2, #40	; 0x28
c0d085a2:	4910      	ldr	r1, [pc, #64]	; (c0d085e4 <USBD_CtlError+0x84>)
c0d085a4:	4479      	add	r1, pc
c0d085a6:	f000 f88d 	bl	c0d086c4 <USBD_CtlSendData>
}
c0d085aa:	bd80      	pop	{r7, pc}
    && req->wIndex == WINUSB_GET_EXTENDED_PROPERTIES_OS_FEATURE 
c0d085ac:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80) 
c0d085ae:	2a05      	cmp	r2, #5
c0d085b0:	d108      	bne.n	c0d085c4 <USBD_CtlError+0x64>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_guid, MIN(req->wLength, sizeof(C_winusb_guid)));
c0d085b2:	88ca      	ldrh	r2, [r1, #6]
c0d085b4:	2a92      	cmp	r2, #146	; 0x92
c0d085b6:	d300      	bcc.n	c0d085ba <USBD_CtlError+0x5a>
c0d085b8:	2292      	movs	r2, #146	; 0x92
c0d085ba:	490b      	ldr	r1, [pc, #44]	; (c0d085e8 <USBD_CtlError+0x88>)
c0d085bc:	4479      	add	r1, pc
c0d085be:	f000 f881 	bl	c0d086c4 <USBD_CtlSendData>
}
c0d085c2:	bd80      	pop	{r7, pc}
      && req->wIndex == MS_OS_20_DESCRIPTOR_INDEX) {
c0d085c4:	888a      	ldrh	r2, [r1, #4]
  else if ((req->bmRequest & 0x80)
c0d085c6:	2a07      	cmp	r2, #7
c0d085c8:	d1cf      	bne.n	c0d0856a <USBD_CtlError+0xa>
    USBD_CtlSendData(pdev, (unsigned char*)C_winusb_request_descriptor, MIN(req->wLength, sizeof(C_winusb_request_descriptor)));
c0d085ca:	88ca      	ldrh	r2, [r1, #6]
c0d085cc:	2ab2      	cmp	r2, #178	; 0xb2
c0d085ce:	d300      	bcc.n	c0d085d2 <USBD_CtlError+0x72>
c0d085d0:	22b2      	movs	r2, #178	; 0xb2
c0d085d2:	4906      	ldr	r1, [pc, #24]	; (c0d085ec <USBD_CtlError+0x8c>)
c0d085d4:	4479      	add	r1, pc
c0d085d6:	f000 f875 	bl	c0d086c4 <USBD_CtlSendData>
}
c0d085da:	bd80      	pop	{r7, pc}
c0d085dc:	000003ee 	.word	0x000003ee
c0d085e0:	00002c4c 	.word	0x00002c4c
c0d085e4:	00002e70 	.word	0x00002e70
c0d085e8:	00002c2e 	.word	0x00002c2e
c0d085ec:	00002ca8 	.word	0x00002ca8

c0d085f0 <USB_power>:
  // nothing to do ?
  return 0;
}
#endif // HAVE_USB_CLASS_CCID

void USB_power(unsigned char enabled) {
c0d085f0:	b570      	push	{r4, r5, r6, lr}
c0d085f2:	4604      	mov	r4, r0
  os_memset(&USBD_Device, 0, sizeof(USBD_Device));
c0d085f4:	4823      	ldr	r0, [pc, #140]	; (c0d08684 <USB_power+0x94>)
c0d085f6:	2500      	movs	r5, #0
c0d085f8:	22d4      	movs	r2, #212	; 0xd4
c0d085fa:	4629      	mov	r1, r5
c0d085fc:	f7fb f9e3 	bl	c0d039c6 <os_memset>

  // init timeouts and other global fields
  os_memset(G_io_app.usb_ep_xfer_len, 0, sizeof(G_io_app.usb_ep_xfer_len));
c0d08600:	4e21      	ldr	r6, [pc, #132]	; (c0d08688 <USB_power+0x98>)
c0d08602:	4630      	mov	r0, r6
c0d08604:	300c      	adds	r0, #12
c0d08606:	2204      	movs	r2, #4
c0d08608:	4629      	mov	r1, r5
c0d0860a:	f7fb f9dc 	bl	c0d039c6 <os_memset>
  os_memset(G_io_app.usb_ep_timeouts, 0, sizeof(G_io_app.usb_ep_timeouts));
c0d0860e:	3610      	adds	r6, #16
c0d08610:	2208      	movs	r2, #8
c0d08612:	4630      	mov	r0, r6
c0d08614:	4629      	mov	r1, r5
c0d08616:	f7fb f9d6 	bl	c0d039c6 <os_memset>

  if (enabled) {
c0d0861a:	2c00      	cmp	r4, #0
c0d0861c:	d02d      	beq.n	c0d0867a <USB_power+0x8a>
    os_memset(&USBD_Device, 0, sizeof(USBD_Device));
c0d0861e:	4c19      	ldr	r4, [pc, #100]	; (c0d08684 <USB_power+0x94>)
c0d08620:	2500      	movs	r5, #0
c0d08622:	22d4      	movs	r2, #212	; 0xd4
c0d08624:	4620      	mov	r0, r4
c0d08626:	4629      	mov	r1, r5
c0d08628:	f7fb f9cd 	bl	c0d039c6 <os_memset>
    /* Init Device Library */
    USBD_Init(&USBD_Device, (USBD_DescriptorsTypeDef*)&HID_Desc, 0);
c0d0862c:	4919      	ldr	r1, [pc, #100]	; (c0d08694 <USB_power+0xa4>)
c0d0862e:	4479      	add	r1, pc
c0d08630:	4620      	mov	r0, r4
c0d08632:	462a      	mov	r2, r5
c0d08634:	f7ff f9ca 	bl	c0d079cc <USBD_Init>
    
    /* Register the HID class */
    USBD_RegisterClassForInterface(HID_INTF,  &USBD_Device, (USBD_ClassTypeDef*)&USBD_HID);
c0d08638:	4a17      	ldr	r2, [pc, #92]	; (c0d08698 <USB_power+0xa8>)
c0d0863a:	447a      	add	r2, pc
c0d0863c:	4628      	mov	r0, r5
c0d0863e:	4621      	mov	r1, r4
c0d08640:	f7ff f9f7 	bl	c0d07a32 <USBD_RegisterClassForInterface>
c0d08644:	2001      	movs	r0, #1
#ifdef HAVE_IO_U2F
    USBD_RegisterClassForInterface(U2F_INTF,  &USBD_Device, (USBD_ClassTypeDef*)&USBD_U2F);
c0d08646:	4a15      	ldr	r2, [pc, #84]	; (c0d0869c <USB_power+0xac>)
c0d08648:	447a      	add	r2, pc
c0d0864a:	4621      	mov	r1, r4
c0d0864c:	f7ff f9f1 	bl	c0d07a32 <USBD_RegisterClassForInterface>
c0d08650:	22ff      	movs	r2, #255	; 0xff
c0d08652:	3252      	adds	r2, #82	; 0x52
    // initialize the U2F tunnel transport
    u2f_transport_init(&G_io_u2f, G_io_apdu_buffer, IO_APDU_BUFFER_SIZE);
c0d08654:	480d      	ldr	r0, [pc, #52]	; (c0d0868c <USB_power+0x9c>)
c0d08656:	490e      	ldr	r1, [pc, #56]	; (c0d08690 <USB_power+0xa0>)
c0d08658:	f7fd fc00 	bl	c0d05e5c <u2f_transport_init>
c0d0865c:	2002      	movs	r0, #2
#ifdef HAVE_USB_CLASS_CCID
    USBD_RegisterClassForInterface(CCID_INTF, &USBD_Device, (USBD_ClassTypeDef*)&USBD_CCID);
#endif // HAVE_USB_CLASS_CCID

#ifdef HAVE_WEBUSB
    USBD_RegisterClassForInterface(WEBUSB_INTF, &USBD_Device, (USBD_ClassTypeDef*)&USBD_WEBUSB);
c0d0865e:	4a10      	ldr	r2, [pc, #64]	; (c0d086a0 <USB_power+0xb0>)
c0d08660:	447a      	add	r2, pc
c0d08662:	4621      	mov	r1, r4
c0d08664:	f7ff f9e5 	bl	c0d07a32 <USBD_RegisterClassForInterface>
c0d08668:	2103      	movs	r1, #3
c0d0866a:	2240      	movs	r2, #64	; 0x40
    USBD_LL_PrepareReceive(&USBD_Device, WEBUSB_EPOUT_ADDR , WEBUSB_EPOUT_SIZE);
c0d0866c:	4620      	mov	r0, r4
c0d0866e:	f7ff f99a 	bl	c0d079a6 <USBD_LL_PrepareReceive>
#endif // HAVE_WEBUSB

    /* Start Device Process */
    USBD_Start(&USBD_Device);
c0d08672:	4620      	mov	r0, r4
c0d08674:	f7ff f9ea 	bl	c0d07a4c <USBD_Start>
  }
  else {
    USBD_DeInit(&USBD_Device);
  }
}
c0d08678:	bd70      	pop	{r4, r5, r6, pc}
    USBD_DeInit(&USBD_Device);
c0d0867a:	4802      	ldr	r0, [pc, #8]	; (c0d08684 <USB_power+0x94>)
c0d0867c:	f7ff f9be 	bl	c0d079fc <USBD_DeInit>
}
c0d08680:	bd70      	pop	{r4, r5, r6, pc}
c0d08682:	46c0      	nop			; (mov r8, r8)
c0d08684:	20002074 	.word	0x20002074
c0d08688:	20001fb4 	.word	0x20001fb4
c0d0868c:	20001fd4 	.word	0x20001fd4
c0d08690:	20001e61 	.word	0x20001e61
c0d08694:	00002b8a 	.word	0x00002b8a
c0d08698:	00002cf6 	.word	0x00002cf6
c0d0869c:	00002d20 	.word	0x00002d20
c0d086a0:	00002d40 	.word	0x00002d40

c0d086a4 <USBD_GetCfgDesc_impl>:
{
c0d086a4:	2160      	movs	r1, #96	; 0x60
  *length = sizeof (USBD_CfgDesc);
c0d086a6:	8001      	strh	r1, [r0, #0]
  return (uint8_t*)USBD_CfgDesc;
c0d086a8:	4801      	ldr	r0, [pc, #4]	; (c0d086b0 <USBD_GetCfgDesc_impl+0xc>)
c0d086aa:	4478      	add	r0, pc
c0d086ac:	4770      	bx	lr
c0d086ae:	46c0      	nop			; (mov r8, r8)
c0d086b0:	00002d92 	.word	0x00002d92

c0d086b4 <USBD_GetDeviceQualifierDesc_impl>:
{
c0d086b4:	210a      	movs	r1, #10
  *length = sizeof (USBD_DeviceQualifierDesc);
c0d086b6:	8001      	strh	r1, [r0, #0]
  return (uint8_t*)USBD_DeviceQualifierDesc;
c0d086b8:	4801      	ldr	r0, [pc, #4]	; (c0d086c0 <USBD_GetDeviceQualifierDesc_impl+0xc>)
c0d086ba:	4478      	add	r0, pc
c0d086bc:	4770      	bx	lr
c0d086be:	46c0      	nop			; (mov r8, r8)
c0d086c0:	00002de2 	.word	0x00002de2

c0d086c4 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
c0d086c4:	b5b0      	push	{r4, r5, r7, lr}
c0d086c6:	460c      	mov	r4, r1
c0d086c8:	21d0      	movs	r1, #208	; 0xd0
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
  // store the continuation data if needed
  pdev->pData = pbuf;
c0d086ca:	5044      	str	r4, [r0, r1]
c0d086cc:	2194      	movs	r1, #148	; 0x94
c0d086ce:	2302      	movs	r3, #2
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
c0d086d0:	5043      	str	r3, [r0, r1]
  pdev->ep_in[0].total_length = len;
c0d086d2:	6182      	str	r2, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
c0d086d4:	61c2      	str	r2, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, MIN(len, pdev->ep_in[0].maxpacket));  
c0d086d6:	6a01      	ldr	r1, [r0, #32]
c0d086d8:	4291      	cmp	r1, r2
c0d086da:	d800      	bhi.n	c0d086de <USBD_CtlSendData+0x1a>
c0d086dc:	460a      	mov	r2, r1
c0d086de:	b293      	uxth	r3, r2
c0d086e0:	2500      	movs	r5, #0
c0d086e2:	4629      	mov	r1, r5
c0d086e4:	4622      	mov	r2, r4
c0d086e6:	f7ff f945 	bl	c0d07974 <USBD_LL_Transmit>
  
  return USBD_OK;
c0d086ea:	4628      	mov	r0, r5
c0d086ec:	bdb0      	pop	{r4, r5, r7, pc}

c0d086ee <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
c0d086ee:	b5b0      	push	{r4, r5, r7, lr}
c0d086f0:	460c      	mov	r4, r1
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, MIN(len, pdev->ep_in[0].maxpacket));   
c0d086f2:	6a01      	ldr	r1, [r0, #32]
c0d086f4:	4291      	cmp	r1, r2
c0d086f6:	d800      	bhi.n	c0d086fa <USBD_CtlContinueSendData+0xc>
c0d086f8:	460a      	mov	r2, r1
c0d086fa:	b293      	uxth	r3, r2
c0d086fc:	2500      	movs	r5, #0
c0d086fe:	4629      	mov	r1, r5
c0d08700:	4622      	mov	r2, r4
c0d08702:	f7ff f937 	bl	c0d07974 <USBD_LL_Transmit>
  return USBD_OK;
c0d08706:	4628      	mov	r0, r5
c0d08708:	bdb0      	pop	{r4, r5, r7, pc}

c0d0870a <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
c0d0870a:	b510      	push	{r4, lr}
c0d0870c:	2400      	movs	r4, #0
  UNUSED(pbuf);
  USBD_LL_PrepareReceive (pdev,
c0d0870e:	4621      	mov	r1, r4
c0d08710:	f7ff f949 	bl	c0d079a6 <USBD_LL_PrepareReceive>
                          0,                                            
                          len);
  return USBD_OK;
c0d08714:	4620      	mov	r0, r4
c0d08716:	bd10      	pop	{r4, pc}

c0d08718 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
c0d08718:	b510      	push	{r4, lr}
c0d0871a:	2194      	movs	r1, #148	; 0x94
c0d0871c:	2204      	movs	r2, #4

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
c0d0871e:	5042      	str	r2, [r0, r1]
c0d08720:	2400      	movs	r4, #0
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
c0d08722:	4621      	mov	r1, r4
c0d08724:	4622      	mov	r2, r4
c0d08726:	4623      	mov	r3, r4
c0d08728:	f7ff f924 	bl	c0d07974 <USBD_LL_Transmit>
  
  return USBD_OK;
c0d0872c:	4620      	mov	r0, r4
c0d0872e:	bd10      	pop	{r4, pc}

c0d08730 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
c0d08730:	b510      	push	{r4, lr}
c0d08732:	2194      	movs	r1, #148	; 0x94
c0d08734:	2205      	movs	r2, #5
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
c0d08736:	5042      	str	r2, [r0, r1]
c0d08738:	2400      	movs	r4, #0
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
c0d0873a:	4621      	mov	r1, r4
c0d0873c:	4622      	mov	r2, r4
c0d0873e:	f7ff f932 	bl	c0d079a6 <USBD_LL_PrepareReceive>
                    0,
                    0);  

  return USBD_OK;
c0d08742:	4620      	mov	r0, r4
c0d08744:	bd10      	pop	{r4, pc}
	...

c0d08748 <array_hexstr>:
#include "tokens.h"

static const unsigned char hex_digits[] =
    {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

void array_hexstr(char *strbuf, const void *bin, unsigned int len) {
c0d08748:	b5b0      	push	{r4, r5, r7, lr}
    while (len--) {
c0d0874a:	2a00      	cmp	r2, #0
c0d0874c:	d00e      	beq.n	c0d0876c <array_hexstr+0x24>
c0d0874e:	4b09      	ldr	r3, [pc, #36]	; (c0d08774 <array_hexstr+0x2c>)
c0d08750:	447b      	add	r3, pc
        *strbuf++ = hex_digits[((*((char *) bin)) >> 4) & 0xF];
c0d08752:	780c      	ldrb	r4, [r1, #0]
c0d08754:	0924      	lsrs	r4, r4, #4
c0d08756:	5d1c      	ldrb	r4, [r3, r4]
c0d08758:	7004      	strb	r4, [r0, #0]
        *strbuf++ = hex_digits[(*((char *) bin)) & 0xF];
c0d0875a:	780c      	ldrb	r4, [r1, #0]
c0d0875c:	250f      	movs	r5, #15
c0d0875e:	4025      	ands	r5, r4
c0d08760:	5d5c      	ldrb	r4, [r3, r5]
c0d08762:	7044      	strb	r4, [r0, #1]
c0d08764:	1c80      	adds	r0, r0, #2
        bin = (const void *) ((unsigned int) bin + 1);
c0d08766:	1c49      	adds	r1, r1, #1
    while (len--) {
c0d08768:	1e52      	subs	r2, r2, #1
c0d0876a:	d1f2      	bne.n	c0d08752 <array_hexstr+0xa>
c0d0876c:	2100      	movs	r1, #0
    }
    *strbuf = 0;  // EOS
c0d0876e:	7001      	strb	r1, [r0, #0]
}
c0d08770:	bdb0      	pop	{r4, r5, r7, pc}
c0d08772:	46c0      	nop			; (mov r8, r8)
c0d08774:	00001ac0 	.word	0x00001ac0

c0d08778 <convertUint256BE>:

void convertUint256BE(uint8_t *data, uint32_t length, uint256_t *target) {
c0d08778:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0877a:	b089      	sub	sp, #36	; 0x24
c0d0877c:	4614      	mov	r4, r2
c0d0877e:	460d      	mov	r5, r1
c0d08780:	4606      	mov	r6, r0
c0d08782:	af01      	add	r7, sp, #4
c0d08784:	2120      	movs	r1, #32
    uint8_t tmp[32];
    memset(tmp, 0, 32);
c0d08786:	4638      	mov	r0, r7
c0d08788:	f000 ff2e 	bl	c0d095e8 <__aeabi_memclr>
    memmove(tmp + 32 - length, data, length);
c0d0878c:	1b78      	subs	r0, r7, r5
c0d0878e:	3020      	adds	r0, #32
c0d08790:	4631      	mov	r1, r6
c0d08792:	462a      	mov	r2, r5
c0d08794:	f000 ff2e 	bl	c0d095f4 <__aeabi_memcpy>
    readu256BE(tmp, target);
c0d08798:	4638      	mov	r0, r7
c0d0879a:	4621      	mov	r1, r4
c0d0879c:	f7fe faca 	bl	c0d06d34 <readu256BE>
}
c0d087a0:	b009      	add	sp, #36	; 0x24
c0d087a2:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d087a4 <getV>:
        }
    }
    return -1;
}

uint32_t getV(txContent_t *txContent) {
c0d087a4:	b580      	push	{r7, lr}
c0d087a6:	217c      	movs	r1, #124	; 0x7c
    uint32_t v = 0;
    if (txContent->vLength == 1) {
c0d087a8:	5c41      	ldrb	r1, [r0, r1]
c0d087aa:	2901      	cmp	r1, #1
c0d087ac:	dd0c      	ble.n	c0d087c8 <getV+0x24>
c0d087ae:	2902      	cmp	r1, #2
c0d087b0:	d00e      	beq.n	c0d087d0 <getV+0x2c>
c0d087b2:	2903      	cmp	r1, #3
c0d087b4:	d113      	bne.n	c0d087de <getV+0x3a>
c0d087b6:	2178      	movs	r1, #120	; 0x78
        v = txContent->v[0];
    } else if (txContent->vLength == 2) {
        v = (txContent->v[0] << 8) | txContent->v[1];
    } else if (txContent->vLength == 3) {
        v = (txContent->v[0] << 16) | (txContent->v[1] << 8) | txContent->v[2];
c0d087b8:	5c41      	ldrb	r1, [r0, r1]
c0d087ba:	0409      	lsls	r1, r1, #16
c0d087bc:	2279      	movs	r2, #121	; 0x79
c0d087be:	5c82      	ldrb	r2, [r0, r2]
c0d087c0:	0212      	lsls	r2, r2, #8
c0d087c2:	1851      	adds	r1, r2, r1
c0d087c4:	227a      	movs	r2, #122	; 0x7a
c0d087c6:	e018      	b.n	c0d087fa <getV+0x56>
    if (txContent->vLength == 1) {
c0d087c8:	2900      	cmp	r1, #0
c0d087ca:	d119      	bne.n	c0d08800 <getV+0x5c>
c0d087cc:	2000      	movs	r0, #0
            txContent->v[3];
    } else if (txContent->vLength != 0) {
        PRINTF("Unexpected v format\n");
        THROW(EXCEPTION);
    }
    return v;
c0d087ce:	bd80      	pop	{r7, pc}
c0d087d0:	2179      	movs	r1, #121	; 0x79
        v = (txContent->v[0] << 8) | txContent->v[1];
c0d087d2:	5c41      	ldrb	r1, [r0, r1]
c0d087d4:	2278      	movs	r2, #120	; 0x78
c0d087d6:	5c80      	ldrb	r0, [r0, r2]
c0d087d8:	0200      	lsls	r0, r0, #8
c0d087da:	1840      	adds	r0, r0, r1
    return v;
c0d087dc:	bd80      	pop	{r7, pc}
    if (txContent->vLength == 1) {
c0d087de:	2904      	cmp	r1, #4
c0d087e0:	d113      	bne.n	c0d0880a <getV+0x66>
c0d087e2:	2178      	movs	r1, #120	; 0x78
        v = (txContent->v[0] << 24) | (txContent->v[1] << 16) | (txContent->v[2] << 8) |
c0d087e4:	5c41      	ldrb	r1, [r0, r1]
c0d087e6:	0609      	lsls	r1, r1, #24
c0d087e8:	2279      	movs	r2, #121	; 0x79
c0d087ea:	5c82      	ldrb	r2, [r0, r2]
c0d087ec:	0412      	lsls	r2, r2, #16
c0d087ee:	1851      	adds	r1, r2, r1
c0d087f0:	227a      	movs	r2, #122	; 0x7a
c0d087f2:	5c82      	ldrb	r2, [r0, r2]
c0d087f4:	0212      	lsls	r2, r2, #8
c0d087f6:	1889      	adds	r1, r1, r2
c0d087f8:	227b      	movs	r2, #123	; 0x7b
c0d087fa:	5c80      	ldrb	r0, [r0, r2]
c0d087fc:	1808      	adds	r0, r1, r0
    return v;
c0d087fe:	bd80      	pop	{r7, pc}
    if (txContent->vLength == 1) {
c0d08800:	2901      	cmp	r1, #1
c0d08802:	d102      	bne.n	c0d0880a <getV+0x66>
c0d08804:	2178      	movs	r1, #120	; 0x78
        v = txContent->v[0];
c0d08806:	5c40      	ldrb	r0, [r0, r1]
    return v;
c0d08808:	bd80      	pop	{r7, pc}
c0d0880a:	2001      	movs	r0, #1
        THROW(EXCEPTION);
c0d0880c:	f7fb f8f9 	bl	c0d03a02 <os_longjmp>

c0d08810 <amountToString>:
void amountToString(uint8_t *amount,
                    uint8_t amount_size,
                    uint8_t decimals,
                    char *ticker,
                    char *out_buffer,
                    uint8_t out_buffer_size) {
c0d08810:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08812:	b0a7      	sub	sp, #156	; 0x9c
c0d08814:	461d      	mov	r5, r3
c0d08816:	9204      	str	r2, [sp, #16]
c0d08818:	460e      	mov	r6, r1
c0d0881a:	4607      	mov	r7, r0
c0d0881c:	ac05      	add	r4, sp, #20
c0d0881e:	2120      	movs	r1, #32
    memset(tmp, 0, 32);
c0d08820:	4620      	mov	r0, r4
c0d08822:	f000 fee1 	bl	c0d095e8 <__aeabi_memclr>
    memmove(tmp + 32 - length, data, length);
c0d08826:	1ba0      	subs	r0, r4, r6
c0d08828:	3020      	adds	r0, #32
c0d0882a:	4639      	mov	r1, r7
c0d0882c:	4632      	mov	r2, r6
c0d0882e:	f000 fee1 	bl	c0d095f4 <__aeabi_memcpy>
c0d08832:	af1e      	add	r7, sp, #120	; 0x78
    readu256BE(tmp, target);
c0d08834:	4620      	mov	r0, r4
c0d08836:	4639      	mov	r1, r7
c0d08838:	f7fe fa7c 	bl	c0d06d34 <readu256BE>
c0d0883c:	210a      	movs	r1, #10
c0d0883e:	ae05      	add	r6, sp, #20
c0d08840:	2464      	movs	r4, #100	; 0x64
    uint256_t amount_256;
    char tmp_buffer[100];
    convertUint256BE(amount, amount_size, &amount_256);
    tostring256(&amount_256, 10, tmp_buffer, 100);
c0d08842:	4638      	mov	r0, r7
c0d08844:	4632      	mov	r2, r6
c0d08846:	4623      	mov	r3, r4
c0d08848:	f7fe ff2c 	bl	c0d076a4 <tostring256>

    uint8_t amount_len = strnlen(tmp_buffer, sizeof(tmp_buffer));
c0d0884c:	4630      	mov	r0, r6
c0d0884e:	4621      	mov	r1, r4
c0d08850:	f001 f92e 	bl	c0d09ab0 <strnlen>
c0d08854:	9002      	str	r0, [sp, #8]
c0d08856:	210c      	movs	r1, #12
c0d08858:	9503      	str	r5, [sp, #12]
    uint8_t ticker_len = strnlen(ticker, MAX_TICKER_LEN);
c0d0885a:	4628      	mov	r0, r5
c0d0885c:	f001 f928 	bl	c0d09ab0 <strnlen>

    memcpy(out_buffer, ticker, MIN(out_buffer_size, ticker_len));
c0d08860:	b2c7      	uxtb	r7, r0
c0d08862:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
c0d08864:	42af      	cmp	r7, r5
c0d08866:	462a      	mov	r2, r5
c0d08868:	d800      	bhi.n	c0d0886c <amountToString+0x5c>
c0d0886a:	463a      	mov	r2, r7
c0d0886c:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
c0d0886e:	4620      	mov	r0, r4
c0d08870:	9903      	ldr	r1, [sp, #12]
c0d08872:	f000 febf 	bl	c0d095f4 <__aeabi_memcpy>

    adjustDecimals(tmp_buffer,
c0d08876:	4668      	mov	r0, sp
c0d08878:	9904      	ldr	r1, [sp, #16]
c0d0887a:	6001      	str	r1, [r0, #0]
                   amount_len,
                   out_buffer + ticker_len,
c0d0887c:	19e2      	adds	r2, r4, r7
                   out_buffer_size - ticker_len - 1,
c0d0887e:	43f8      	mvns	r0, r7
c0d08880:	1943      	adds	r3, r0, r5
                   amount_len,
c0d08882:	9802      	ldr	r0, [sp, #8]
c0d08884:	b2c1      	uxtb	r1, r0
    adjustDecimals(tmp_buffer,
c0d08886:	4630      	mov	r0, r6
c0d08888:	f7f9 fbd8 	bl	c0d0203c <adjustDecimals>
c0d0888c:	1960      	adds	r0, r4, r5
c0d0888e:	2100      	movs	r1, #0
c0d08890:	43ca      	mvns	r2, r1
                   decimals);
    out_buffer[out_buffer_size - 1] = '\0';
c0d08892:	5481      	strb	r1, [r0, r2]
}
c0d08894:	b027      	add	sp, #156	; 0x9c
c0d08896:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d08898 <parse_swap_config>:

bool parse_swap_config(uint8_t *config, uint8_t config_len, char *ticker, uint8_t *decimals) {
c0d08898:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0889a:	b081      	sub	sp, #4
c0d0889c:	4605      	mov	r5, r0
c0d0889e:	2000      	movs	r0, #0
    uint8_t ticker_len, offset = 0;
    if (config_len == 0) {
c0d088a0:	2900      	cmp	r1, #0
c0d088a2:	d01b      	beq.n	c0d088dc <parse_swap_config+0x44>
c0d088a4:	460e      	mov	r6, r1
        return false;
    }
    ticker_len = config[offset++];
c0d088a6:	782c      	ldrb	r4, [r5, #0]
    if (ticker_len == 0 || ticker_len > MAX_TICKER_LEN - 2 || config_len - offset < ticker_len) {
c0d088a8:	428c      	cmp	r4, r1
c0d088aa:	d217      	bcs.n	c0d088dc <parse_swap_config+0x44>
c0d088ac:	1e61      	subs	r1, r4, #1
c0d088ae:	b2c9      	uxtb	r1, r1
c0d088b0:	2909      	cmp	r1, #9
c0d088b2:	d813      	bhi.n	c0d088dc <parse_swap_config+0x44>
c0d088b4:	4617      	mov	r7, r2
        return false;
    }
    memcpy(ticker, config + offset, ticker_len);
c0d088b6:	1c69      	adds	r1, r5, #1
c0d088b8:	4610      	mov	r0, r2
c0d088ba:	4622      	mov	r2, r4
c0d088bc:	9300      	str	r3, [sp, #0]
c0d088be:	f000 fe99 	bl	c0d095f4 <__aeabi_memcpy>
c0d088c2:	9a00      	ldr	r2, [sp, #0]
c0d088c4:	2020      	movs	r0, #32
    offset += ticker_len;
    ticker[ticker_len] = ' ';
c0d088c6:	5538      	strb	r0, [r7, r4]
    memcpy(ticker, config + offset, ticker_len);
c0d088c8:	1939      	adds	r1, r7, r4
c0d088ca:	2000      	movs	r0, #0
    ticker[ticker_len + 1] = '\0';
c0d088cc:	7048      	strb	r0, [r1, #1]

    if (config_len - offset < 1) {
c0d088ce:	1c61      	adds	r1, r4, #1
c0d088d0:	b2c9      	uxtb	r1, r1
c0d088d2:	42b1      	cmp	r1, r6
c0d088d4:	d202      	bcs.n	c0d088dc <parse_swap_config+0x44>
        return false;
    }
    *decimals = config[offset];
c0d088d6:	5c68      	ldrb	r0, [r5, r1]
c0d088d8:	7010      	strb	r0, [r2, #0]
c0d088da:	2001      	movs	r0, #1
    return true;
}
c0d088dc:	b001      	add	sp, #4
c0d088de:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d088e0 <ux_flow_is_first>:
	}
	return 1;
}

// to hide the left tick or not
unsigned int ux_flow_is_first(void) {
c0d088e0:	b5b0      	push	{r4, r5, r7, lr}
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d088e2:	4912      	ldr	r1, [pc, #72]	; (c0d0892c <ux_flow_is_first+0x4c>)
c0d088e4:	780a      	ldrb	r2, [r1, #0]
c0d088e6:	2001      	movs	r0, #1
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d088e8:	2a01      	cmp	r2, #1
c0d088ea:	d81d      	bhi.n	c0d08928 <ux_flow_is_first+0x48>
c0d088ec:	1e52      	subs	r2, r2, #1
c0d088ee:	230c      	movs	r3, #12
c0d088f0:	4353      	muls	r3, r2
c0d088f2:	18cb      	adds	r3, r1, r3
c0d088f4:	8b1a      	ldrh	r2, [r3, #24]
	// no previous ?
	if (!ux_flow_check_valid()
		|| G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d088f6:	2a00      	cmp	r2, #0
c0d088f8:	d016      	beq.n	c0d08928 <ux_flow_is_first+0x48>
c0d088fa:	6919      	ldr	r1, [r3, #16]
		|| (G_ux.flow_stack[G_ux.stack_count-1].index == 0 
c0d088fc:	2900      	cmp	r1, #0
c0d088fe:	d013      	beq.n	c0d08928 <ux_flow_is_first+0x48>
c0d08900:	8a9b      	ldrh	r3, [r3, #20]
			  && G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].length-1] != FLOW_LOOP)) {
c0d08902:	2b00      	cmp	r3, #0
c0d08904:	d106      	bne.n	c0d08914 <ux_flow_is_first+0x34>
c0d08906:	0094      	lsls	r4, r2, #2
c0d08908:	190c      	adds	r4, r1, r4
c0d0890a:	2503      	movs	r5, #3
c0d0890c:	43ed      	mvns	r5, r5
c0d0890e:	5964      	ldr	r4, [r4, r5]
	if (!ux_flow_check_valid()
c0d08910:	1ce4      	adds	r4, r4, #3
c0d08912:	d109      	bne.n	c0d08928 <ux_flow_is_first+0x48>
		return 1;
	}

	// previous is a flow barrier ?
	if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
		&& G_ux.flow_stack[G_ux.stack_count-1].index < G_ux.flow_stack[G_ux.stack_count-1].length
c0d08914:	4293      	cmp	r3, r2
c0d08916:	d206      	bcs.n	c0d08926 <ux_flow_is_first+0x46>
		&& G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index-1] == FLOW_BARRIER) {
c0d08918:	009a      	lsls	r2, r3, #2
c0d0891a:	1889      	adds	r1, r1, r2
c0d0891c:	2203      	movs	r2, #3
c0d0891e:	43d2      	mvns	r2, r2
c0d08920:	5889      	ldr	r1, [r1, r2]
	if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d08922:	1c89      	adds	r1, r1, #2
c0d08924:	d000      	beq.n	c0d08928 <ux_flow_is_first+0x48>
c0d08926:	2000      	movs	r0, #0
		return 1;
	}

	// not the first, for sure
	return 0;
}
c0d08928:	bdb0      	pop	{r4, r5, r7, pc}
c0d0892a:	46c0      	nop			; (mov r8, r8)
c0d0892c:	2000195c 	.word	0x2000195c

c0d08930 <ux_flow_is_last>:

unsigned int ux_flow_is_last(void){
c0d08930:	b510      	push	{r4, lr}
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d08932:	490e      	ldr	r1, [pc, #56]	; (c0d0896c <ux_flow_is_last+0x3c>)
c0d08934:	780a      	ldrb	r2, [r1, #0]
c0d08936:	2001      	movs	r0, #1
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d08938:	2a01      	cmp	r2, #1
c0d0893a:	d816      	bhi.n	c0d0896a <ux_flow_is_last+0x3a>
c0d0893c:	1e52      	subs	r2, r2, #1
c0d0893e:	230c      	movs	r3, #12
c0d08940:	4353      	muls	r3, r2
c0d08942:	18cb      	adds	r3, r1, r3
c0d08944:	8b1a      	ldrh	r2, [r3, #24]
	// last ?
	if (!ux_flow_check_valid()
		|| G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d08946:	2a00      	cmp	r2, #0
c0d08948:	d00f      	beq.n	c0d0896a <ux_flow_is_last+0x3a>
c0d0894a:	6919      	ldr	r1, [r3, #16]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0
c0d0894c:	2900      	cmp	r1, #0
c0d0894e:	d00c      	beq.n	c0d0896a <ux_flow_is_last+0x3a>
		|| G_ux.flow_stack[G_ux.stack_count-1].index >= G_ux.flow_stack[G_ux.stack_count-1].length -1) {
c0d08950:	8a9b      	ldrh	r3, [r3, #20]
c0d08952:	1e54      	subs	r4, r2, #1
	if (!ux_flow_check_valid()
c0d08954:	429c      	cmp	r4, r3
c0d08956:	dd08      	ble.n	c0d0896a <ux_flow_is_last+0x3a>
		return 1;
	}

	// followed by a flow barrier ?
	if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
		&& G_ux.flow_stack[G_ux.stack_count-1].index < G_ux.flow_stack[G_ux.stack_count-1].length - 2
c0d08958:	1e92      	subs	r2, r2, #2
c0d0895a:	429a      	cmp	r2, r3
c0d0895c:	dd04      	ble.n	c0d08968 <ux_flow_is_last+0x38>
		&& G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d0895e:	009a      	lsls	r2, r3, #2
c0d08960:	1889      	adds	r1, r1, r2
c0d08962:	6849      	ldr	r1, [r1, #4]
	if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d08964:	1c89      	adds	r1, r1, #2
c0d08966:	d000      	beq.n	c0d0896a <ux_flow_is_last+0x3a>
c0d08968:	2000      	movs	r0, #0
		return 1;
	}

	// is not last
	return 0;
}
c0d0896a:	bd10      	pop	{r4, pc}
c0d0896c:	2000195c 	.word	0x2000195c

c0d08970 <ux_flow_direction>:

ux_flow_direction_t ux_flow_direction(void) {
	if (G_ux.stack_count) {
c0d08970:	4809      	ldr	r0, [pc, #36]	; (c0d08998 <ux_flow_direction+0x28>)
c0d08972:	7801      	ldrb	r1, [r0, #0]
c0d08974:	2900      	cmp	r1, #0
c0d08976:	d00c      	beq.n	c0d08992 <ux_flow_direction+0x22>
c0d08978:	220c      	movs	r2, #12
		if (G_ux.flow_stack[G_ux.stack_count-1].index > G_ux.flow_stack[G_ux.stack_count-1].prev_index) {
c0d0897a:	434a      	muls	r2, r1
c0d0897c:	1881      	adds	r1, r0, r2
c0d0897e:	8948      	ldrh	r0, [r1, #10]
c0d08980:	8909      	ldrh	r1, [r1, #8]
c0d08982:	4281      	cmp	r1, r0
c0d08984:	d901      	bls.n	c0d0898a <ux_flow_direction+0x1a>
c0d08986:	2001      	movs	r0, #1
c0d08988:	e004      	b.n	c0d08994 <ux_flow_direction+0x24>
		return FLOW_DIRECTION_FORWARD;
		}
		else if (G_ux.flow_stack[G_ux.stack_count-1].index < G_ux.flow_stack[G_ux.stack_count-1].prev_index) {
c0d0898a:	4281      	cmp	r1, r0
c0d0898c:	d201      	bcs.n	c0d08992 <ux_flow_direction+0x22>
c0d0898e:	20ff      	movs	r0, #255	; 0xff
c0d08990:	e000      	b.n	c0d08994 <ux_flow_direction+0x24>
c0d08992:	2000      	movs	r0, #0
			return FLOW_DIRECTION_BACKWARD;
		}
	}
  return FLOW_DIRECTION_START;
}
c0d08994:	b240      	sxtb	r0, r0
c0d08996:	4770      	bx	lr
c0d08998:	2000195c 	.word	0x2000195c

c0d0899c <ux_flow_next_internal>:
			           STEPSPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->validate_flow), 
			           (const ux_flow_step_t*) PIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->params));
	}
}

static void ux_flow_next_internal(unsigned int display_step) {
c0d0899c:	b570      	push	{r4, r5, r6, lr}
c0d0899e:	4601      	mov	r1, r0
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d089a0:	4a15      	ldr	r2, [pc, #84]	; (c0d089f8 <ux_flow_next_internal+0x5c>)
c0d089a2:	7810      	ldrb	r0, [r2, #0]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d089a4:	2801      	cmp	r0, #1
c0d089a6:	d826      	bhi.n	c0d089f6 <ux_flow_next_internal+0x5a>
c0d089a8:	1e40      	subs	r0, r0, #1
c0d089aa:	230c      	movs	r3, #12
c0d089ac:	4343      	muls	r3, r0
c0d089ae:	18d2      	adds	r2, r2, r3
c0d089b0:	8b16      	ldrh	r6, [r2, #24]
	// last reached already (need validation, not next)
	if (!ux_flow_check_valid()
		|| G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d089b2:	2e00      	cmp	r6, #0
c0d089b4:	d01f      	beq.n	c0d089f6 <ux_flow_next_internal+0x5a>
c0d089b6:	6914      	ldr	r4, [r2, #16]
		|| G_ux.flow_stack[G_ux.stack_count-1].length <= 1
c0d089b8:	2c00      	cmp	r4, #0
c0d089ba:	d01c      	beq.n	c0d089f6 <ux_flow_next_internal+0x5a>
		|| G_ux.flow_stack[G_ux.stack_count-1].index >= G_ux.flow_stack[G_ux.stack_count-1].length -1) {
c0d089bc:	2e02      	cmp	r6, #2
c0d089be:	d31a      	bcc.n	c0d089f6 <ux_flow_next_internal+0x5a>
c0d089c0:	8a93      	ldrh	r3, [r2, #20]
c0d089c2:	1e75      	subs	r5, r6, #1
	if (!ux_flow_check_valid()
c0d089c4:	429d      	cmp	r5, r3
c0d089c6:	dd16      	ble.n	c0d089f6 <ux_flow_next_internal+0x5a>
c0d089c8:	4615      	mov	r5, r2
c0d089ca:	3514      	adds	r5, #20
		return;
	}

	// followed by a flow barrier ? => need validation instead of next
	if (G_ux.flow_stack[G_ux.stack_count-1].index <= G_ux.flow_stack[G_ux.stack_count-1].length - 2) {
c0d089cc:	1eb6      	subs	r6, r6, #2
c0d089ce:	429e      	cmp	r6, r3
c0d089d0:	db0a      	blt.n	c0d089e8 <ux_flow_next_internal+0x4c>
		if (G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d089d2:	009e      	lsls	r6, r3, #2
c0d089d4:	19a4      	adds	r4, r4, r6
c0d089d6:	6864      	ldr	r4, [r4, #4]
c0d089d8:	1ca6      	adds	r6, r4, #2
c0d089da:	d00c      	beq.n	c0d089f6 <ux_flow_next_internal+0x5a>
c0d089dc:	1ce4      	adds	r4, r4, #3
c0d089de:	d103      	bne.n	c0d089e8 <ux_flow_next_internal+0x4c>
c0d089e0:	2100      	movs	r1, #0
		}

		// followed by a flow barrier ? => need validation instead of next
		if (G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_LOOP) {
			// display first step, fake direction as forward
			G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index = 0;
c0d089e2:	8029      	strh	r1, [r5, #0]
c0d089e4:	82d1      	strh	r1, [r2, #22]
c0d089e6:	e004      	b.n	c0d089f2 <ux_flow_next_internal+0x56>
			return;
		}
	}

	// advance flow pointer and display it (skip META STEPS)
	G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index;
c0d089e8:	82d3      	strh	r3, [r2, #22]
	G_ux.flow_stack[G_ux.stack_count-1].index++;
c0d089ea:	1c5a      	adds	r2, r3, #1
c0d089ec:	802a      	strh	r2, [r5, #0]
	if (display_step) {
c0d089ee:	2900      	cmp	r1, #0
c0d089f0:	d001      	beq.n	c0d089f6 <ux_flow_next_internal+0x5a>
c0d089f2:	f000 f83b 	bl	c0d08a6c <ux_flow_engine_init_step>
		ux_flow_engine_init_step(G_ux.stack_count-1);
	}
}
c0d089f6:	bd70      	pop	{r4, r5, r6, pc}
c0d089f8:	2000195c 	.word	0x2000195c

c0d089fc <ux_flow_next>:

void ux_flow_next_no_display(void) {
	ux_flow_next_internal(0);
}

void ux_flow_next(void) {
c0d089fc:	b580      	push	{r7, lr}
c0d089fe:	2001      	movs	r0, #1
	ux_flow_next_internal(1);
c0d08a00:	f7ff ffcc 	bl	c0d0899c <ux_flow_next_internal>
}
c0d08a04:	bd80      	pop	{r7, pc}
	...

c0d08a08 <ux_flow_prev>:

void ux_flow_prev(void) {
c0d08a08:	b5b0      	push	{r4, r5, r7, lr}
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d08a0a:	4917      	ldr	r1, [pc, #92]	; (c0d08a68 <ux_flow_prev+0x60>)
c0d08a0c:	7808      	ldrb	r0, [r1, #0]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d08a0e:	2801      	cmp	r0, #1
c0d08a10:	d828      	bhi.n	c0d08a64 <ux_flow_prev+0x5c>
c0d08a12:	1e40      	subs	r0, r0, #1
c0d08a14:	220c      	movs	r2, #12
c0d08a16:	4342      	muls	r2, r0
c0d08a18:	1889      	adds	r1, r1, r2
c0d08a1a:	8b0a      	ldrh	r2, [r1, #24]
	// first reached already
	if (!ux_flow_check_valid()
		|| G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d08a1c:	2a00      	cmp	r2, #0
c0d08a1e:	d021      	beq.n	c0d08a64 <ux_flow_prev+0x5c>
c0d08a20:	690c      	ldr	r4, [r1, #16]
		|| G_ux.flow_stack[G_ux.stack_count-1].length <= 1
c0d08a22:	2c00      	cmp	r4, #0
c0d08a24:	d01e      	beq.n	c0d08a64 <ux_flow_prev+0x5c>
		|| (G_ux.flow_stack[G_ux.stack_count-1].index == 0 
c0d08a26:	2a02      	cmp	r2, #2
c0d08a28:	d31c      	bcc.n	c0d08a64 <ux_flow_prev+0x5c>
c0d08a2a:	8a8d      	ldrh	r5, [r1, #20]
c0d08a2c:	460b      	mov	r3, r1
c0d08a2e:	3314      	adds	r3, #20
			  && G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].length-1] != FLOW_LOOP)) {
c0d08a30:	2d00      	cmp	r5, #0
c0d08a32:	d00a      	beq.n	c0d08a4a <ux_flow_prev+0x42>
		ux_flow_engine_init_step(G_ux.stack_count-1);
		return;
	}

	// previous item is a flow barrier ?
	if (G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index-1] == FLOW_BARRIER) {
c0d08a34:	00aa      	lsls	r2, r5, #2
c0d08a36:	18a2      	adds	r2, r4, r2
c0d08a38:	2403      	movs	r4, #3
c0d08a3a:	43e4      	mvns	r4, r4
c0d08a3c:	5912      	ldr	r2, [r2, r4]
c0d08a3e:	1c92      	adds	r2, r2, #2
c0d08a40:	d010      	beq.n	c0d08a64 <ux_flow_prev+0x5c>
		return;
	}

	// advance flow pointer and display it (skip META STEPS)
	G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index;
c0d08a42:	82cd      	strh	r5, [r1, #22]
	G_ux.flow_stack[G_ux.stack_count-1].index--;
c0d08a44:	1e69      	subs	r1, r5, #1
c0d08a46:	8019      	strh	r1, [r3, #0]
c0d08a48:	e00a      	b.n	c0d08a60 <ux_flow_prev+0x58>
			  && G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].length-1] != FLOW_LOOP)) {
c0d08a4a:	0095      	lsls	r5, r2, #2
c0d08a4c:	1964      	adds	r4, r4, r5
c0d08a4e:	2503      	movs	r5, #3
c0d08a50:	43ed      	mvns	r5, r5
c0d08a52:	5964      	ldr	r4, [r4, r5]
	if (!ux_flow_check_valid()
c0d08a54:	1ce4      	adds	r4, r4, #3
c0d08a56:	d105      	bne.n	c0d08a64 <ux_flow_prev+0x5c>
		G_ux.flow_stack[G_ux.stack_count-1].index = G_ux.flow_stack[G_ux.stack_count-1].length-2;
c0d08a58:	1e94      	subs	r4, r2, #2
c0d08a5a:	801c      	strh	r4, [r3, #0]
		G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index+1;
c0d08a5c:	1e52      	subs	r2, r2, #1
c0d08a5e:	82ca      	strh	r2, [r1, #22]
c0d08a60:	f000 f804 	bl	c0d08a6c <ux_flow_engine_init_step>

	ux_flow_engine_init_step(G_ux.stack_count-1);
}
c0d08a64:	bdb0      	pop	{r4, r5, r7, pc}
c0d08a66:	46c0      	nop			; (mov r8, r8)
c0d08a68:	2000195c 	.word	0x2000195c

c0d08a6c <ux_flow_engine_init_step>:
static void ux_flow_engine_init_step(unsigned int stack_slot) {
c0d08a6c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08a6e:	b081      	sub	sp, #4
c0d08a70:	4604      	mov	r4, r0
c0d08a72:	200c      	movs	r0, #12
	if (G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] == FLOW_END_STEP) {
c0d08a74:	4360      	muls	r0, r4
c0d08a76:	491a      	ldr	r1, [pc, #104]	; (c0d08ae0 <ux_flow_engine_init_step+0x74>)
c0d08a78:	180e      	adds	r6, r1, r0
c0d08a7a:	6930      	ldr	r0, [r6, #16]
c0d08a7c:	8ab1      	ldrh	r1, [r6, #20]
c0d08a7e:	0089      	lsls	r1, r1, #2
c0d08a80:	5840      	ldr	r0, [r0, r1]
c0d08a82:	2103      	movs	r1, #3
c0d08a84:	43c9      	mvns	r1, r1
c0d08a86:	4288      	cmp	r0, r1
c0d08a88:	d827      	bhi.n	c0d08ada <ux_flow_engine_init_step+0x6e>
c0d08a8a:	4637      	mov	r7, r6
c0d08a8c:	3714      	adds	r7, #20
c0d08a8e:	3610      	adds	r6, #16
	if (STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->init) {
c0d08a90:	f7fb ffa0 	bl	c0d049d4 <pic>
c0d08a94:	6831      	ldr	r1, [r6, #0]
c0d08a96:	883a      	ldrh	r2, [r7, #0]
c0d08a98:	0092      	lsls	r2, r2, #2
c0d08a9a:	5889      	ldr	r1, [r1, r2]
c0d08a9c:	6805      	ldr	r5, [r0, #0]
c0d08a9e:	4608      	mov	r0, r1
c0d08aa0:	f7fb ff98 	bl	c0d049d4 <pic>
c0d08aa4:	2d00      	cmp	r5, #0
c0d08aa6:	d006      	beq.n	c0d08ab6 <ux_flow_engine_init_step+0x4a>
		INITPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->init)(stack_slot);
c0d08aa8:	6800      	ldr	r0, [r0, #0]
c0d08aaa:	f7fb ff93 	bl	c0d049d4 <pic>
c0d08aae:	4601      	mov	r1, r0
c0d08ab0:	4620      	mov	r0, r4
c0d08ab2:	4788      	blx	r1
c0d08ab4:	e011      	b.n	c0d08ada <ux_flow_engine_init_step+0x6e>
			           STEPSPIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->validate_flow), 
c0d08ab6:	6880      	ldr	r0, [r0, #8]
c0d08ab8:	f7fb ff8c 	bl	c0d049d4 <pic>
c0d08abc:	4605      	mov	r5, r0
			           (const ux_flow_step_t*) PIC(STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index])->params));
c0d08abe:	6830      	ldr	r0, [r6, #0]
c0d08ac0:	8839      	ldrh	r1, [r7, #0]
c0d08ac2:	0089      	lsls	r1, r1, #2
c0d08ac4:	5840      	ldr	r0, [r0, r1]
c0d08ac6:	f7fb ff85 	bl	c0d049d4 <pic>
c0d08aca:	6840      	ldr	r0, [r0, #4]
c0d08acc:	f7fb ff82 	bl	c0d049d4 <pic>
c0d08ad0:	4602      	mov	r2, r0
		ux_flow_init(stack_slot,
c0d08ad2:	4620      	mov	r0, r4
c0d08ad4:	4629      	mov	r1, r5
c0d08ad6:	f000 f85d 	bl	c0d08b94 <ux_flow_init>
}
c0d08ada:	b001      	add	sp, #4
c0d08adc:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d08ade:	46c0      	nop			; (mov r8, r8)
c0d08ae0:	2000195c 	.word	0x2000195c

c0d08ae4 <ux_flow_validate>:

void ux_flow_validate(void) {
c0d08ae4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08ae6:	b081      	sub	sp, #4
	if (G_ux.stack_count > UX_STACK_SLOT_COUNT
c0d08ae8:	4d29      	ldr	r5, [pc, #164]	; (c0d08b90 <ux_flow_validate+0xac>)
c0d08aea:	7828      	ldrb	r0, [r5, #0]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0) {
c0d08aec:	2801      	cmp	r0, #1
c0d08aee:	d825      	bhi.n	c0d08b3c <ux_flow_validate+0x58>
c0d08af0:	1e40      	subs	r0, r0, #1
c0d08af2:	260c      	movs	r6, #12
c0d08af4:	4370      	muls	r0, r6
c0d08af6:	182a      	adds	r2, r5, r0
c0d08af8:	8b10      	ldrh	r0, [r2, #24]
	// no flow ?
	if (!ux_flow_check_valid()
	  || G_ux.flow_stack[G_ux.stack_count-1].steps == NULL
c0d08afa:	2800      	cmp	r0, #0
c0d08afc:	d01e      	beq.n	c0d08b3c <ux_flow_validate+0x58>
c0d08afe:	6911      	ldr	r1, [r2, #16]
		|| G_ux.flow_stack[G_ux.stack_count-1].length == 0
c0d08b00:	2900      	cmp	r1, #0
c0d08b02:	d01b      	beq.n	c0d08b3c <ux_flow_validate+0x58>
		|| G_ux.flow_stack[G_ux.stack_count-1].index >= G_ux.flow_stack[G_ux.stack_count-1].length) {
c0d08b04:	8a92      	ldrh	r2, [r2, #20]
	if (!ux_flow_check_valid()
c0d08b06:	4282      	cmp	r2, r0
c0d08b08:	d218      	bcs.n	c0d08b3c <ux_flow_validate+0x58>
		return;
	}

	// no validation flow ?
	if (STEPPIC(G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index])->validate_flow != NULL) {
c0d08b0a:	0090      	lsls	r0, r2, #2
c0d08b0c:	5808      	ldr	r0, [r1, r0]
c0d08b0e:	f7fb ff61 	bl	c0d049d4 <pic>
c0d08b12:	6880      	ldr	r0, [r0, #8]
c0d08b14:	7829      	ldrb	r1, [r5, #0]
c0d08b16:	1e4c      	subs	r4, r1, #1
	}
	else {
		// if next is a barrier, then proceed to the item after the barrier
		// if NOT followed by a barrier, then validation is only performed through 
		// a validate_flow specified in the step, else ignored
		if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d08b18:	4366      	muls	r6, r4
	if (STEPPIC(G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index])->validate_flow != NULL) {
c0d08b1a:	2800      	cmp	r0, #0
c0d08b1c:	d010      	beq.n	c0d08b40 <ux_flow_validate+0x5c>
		ux_flow_init(G_ux.stack_count-1, STEPSPIC(STEPPIC(G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index])->validate_flow), NULL);
c0d08b1e:	19a8      	adds	r0, r5, r6
c0d08b20:	6901      	ldr	r1, [r0, #16]
c0d08b22:	8a80      	ldrh	r0, [r0, #20]
c0d08b24:	0080      	lsls	r0, r0, #2
c0d08b26:	5808      	ldr	r0, [r1, r0]
c0d08b28:	f7fb ff54 	bl	c0d049d4 <pic>
c0d08b2c:	6880      	ldr	r0, [r0, #8]
c0d08b2e:	f7fb ff51 	bl	c0d049d4 <pic>
c0d08b32:	4601      	mov	r1, r0
c0d08b34:	2200      	movs	r2, #0
c0d08b36:	4620      	mov	r0, r4
c0d08b38:	f000 f82c 	bl	c0d08b94 <ux_flow_init>
				// execute reached step
				ux_flow_engine_init_step(G_ux.stack_count-1);
			}
		}
	}
}
c0d08b3c:	b001      	add	sp, #4
c0d08b3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d08b40:	19a8      	adds	r0, r5, r6
c0d08b42:	8b02      	ldrh	r2, [r0, #24]
			&& G_ux.flow_stack[G_ux.stack_count-1].index <= G_ux.flow_stack[G_ux.stack_count-1].length - 2) {
c0d08b44:	2a00      	cmp	r2, #0
c0d08b46:	d0f9      	beq.n	c0d08b3c <ux_flow_validate+0x58>
c0d08b48:	8a81      	ldrh	r1, [r0, #20]
c0d08b4a:	1e93      	subs	r3, r2, #2
		if (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d08b4c:	428b      	cmp	r3, r1
c0d08b4e:	dbf5      	blt.n	c0d08b3c <ux_flow_validate+0x58>
c0d08b50:	4602      	mov	r2, r0
c0d08b52:	3214      	adds	r2, #20
			if (G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d08b54:	6905      	ldr	r5, [r0, #16]
c0d08b56:	008e      	lsls	r6, r1, #2
c0d08b58:	19ae      	adds	r6, r5, r6
c0d08b5a:	6876      	ldr	r6, [r6, #4]
c0d08b5c:	1cf7      	adds	r7, r6, #3
c0d08b5e:	d010      	beq.n	c0d08b82 <ux_flow_validate+0x9e>
c0d08b60:	1cb6      	adds	r6, r6, #2
c0d08b62:	d1eb      	bne.n	c0d08b3c <ux_flow_validate+0x58>
c0d08b64:	460e      	mov	r6, r1
					&& G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d08b66:	00b6      	lsls	r6, r6, #2
c0d08b68:	19ae      	adds	r6, r5, r6
c0d08b6a:	6876      	ldr	r6, [r6, #4]
				while (G_ux.flow_stack[G_ux.stack_count-1].length > 0 
c0d08b6c:	1cb6      	adds	r6, r6, #2
c0d08b6e:	d104      	bne.n	c0d08b7a <ux_flow_validate+0x96>
					G_ux.flow_stack[G_ux.stack_count-1].index++;
c0d08b70:	1c49      	adds	r1, r1, #1
c0d08b72:	8011      	strh	r1, [r2, #0]
					&& G_ux.flow_stack[G_ux.stack_count-1].index <= G_ux.flow_stack[G_ux.stack_count-1].length - 2
c0d08b74:	b28e      	uxth	r6, r1
					&& G_ux.flow_stack[G_ux.stack_count-1].steps[G_ux.flow_stack[G_ux.stack_count-1].index+1] == FLOW_BARRIER) {
c0d08b76:	42b3      	cmp	r3, r6
c0d08b78:	daf5      	bge.n	c0d08b66 <ux_flow_validate+0x82>
				G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index;
c0d08b7a:	82c1      	strh	r1, [r0, #22]
				G_ux.flow_stack[G_ux.stack_count-1].index++;
c0d08b7c:	1c48      	adds	r0, r1, #1
c0d08b7e:	8010      	strh	r0, [r2, #0]
c0d08b80:	e002      	b.n	c0d08b88 <ux_flow_validate+0xa4>
c0d08b82:	2100      	movs	r1, #0
				G_ux.flow_stack[G_ux.stack_count-1].prev_index = G_ux.flow_stack[G_ux.stack_count-1].index = 0;
c0d08b84:	8011      	strh	r1, [r2, #0]
c0d08b86:	82c1      	strh	r1, [r0, #22]
c0d08b88:	4620      	mov	r0, r4
c0d08b8a:	f7ff ff6f 	bl	c0d08a6c <ux_flow_engine_init_step>
c0d08b8e:	e7d5      	b.n	c0d08b3c <ux_flow_validate+0x58>
c0d08b90:	2000195c 	.word	0x2000195c

c0d08b94 <ux_flow_init>:
 * Last step is marked with a FLOW_END_STEP value
 */
#define FLOW_END_STEP ((void*)0xFFFFFFFFUL)
#define FLOW_BARRIER  ((void*)0xFFFFFFFEUL)
#define FLOW_START    ((void*)0xFFFFFFFDUL)
void ux_flow_init(unsigned int stack_slot, const ux_flow_step_t* const * steps, const ux_flow_step_t* const start_step) {
c0d08b94:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08b96:	b083      	sub	sp, #12
c0d08b98:	4615      	mov	r5, r2
c0d08b9a:	460e      	mov	r6, r1
c0d08b9c:	4604      	mov	r4, r0
c0d08b9e:	220c      	movs	r2, #12
	G_ux.flow_stack[stack_slot].length = G_ux.flow_stack[stack_slot].prev_index = G_ux.flow_stack[stack_slot].index = 0;
c0d08ba0:	4610      	mov	r0, r2
c0d08ba2:	4360      	muls	r0, r4
c0d08ba4:	4b21      	ldr	r3, [pc, #132]	; (c0d08c2c <ux_flow_init+0x98>)
c0d08ba6:	181f      	adds	r7, r3, r0
c0d08ba8:	2100      	movs	r1, #0
	G_ux.flow_stack[stack_slot].steps = NULL;
c0d08baa:	8339      	strh	r1, [r7, #24]
c0d08bac:	6139      	str	r1, [r7, #16]
c0d08bae:	6179      	str	r1, [r7, #20]
	
	// reset paging to avoid troubles if first step is a paginated step
	os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d08bb0:	1d18      	adds	r0, r3, #4
c0d08bb2:	f7fa ff08 	bl	c0d039c6 <os_memset>

	if (steps) {
c0d08bb6:	2e00      	cmp	r6, #0
c0d08bb8:	d035      	beq.n	c0d08c26 <ux_flow_init+0x92>
c0d08bba:	9501      	str	r5, [sp, #4]
c0d08bbc:	9402      	str	r4, [sp, #8]
c0d08bbe:	463c      	mov	r4, r7
c0d08bc0:	3410      	adds	r4, #16
c0d08bc2:	463d      	mov	r5, r7
c0d08bc4:	3518      	adds	r5, #24
		G_ux.flow_stack[stack_slot].steps = STEPSPIC(steps);
c0d08bc6:	4630      	mov	r0, r6
c0d08bc8:	f7fb ff04 	bl	c0d049d4 <pic>
c0d08bcc:	6020      	str	r0, [r4, #0]
		while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].length] != FLOW_END_STEP) {
c0d08bce:	8829      	ldrh	r1, [r5, #0]
c0d08bd0:	008a      	lsls	r2, r1, #2
c0d08bd2:	5882      	ldr	r2, [r0, r2]
c0d08bd4:	1c52      	adds	r2, r2, #1
c0d08bd6:	d006      	beq.n	c0d08be6 <ux_flow_init+0x52>
			G_ux.flow_stack[stack_slot].length++;
c0d08bd8:	1c49      	adds	r1, r1, #1
		while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].length] != FLOW_END_STEP) {
c0d08bda:	b28a      	uxth	r2, r1
c0d08bdc:	0092      	lsls	r2, r2, #2
c0d08bde:	5882      	ldr	r2, [r0, r2]
c0d08be0:	1c52      	adds	r2, r2, #1
c0d08be2:	d1f9      	bne.n	c0d08bd8 <ux_flow_init+0x44>
c0d08be4:	8029      	strh	r1, [r5, #0]
c0d08be6:	9801      	ldr	r0, [sp, #4]
		}
		if (start_step != NULL) {
c0d08be8:	2800      	cmp	r0, #0
c0d08bea:	d019      	beq.n	c0d08c20 <ux_flow_init+0x8c>
c0d08bec:	463e      	mov	r6, r7
c0d08bee:	3614      	adds	r6, #20
			const ux_flow_step_t* const start_step2  = STEPPIC(start_step);
c0d08bf0:	f7fb fef0 	bl	c0d049d4 <pic>
c0d08bf4:	4605      	mov	r5, r0
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0d08bf6:	6820      	ldr	r0, [r4, #0]
c0d08bf8:	8831      	ldrh	r1, [r6, #0]
c0d08bfa:	0089      	lsls	r1, r1, #2
c0d08bfc:	5840      	ldr	r0, [r0, r1]
				 && STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index]) != start_step2) {
c0d08bfe:	1c41      	adds	r1, r0, #1
c0d08c00:	d00e      	beq.n	c0d08c20 <ux_flow_init+0x8c>
c0d08c02:	3716      	adds	r7, #22
c0d08c04:	f7fb fee6 	bl	c0d049d4 <pic>
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0d08c08:	42a8      	cmp	r0, r5
c0d08c0a:	d009      	beq.n	c0d08c20 <ux_flow_init+0x8c>
				G_ux.flow_stack[stack_slot].prev_index = G_ux.flow_stack[stack_slot].index;
c0d08c0c:	8830      	ldrh	r0, [r6, #0]
c0d08c0e:	8038      	strh	r0, [r7, #0]
				G_ux.flow_stack[stack_slot].index++;
c0d08c10:	1c40      	adds	r0, r0, #1
c0d08c12:	8030      	strh	r0, [r6, #0]
			while(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index] != FLOW_END_STEP
c0d08c14:	b280      	uxth	r0, r0
c0d08c16:	0080      	lsls	r0, r0, #2
c0d08c18:	6821      	ldr	r1, [r4, #0]
c0d08c1a:	5808      	ldr	r0, [r1, r0]
				 && STEPPIC(G_ux.flow_stack[stack_slot].steps[G_ux.flow_stack[stack_slot].index]) != start_step2) {
c0d08c1c:	1c41      	adds	r1, r0, #1
c0d08c1e:	d1f1      	bne.n	c0d08c04 <ux_flow_init+0x70>
			}
		}

		// init step
		ux_flow_engine_init_step(stack_slot);
c0d08c20:	9802      	ldr	r0, [sp, #8]
c0d08c22:	f7ff ff23 	bl	c0d08a6c <ux_flow_engine_init_step>
	}
}
c0d08c26:	b003      	add	sp, #12
c0d08c28:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d08c2a:	46c0      	nop			; (mov r8, r8)
c0d08c2c:	2000195c 	.word	0x2000195c

c0d08c30 <ux_flow_button_callback>:

void ux_flow_uninit(unsigned int stack_slot) {
	memset(&G_ux.flow_stack[stack_slot], 0, sizeof(G_ux.flow_stack[stack_slot]));
}

unsigned int ux_flow_button_callback(unsigned int button_mask, unsigned int button_mask_counter) {
c0d08c30:	b580      	push	{r7, lr}
c0d08c32:	490a      	ldr	r1, [pc, #40]	; (c0d08c5c <ux_flow_button_callback+0x2c>)
  UNUSED(button_mask_counter);
  switch(button_mask) {
c0d08c34:	4288      	cmp	r0, r1
c0d08c36:	d008      	beq.n	c0d08c4a <ux_flow_button_callback+0x1a>
c0d08c38:	4909      	ldr	r1, [pc, #36]	; (c0d08c60 <ux_flow_button_callback+0x30>)
c0d08c3a:	4288      	cmp	r0, r1
c0d08c3c:	d008      	beq.n	c0d08c50 <ux_flow_button_callback+0x20>
c0d08c3e:	4909      	ldr	r1, [pc, #36]	; (c0d08c64 <ux_flow_button_callback+0x34>)
c0d08c40:	4288      	cmp	r0, r1
c0d08c42:	d108      	bne.n	c0d08c56 <ux_flow_button_callback+0x26>
    case BUTTON_EVT_RELEASED|BUTTON_LEFT:
      ux_flow_prev();
c0d08c44:	f7ff fee0 	bl	c0d08a08 <ux_flow_prev>
c0d08c48:	e005      	b.n	c0d08c56 <ux_flow_button_callback+0x26>
      break;
    case BUTTON_EVT_RELEASED|BUTTON_RIGHT:
      ux_flow_next();
      break;
    case BUTTON_EVT_RELEASED|BUTTON_LEFT|BUTTON_RIGHT:
      ux_flow_validate();
c0d08c4a:	f7ff ff4b 	bl	c0d08ae4 <ux_flow_validate>
c0d08c4e:	e002      	b.n	c0d08c56 <ux_flow_button_callback+0x26>
c0d08c50:	2001      	movs	r0, #1
	ux_flow_next_internal(1);
c0d08c52:	f7ff fea3 	bl	c0d0899c <ux_flow_next_internal>
c0d08c56:	2000      	movs	r0, #0
      break;
  }
  return 0;
c0d08c58:	bd80      	pop	{r7, pc}
c0d08c5a:	46c0      	nop			; (mov r8, r8)
c0d08c5c:	80000003 	.word	0x80000003
c0d08c60:	80000002 	.word	0x80000002
c0d08c64:	80000001 	.word	0x80000001

c0d08c68 <ux_stack_get_step_params>:
}

void* ux_stack_get_step_params(unsigned int stack_slot) {
c0d08c68:	b510      	push	{r4, lr}
c0d08c6a:	4601      	mov	r1, r0
c0d08c6c:	2000      	movs	r0, #0
	if (stack_slot >= UX_STACK_SLOT_COUNT) {
c0d08c6e:	2900      	cmp	r1, #0
c0d08c70:	d10f      	bne.n	c0d08c92 <ux_stack_get_step_params+0x2a>
		return NULL;
	}

	if (G_ux.flow_stack[stack_slot].length == 0) {
c0d08c72:	4c08      	ldr	r4, [pc, #32]	; (c0d08c94 <ux_stack_get_step_params+0x2c>)
c0d08c74:	8b21      	ldrh	r1, [r4, #24]
		return NULL;
	}

	if (G_ux.flow_stack[stack_slot].index >= G_ux.flow_stack[stack_slot].length) {
c0d08c76:	8aa2      	ldrh	r2, [r4, #20]
	if (G_ux.flow_stack[stack_slot].length == 0) {
c0d08c78:	428a      	cmp	r2, r1
c0d08c7a:	d20a      	bcs.n	c0d08c92 <ux_stack_get_step_params+0x2a>
		return NULL;
	}

	return (void*)PIC(STEPPIC(STEPSPIC(G_ux.flow_stack[stack_slot].steps)[G_ux.flow_stack[stack_slot].index])->params);
c0d08c7c:	6920      	ldr	r0, [r4, #16]
c0d08c7e:	f7fb fea9 	bl	c0d049d4 <pic>
c0d08c82:	8aa1      	ldrh	r1, [r4, #20]
c0d08c84:	0089      	lsls	r1, r1, #2
c0d08c86:	5840      	ldr	r0, [r0, r1]
c0d08c88:	f7fb fea4 	bl	c0d049d4 <pic>
c0d08c8c:	6840      	ldr	r0, [r0, #4]
c0d08c8e:	f7fb fea1 	bl	c0d049d4 <pic>
}
c0d08c92:	bd10      	pop	{r4, pc}
c0d08c94:	2000195c 	.word	0x2000195c

c0d08c98 <ux_stack_get_current_step_params>:

void* ux_stack_get_current_step_params(void) {
c0d08c98:	b580      	push	{r7, lr}
	return ux_stack_get_step_params(G_ux.stack_count-1);
c0d08c9a:	4803      	ldr	r0, [pc, #12]	; (c0d08ca8 <ux_stack_get_current_step_params+0x10>)
c0d08c9c:	7800      	ldrb	r0, [r0, #0]
c0d08c9e:	1e40      	subs	r0, r0, #1
c0d08ca0:	f7ff ffe2 	bl	c0d08c68 <ux_stack_get_step_params>
c0d08ca4:	bd80      	pop	{r7, pc}
c0d08ca6:	46c0      	nop			; (mov r8, r8)
c0d08ca8:	2000195c 	.word	0x2000195c

c0d08cac <ux_layout_bb_init_common>:
  }
  return &G_ux.tmp_element;
}
*/

void ux_layout_bb_init_common(unsigned int stack_slot) {
c0d08cac:	b510      	push	{r4, lr}
c0d08cae:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0d08cb0:	f000 fb9c 	bl	c0d093ec <ux_stack_init>
c0d08cb4:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_bb_elements;
c0d08cb6:	4360      	muls	r0, r4
c0d08cb8:	4908      	ldr	r1, [pc, #32]	; (c0d08cdc <ux_layout_bb_init_common+0x30>)
c0d08cba:	1808      	adds	r0, r1, r0
c0d08cbc:	21c4      	movs	r1, #196	; 0xc4
c0d08cbe:	2205      	movs	r2, #5
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_bb_elements);
c0d08cc0:	5442      	strb	r2, [r0, r1]
c0d08cc2:	21c0      	movs	r1, #192	; 0xc0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_bb_elements;
c0d08cc4:	4a06      	ldr	r2, [pc, #24]	; (c0d08ce0 <ux_layout_bb_init_common+0x34>)
c0d08cc6:	447a      	add	r2, pc
c0d08cc8:	5042      	str	r2, [r0, r1]
c0d08cca:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0d08ccc:	4a05      	ldr	r2, [pc, #20]	; (c0d08ce4 <ux_layout_bb_init_common+0x38>)
c0d08cce:	447a      	add	r2, pc
c0d08cd0:	5042      	str	r2, [r0, r1]
c0d08cd2:	21bd      	movs	r1, #189	; 0xbd
c0d08cd4:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0d08cd6:	5442      	strb	r2, [r0, r1]
}
c0d08cd8:	bd10      	pop	{r4, pc}
c0d08cda:	46c0      	nop			; (mov r8, r8)
c0d08cdc:	2000195c 	.word	0x2000195c
c0d08ce0:	000027e2 	.word	0x000027e2
c0d08ce4:	ffffff5f 	.word	0xffffff5f

c0d08ce8 <ux_layout_bn_prepro>:
#endif
#endif
};
*/

const bagl_element_t* ux_layout_bn_prepro(const bagl_element_t* element) {
c0d08ce8:	b580      	push	{r7, lr}
      G_ux.tmp_element.text = params->line2;
      break;
  }
  return &G_ux.tmp_element;
*/
  const bagl_element_t* e = ux_layout_strings_prepro(element);
c0d08cea:	f000 fae3 	bl	c0d092b4 <ux_layout_strings_prepro>
  if (e && G_ux.tmp_element.component.userid == 0x11) {
c0d08cee:	2800      	cmp	r0, #0
c0d08cf0:	d007      	beq.n	c0d08d02 <ux_layout_bn_prepro+0x1a>
c0d08cf2:	229d      	movs	r2, #157	; 0x9d
c0d08cf4:	4903      	ldr	r1, [pc, #12]	; (c0d08d04 <ux_layout_bn_prepro+0x1c>)
c0d08cf6:	5c8a      	ldrb	r2, [r1, r2]
c0d08cf8:	2a11      	cmp	r2, #17
c0d08cfa:	d102      	bne.n	c0d08d02 <ux_layout_bn_prepro+0x1a>
c0d08cfc:	22b4      	movs	r2, #180	; 0xb4
c0d08cfe:	4b02      	ldr	r3, [pc, #8]	; (c0d08d08 <ux_layout_bn_prepro+0x20>)
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER;
c0d08d00:	528b      	strh	r3, [r1, r2]
  }
  return e;
c0d08d02:	bd80      	pop	{r7, pc}
c0d08d04:	2000195c 	.word	0x2000195c
c0d08d08:	0000800a 	.word	0x0000800a

c0d08d0c <ux_layout_bn_init>:
}

void ux_layout_bn_init(unsigned int stack_slot) { 
c0d08d0c:	b510      	push	{r4, lr}
c0d08d0e:	4604      	mov	r4, r0
  ux_layout_bb_init_common(stack_slot);
c0d08d10:	f7ff ffcc 	bl	c0d08cac <ux_layout_bb_init_common>
c0d08d14:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_bn_prepro;
c0d08d16:	4360      	muls	r0, r4
c0d08d18:	4904      	ldr	r1, [pc, #16]	; (c0d08d2c <ux_layout_bn_init+0x20>)
c0d08d1a:	1808      	adds	r0, r1, r0
c0d08d1c:	21cc      	movs	r1, #204	; 0xcc
c0d08d1e:	4a04      	ldr	r2, [pc, #16]	; (c0d08d30 <ux_layout_bn_init+0x24>)
c0d08d20:	447a      	add	r2, pc
c0d08d22:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d08d24:	4620      	mov	r0, r4
c0d08d26:	f000 fb3b 	bl	c0d093a0 <ux_stack_display>
}
c0d08d2a:	bd10      	pop	{r4, pc}
c0d08d2c:	2000195c 	.word	0x2000195c
c0d08d30:	ffffffc5 	.word	0xffffffc5

c0d08d34 <ux_layout_nn_prepro>:
  {{BAGL_LABELINE                       , 0x11,   0,  26, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL},
#endif // TARGET_NANOX
};
*/

const bagl_element_t* ux_layout_nn_prepro(const bagl_element_t* element) {
c0d08d34:	b580      	push	{r7, lr}
      G_ux.tmp_element.text = params->line2;
      break;
  }
  return &G_ux.tmp_element;
*/
  const bagl_element_t* e = ux_layout_strings_prepro(element);
c0d08d36:	f000 fabd 	bl	c0d092b4 <ux_layout_strings_prepro>
  if (e && G_ux.tmp_element.component.userid >= 0x10) {
c0d08d3a:	2800      	cmp	r0, #0
c0d08d3c:	d007      	beq.n	c0d08d4e <ux_layout_nn_prepro+0x1a>
c0d08d3e:	229d      	movs	r2, #157	; 0x9d
c0d08d40:	4903      	ldr	r1, [pc, #12]	; (c0d08d50 <ux_layout_nn_prepro+0x1c>)
c0d08d42:	5c8a      	ldrb	r2, [r1, r2]
c0d08d44:	2a10      	cmp	r2, #16
c0d08d46:	d302      	bcc.n	c0d08d4e <ux_layout_nn_prepro+0x1a>
c0d08d48:	22b4      	movs	r2, #180	; 0xb4
c0d08d4a:	4b02      	ldr	r3, [pc, #8]	; (c0d08d54 <ux_layout_nn_prepro+0x20>)
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER;
c0d08d4c:	528b      	strh	r3, [r1, r2]
  }
  return e;
c0d08d4e:	bd80      	pop	{r7, pc}
c0d08d50:	2000195c 	.word	0x2000195c
c0d08d54:	0000800a 	.word	0x0000800a

c0d08d58 <ux_layout_nn_init>:
}

void ux_layout_nn_init(unsigned int stack_slot) {
c0d08d58:	b510      	push	{r4, lr}
c0d08d5a:	4604      	mov	r4, r0
  ux_layout_bb_init_common(stack_slot);
c0d08d5c:	f7ff ffa6 	bl	c0d08cac <ux_layout_bb_init_common>
c0d08d60:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_nn_prepro;
c0d08d62:	4360      	muls	r0, r4
c0d08d64:	4904      	ldr	r1, [pc, #16]	; (c0d08d78 <ux_layout_nn_init+0x20>)
c0d08d66:	1808      	adds	r0, r1, r0
c0d08d68:	21cc      	movs	r1, #204	; 0xcc
c0d08d6a:	4a04      	ldr	r2, [pc, #16]	; (c0d08d7c <ux_layout_nn_init+0x24>)
c0d08d6c:	447a      	add	r2, pc
c0d08d6e:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d08d70:	4620      	mov	r0, r4
c0d08d72:	f000 fb15 	bl	c0d093a0 <ux_stack_display>
}
c0d08d76:	bd10      	pop	{r4, pc}
c0d08d78:	2000195c 	.word	0x2000195c
c0d08d7c:	ffffffc5 	.word	0xffffffc5

c0d08d80 <ux_layout_paging_compute>:
  //       || (c >= '0' && c <= '9'));
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
}

// return the number of pages to be displayed when current page to show is -1
unsigned int ux_layout_paging_compute(unsigned int stack_slot, unsigned int page_to_display) {
c0d08d80:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08d82:	b087      	sub	sp, #28
c0d08d84:	460e      	mov	r6, r1
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_step_params(stack_slot);
c0d08d86:	f7ff ff6f 	bl	c0d08c68 <ux_stack_get_step_params>
c0d08d8a:	9006      	str	r0, [sp, #24]

  // reset length and offset of lines
  os_memset(&G_ux.layout_paging.offsets, 0, sizeof(G_ux.layout_paging.offsets));
c0d08d8c:	4c44      	ldr	r4, [pc, #272]	; (c0d08ea0 <ux_layout_paging_compute+0x120>)
c0d08d8e:	4620      	mov	r0, r4
c0d08d90:	300c      	adds	r0, #12
c0d08d92:	2500      	movs	r5, #0
c0d08d94:	2702      	movs	r7, #2
c0d08d96:	4629      	mov	r1, r5
c0d08d98:	463a      	mov	r2, r7
c0d08d9a:	f7fa fe14 	bl	c0d039c6 <os_memset>
  os_memset(&G_ux.layout_paging.lengths, 0, sizeof(G_ux.layout_paging.lengths));
c0d08d9e:	4620      	mov	r0, r4
c0d08da0:	300e      	adds	r0, #14
c0d08da2:	9505      	str	r5, [sp, #20]
c0d08da4:	4629      	mov	r1, r5
c0d08da6:	463a      	mov	r2, r7
c0d08da8:	f7fa fe0d 	bl	c0d039c6 <os_memset>

  // a page has been asked, but no page exists
  if (page_to_display != -1UL && G_ux.layout_paging.count == 0) {
c0d08dac:	1c70      	adds	r0, r6, #1
c0d08dae:	9004      	str	r0, [sp, #16]
c0d08db0:	d002      	beq.n	c0d08db8 <ux_layout_paging_compute+0x38>
c0d08db2:	68a0      	ldr	r0, [r4, #8]
c0d08db4:	2800      	cmp	r0, #0
c0d08db6:	d06f      	beq.n	c0d08e98 <ux_layout_paging_compute+0x118>
  }

  // compute offset/length of text of each line for the current page
  unsigned int page = 0;
  unsigned int line = 0;
  const char* start = STRPIC(params->text);
c0d08db8:	9806      	ldr	r0, [sp, #24]
c0d08dba:	6840      	ldr	r0, [r0, #4]
c0d08dbc:	f7fb fe0a 	bl	c0d049d4 <pic>
c0d08dc0:	4606      	mov	r6, r0
  const char* start2 = start;
  const char* end = start + strlen(start);
c0d08dc2:	f000 fdd7 	bl	c0d09974 <strlen>
  while (start < end) {
c0d08dc6:	2801      	cmp	r0, #1
c0d08dc8:	db5d      	blt.n	c0d08e86 <ux_layout_paging_compute+0x106>
c0d08dca:	1830      	adds	r0, r6, r0
c0d08dcc:	6861      	ldr	r1, [r4, #4]
c0d08dce:	9105      	str	r1, [sp, #20]
c0d08dd0:	68a1      	ldr	r1, [r4, #8]
c0d08dd2:	9102      	str	r1, [sp, #8]
c0d08dd4:	2100      	movs	r1, #0
c0d08dd6:	9103      	str	r1, [sp, #12]
c0d08dd8:	9106      	str	r1, [sp, #24]
c0d08dda:	9601      	str	r6, [sp, #4]
c0d08ddc:	9a03      	ldr	r2, [sp, #12]
c0d08dde:	4613      	mov	r3, r2
c0d08de0:	4631      	mov	r1, r6
    unsigned int len = 0;
    unsigned int linew = 0; 
    const char* last_word_delim = start;
    // not reached end of content
    while (start + len < end
c0d08de2:	18b7      	adds	r7, r6, r2
c0d08de4:	4287      	cmp	r7, r0
c0d08de6:	d212      	bcs.n	c0d08e0e <ux_layout_paging_compute+0x8e>
      #else // TARGET_NANOX
      // nano s does not have the bagl lib o nthe SE side
      linew = (len+1)*7 /* width of a capitalized W (the largest char in each font) */;
      #endif //TARGET_NANOX
      //if (start[len] )
      if (linew > PIXEL_PER_LINE) {
c0d08de8:	1ddb      	adds	r3, r3, #7
c0d08dea:	2b72      	cmp	r3, #114	; 0x72
c0d08dec:	d80f      	bhi.n	c0d08e0e <ux_layout_paging_compute+0x8e>
        // we got a full line
        break;
      }
      unsigned char c = start[len];
c0d08dee:	783d      	ldrb	r5, [r7, #0]
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
c0d08df0:	462c      	mov	r4, r5
c0d08df2:	3c09      	subs	r4, #9
c0d08df4:	2c02      	cmp	r4, #2
c0d08df6:	d306      	bcc.n	c0d08e06 <ux_layout_paging_compute+0x86>
c0d08df8:	2d20      	cmp	r5, #32
c0d08dfa:	d004      	beq.n	c0d08e06 <ux_layout_paging_compute+0x86>
c0d08dfc:	2d2d      	cmp	r5, #45	; 0x2d
c0d08dfe:	d002      	beq.n	c0d08e06 <ux_layout_paging_compute+0x86>
      if (is_word_delim(c)) {
c0d08e00:	2d5f      	cmp	r5, #95	; 0x5f
c0d08e02:	d000      	beq.n	c0d08e06 <ux_layout_paging_compute+0x86>
c0d08e04:	460f      	mov	r7, r1
c0d08e06:	4639      	mov	r1, r7
c0d08e08:	1c52      	adds	r2, r2, #1
c0d08e0a:	2d0a      	cmp	r5, #10
c0d08e0c:	d1e9      	bne.n	c0d08de2 <ux_layout_paging_compute+0x62>
        break;
      }
    }

    // if not splitting line onto a word delimiter, then cut at the previous word_delim, adjust len accordingly (and a wor delim has been found already)
    if (start + len < end && last_word_delim != start && len) {
c0d08e0e:	18b3      	adds	r3, r6, r2
c0d08e10:	4283      	cmp	r3, r0
c0d08e12:	d222      	bcs.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e14:	2a00      	cmp	r2, #0
c0d08e16:	d020      	beq.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e18:	42b1      	cmp	r1, r6
c0d08e1a:	d01e      	beq.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e1c:	2400      	movs	r4, #0
c0d08e1e:	43e4      	mvns	r4, r4
      // if line split within a word
      if ((!is_word_delim(start[len-1]) && !is_word_delim(start[len]))) {
c0d08e20:	5d1c      	ldrb	r4, [r3, r4]
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
c0d08e22:	2c2c      	cmp	r4, #44	; 0x2c
c0d08e24:	dc06      	bgt.n	c0d08e34 <ux_layout_paging_compute+0xb4>
c0d08e26:	4625      	mov	r5, r4
c0d08e28:	3d09      	subs	r5, #9
c0d08e2a:	2d02      	cmp	r5, #2
c0d08e2c:	d315      	bcc.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e2e:	2c20      	cmp	r4, #32
c0d08e30:	d013      	beq.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e32:	e003      	b.n	c0d08e3c <ux_layout_paging_compute+0xbc>
c0d08e34:	2c2d      	cmp	r4, #45	; 0x2d
c0d08e36:	d010      	beq.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e38:	2c5f      	cmp	r4, #95	; 0x5f
c0d08e3a:	d00e      	beq.n	c0d08e5a <ux_layout_paging_compute+0xda>
      if ((!is_word_delim(start[len-1]) && !is_word_delim(start[len]))) {
c0d08e3c:	781b      	ldrb	r3, [r3, #0]
  return c == ' ' || c == '\n' || c == '\t' || c == '-' || c == '_';
c0d08e3e:	2b2c      	cmp	r3, #44	; 0x2c
c0d08e40:	dc06      	bgt.n	c0d08e50 <ux_layout_paging_compute+0xd0>
c0d08e42:	461c      	mov	r4, r3
c0d08e44:	3c09      	subs	r4, #9
c0d08e46:	2c02      	cmp	r4, #2
c0d08e48:	d307      	bcc.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e4a:	2b20      	cmp	r3, #32
c0d08e4c:	d005      	beq.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e4e:	e003      	b.n	c0d08e58 <ux_layout_paging_compute+0xd8>
c0d08e50:	2b2d      	cmp	r3, #45	; 0x2d
c0d08e52:	d002      	beq.n	c0d08e5a <ux_layout_paging_compute+0xda>
c0d08e54:	2b5f      	cmp	r3, #95	; 0x5f
c0d08e56:	d000      	beq.n	c0d08e5a <ux_layout_paging_compute+0xda>
        len = last_word_delim - start;
c0d08e58:	1b8a      	subs	r2, r1, r6
      }
    }

    // fill up the paging structure
    if (page_to_display != -1UL && G_ux.layout_paging.current == page && G_ux.layout_paging.current < G_ux.layout_paging.count) {
c0d08e5a:	9904      	ldr	r1, [sp, #16]
c0d08e5c:	2900      	cmp	r1, #0
c0d08e5e:	d007      	beq.n	c0d08e70 <ux_layout_paging_compute+0xf0>
c0d08e60:	9905      	ldr	r1, [sp, #20]
c0d08e62:	9b06      	ldr	r3, [sp, #24]
c0d08e64:	4299      	cmp	r1, r3
c0d08e66:	d103      	bne.n	c0d08e70 <ux_layout_paging_compute+0xf0>
c0d08e68:	9905      	ldr	r1, [sp, #20]
c0d08e6a:	9b02      	ldr	r3, [sp, #8]
c0d08e6c:	4299      	cmp	r1, r3
c0d08e6e:	d30d      	bcc.n	c0d08e8c <ux_layout_paging_compute+0x10c>
        return page;
      }
    }

    // prepare for next line
    start += len;
c0d08e70:	18b6      	adds	r6, r6, r2
    line++;
    if (
#if UX_LAYOUT_PAGING_LINE > 1
      line >= UX_LAYOUT_PAGING_LINE && 
#endif // UX_LAYOUT_PAGING_LINE
      start < end) {
c0d08e72:	4286      	cmp	r6, r0
c0d08e74:	d202      	bcs.n	c0d08e7c <ux_layout_paging_compute+0xfc>
c0d08e76:	9906      	ldr	r1, [sp, #24]
c0d08e78:	1c49      	adds	r1, r1, #1
c0d08e7a:	9106      	str	r1, [sp, #24]
  while (start < end) {
c0d08e7c:	4286      	cmp	r6, r0
c0d08e7e:	d3ad      	bcc.n	c0d08ddc <ux_layout_paging_compute+0x5c>
      page++;
      line = 0;
    }
  }
  return page+1;
c0d08e80:	9806      	ldr	r0, [sp, #24]
c0d08e82:	1c40      	adds	r0, r0, #1
c0d08e84:	e000      	b.n	c0d08e88 <ux_layout_paging_compute+0x108>
c0d08e86:	2001      	movs	r0, #1
c0d08e88:	9005      	str	r0, [sp, #20]
c0d08e8a:	e005      	b.n	c0d08e98 <ux_layout_paging_compute+0x118>
c0d08e8c:	4804      	ldr	r0, [pc, #16]	; (c0d08ea0 <ux_layout_paging_compute+0x120>)
c0d08e8e:	4601      	mov	r1, r0
      G_ux.layout_paging.lengths[line] = len;
c0d08e90:	81c2      	strh	r2, [r0, #14]
      G_ux.layout_paging.offsets[line] = start - start2;
c0d08e92:	9801      	ldr	r0, [sp, #4]
c0d08e94:	1a30      	subs	r0, r6, r0
c0d08e96:	8188      	strh	r0, [r1, #12]
}
c0d08e98:	9805      	ldr	r0, [sp, #20]
c0d08e9a:	b007      	add	sp, #28
c0d08e9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d08e9e:	46c0      	nop			; (mov r8, r8)
c0d08ea0:	2000195c 	.word	0x2000195c

c0d08ea4 <ux_layout_paging_redisplay>:

// redisplay current page
void ux_layout_paging_redisplay(unsigned int stack_slot) {
c0d08ea4:	b5b0      	push	{r4, r5, r7, lr}
c0d08ea6:	4604      	mov	r4, r0

#ifndef TARGET_NANOX
  ux_layout_bb_init_common(stack_slot);
c0d08ea8:	f7ff ff00 	bl	c0d08cac <ux_layout_bb_init_common>
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_paging_elements);
  G_ux.stack[stack_slot].element_arrays_count = 1;
#endif // TARGET_NANOX

  // request offsets and lengths of lines for the current page
  ux_layout_paging_compute(stack_slot, G_ux.layout_paging.current);
c0d08eac:	4d09      	ldr	r5, [pc, #36]	; (c0d08ed4 <ux_layout_paging_redisplay+0x30>)
c0d08eae:	6869      	ldr	r1, [r5, #4]
c0d08eb0:	4620      	mov	r0, r4
c0d08eb2:	f7ff ff65 	bl	c0d08d80 <ux_layout_paging_compute>
c0d08eb6:	2024      	movs	r0, #36	; 0x24

  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_paging_prepro;
c0d08eb8:	4360      	muls	r0, r4
c0d08eba:	1828      	adds	r0, r5, r0
c0d08ebc:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].button_push_callback = ux_layout_paging_button_callback;
c0d08ebe:	4a06      	ldr	r2, [pc, #24]	; (c0d08ed8 <ux_layout_paging_redisplay+0x34>)
c0d08ec0:	447a      	add	r2, pc
c0d08ec2:	5042      	str	r2, [r0, r1]
c0d08ec4:	21cc      	movs	r1, #204	; 0xcc
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_paging_prepro;
c0d08ec6:	4a05      	ldr	r2, [pc, #20]	; (c0d08edc <ux_layout_paging_redisplay+0x38>)
c0d08ec8:	447a      	add	r2, pc
c0d08eca:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d08ecc:	4620      	mov	r0, r4
c0d08ece:	f000 fa67 	bl	c0d093a0 <ux_stack_display>
}
c0d08ed2:	bdb0      	pop	{r4, r5, r7, pc}
c0d08ed4:	2000195c 	.word	0x2000195c
c0d08ed8:	0000011d 	.word	0x0000011d
c0d08edc:	00000015 	.word	0x00000015

c0d08ee0 <ux_layout_paging_prepro>:
static const bagl_element_t* ux_layout_paging_prepro(const bagl_element_t* element) {
c0d08ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d08ee2:	b083      	sub	sp, #12
c0d08ee4:	4606      	mov	r6, r0
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_current_step_params();
c0d08ee6:	f7ff fed7 	bl	c0d08c98 <ux_stack_get_current_step_params>
c0d08eea:	4605      	mov	r5, r0
  os_memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0d08eec:	4f37      	ldr	r7, [pc, #220]	; (c0d08fcc <ux_layout_paging_prepro+0xec>)
c0d08eee:	463c      	mov	r4, r7
c0d08ef0:	349c      	adds	r4, #156	; 0x9c
c0d08ef2:	2220      	movs	r2, #32
c0d08ef4:	4620      	mov	r0, r4
c0d08ef6:	4631      	mov	r1, r6
c0d08ef8:	f7fa fd4f 	bl	c0d0399a <os_memmove>
  switch (element->component.userid) {
c0d08efc:	7870      	ldrb	r0, [r6, #1]
c0d08efe:	2810      	cmp	r0, #16
c0d08f00:	dc17      	bgt.n	c0d08f32 <ux_layout_paging_prepro+0x52>
c0d08f02:	2801      	cmp	r0, #1
c0d08f04:	d036      	beq.n	c0d08f74 <ux_layout_paging_prepro+0x94>
c0d08f06:	2802      	cmp	r0, #2
c0d08f08:	d03c      	beq.n	c0d08f84 <ux_layout_paging_prepro+0xa4>
c0d08f0a:	2810      	cmp	r0, #16
c0d08f0c:	d15b      	bne.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
    	if (params->title) {
c0d08f0e:	6828      	ldr	r0, [r5, #0]
c0d08f10:	463e      	mov	r6, r7
c0d08f12:	2800      	cmp	r0, #0
c0d08f14:	d041      	beq.n	c0d08f9a <ux_layout_paging_prepro+0xba>
        SPRINTF(G_ux.string_buffer, (G_ux.layout_paging.count>1)?"%s (%d/%d)":"%s", STRPIC(params->title), G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0d08f16:	68bd      	ldr	r5, [r7, #8]
c0d08f18:	f7fb fd5c 	bl	c0d049d4 <pic>
c0d08f1c:	4603      	mov	r3, r0
c0d08f1e:	6878      	ldr	r0, [r7, #4]
c0d08f20:	68b9      	ldr	r1, [r7, #8]
c0d08f22:	466a      	mov	r2, sp
c0d08f24:	1c40      	adds	r0, r0, #1
c0d08f26:	c203      	stmia	r2!, {r0, r1}
c0d08f28:	2d01      	cmp	r5, #1
c0d08f2a:	d841      	bhi.n	c0d08fb0 <ux_layout_paging_prepro+0xd0>
c0d08f2c:	4a29      	ldr	r2, [pc, #164]	; (c0d08fd4 <ux_layout_paging_prepro+0xf4>)
c0d08f2e:	447a      	add	r2, pc
c0d08f30:	e040      	b.n	c0d08fb4 <ux_layout_paging_prepro+0xd4>
  switch (element->component.userid) {
c0d08f32:	4601      	mov	r1, r0
c0d08f34:	3911      	subs	r1, #17
c0d08f36:	2903      	cmp	r1, #3
c0d08f38:	d245      	bcs.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
c0d08f3a:	210f      	movs	r1, #15
      unsigned int lineidx = (element->component.userid&0xF)-1;
c0d08f3c:	4008      	ands	r0, r1
c0d08f3e:	1e40      	subs	r0, r0, #1
      if (G_ux.layout_paging.lengths[lineidx]) {
c0d08f40:	0040      	lsls	r0, r0, #1
c0d08f42:	4922      	ldr	r1, [pc, #136]	; (c0d08fcc <ux_layout_paging_prepro+0xec>)
c0d08f44:	180f      	adds	r7, r1, r0
c0d08f46:	89fe      	ldrh	r6, [r7, #14]
c0d08f48:	2e00      	cmp	r6, #0
c0d08f4a:	d03c      	beq.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
        SPRINTF(G_ux.string_buffer, "%.*s", G_ux.layout_paging.lengths[lineidx], STRPIC(params->text) + G_ux.layout_paging.offsets[lineidx]);
c0d08f4c:	6868      	ldr	r0, [r5, #4]
c0d08f4e:	f7fb fd41 	bl	c0d049d4 <pic>
c0d08f52:	89b9      	ldrh	r1, [r7, #12]
c0d08f54:	1840      	adds	r0, r0, r1
c0d08f56:	4669      	mov	r1, sp
c0d08f58:	6008      	str	r0, [r1, #0]
c0d08f5a:	4f1c      	ldr	r7, [pc, #112]	; (c0d08fcc <ux_layout_paging_prepro+0xec>)
c0d08f5c:	463d      	mov	r5, r7
c0d08f5e:	351c      	adds	r5, #28
c0d08f60:	2180      	movs	r1, #128	; 0x80
c0d08f62:	4a1e      	ldr	r2, [pc, #120]	; (c0d08fdc <ux_layout_paging_prepro+0xfc>)
c0d08f64:	447a      	add	r2, pc
c0d08f66:	4628      	mov	r0, r5
c0d08f68:	4633      	mov	r3, r6
c0d08f6a:	f7fb fb5f 	bl	c0d0462c <snprintf>
c0d08f6e:	20b8      	movs	r0, #184	; 0xb8
        G_ux.tmp_element.text = G_ux.string_buffer;
c0d08f70:	503d      	str	r5, [r7, r0]
c0d08f72:	e028      	b.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
  		if (ux_flow_is_first() && G_ux.layout_paging.current == 0) {
c0d08f74:	f7ff fcb4 	bl	c0d088e0 <ux_flow_is_first>
c0d08f78:	2800      	cmp	r0, #0
c0d08f7a:	d024      	beq.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
c0d08f7c:	6878      	ldr	r0, [r7, #4]
c0d08f7e:	2800      	cmp	r0, #0
c0d08f80:	d009      	beq.n	c0d08f96 <ux_layout_paging_prepro+0xb6>
c0d08f82:	e020      	b.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
  		if (ux_flow_is_last() && G_ux.layout_paging.current == G_ux.layout_paging.count -1 ) {
c0d08f84:	f7ff fcd4 	bl	c0d08930 <ux_flow_is_last>
c0d08f88:	2800      	cmp	r0, #0
c0d08f8a:	d01c      	beq.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
c0d08f8c:	6878      	ldr	r0, [r7, #4]
c0d08f8e:	68b9      	ldr	r1, [r7, #8]
c0d08f90:	1e49      	subs	r1, r1, #1
c0d08f92:	4288      	cmp	r0, r1
c0d08f94:	d117      	bne.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
c0d08f96:	2400      	movs	r4, #0
c0d08f98:	e015      	b.n	c0d08fc6 <ux_layout_paging_prepro+0xe6>
        SPRINTF(G_ux.string_buffer, "%d/%d", G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0d08f9a:	6879      	ldr	r1, [r7, #4]
c0d08f9c:	68b8      	ldr	r0, [r7, #8]
c0d08f9e:	466a      	mov	r2, sp
c0d08fa0:	6010      	str	r0, [r2, #0]
c0d08fa2:	4638      	mov	r0, r7
c0d08fa4:	301c      	adds	r0, #28
c0d08fa6:	1c4b      	adds	r3, r1, #1
c0d08fa8:	2180      	movs	r1, #128	; 0x80
c0d08faa:	4a0b      	ldr	r2, [pc, #44]	; (c0d08fd8 <ux_layout_paging_prepro+0xf8>)
c0d08fac:	447a      	add	r2, pc
c0d08fae:	e004      	b.n	c0d08fba <ux_layout_paging_prepro+0xda>
c0d08fb0:	4a07      	ldr	r2, [pc, #28]	; (c0d08fd0 <ux_layout_paging_prepro+0xf0>)
c0d08fb2:	447a      	add	r2, pc
        SPRINTF(G_ux.string_buffer, (G_ux.layout_paging.count>1)?"%s (%d/%d)":"%s", STRPIC(params->title), G_ux.layout_paging.current+1, G_ux.layout_paging.count);
c0d08fb4:	4630      	mov	r0, r6
c0d08fb6:	301c      	adds	r0, #28
c0d08fb8:	2180      	movs	r1, #128	; 0x80
c0d08fba:	f7fb fb37 	bl	c0d0462c <snprintf>
      G_ux.tmp_element.text = G_ux.string_buffer;
c0d08fbe:	4630      	mov	r0, r6
c0d08fc0:	301c      	adds	r0, #28
c0d08fc2:	21b8      	movs	r1, #184	; 0xb8
c0d08fc4:	5070      	str	r0, [r6, r1]
}
c0d08fc6:	4620      	mov	r0, r4
c0d08fc8:	b003      	add	sp, #12
c0d08fca:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d08fcc:	2000195c 	.word	0x2000195c
c0d08fd0:	00002596 	.word	0x00002596
c0d08fd4:	00002625 	.word	0x00002625
c0d08fd8:	000025aa 	.word	0x000025aa
c0d08fdc:	00000c32 	.word	0x00000c32

c0d08fe0 <ux_layout_paging_button_callback>:
    G_ux.layout_paging.current--;
    ux_layout_paging_redisplay(G_ux.stack_count-1);
  }
}

static unsigned int ux_layout_paging_button_callback(unsigned int button_mask, unsigned int button_mask_counter) {
c0d08fe0:	b580      	push	{r7, lr}
c0d08fe2:	4917      	ldr	r1, [pc, #92]	; (c0d09040 <ux_layout_paging_button_callback+0x60>)
  UNUSED(button_mask_counter);
  switch(button_mask) {
c0d08fe4:	4288      	cmp	r0, r1
c0d08fe6:	d00b      	beq.n	c0d09000 <ux_layout_paging_button_callback+0x20>
c0d08fe8:	4916      	ldr	r1, [pc, #88]	; (c0d09044 <ux_layout_paging_button_callback+0x64>)
c0d08fea:	4288      	cmp	r0, r1
c0d08fec:	d013      	beq.n	c0d09016 <ux_layout_paging_button_callback+0x36>
c0d08fee:	4916      	ldr	r1, [pc, #88]	; (c0d09048 <ux_layout_paging_button_callback+0x68>)
c0d08ff0:	4288      	cmp	r0, r1
c0d08ff2:	d122      	bne.n	c0d0903a <ux_layout_paging_button_callback+0x5a>
  if (G_ux.layout_paging.current == 0) {
c0d08ff4:	4815      	ldr	r0, [pc, #84]	; (c0d0904c <ux_layout_paging_button_callback+0x6c>)
c0d08ff6:	6841      	ldr	r1, [r0, #4]
c0d08ff8:	2900      	cmp	r1, #0
c0d08ffa:	d01c      	beq.n	c0d09036 <ux_layout_paging_button_callback+0x56>
    G_ux.layout_paging.current--;
c0d08ffc:	1e49      	subs	r1, r1, #1
c0d08ffe:	e014      	b.n	c0d0902a <ux_layout_paging_button_callback+0x4a>
      break;
    case BUTTON_EVT_RELEASED|BUTTON_RIGHT:
      ux_layout_paging_next();
      break;
    case BUTTON_EVT_RELEASED|BUTTON_LEFT|BUTTON_RIGHT:
      if (G_ux.layout_paging.count == 0 
c0d09000:	4912      	ldr	r1, [pc, #72]	; (c0d0904c <ux_layout_paging_button_callback+0x6c>)
c0d09002:	6888      	ldr	r0, [r1, #8]
        || G_ux.layout_paging.count-1 == G_ux.layout_paging.current) {
c0d09004:	2800      	cmp	r0, #0
c0d09006:	d003      	beq.n	c0d09010 <ux_layout_paging_button_callback+0x30>
c0d09008:	6849      	ldr	r1, [r1, #4]
c0d0900a:	1e40      	subs	r0, r0, #1
      if (G_ux.layout_paging.count == 0 
c0d0900c:	4288      	cmp	r0, r1
c0d0900e:	d114      	bne.n	c0d0903a <ux_layout_paging_button_callback+0x5a>
        ux_flow_validate();
c0d09010:	f7ff fd68 	bl	c0d08ae4 <ux_flow_validate>
c0d09014:	e011      	b.n	c0d0903a <ux_layout_paging_button_callback+0x5a>
  if (G_ux.layout_paging.current == G_ux.layout_paging.count-1) {
c0d09016:	480d      	ldr	r0, [pc, #52]	; (c0d0904c <ux_layout_paging_button_callback+0x6c>)
c0d09018:	6841      	ldr	r1, [r0, #4]
c0d0901a:	6882      	ldr	r2, [r0, #8]
c0d0901c:	1e52      	subs	r2, r2, #1
c0d0901e:	4291      	cmp	r1, r2
c0d09020:	d102      	bne.n	c0d09028 <ux_layout_paging_button_callback+0x48>
    ux_flow_next();
c0d09022:	f7ff fceb 	bl	c0d089fc <ux_flow_next>
c0d09026:	e008      	b.n	c0d0903a <ux_layout_paging_button_callback+0x5a>
    G_ux.layout_paging.current++;
c0d09028:	1c49      	adds	r1, r1, #1
c0d0902a:	6041      	str	r1, [r0, #4]
c0d0902c:	7800      	ldrb	r0, [r0, #0]
c0d0902e:	1e40      	subs	r0, r0, #1
c0d09030:	f7ff ff38 	bl	c0d08ea4 <ux_layout_paging_redisplay>
c0d09034:	e001      	b.n	c0d0903a <ux_layout_paging_button_callback+0x5a>
    ux_flow_prev();
c0d09036:	f7ff fce7 	bl	c0d08a08 <ux_flow_prev>
c0d0903a:	2000      	movs	r0, #0
      }
      break;
  }
  return 0;
c0d0903c:	bd80      	pop	{r7, pc}
c0d0903e:	46c0      	nop			; (mov r8, r8)
c0d09040:	80000003 	.word	0x80000003
c0d09044:	80000002 	.word	0x80000002
c0d09048:	80000001 	.word	0x80000001
c0d0904c:	2000195c 	.word	0x2000195c

c0d09050 <ux_layout_paging_init>:
}

unsigned short bagl_compute_line_width(unsigned short font_id, unsigned short width, const void * text, unsigned char text_length, unsigned char text_encoding);

void ux_layout_paging_init(unsigned int stack_slot) {
c0d09050:	b570      	push	{r4, r5, r6, lr}
c0d09052:	4604      	mov	r4, r0

  // depending flow browsing direction, select the correct page to display
  switch(ux_flow_direction()) {
c0d09054:	f7ff fc8c 	bl	c0d08970 <ux_flow_direction>
c0d09058:	2801      	cmp	r0, #1
c0d0905a:	d00b      	beq.n	c0d09074 <ux_layout_paging_init+0x24>
c0d0905c:	1c40      	adds	r0, r0, #1
c0d0905e:	d10f      	bne.n	c0d09080 <ux_layout_paging_init+0x30>
  ux_layout_paging_redisplay(stack_slot);
}

// function callable externally which reset the paging (to be called before init when willing to redisplay the first page)
void ux_layout_paging_reset(void) {
  os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d09060:	4e1c      	ldr	r6, [pc, #112]	; (c0d090d4 <ux_layout_paging_init+0x84>)
c0d09062:	1d30      	adds	r0, r6, #4
c0d09064:	2500      	movs	r5, #0
c0d09066:	220c      	movs	r2, #12
c0d09068:	4629      	mov	r1, r5
c0d0906a:	f7fa fcac 	bl	c0d039c6 <os_memset>
c0d0906e:	43e8      	mvns	r0, r5
      G_ux.layout_paging.current = -1UL;
c0d09070:	6070      	str	r0, [r6, #4]
c0d09072:	e005      	b.n	c0d09080 <ux_layout_paging_init+0x30>
  os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d09074:	4817      	ldr	r0, [pc, #92]	; (c0d090d4 <ux_layout_paging_init+0x84>)
c0d09076:	1d00      	adds	r0, r0, #4
c0d09078:	2100      	movs	r1, #0
c0d0907a:	220c      	movs	r2, #12
c0d0907c:	f7fa fca3 	bl	c0d039c6 <os_memset>
  ux_stack_init(stack_slot);
c0d09080:	4620      	mov	r0, r4
c0d09082:	f000 f9b3 	bl	c0d093ec <ux_stack_init>
  const ux_layout_paging_params_t* params = (const ux_layout_paging_params_t*)ux_stack_get_step_params(stack_slot);
c0d09086:	4620      	mov	r0, r4
c0d09088:	f7ff fdee 	bl	c0d08c68 <ux_stack_get_step_params>
  if (params->text == NULL /*|| strlen(STRPIC(params->text)) == 0*/) {
c0d0908c:	6840      	ldr	r0, [r0, #4]
c0d0908e:	2800      	cmp	r0, #0
c0d09090:	d019      	beq.n	c0d090c6 <ux_layout_paging_init+0x76>
c0d09092:	2000      	movs	r0, #0
c0d09094:	43c1      	mvns	r1, r0
  G_ux.layout_paging.count = ux_layout_paging_compute(stack_slot, -1UL); // at least one page
c0d09096:	4620      	mov	r0, r4
c0d09098:	f7ff fe72 	bl	c0d08d80 <ux_layout_paging_compute>
c0d0909c:	4d0d      	ldr	r5, [pc, #52]	; (c0d090d4 <ux_layout_paging_init+0x84>)
c0d0909e:	60a8      	str	r0, [r5, #8]
  if (G_ux.layout_paging.count == 0) {
c0d090a0:	2800      	cmp	r0, #0
c0d090a2:	d107      	bne.n	c0d090b4 <ux_layout_paging_init+0x64>
  os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d090a4:	1d28      	adds	r0, r5, #4
c0d090a6:	2100      	movs	r1, #0
c0d090a8:	220c      	movs	r2, #12
c0d090aa:	f7fa fc8c 	bl	c0d039c6 <os_memset>
  if (G_ux.layout_paging.count && G_ux.layout_paging.current > G_ux.layout_paging.count-1UL) {
c0d090ae:	68a8      	ldr	r0, [r5, #8]
c0d090b0:	2800      	cmp	r0, #0
c0d090b2:	d004      	beq.n	c0d090be <ux_layout_paging_init+0x6e>
c0d090b4:	1e40      	subs	r0, r0, #1
c0d090b6:	6869      	ldr	r1, [r5, #4]
c0d090b8:	4281      	cmp	r1, r0
c0d090ba:	d900      	bls.n	c0d090be <ux_layout_paging_init+0x6e>
    G_ux.layout_paging.current = G_ux.layout_paging.count-1;
c0d090bc:	6068      	str	r0, [r5, #4]
  ux_layout_paging_redisplay(stack_slot);
c0d090be:	4620      	mov	r0, r4
c0d090c0:	f7ff fef0 	bl	c0d08ea4 <ux_layout_paging_redisplay>
}
c0d090c4:	bd70      	pop	{r4, r5, r6, pc}
  os_memset(&G_ux.layout_paging, 0, sizeof(G_ux.layout_paging));
c0d090c6:	4803      	ldr	r0, [pc, #12]	; (c0d090d4 <ux_layout_paging_init+0x84>)
c0d090c8:	1d00      	adds	r0, r0, #4
c0d090ca:	2100      	movs	r1, #0
c0d090cc:	220c      	movs	r2, #12
c0d090ce:	f7fa fc7a 	bl	c0d039c6 <os_memset>
}
c0d090d2:	bd70      	pop	{r4, r5, r6, pc}
c0d090d4:	2000195c 	.word	0x2000195c

c0d090d8 <ux_layout_pb_prepro>:
  {{BAGL_ICON                           , 0x10,  56,  2,  16,  16, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL},
  {{BAGL_LABELINE                       , 0x11,   0, 28, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL},
#endif // TARGET_NANOX
};

const bagl_element_t* ux_layout_pb_prepro(const bagl_element_t* element) {
c0d090d8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d090da:	b081      	sub	sp, #4
c0d090dc:	4606      	mov	r6, r0
  // don't display if null
  const ux_layout_pb_params_t* params = (const ux_layout_pb_params_t*)ux_stack_get_current_step_params();
c0d090de:	f7ff fddb 	bl	c0d08c98 <ux_stack_get_current_step_params>
c0d090e2:	4605      	mov	r5, r0

	// copy element before any mod
	os_memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0d090e4:	4f11      	ldr	r7, [pc, #68]	; (c0d0912c <ux_layout_pb_prepro+0x54>)
c0d090e6:	463c      	mov	r4, r7
c0d090e8:	349c      	adds	r4, #156	; 0x9c
c0d090ea:	2220      	movs	r2, #32
c0d090ec:	4620      	mov	r0, r4
c0d090ee:	4631      	mov	r1, r6
c0d090f0:	f7fa fc53 	bl	c0d0399a <os_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0d090f4:	7870      	ldrb	r0, [r6, #1]
c0d090f6:	280f      	cmp	r0, #15
c0d090f8:	dc06      	bgt.n	c0d09108 <ux_layout_pb_prepro+0x30>
c0d090fa:	2801      	cmp	r0, #1
c0d090fc:	d00a      	beq.n	c0d09114 <ux_layout_pb_prepro+0x3c>
c0d090fe:	2802      	cmp	r0, #2
c0d09100:	d111      	bne.n	c0d09126 <ux_layout_pb_prepro+0x4e>
  			return NULL;
  		}
  		break;

  	case 0x02:
  		if (ux_flow_is_last()) {
c0d09102:	f7ff fc15 	bl	c0d08930 <ux_flow_is_last>
c0d09106:	e007      	b.n	c0d09118 <ux_layout_pb_prepro+0x40>
  switch (element->component.userid) {
c0d09108:	2810      	cmp	r0, #16
c0d0910a:	d009      	beq.n	c0d09120 <ux_layout_pb_prepro+0x48>
c0d0910c:	2811      	cmp	r0, #17
c0d0910e:	d10a      	bne.n	c0d09126 <ux_layout_pb_prepro+0x4e>
    case 0x10:
  		G_ux.tmp_element.text = (const char*)params->icon;
      break;

    case 0x11:
  		G_ux.tmp_element.text = params->line1;
c0d09110:	6868      	ldr	r0, [r5, #4]
c0d09112:	e006      	b.n	c0d09122 <ux_layout_pb_prepro+0x4a>
  		if (ux_flow_is_first()) {
c0d09114:	f7ff fbe4 	bl	c0d088e0 <ux_flow_is_first>
c0d09118:	2800      	cmp	r0, #0
c0d0911a:	d004      	beq.n	c0d09126 <ux_layout_pb_prepro+0x4e>
c0d0911c:	2400      	movs	r4, #0
c0d0911e:	e002      	b.n	c0d09126 <ux_layout_pb_prepro+0x4e>
  		G_ux.tmp_element.text = (const char*)params->icon;
c0d09120:	6828      	ldr	r0, [r5, #0]
c0d09122:	21b8      	movs	r1, #184	; 0xb8
c0d09124:	5078      	str	r0, [r7, r1]
      break;
  }
  return &G_ux.tmp_element;
}
c0d09126:	4620      	mov	r0, r4
c0d09128:	b001      	add	sp, #4
c0d0912a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0912c:	2000195c 	.word	0x2000195c

c0d09130 <ux_layout_pb_init>:

void ux_layout_pb_init(unsigned int stack_slot) {
c0d09130:	b510      	push	{r4, lr}
c0d09132:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0d09134:	f000 f95a 	bl	c0d093ec <ux_stack_init>
c0d09138:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pb_elements;
c0d0913a:	4360      	muls	r0, r4
c0d0913c:	490b      	ldr	r1, [pc, #44]	; (c0d0916c <ux_layout_pb_init+0x3c>)
c0d0913e:	1808      	adds	r0, r1, r0
c0d09140:	21c4      	movs	r1, #196	; 0xc4
c0d09142:	2205      	movs	r2, #5
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_pb_elements);
c0d09144:	5442      	strb	r2, [r0, r1]
c0d09146:	21c0      	movs	r1, #192	; 0xc0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pb_elements;
c0d09148:	4a09      	ldr	r2, [pc, #36]	; (c0d09170 <ux_layout_pb_init+0x40>)
c0d0914a:	447a      	add	r2, pc
c0d0914c:	5042      	str	r2, [r0, r1]
c0d0914e:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pb_prepro;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0d09150:	4a08      	ldr	r2, [pc, #32]	; (c0d09174 <ux_layout_pb_init+0x44>)
c0d09152:	447a      	add	r2, pc
c0d09154:	5042      	str	r2, [r0, r1]
c0d09156:	21cc      	movs	r1, #204	; 0xcc
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pb_prepro;
c0d09158:	4a07      	ldr	r2, [pc, #28]	; (c0d09178 <ux_layout_pb_init+0x48>)
c0d0915a:	447a      	add	r2, pc
c0d0915c:	5042      	str	r2, [r0, r1]
c0d0915e:	21bd      	movs	r1, #189	; 0xbd
c0d09160:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0d09162:	5442      	strb	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d09164:	4620      	mov	r0, r4
c0d09166:	f000 f91b 	bl	c0d093a0 <ux_stack_display>
}
c0d0916a:	bd10      	pop	{r4, pc}
c0d0916c:	2000195c 	.word	0x2000195c
c0d09170:	00002412 	.word	0x00002412
c0d09174:	fffffadb 	.word	0xfffffadb
c0d09178:	ffffff7b 	.word	0xffffff7b

c0d0917c <ux_layout_pbb_prepro>:
  {{BAGL_LABELINE                       , 0x10,  41,  12, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px, 0  }, NULL},
  {{BAGL_LABELINE                       , 0x11,  41,  26, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px, 0  }, NULL},
#endif // TARGET_NANOX
};

const bagl_element_t* ux_layout_pbb_prepro(const bagl_element_t* element) {
c0d0917c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0917e:	b081      	sub	sp, #4
c0d09180:	4606      	mov	r6, r0
  // don't display if null
  const ux_layout_icon_strings_params_t* params = (const ux_layout_icon_strings_params_t*)ux_stack_get_current_step_params();
c0d09182:	f7ff fd89 	bl	c0d08c98 <ux_stack_get_current_step_params>
c0d09186:	4605      	mov	r5, r0

	// ocpy element before any mod
	os_memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0d09188:	4f15      	ldr	r7, [pc, #84]	; (c0d091e0 <ux_layout_pbb_prepro+0x64>)
c0d0918a:	463c      	mov	r4, r7
c0d0918c:	349c      	adds	r4, #156	; 0x9c
c0d0918e:	2220      	movs	r2, #32
c0d09190:	4620      	mov	r0, r4
c0d09192:	4631      	mov	r1, r6
c0d09194:	f7fa fc01 	bl	c0d0399a <os_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0d09198:	7870      	ldrb	r0, [r6, #1]
c0d0919a:	280f      	cmp	r0, #15
c0d0919c:	dc07      	bgt.n	c0d091ae <ux_layout_pbb_prepro+0x32>
c0d0919e:	2801      	cmp	r0, #1
c0d091a0:	d012      	beq.n	c0d091c8 <ux_layout_pbb_prepro+0x4c>
c0d091a2:	2802      	cmp	r0, #2
c0d091a4:	d013      	beq.n	c0d091ce <ux_layout_pbb_prepro+0x52>
c0d091a6:	280f      	cmp	r0, #15
c0d091a8:	d116      	bne.n	c0d091d8 <ux_layout_pbb_prepro+0x5c>
  			return NULL;
  		}
  		break;

    case 0x0F:
  		G_ux.tmp_element.text = (const char*)params->icon;
c0d091aa:	6828      	ldr	r0, [r5, #0]
c0d091ac:	e009      	b.n	c0d091c2 <ux_layout_pbb_prepro+0x46>
  switch (element->component.userid) {
c0d091ae:	3810      	subs	r0, #16
c0d091b0:	2802      	cmp	r0, #2
c0d091b2:	d211      	bcs.n	c0d091d8 <ux_layout_pbb_prepro+0x5c>
c0d091b4:	209d      	movs	r0, #157	; 0x9d
      break;

    case 0x10:
    case 0x11:
      G_ux.tmp_element.text = params->lines[G_ux.tmp_element.component.userid&0xF];
c0d091b6:	5c38      	ldrb	r0, [r7, r0]
c0d091b8:	210f      	movs	r1, #15
c0d091ba:	4001      	ands	r1, r0
c0d091bc:	0088      	lsls	r0, r1, #2
c0d091be:	1828      	adds	r0, r5, r0
c0d091c0:	6840      	ldr	r0, [r0, #4]
c0d091c2:	21b8      	movs	r1, #184	; 0xb8
c0d091c4:	5078      	str	r0, [r7, r1]
c0d091c6:	e007      	b.n	c0d091d8 <ux_layout_pbb_prepro+0x5c>
  		if (ux_flow_is_first()) {
c0d091c8:	f7ff fb8a 	bl	c0d088e0 <ux_flow_is_first>
c0d091cc:	e001      	b.n	c0d091d2 <ux_layout_pbb_prepro+0x56>
  		if (ux_flow_is_last()) {
c0d091ce:	f7ff fbaf 	bl	c0d08930 <ux_flow_is_last>
c0d091d2:	2800      	cmp	r0, #0
c0d091d4:	d000      	beq.n	c0d091d8 <ux_layout_pbb_prepro+0x5c>
c0d091d6:	2400      	movs	r4, #0
      break;

  }
  return &G_ux.tmp_element;
}
c0d091d8:	4620      	mov	r0, r4
c0d091da:	b001      	add	sp, #4
c0d091dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d091de:	46c0      	nop			; (mov r8, r8)
c0d091e0:	2000195c 	.word	0x2000195c

c0d091e4 <ux_layout_pbb_init_common>:


void ux_layout_pbb_init_common(unsigned int stack_slot) {
c0d091e4:	b510      	push	{r4, lr}
c0d091e6:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0d091e8:	f000 f900 	bl	c0d093ec <ux_stack_init>
c0d091ec:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0d091ee:	4360      	muls	r0, r4
c0d091f0:	4908      	ldr	r1, [pc, #32]	; (c0d09214 <ux_layout_pbb_init_common+0x30>)
c0d091f2:	1808      	adds	r0, r1, r0
c0d091f4:	21c4      	movs	r1, #196	; 0xc4
c0d091f6:	2206      	movs	r2, #6
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_pbb_elements);
c0d091f8:	5442      	strb	r2, [r0, r1]
c0d091fa:	21c0      	movs	r1, #192	; 0xc0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0d091fc:	4a06      	ldr	r2, [pc, #24]	; (c0d09218 <ux_layout_pbb_init_common+0x34>)
c0d091fe:	447a      	add	r2, pc
c0d09200:	5042      	str	r2, [r0, r1]
c0d09202:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].element_arrays_count = 1;
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0d09204:	4a05      	ldr	r2, [pc, #20]	; (c0d0921c <ux_layout_pbb_init_common+0x38>)
c0d09206:	447a      	add	r2, pc
c0d09208:	5042      	str	r2, [r0, r1]
c0d0920a:	21bd      	movs	r1, #189	; 0xbd
c0d0920c:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0d0920e:	5442      	strb	r2, [r0, r1]
}
c0d09210:	bd10      	pop	{r4, pc}
c0d09212:	46c0      	nop			; (mov r8, r8)
c0d09214:	2000195c 	.word	0x2000195c
c0d09218:	000023fe 	.word	0x000023fe
c0d0921c:	fffffa27 	.word	0xfffffa27

c0d09220 <ux_layout_pbb_init>:

void ux_layout_pbb_init(unsigned int stack_slot) {
c0d09220:	b510      	push	{r4, lr}
c0d09222:	4604      	mov	r4, r0
  ux_stack_init(stack_slot);
c0d09224:	f000 f8e2 	bl	c0d093ec <ux_stack_init>
c0d09228:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0d0922a:	4360      	muls	r0, r4
c0d0922c:	490b      	ldr	r1, [pc, #44]	; (c0d0925c <ux_layout_pbb_init+0x3c>)
c0d0922e:	1808      	adds	r0, r1, r0
c0d09230:	21c4      	movs	r1, #196	; 0xc4
c0d09232:	2206      	movs	r2, #6
  G_ux.stack[stack_slot].element_arrays[0].element_array_count = ARRAYLEN(ux_layout_pbb_elements);
c0d09234:	5442      	strb	r2, [r0, r1]
c0d09236:	21c0      	movs	r1, #192	; 0xc0
  G_ux.stack[stack_slot].element_arrays[0].element_array = ux_layout_pbb_elements;
c0d09238:	4a09      	ldr	r2, [pc, #36]	; (c0d09260 <ux_layout_pbb_init+0x40>)
c0d0923a:	447a      	add	r2, pc
c0d0923c:	5042      	str	r2, [r0, r1]
c0d0923e:	21d0      	movs	r1, #208	; 0xd0
  G_ux.stack[stack_slot].button_push_callback = ux_flow_button_callback;
c0d09240:	4a08      	ldr	r2, [pc, #32]	; (c0d09264 <ux_layout_pbb_init+0x44>)
c0d09242:	447a      	add	r2, pc
c0d09244:	5042      	str	r2, [r0, r1]
c0d09246:	21bd      	movs	r1, #189	; 0xbd
c0d09248:	2201      	movs	r2, #1
  G_ux.stack[stack_slot].element_arrays_count = 1;
c0d0924a:	5442      	strb	r2, [r0, r1]
c0d0924c:	21cc      	movs	r1, #204	; 0xcc
  ux_layout_pbb_init_common(stack_slot);
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pbb_prepro;
c0d0924e:	4a06      	ldr	r2, [pc, #24]	; (c0d09268 <ux_layout_pbb_init+0x48>)
c0d09250:	447a      	add	r2, pc
c0d09252:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d09254:	4620      	mov	r0, r4
c0d09256:	f000 f8a3 	bl	c0d093a0 <ux_stack_display>
}
c0d0925a:	bd10      	pop	{r4, pc}
c0d0925c:	2000195c 	.word	0x2000195c
c0d09260:	000023c2 	.word	0x000023c2
c0d09264:	fffff9eb 	.word	0xfffff9eb
c0d09268:	ffffff29 	.word	0xffffff29

c0d0926c <ux_layout_pnn_prepro>:
#endif // TARGET_NANOX

};
*/

const bagl_element_t* ux_layout_pnn_prepro(const bagl_element_t* element) {
c0d0926c:	b580      	push	{r7, lr}
      G_ux.tmp_element.text = params->line2;
      break;
  }
  return &G_ux.tmp_element;
  */
  const bagl_element_t* e = ux_layout_pbb_prepro(element);
c0d0926e:	f7ff ff85 	bl	c0d0917c <ux_layout_pbb_prepro>
  if (e && G_ux.tmp_element.component.userid >= 0x10) {
c0d09272:	2800      	cmp	r0, #0
c0d09274:	d007      	beq.n	c0d09286 <ux_layout_pnn_prepro+0x1a>
c0d09276:	229d      	movs	r2, #157	; 0x9d
c0d09278:	4903      	ldr	r1, [pc, #12]	; (c0d09288 <ux_layout_pnn_prepro+0x1c>)
c0d0927a:	5c8a      	ldrb	r2, [r1, r2]
c0d0927c:	2a10      	cmp	r2, #16
c0d0927e:	d302      	bcc.n	c0d09286 <ux_layout_pnn_prepro+0x1a>
c0d09280:	22b4      	movs	r2, #180	; 0xb4
c0d09282:	230a      	movs	r3, #10
    G_ux.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_REGULAR_11px;
c0d09284:	528b      	strh	r3, [r1, r2]
  }
  return e;
c0d09286:	bd80      	pop	{r7, pc}
c0d09288:	2000195c 	.word	0x2000195c

c0d0928c <ux_layout_pnn_init>:
}

void ux_layout_pnn_init(unsigned int stack_slot) { 
c0d0928c:	b510      	push	{r4, lr}
c0d0928e:	4604      	mov	r4, r0
  ux_layout_pbb_init_common(stack_slot);
c0d09290:	f7ff ffa8 	bl	c0d091e4 <ux_layout_pbb_init_common>
c0d09294:	2024      	movs	r0, #36	; 0x24
  G_ux.stack[stack_slot].screen_before_element_display_callback = ux_layout_pnn_prepro;
c0d09296:	4360      	muls	r0, r4
c0d09298:	4904      	ldr	r1, [pc, #16]	; (c0d092ac <ux_layout_pnn_init+0x20>)
c0d0929a:	1808      	adds	r0, r1, r0
c0d0929c:	21cc      	movs	r1, #204	; 0xcc
c0d0929e:	4a04      	ldr	r2, [pc, #16]	; (c0d092b0 <ux_layout_pnn_init+0x24>)
c0d092a0:	447a      	add	r2, pc
c0d092a2:	5042      	str	r2, [r0, r1]
  ux_stack_display(stack_slot);
c0d092a4:	4620      	mov	r0, r4
c0d092a6:	f000 f87b 	bl	c0d093a0 <ux_stack_display>
}
c0d092aa:	bd10      	pop	{r4, pc}
c0d092ac:	2000195c 	.word	0x2000195c
c0d092b0:	ffffffc9 	.word	0xffffffc9

c0d092b4 <ux_layout_strings_prepro>:
    G_ux.stack[stack_slot].ticker_value = ms;
    G_ux.stack[stack_slot].ticker_interval = ms; // restart
  }
}

const bagl_element_t* ux_layout_strings_prepro(const bagl_element_t* element) {
c0d092b4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d092b6:	b081      	sub	sp, #4
c0d092b8:	4606      	mov	r6, r0
  // don't display if null
  const ux_layout_strings_params_t* params = (const ux_layout_strings_params_t*)ux_stack_get_current_step_params();
c0d092ba:	f7ff fced 	bl	c0d08c98 <ux_stack_get_current_step_params>
c0d092be:	4605      	mov	r5, r0
  // ocpy element before any mod
  os_memmove(&G_ux.tmp_element, element, sizeof(bagl_element_t));
c0d092c0:	4f11      	ldr	r7, [pc, #68]	; (c0d09308 <ux_layout_strings_prepro+0x54>)
c0d092c2:	463c      	mov	r4, r7
c0d092c4:	349c      	adds	r4, #156	; 0x9c
c0d092c6:	2220      	movs	r2, #32
c0d092c8:	4620      	mov	r0, r4
c0d092ca:	4631      	mov	r1, r6
c0d092cc:	f7fa fb65 	bl	c0d0399a <os_memmove>

  // for dashboard, setup the current application's name
  switch (element->component.userid) {
c0d092d0:	7870      	ldrb	r0, [r6, #1]
c0d092d2:	2802      	cmp	r0, #2
c0d092d4:	d004      	beq.n	c0d092e0 <ux_layout_strings_prepro+0x2c>
c0d092d6:	2801      	cmp	r0, #1
c0d092d8:	d108      	bne.n	c0d092ec <ux_layout_strings_prepro+0x38>
    case 0x01:
      if (ux_flow_is_first()) {
c0d092da:	f7ff fb01 	bl	c0d088e0 <ux_flow_is_first>
c0d092de:	e001      	b.n	c0d092e4 <ux_layout_strings_prepro+0x30>
        return NULL;
      }
      break;

    case 0x02:
      if (ux_flow_is_last()) {
c0d092e0:	f7ff fb26 	bl	c0d08930 <ux_flow_is_last>
c0d092e4:	2800      	cmp	r0, #0
c0d092e6:	d00c      	beq.n	c0d09302 <ux_layout_strings_prepro+0x4e>
c0d092e8:	2400      	movs	r4, #0
c0d092ea:	e00a      	b.n	c0d09302 <ux_layout_strings_prepro+0x4e>
c0d092ec:	209d      	movs	r0, #157	; 0x9d
        return NULL;
      }
      break;

    default:
      if (G_ux.tmp_element.component.userid&0xF0) {
c0d092ee:	5c38      	ldrb	r0, [r7, r0]
c0d092f0:	0601      	lsls	r1, r0, #24
c0d092f2:	0f09      	lsrs	r1, r1, #28
c0d092f4:	d005      	beq.n	c0d09302 <ux_layout_strings_prepro+0x4e>
c0d092f6:	210f      	movs	r1, #15
        G_ux.tmp_element.text = params->lines[G_ux.tmp_element.component.userid&0xF];
c0d092f8:	4008      	ands	r0, r1
c0d092fa:	0080      	lsls	r0, r0, #2
c0d092fc:	5828      	ldr	r0, [r5, r0]
c0d092fe:	21b8      	movs	r1, #184	; 0xb8
c0d09300:	5078      	str	r0, [r7, r1]
      }
      break;
  }
  return &G_ux.tmp_element;
}
c0d09302:	4620      	mov	r0, r4
c0d09304:	b001      	add	sp, #4
c0d09306:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d09308:	2000195c 	.word	0x2000195c

c0d0930c <ux_stack_push>:
    }
  }
  return 0;
}

unsigned int ux_stack_push(void) {
c0d0930c:	b5b0      	push	{r4, r5, r7, lr}
  // only push if an available slot exists
  if (G_ux.stack_count < ARRAYLEN(G_ux.stack)) {
c0d0930e:	4d0c      	ldr	r5, [pc, #48]	; (c0d09340 <ux_stack_push+0x34>)
c0d09310:	7828      	ldrb	r0, [r5, #0]
c0d09312:	2800      	cmp	r0, #0
c0d09314:	d111      	bne.n	c0d0933a <ux_stack_push+0x2e>
    os_memset(&G_ux.stack[G_ux.stack_count], 0, sizeof(G_ux.stack[0]));
c0d09316:	4628      	mov	r0, r5
c0d09318:	30bc      	adds	r0, #188	; 0xbc
c0d0931a:	2400      	movs	r4, #0
c0d0931c:	2224      	movs	r2, #36	; 0x24
c0d0931e:	4621      	mov	r1, r4
c0d09320:	f7fa fb51 	bl	c0d039c6 <os_memset>
#ifdef HAVE_UX_FLOW
    os_memset(&G_ux.flow_stack[G_ux.stack_count], 0, sizeof(G_ux.flow_stack[0]));
c0d09324:	7828      	ldrb	r0, [r5, #0]
c0d09326:	220c      	movs	r2, #12
c0d09328:	4350      	muls	r0, r2
c0d0932a:	1828      	adds	r0, r5, r0
c0d0932c:	3010      	adds	r0, #16
c0d0932e:	4621      	mov	r1, r4
c0d09330:	f7fa fb49 	bl	c0d039c6 <os_memset>
#endif // HAVE_UX_FLOW
    G_ux.stack_count++;
c0d09334:	7828      	ldrb	r0, [r5, #0]
c0d09336:	1c40      	adds	r0, r0, #1
c0d09338:	7028      	strb	r0, [r5, #0]
  }
  // return the stack top index
  return G_ux.stack_count-1;
c0d0933a:	b2c0      	uxtb	r0, r0
c0d0933c:	1e40      	subs	r0, r0, #1
c0d0933e:	bdb0      	pop	{r4, r5, r7, pc}
c0d09340:	2000195c 	.word	0x2000195c

c0d09344 <ux_stack_pop>:
}
unsigned int ux_stack_pop(void) {
c0d09344:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09346:	b081      	sub	sp, #4
  unsigned int exit_code = BOLOS_UX_OK;
  // only pop if more than two stack entry (0 and 1,top is an index not a count)
  if (G_ux.stack_count > 0) {
c0d09348:	4e14      	ldr	r6, [pc, #80]	; (c0d0939c <ux_stack_pop+0x58>)
c0d0934a:	7830      	ldrb	r0, [r6, #0]
c0d0934c:	2800      	cmp	r0, #0
c0d0934e:	d01e      	beq.n	c0d0938e <ux_stack_pop+0x4a>
    G_ux.stack_count--;
c0d09350:	1e40      	subs	r0, r0, #1
c0d09352:	7030      	strb	r0, [r6, #0]
    exit_code = G_ux.stack[G_ux.stack_count].exit_code_after_elements_displayed;
c0d09354:	b2c0      	uxtb	r0, r0
c0d09356:	2424      	movs	r4, #36	; 0x24
c0d09358:	4360      	muls	r0, r4
c0d0935a:	1830      	adds	r0, r6, r0
c0d0935c:	21bc      	movs	r1, #188	; 0xbc
c0d0935e:	5c47      	ldrb	r7, [r0, r1]
c0d09360:	30bc      	adds	r0, #188	; 0xbc
c0d09362:	2500      	movs	r5, #0
    // wipe popped slot
    os_memset(&G_ux.stack[G_ux.stack_count], 0, sizeof(G_ux.stack[0]));
c0d09364:	4629      	mov	r1, r5
c0d09366:	4622      	mov	r2, r4
c0d09368:	f7fa fb2d 	bl	c0d039c6 <os_memset>
#ifdef HAVE_UX_FLOW
    os_memset(&G_ux.flow_stack[G_ux.stack_count], 0, sizeof(G_ux.flow_stack[0]));
c0d0936c:	7830      	ldrb	r0, [r6, #0]
c0d0936e:	220c      	movs	r2, #12
c0d09370:	4350      	muls	r0, r2
c0d09372:	1830      	adds	r0, r6, r0
c0d09374:	3010      	adds	r0, #16
c0d09376:	4629      	mov	r1, r5
c0d09378:	f7fa fb25 	bl	c0d039c6 <os_memset>
#endif // HAVE_UX_FLOW
  }

  // prepare output code when popping the last stack screen
  if (G_ux.stack_count==0) {
c0d0937c:	7830      	ldrb	r0, [r6, #0]
c0d0937e:	2800      	cmp	r0, #0
c0d09380:	d006      	beq.n	c0d09390 <ux_stack_pop+0x4c>
    G_ux.exit_code = exit_code;
  }
  // ask for a complete redraw (optimisation due to blink must be avoided as we're returning from a modal, and within the bolos ux screen stack)
  else {
    // prepare to redraw the slot when asked
    G_ux.stack[G_ux.stack_count-1].element_index = 0;
c0d09382:	1e40      	subs	r0, r0, #1
c0d09384:	4344      	muls	r4, r0
c0d09386:	1931      	adds	r1, r6, r4
c0d09388:	22be      	movs	r2, #190	; 0xbe
c0d0938a:	528d      	strh	r5, [r1, r2]
c0d0938c:	e003      	b.n	c0d09396 <ux_stack_pop+0x52>
c0d0938e:	27aa      	movs	r7, #170	; 0xaa
    G_ux.exit_code = exit_code;
c0d09390:	7077      	strb	r7, [r6, #1]
c0d09392:	2000      	movs	r0, #0
c0d09394:	43c0      	mvns	r0, r0
  }
  // return the stack top index (or -1 if no top)
  return G_ux.stack_count-1; 
c0d09396:	b001      	add	sp, #4
c0d09398:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0939a:	46c0      	nop			; (mov r8, r8)
c0d0939c:	2000195c 	.word	0x2000195c

c0d093a0 <ux_stack_display>:
}
#endif // UX_STACK_SLOT_ARRAY_COUNT == 1
#endif // TARGET_NANOX

// common code for all screens
void ux_stack_display(unsigned int stack_slot) {
c0d093a0:	b5b0      	push	{r4, r5, r7, lr}
c0d093a2:	4604      	mov	r4, r0
  // don't display any elements of a previous screen replacement
  if(G_ux.stack_count > 0 && stack_slot+1 == G_ux.stack_count) {
c0d093a4:	4810      	ldr	r0, [pc, #64]	; (c0d093e8 <ux_stack_display+0x48>)
c0d093a6:	7801      	ldrb	r1, [r0, #0]
c0d093a8:	2900      	cmp	r1, #0
c0d093aa:	d00e      	beq.n	c0d093ca <ux_stack_display+0x2a>
c0d093ac:	1c62      	adds	r2, r4, #1
c0d093ae:	428a      	cmp	r2, r1
c0d093b0:	d10b      	bne.n	c0d093ca <ux_stack_display+0x2a>
c0d093b2:	2124      	movs	r1, #36	; 0x24
    io_seproxyhal_init_ux();
    // at worse a redisplay of the current screen has been requested, ensure to redraw it correctly
    G_ux.stack[stack_slot].element_index = 0;
c0d093b4:	4361      	muls	r1, r4
c0d093b6:	1845      	adds	r5, r0, r1
    io_seproxyhal_init_ux();
c0d093b8:	f7fa fd7a 	bl	c0d03eb0 <io_seproxyhal_init_ux>
c0d093bc:	20be      	movs	r0, #190	; 0xbe
c0d093be:	2100      	movs	r1, #0
    G_ux.stack[stack_slot].element_index = 0;
c0d093c0:	5229      	strh	r1, [r5, r0]
#ifdef TARGET_NANOX
    ux_stack_display_elements(&G_ux.stack[stack_slot]); // on balenos, no need to wait for the display processed event
#else // TARGET_NANOX
    ux_stack_al_display_next_element(stack_slot);
c0d093c2:	4620      	mov	r0, r4
c0d093c4:	f000 f826 	bl	c0d09414 <ux_stack_al_display_next_element>
    if (G_ux.exit_code == BOLOS_UX_OK) {
      G_ux.exit_code = BOLOS_UX_REDRAW;
    }
  }
  // else don't draw (in stack insertion)
}
c0d093c8:	bdb0      	pop	{r4, r5, r7, pc}
  if(G_ux.stack_count > 0 && stack_slot+1 == G_ux.stack_count) {
c0d093ca:	424a      	negs	r2, r1
c0d093cc:	414a      	adcs	r2, r1
  else if (stack_slot == -1UL || G_ux.stack_count == 0) {
c0d093ce:	1c61      	adds	r1, r4, #1
c0d093d0:	424b      	negs	r3, r1
c0d093d2:	414b      	adcs	r3, r1
c0d093d4:	4313      	orrs	r3, r2
c0d093d6:	2b01      	cmp	r3, #1
c0d093d8:	d104      	bne.n	c0d093e4 <ux_stack_display+0x44>
c0d093da:	7841      	ldrb	r1, [r0, #1]
c0d093dc:	29aa      	cmp	r1, #170	; 0xaa
c0d093de:	d101      	bne.n	c0d093e4 <ux_stack_display+0x44>
c0d093e0:	2169      	movs	r1, #105	; 0x69
      G_ux.exit_code = BOLOS_UX_REDRAW;
c0d093e2:	7041      	strb	r1, [r0, #1]
}
c0d093e4:	bdb0      	pop	{r4, r5, r7, pc}
c0d093e6:	46c0      	nop			; (mov r8, r8)
c0d093e8:	2000195c 	.word	0x2000195c

c0d093ec <ux_stack_init>:
void ux_stack_init(unsigned int stack_slot) {
c0d093ec:	b570      	push	{r4, r5, r6, lr}
c0d093ee:	2424      	movs	r4, #36	; 0x24
  os_memset(&G_ux.stack[stack_slot], 0, sizeof(G_ux.stack[0]));
c0d093f0:	4360      	muls	r0, r4
c0d093f2:	4907      	ldr	r1, [pc, #28]	; (c0d09410 <ux_stack_init+0x24>)
c0d093f4:	180e      	adds	r6, r1, r0
  io_seproxyhal_init_ux(); // glitch upon ux_stack_display for a button being pressed in a previous screen
c0d093f6:	f7fa fd5b 	bl	c0d03eb0 <io_seproxyhal_init_ux>
  os_memset(&G_ux.stack[stack_slot], 0, sizeof(G_ux.stack[0]));
c0d093fa:	4630      	mov	r0, r6
c0d093fc:	30bc      	adds	r0, #188	; 0xbc
c0d093fe:	2500      	movs	r5, #0
c0d09400:	4629      	mov	r1, r5
c0d09402:	4622      	mov	r2, r4
c0d09404:	f7fa fadf 	bl	c0d039c6 <os_memset>
c0d09408:	20bc      	movs	r0, #188	; 0xbc
  G_ux.stack[stack_slot].exit_code_after_elements_displayed = BOLOS_UX_CONTINUE;
c0d0940a:	5435      	strb	r5, [r6, r0]
}
c0d0940c:	bd70      	pop	{r4, r5, r6, pc}
c0d0940e:	46c0      	nop			; (mov r8, r8)
c0d09410:	2000195c 	.word	0x2000195c

c0d09414 <ux_stack_al_display_next_element>:
void ux_stack_al_display_next_element(unsigned int stack_slot) {
c0d09414:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09416:	b081      	sub	sp, #4
c0d09418:	4604      	mov	r4, r0
c0d0941a:	2004      	movs	r0, #4
  unsigned int status = os_sched_last_status(TASK_BOLOS_UX);
c0d0941c:	f7fc fbaa 	bl	c0d05b74 <os_sched_last_status>
  if (status != BOLOS_UX_IGNORE && status != BOLOS_UX_CONTINUE) {
c0d09420:	2800      	cmp	r0, #0
c0d09422:	d039      	beq.n	c0d09498 <ux_stack_al_display_next_element+0x84>
c0d09424:	2897      	cmp	r0, #151	; 0x97
c0d09426:	d037      	beq.n	c0d09498 <ux_stack_al_display_next_element+0x84>
c0d09428:	2024      	movs	r0, #36	; 0x24
      && G_ux.stack[stack_slot].element_index < G_ux.stack[stack_slot].element_arrays[0].element_array_count
c0d0942a:	4360      	muls	r0, r4
c0d0942c:	491b      	ldr	r1, [pc, #108]	; (c0d0949c <ux_stack_al_display_next_element+0x88>)
c0d0942e:	180c      	adds	r4, r1, r0
c0d09430:	20c0      	movs	r0, #192	; 0xc0
    while (G_ux.stack[stack_slot].element_arrays[0].element_array
c0d09432:	5820      	ldr	r0, [r4, r0]
      && G_ux.stack[stack_slot].element_index < G_ux.stack[stack_slot].element_arrays[0].element_array_count
c0d09434:	2800      	cmp	r0, #0
c0d09436:	d02f      	beq.n	c0d09498 <ux_stack_al_display_next_element+0x84>
c0d09438:	4625      	mov	r5, r4
c0d0943a:	35c0      	adds	r5, #192	; 0xc0
c0d0943c:	4626      	mov	r6, r4
c0d0943e:	36be      	adds	r6, #190	; 0xbe
c0d09440:	4627      	mov	r7, r4
c0d09442:	37cc      	adds	r7, #204	; 0xcc
c0d09444:	34c4      	adds	r4, #196	; 0xc4
c0d09446:	8830      	ldrh	r0, [r6, #0]
c0d09448:	7821      	ldrb	r1, [r4, #0]
c0d0944a:	b280      	uxth	r0, r0
      && ! io_seproxyhal_spi_is_status_sent()
c0d0944c:	4288      	cmp	r0, r1
c0d0944e:	d223      	bcs.n	c0d09498 <ux_stack_al_display_next_element+0x84>
c0d09450:	f7fc fb5c 	bl	c0d05b0c <io_seph_is_status_sent>
      && (os_perso_isonboarded() != BOLOS_UX_OK || os_global_pin_is_validated() == BOLOS_UX_OK)) {
c0d09454:	2800      	cmp	r0, #0
c0d09456:	d11f      	bne.n	c0d09498 <ux_stack_al_display_next_element+0x84>
c0d09458:	f7fc face 	bl	c0d059f8 <os_perso_isonboarded>
c0d0945c:	28aa      	cmp	r0, #170	; 0xaa
c0d0945e:	d103      	bne.n	c0d09468 <ux_stack_al_display_next_element+0x54>
c0d09460:	f7fc faf4 	bl	c0d05a4c <os_global_pin_is_validated>
    while (G_ux.stack[stack_slot].element_arrays[0].element_array
c0d09464:	28aa      	cmp	r0, #170	; 0xaa
c0d09466:	d117      	bne.n	c0d09498 <ux_stack_al_display_next_element+0x84>
      const bagl_element_t* element = &G_ux.stack[stack_slot].element_arrays[0].element_array[G_ux.stack[stack_slot].element_index];
c0d09468:	6828      	ldr	r0, [r5, #0]
c0d0946a:	8831      	ldrh	r1, [r6, #0]
c0d0946c:	0149      	lsls	r1, r1, #5
c0d0946e:	1840      	adds	r0, r0, r1
      if (!G_ux.stack[stack_slot].screen_before_element_display_callback || (element = G_ux.stack[stack_slot].screen_before_element_display_callback(element)) ) {
c0d09470:	6839      	ldr	r1, [r7, #0]
c0d09472:	2900      	cmp	r1, #0
c0d09474:	d002      	beq.n	c0d0947c <ux_stack_al_display_next_element+0x68>
c0d09476:	4788      	blx	r1
c0d09478:	2800      	cmp	r0, #0
c0d0947a:	d007      	beq.n	c0d0948c <ux_stack_al_display_next_element+0x78>
        if ((unsigned int)element == 1) { /*backward compat with coding to avoid smashing everything*/
c0d0947c:	2801      	cmp	r0, #1
c0d0947e:	d103      	bne.n	c0d09488 <ux_stack_al_display_next_element+0x74>
          element = &G_ux.stack[stack_slot].element_arrays[0].element_array[G_ux.stack[stack_slot].element_index];
c0d09480:	6828      	ldr	r0, [r5, #0]
c0d09482:	8831      	ldrh	r1, [r6, #0]
c0d09484:	0149      	lsls	r1, r1, #5
c0d09486:	1840      	adds	r0, r0, r1
        io_seproxyhal_display(element);
c0d09488:	f7f9 ffb4 	bl	c0d033f4 <io_seproxyhal_display>
      G_ux.stack[stack_slot].element_index++;
c0d0948c:	8830      	ldrh	r0, [r6, #0]
c0d0948e:	1c40      	adds	r0, r0, #1
c0d09490:	8030      	strh	r0, [r6, #0]
    while (G_ux.stack[stack_slot].element_arrays[0].element_array
c0d09492:	6829      	ldr	r1, [r5, #0]
      && G_ux.stack[stack_slot].element_index < G_ux.stack[stack_slot].element_arrays[0].element_array_count
c0d09494:	2900      	cmp	r1, #0
c0d09496:	d1d7      	bne.n	c0d09448 <ux_stack_al_display_next_element+0x34>
}
c0d09498:	b001      	add	sp, #4
c0d0949a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0949c:	2000195c 	.word	0x2000195c

c0d094a0 <__udivsi3>:
c0d094a0:	2200      	movs	r2, #0
c0d094a2:	0843      	lsrs	r3, r0, #1
c0d094a4:	428b      	cmp	r3, r1
c0d094a6:	d374      	bcc.n	c0d09592 <__udivsi3+0xf2>
c0d094a8:	0903      	lsrs	r3, r0, #4
c0d094aa:	428b      	cmp	r3, r1
c0d094ac:	d35f      	bcc.n	c0d0956e <__udivsi3+0xce>
c0d094ae:	0a03      	lsrs	r3, r0, #8
c0d094b0:	428b      	cmp	r3, r1
c0d094b2:	d344      	bcc.n	c0d0953e <__udivsi3+0x9e>
c0d094b4:	0b03      	lsrs	r3, r0, #12
c0d094b6:	428b      	cmp	r3, r1
c0d094b8:	d328      	bcc.n	c0d0950c <__udivsi3+0x6c>
c0d094ba:	0c03      	lsrs	r3, r0, #16
c0d094bc:	428b      	cmp	r3, r1
c0d094be:	d30d      	bcc.n	c0d094dc <__udivsi3+0x3c>
c0d094c0:	22ff      	movs	r2, #255	; 0xff
c0d094c2:	0209      	lsls	r1, r1, #8
c0d094c4:	ba12      	rev	r2, r2
c0d094c6:	0c03      	lsrs	r3, r0, #16
c0d094c8:	428b      	cmp	r3, r1
c0d094ca:	d302      	bcc.n	c0d094d2 <__udivsi3+0x32>
c0d094cc:	1212      	asrs	r2, r2, #8
c0d094ce:	0209      	lsls	r1, r1, #8
c0d094d0:	d065      	beq.n	c0d0959e <__udivsi3+0xfe>
c0d094d2:	0b03      	lsrs	r3, r0, #12
c0d094d4:	428b      	cmp	r3, r1
c0d094d6:	d319      	bcc.n	c0d0950c <__udivsi3+0x6c>
c0d094d8:	e000      	b.n	c0d094dc <__udivsi3+0x3c>
c0d094da:	0a09      	lsrs	r1, r1, #8
c0d094dc:	0bc3      	lsrs	r3, r0, #15
c0d094de:	428b      	cmp	r3, r1
c0d094e0:	d301      	bcc.n	c0d094e6 <__udivsi3+0x46>
c0d094e2:	03cb      	lsls	r3, r1, #15
c0d094e4:	1ac0      	subs	r0, r0, r3
c0d094e6:	4152      	adcs	r2, r2
c0d094e8:	0b83      	lsrs	r3, r0, #14
c0d094ea:	428b      	cmp	r3, r1
c0d094ec:	d301      	bcc.n	c0d094f2 <__udivsi3+0x52>
c0d094ee:	038b      	lsls	r3, r1, #14
c0d094f0:	1ac0      	subs	r0, r0, r3
c0d094f2:	4152      	adcs	r2, r2
c0d094f4:	0b43      	lsrs	r3, r0, #13
c0d094f6:	428b      	cmp	r3, r1
c0d094f8:	d301      	bcc.n	c0d094fe <__udivsi3+0x5e>
c0d094fa:	034b      	lsls	r3, r1, #13
c0d094fc:	1ac0      	subs	r0, r0, r3
c0d094fe:	4152      	adcs	r2, r2
c0d09500:	0b03      	lsrs	r3, r0, #12
c0d09502:	428b      	cmp	r3, r1
c0d09504:	d301      	bcc.n	c0d0950a <__udivsi3+0x6a>
c0d09506:	030b      	lsls	r3, r1, #12
c0d09508:	1ac0      	subs	r0, r0, r3
c0d0950a:	4152      	adcs	r2, r2
c0d0950c:	0ac3      	lsrs	r3, r0, #11
c0d0950e:	428b      	cmp	r3, r1
c0d09510:	d301      	bcc.n	c0d09516 <__udivsi3+0x76>
c0d09512:	02cb      	lsls	r3, r1, #11
c0d09514:	1ac0      	subs	r0, r0, r3
c0d09516:	4152      	adcs	r2, r2
c0d09518:	0a83      	lsrs	r3, r0, #10
c0d0951a:	428b      	cmp	r3, r1
c0d0951c:	d301      	bcc.n	c0d09522 <__udivsi3+0x82>
c0d0951e:	028b      	lsls	r3, r1, #10
c0d09520:	1ac0      	subs	r0, r0, r3
c0d09522:	4152      	adcs	r2, r2
c0d09524:	0a43      	lsrs	r3, r0, #9
c0d09526:	428b      	cmp	r3, r1
c0d09528:	d301      	bcc.n	c0d0952e <__udivsi3+0x8e>
c0d0952a:	024b      	lsls	r3, r1, #9
c0d0952c:	1ac0      	subs	r0, r0, r3
c0d0952e:	4152      	adcs	r2, r2
c0d09530:	0a03      	lsrs	r3, r0, #8
c0d09532:	428b      	cmp	r3, r1
c0d09534:	d301      	bcc.n	c0d0953a <__udivsi3+0x9a>
c0d09536:	020b      	lsls	r3, r1, #8
c0d09538:	1ac0      	subs	r0, r0, r3
c0d0953a:	4152      	adcs	r2, r2
c0d0953c:	d2cd      	bcs.n	c0d094da <__udivsi3+0x3a>
c0d0953e:	09c3      	lsrs	r3, r0, #7
c0d09540:	428b      	cmp	r3, r1
c0d09542:	d301      	bcc.n	c0d09548 <__udivsi3+0xa8>
c0d09544:	01cb      	lsls	r3, r1, #7
c0d09546:	1ac0      	subs	r0, r0, r3
c0d09548:	4152      	adcs	r2, r2
c0d0954a:	0983      	lsrs	r3, r0, #6
c0d0954c:	428b      	cmp	r3, r1
c0d0954e:	d301      	bcc.n	c0d09554 <__udivsi3+0xb4>
c0d09550:	018b      	lsls	r3, r1, #6
c0d09552:	1ac0      	subs	r0, r0, r3
c0d09554:	4152      	adcs	r2, r2
c0d09556:	0943      	lsrs	r3, r0, #5
c0d09558:	428b      	cmp	r3, r1
c0d0955a:	d301      	bcc.n	c0d09560 <__udivsi3+0xc0>
c0d0955c:	014b      	lsls	r3, r1, #5
c0d0955e:	1ac0      	subs	r0, r0, r3
c0d09560:	4152      	adcs	r2, r2
c0d09562:	0903      	lsrs	r3, r0, #4
c0d09564:	428b      	cmp	r3, r1
c0d09566:	d301      	bcc.n	c0d0956c <__udivsi3+0xcc>
c0d09568:	010b      	lsls	r3, r1, #4
c0d0956a:	1ac0      	subs	r0, r0, r3
c0d0956c:	4152      	adcs	r2, r2
c0d0956e:	08c3      	lsrs	r3, r0, #3
c0d09570:	428b      	cmp	r3, r1
c0d09572:	d301      	bcc.n	c0d09578 <__udivsi3+0xd8>
c0d09574:	00cb      	lsls	r3, r1, #3
c0d09576:	1ac0      	subs	r0, r0, r3
c0d09578:	4152      	adcs	r2, r2
c0d0957a:	0883      	lsrs	r3, r0, #2
c0d0957c:	428b      	cmp	r3, r1
c0d0957e:	d301      	bcc.n	c0d09584 <__udivsi3+0xe4>
c0d09580:	008b      	lsls	r3, r1, #2
c0d09582:	1ac0      	subs	r0, r0, r3
c0d09584:	4152      	adcs	r2, r2
c0d09586:	0843      	lsrs	r3, r0, #1
c0d09588:	428b      	cmp	r3, r1
c0d0958a:	d301      	bcc.n	c0d09590 <__udivsi3+0xf0>
c0d0958c:	004b      	lsls	r3, r1, #1
c0d0958e:	1ac0      	subs	r0, r0, r3
c0d09590:	4152      	adcs	r2, r2
c0d09592:	1a41      	subs	r1, r0, r1
c0d09594:	d200      	bcs.n	c0d09598 <__udivsi3+0xf8>
c0d09596:	4601      	mov	r1, r0
c0d09598:	4152      	adcs	r2, r2
c0d0959a:	4610      	mov	r0, r2
c0d0959c:	4770      	bx	lr
c0d0959e:	e7ff      	b.n	c0d095a0 <__udivsi3+0x100>
c0d095a0:	b501      	push	{r0, lr}
c0d095a2:	2000      	movs	r0, #0
c0d095a4:	f000 f806 	bl	c0d095b4 <__aeabi_idiv0>
c0d095a8:	bd02      	pop	{r1, pc}
c0d095aa:	46c0      	nop			; (mov r8, r8)

c0d095ac <__aeabi_uidivmod>:
c0d095ac:	2900      	cmp	r1, #0
c0d095ae:	d0f7      	beq.n	c0d095a0 <__udivsi3+0x100>
c0d095b0:	e776      	b.n	c0d094a0 <__udivsi3>
c0d095b2:	4770      	bx	lr

c0d095b4 <__aeabi_idiv0>:
c0d095b4:	4770      	bx	lr
c0d095b6:	46c0      	nop			; (mov r8, r8)

c0d095b8 <__aeabi_llsr>:
c0d095b8:	40d0      	lsrs	r0, r2
c0d095ba:	000b      	movs	r3, r1
c0d095bc:	40d1      	lsrs	r1, r2
c0d095be:	469c      	mov	ip, r3
c0d095c0:	3a20      	subs	r2, #32
c0d095c2:	40d3      	lsrs	r3, r2
c0d095c4:	4318      	orrs	r0, r3
c0d095c6:	4252      	negs	r2, r2
c0d095c8:	4663      	mov	r3, ip
c0d095ca:	4093      	lsls	r3, r2
c0d095cc:	4318      	orrs	r0, r3
c0d095ce:	4770      	bx	lr

c0d095d0 <__aeabi_llsl>:
c0d095d0:	4091      	lsls	r1, r2
c0d095d2:	0003      	movs	r3, r0
c0d095d4:	4090      	lsls	r0, r2
c0d095d6:	469c      	mov	ip, r3
c0d095d8:	3a20      	subs	r2, #32
c0d095da:	4093      	lsls	r3, r2
c0d095dc:	4319      	orrs	r1, r3
c0d095de:	4252      	negs	r2, r2
c0d095e0:	4663      	mov	r3, ip
c0d095e2:	40d3      	lsrs	r3, r2
c0d095e4:	4319      	orrs	r1, r3
c0d095e6:	4770      	bx	lr

c0d095e8 <__aeabi_memclr>:
c0d095e8:	b510      	push	{r4, lr}
c0d095ea:	2200      	movs	r2, #0
c0d095ec:	f000 f80a 	bl	c0d09604 <__aeabi_memset>
c0d095f0:	bd10      	pop	{r4, pc}
c0d095f2:	46c0      	nop			; (mov r8, r8)

c0d095f4 <__aeabi_memcpy>:
c0d095f4:	b510      	push	{r4, lr}
c0d095f6:	f000 f835 	bl	c0d09664 <memcpy>
c0d095fa:	bd10      	pop	{r4, pc}

c0d095fc <__aeabi_memmove>:
c0d095fc:	b510      	push	{r4, lr}
c0d095fe:	f000 f883 	bl	c0d09708 <memmove>
c0d09602:	bd10      	pop	{r4, pc}

c0d09604 <__aeabi_memset>:
c0d09604:	000b      	movs	r3, r1
c0d09606:	b510      	push	{r4, lr}
c0d09608:	0011      	movs	r1, r2
c0d0960a:	001a      	movs	r2, r3
c0d0960c:	f000 f8d2 	bl	c0d097b4 <memset>
c0d09610:	bd10      	pop	{r4, pc}
c0d09612:	46c0      	nop			; (mov r8, r8)

c0d09614 <explicit_bzero>:
c0d09614:	b510      	push	{r4, lr}
c0d09616:	f000 fa5d 	bl	c0d09ad4 <bzero>
c0d0961a:	bd10      	pop	{r4, pc}

c0d0961c <memcmp>:
c0d0961c:	b530      	push	{r4, r5, lr}
c0d0961e:	2a03      	cmp	r2, #3
c0d09620:	d90c      	bls.n	c0d0963c <memcmp+0x20>
c0d09622:	0003      	movs	r3, r0
c0d09624:	430b      	orrs	r3, r1
c0d09626:	079b      	lsls	r3, r3, #30
c0d09628:	d119      	bne.n	c0d0965e <memcmp+0x42>
c0d0962a:	6803      	ldr	r3, [r0, #0]
c0d0962c:	680c      	ldr	r4, [r1, #0]
c0d0962e:	42a3      	cmp	r3, r4
c0d09630:	d115      	bne.n	c0d0965e <memcmp+0x42>
c0d09632:	3a04      	subs	r2, #4
c0d09634:	3004      	adds	r0, #4
c0d09636:	3104      	adds	r1, #4
c0d09638:	2a03      	cmp	r2, #3
c0d0963a:	d8f6      	bhi.n	c0d0962a <memcmp+0xe>
c0d0963c:	1e55      	subs	r5, r2, #1
c0d0963e:	2a00      	cmp	r2, #0
c0d09640:	d00b      	beq.n	c0d0965a <memcmp+0x3e>
c0d09642:	2300      	movs	r3, #0
c0d09644:	e003      	b.n	c0d0964e <memcmp+0x32>
c0d09646:	1c5a      	adds	r2, r3, #1
c0d09648:	429d      	cmp	r5, r3
c0d0964a:	d006      	beq.n	c0d0965a <memcmp+0x3e>
c0d0964c:	0013      	movs	r3, r2
c0d0964e:	5cc2      	ldrb	r2, [r0, r3]
c0d09650:	5ccc      	ldrb	r4, [r1, r3]
c0d09652:	42a2      	cmp	r2, r4
c0d09654:	d0f7      	beq.n	c0d09646 <memcmp+0x2a>
c0d09656:	1b10      	subs	r0, r2, r4
c0d09658:	e000      	b.n	c0d0965c <memcmp+0x40>
c0d0965a:	2000      	movs	r0, #0
c0d0965c:	bd30      	pop	{r4, r5, pc}
c0d0965e:	1e55      	subs	r5, r2, #1
c0d09660:	e7ef      	b.n	c0d09642 <memcmp+0x26>
c0d09662:	46c0      	nop			; (mov r8, r8)

c0d09664 <memcpy>:
c0d09664:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09666:	46c6      	mov	lr, r8
c0d09668:	b500      	push	{lr}
c0d0966a:	2a0f      	cmp	r2, #15
c0d0966c:	d941      	bls.n	c0d096f2 <memcpy+0x8e>
c0d0966e:	2703      	movs	r7, #3
c0d09670:	000d      	movs	r5, r1
c0d09672:	003e      	movs	r6, r7
c0d09674:	4305      	orrs	r5, r0
c0d09676:	000c      	movs	r4, r1
c0d09678:	0003      	movs	r3, r0
c0d0967a:	402e      	ands	r6, r5
c0d0967c:	422f      	tst	r7, r5
c0d0967e:	d13d      	bne.n	c0d096fc <memcpy+0x98>
c0d09680:	0015      	movs	r5, r2
c0d09682:	3d10      	subs	r5, #16
c0d09684:	092d      	lsrs	r5, r5, #4
c0d09686:	46a8      	mov	r8, r5
c0d09688:	012d      	lsls	r5, r5, #4
c0d0968a:	46ac      	mov	ip, r5
c0d0968c:	4484      	add	ip, r0
c0d0968e:	6827      	ldr	r7, [r4, #0]
c0d09690:	001d      	movs	r5, r3
c0d09692:	601f      	str	r7, [r3, #0]
c0d09694:	6867      	ldr	r7, [r4, #4]
c0d09696:	605f      	str	r7, [r3, #4]
c0d09698:	68a7      	ldr	r7, [r4, #8]
c0d0969a:	609f      	str	r7, [r3, #8]
c0d0969c:	68e7      	ldr	r7, [r4, #12]
c0d0969e:	3410      	adds	r4, #16
c0d096a0:	60df      	str	r7, [r3, #12]
c0d096a2:	3310      	adds	r3, #16
c0d096a4:	4565      	cmp	r5, ip
c0d096a6:	d1f2      	bne.n	c0d0968e <memcpy+0x2a>
c0d096a8:	4645      	mov	r5, r8
c0d096aa:	230f      	movs	r3, #15
c0d096ac:	240c      	movs	r4, #12
c0d096ae:	3501      	adds	r5, #1
c0d096b0:	012d      	lsls	r5, r5, #4
c0d096b2:	1949      	adds	r1, r1, r5
c0d096b4:	4013      	ands	r3, r2
c0d096b6:	1945      	adds	r5, r0, r5
c0d096b8:	4214      	tst	r4, r2
c0d096ba:	d022      	beq.n	c0d09702 <memcpy+0x9e>
c0d096bc:	598c      	ldr	r4, [r1, r6]
c0d096be:	51ac      	str	r4, [r5, r6]
c0d096c0:	3604      	adds	r6, #4
c0d096c2:	1b9c      	subs	r4, r3, r6
c0d096c4:	2c03      	cmp	r4, #3
c0d096c6:	d8f9      	bhi.n	c0d096bc <memcpy+0x58>
c0d096c8:	3b04      	subs	r3, #4
c0d096ca:	089b      	lsrs	r3, r3, #2
c0d096cc:	3301      	adds	r3, #1
c0d096ce:	009b      	lsls	r3, r3, #2
c0d096d0:	18ed      	adds	r5, r5, r3
c0d096d2:	18c9      	adds	r1, r1, r3
c0d096d4:	2303      	movs	r3, #3
c0d096d6:	401a      	ands	r2, r3
c0d096d8:	1e56      	subs	r6, r2, #1
c0d096da:	2a00      	cmp	r2, #0
c0d096dc:	d006      	beq.n	c0d096ec <memcpy+0x88>
c0d096de:	2300      	movs	r3, #0
c0d096e0:	5ccc      	ldrb	r4, [r1, r3]
c0d096e2:	001a      	movs	r2, r3
c0d096e4:	54ec      	strb	r4, [r5, r3]
c0d096e6:	3301      	adds	r3, #1
c0d096e8:	4296      	cmp	r6, r2
c0d096ea:	d1f9      	bne.n	c0d096e0 <memcpy+0x7c>
c0d096ec:	bc80      	pop	{r7}
c0d096ee:	46b8      	mov	r8, r7
c0d096f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d096f2:	0005      	movs	r5, r0
c0d096f4:	1e56      	subs	r6, r2, #1
c0d096f6:	2a00      	cmp	r2, #0
c0d096f8:	d1f1      	bne.n	c0d096de <memcpy+0x7a>
c0d096fa:	e7f7      	b.n	c0d096ec <memcpy+0x88>
c0d096fc:	0005      	movs	r5, r0
c0d096fe:	1e56      	subs	r6, r2, #1
c0d09700:	e7ed      	b.n	c0d096de <memcpy+0x7a>
c0d09702:	001a      	movs	r2, r3
c0d09704:	e7f6      	b.n	c0d096f4 <memcpy+0x90>
c0d09706:	46c0      	nop			; (mov r8, r8)

c0d09708 <memmove>:
c0d09708:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0970a:	4288      	cmp	r0, r1
c0d0970c:	d90a      	bls.n	c0d09724 <memmove+0x1c>
c0d0970e:	188b      	adds	r3, r1, r2
c0d09710:	4298      	cmp	r0, r3
c0d09712:	d207      	bcs.n	c0d09724 <memmove+0x1c>
c0d09714:	1e53      	subs	r3, r2, #1
c0d09716:	2a00      	cmp	r2, #0
c0d09718:	d003      	beq.n	c0d09722 <memmove+0x1a>
c0d0971a:	5cca      	ldrb	r2, [r1, r3]
c0d0971c:	54c2      	strb	r2, [r0, r3]
c0d0971e:	3b01      	subs	r3, #1
c0d09720:	d2fb      	bcs.n	c0d0971a <memmove+0x12>
c0d09722:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d09724:	2a0f      	cmp	r2, #15
c0d09726:	d80b      	bhi.n	c0d09740 <memmove+0x38>
c0d09728:	0005      	movs	r5, r0
c0d0972a:	1e56      	subs	r6, r2, #1
c0d0972c:	2a00      	cmp	r2, #0
c0d0972e:	d0f8      	beq.n	c0d09722 <memmove+0x1a>
c0d09730:	2300      	movs	r3, #0
c0d09732:	5ccc      	ldrb	r4, [r1, r3]
c0d09734:	001a      	movs	r2, r3
c0d09736:	54ec      	strb	r4, [r5, r3]
c0d09738:	3301      	adds	r3, #1
c0d0973a:	4296      	cmp	r6, r2
c0d0973c:	d1f9      	bne.n	c0d09732 <memmove+0x2a>
c0d0973e:	e7f0      	b.n	c0d09722 <memmove+0x1a>
c0d09740:	2703      	movs	r7, #3
c0d09742:	000d      	movs	r5, r1
c0d09744:	003e      	movs	r6, r7
c0d09746:	4305      	orrs	r5, r0
c0d09748:	000c      	movs	r4, r1
c0d0974a:	0003      	movs	r3, r0
c0d0974c:	402e      	ands	r6, r5
c0d0974e:	422f      	tst	r7, r5
c0d09750:	d12b      	bne.n	c0d097aa <memmove+0xa2>
c0d09752:	0015      	movs	r5, r2
c0d09754:	3d10      	subs	r5, #16
c0d09756:	092d      	lsrs	r5, r5, #4
c0d09758:	46ac      	mov	ip, r5
c0d0975a:	012f      	lsls	r7, r5, #4
c0d0975c:	183f      	adds	r7, r7, r0
c0d0975e:	6825      	ldr	r5, [r4, #0]
c0d09760:	601d      	str	r5, [r3, #0]
c0d09762:	6865      	ldr	r5, [r4, #4]
c0d09764:	605d      	str	r5, [r3, #4]
c0d09766:	68a5      	ldr	r5, [r4, #8]
c0d09768:	609d      	str	r5, [r3, #8]
c0d0976a:	68e5      	ldr	r5, [r4, #12]
c0d0976c:	3410      	adds	r4, #16
c0d0976e:	60dd      	str	r5, [r3, #12]
c0d09770:	001d      	movs	r5, r3
c0d09772:	3310      	adds	r3, #16
c0d09774:	42bd      	cmp	r5, r7
c0d09776:	d1f2      	bne.n	c0d0975e <memmove+0x56>
c0d09778:	4665      	mov	r5, ip
c0d0977a:	230f      	movs	r3, #15
c0d0977c:	240c      	movs	r4, #12
c0d0977e:	3501      	adds	r5, #1
c0d09780:	012d      	lsls	r5, r5, #4
c0d09782:	1949      	adds	r1, r1, r5
c0d09784:	4013      	ands	r3, r2
c0d09786:	1945      	adds	r5, r0, r5
c0d09788:	4214      	tst	r4, r2
c0d0978a:	d011      	beq.n	c0d097b0 <memmove+0xa8>
c0d0978c:	598c      	ldr	r4, [r1, r6]
c0d0978e:	51ac      	str	r4, [r5, r6]
c0d09790:	3604      	adds	r6, #4
c0d09792:	1b9c      	subs	r4, r3, r6
c0d09794:	2c03      	cmp	r4, #3
c0d09796:	d8f9      	bhi.n	c0d0978c <memmove+0x84>
c0d09798:	3b04      	subs	r3, #4
c0d0979a:	089b      	lsrs	r3, r3, #2
c0d0979c:	3301      	adds	r3, #1
c0d0979e:	009b      	lsls	r3, r3, #2
c0d097a0:	18ed      	adds	r5, r5, r3
c0d097a2:	18c9      	adds	r1, r1, r3
c0d097a4:	2303      	movs	r3, #3
c0d097a6:	401a      	ands	r2, r3
c0d097a8:	e7bf      	b.n	c0d0972a <memmove+0x22>
c0d097aa:	0005      	movs	r5, r0
c0d097ac:	1e56      	subs	r6, r2, #1
c0d097ae:	e7bf      	b.n	c0d09730 <memmove+0x28>
c0d097b0:	001a      	movs	r2, r3
c0d097b2:	e7ba      	b.n	c0d0972a <memmove+0x22>

c0d097b4 <memset>:
c0d097b4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d097b6:	0005      	movs	r5, r0
c0d097b8:	0783      	lsls	r3, r0, #30
c0d097ba:	d049      	beq.n	c0d09850 <memset+0x9c>
c0d097bc:	1e54      	subs	r4, r2, #1
c0d097be:	2a00      	cmp	r2, #0
c0d097c0:	d045      	beq.n	c0d0984e <memset+0x9a>
c0d097c2:	0003      	movs	r3, r0
c0d097c4:	2603      	movs	r6, #3
c0d097c6:	b2ca      	uxtb	r2, r1
c0d097c8:	e002      	b.n	c0d097d0 <memset+0x1c>
c0d097ca:	3501      	adds	r5, #1
c0d097cc:	3c01      	subs	r4, #1
c0d097ce:	d33e      	bcc.n	c0d0984e <memset+0x9a>
c0d097d0:	3301      	adds	r3, #1
c0d097d2:	702a      	strb	r2, [r5, #0]
c0d097d4:	4233      	tst	r3, r6
c0d097d6:	d1f8      	bne.n	c0d097ca <memset+0x16>
c0d097d8:	2c03      	cmp	r4, #3
c0d097da:	d930      	bls.n	c0d0983e <memset+0x8a>
c0d097dc:	22ff      	movs	r2, #255	; 0xff
c0d097de:	400a      	ands	r2, r1
c0d097e0:	0215      	lsls	r5, r2, #8
c0d097e2:	4315      	orrs	r5, r2
c0d097e4:	042a      	lsls	r2, r5, #16
c0d097e6:	4315      	orrs	r5, r2
c0d097e8:	2c0f      	cmp	r4, #15
c0d097ea:	d934      	bls.n	c0d09856 <memset+0xa2>
c0d097ec:	0027      	movs	r7, r4
c0d097ee:	3f10      	subs	r7, #16
c0d097f0:	093f      	lsrs	r7, r7, #4
c0d097f2:	013e      	lsls	r6, r7, #4
c0d097f4:	46b4      	mov	ip, r6
c0d097f6:	001e      	movs	r6, r3
c0d097f8:	001a      	movs	r2, r3
c0d097fa:	3610      	adds	r6, #16
c0d097fc:	4466      	add	r6, ip
c0d097fe:	6015      	str	r5, [r2, #0]
c0d09800:	6055      	str	r5, [r2, #4]
c0d09802:	6095      	str	r5, [r2, #8]
c0d09804:	60d5      	str	r5, [r2, #12]
c0d09806:	3210      	adds	r2, #16
c0d09808:	42b2      	cmp	r2, r6
c0d0980a:	d1f8      	bne.n	c0d097fe <memset+0x4a>
c0d0980c:	3701      	adds	r7, #1
c0d0980e:	013f      	lsls	r7, r7, #4
c0d09810:	19db      	adds	r3, r3, r7
c0d09812:	270f      	movs	r7, #15
c0d09814:	220c      	movs	r2, #12
c0d09816:	4027      	ands	r7, r4
c0d09818:	4022      	ands	r2, r4
c0d0981a:	003c      	movs	r4, r7
c0d0981c:	2a00      	cmp	r2, #0
c0d0981e:	d00e      	beq.n	c0d0983e <memset+0x8a>
c0d09820:	1f3e      	subs	r6, r7, #4
c0d09822:	08b6      	lsrs	r6, r6, #2
c0d09824:	00b4      	lsls	r4, r6, #2
c0d09826:	46a4      	mov	ip, r4
c0d09828:	001a      	movs	r2, r3
c0d0982a:	1d1c      	adds	r4, r3, #4
c0d0982c:	4464      	add	r4, ip
c0d0982e:	c220      	stmia	r2!, {r5}
c0d09830:	42a2      	cmp	r2, r4
c0d09832:	d1fc      	bne.n	c0d0982e <memset+0x7a>
c0d09834:	2403      	movs	r4, #3
c0d09836:	3601      	adds	r6, #1
c0d09838:	00b6      	lsls	r6, r6, #2
c0d0983a:	199b      	adds	r3, r3, r6
c0d0983c:	403c      	ands	r4, r7
c0d0983e:	2c00      	cmp	r4, #0
c0d09840:	d005      	beq.n	c0d0984e <memset+0x9a>
c0d09842:	b2c9      	uxtb	r1, r1
c0d09844:	191c      	adds	r4, r3, r4
c0d09846:	7019      	strb	r1, [r3, #0]
c0d09848:	3301      	adds	r3, #1
c0d0984a:	429c      	cmp	r4, r3
c0d0984c:	d1fb      	bne.n	c0d09846 <memset+0x92>
c0d0984e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d09850:	0003      	movs	r3, r0
c0d09852:	0014      	movs	r4, r2
c0d09854:	e7c0      	b.n	c0d097d8 <memset+0x24>
c0d09856:	0027      	movs	r7, r4
c0d09858:	e7e2      	b.n	c0d09820 <memset+0x6c>
c0d0985a:	46c0      	nop			; (mov r8, r8)

c0d0985c <setjmp>:
c0d0985c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
c0d0985e:	4641      	mov	r1, r8
c0d09860:	464a      	mov	r2, r9
c0d09862:	4653      	mov	r3, sl
c0d09864:	465c      	mov	r4, fp
c0d09866:	466d      	mov	r5, sp
c0d09868:	4676      	mov	r6, lr
c0d0986a:	c07e      	stmia	r0!, {r1, r2, r3, r4, r5, r6}
c0d0986c:	3828      	subs	r0, #40	; 0x28
c0d0986e:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
c0d09870:	2000      	movs	r0, #0
c0d09872:	4770      	bx	lr

c0d09874 <longjmp>:
c0d09874:	3010      	adds	r0, #16
c0d09876:	c87c      	ldmia	r0!, {r2, r3, r4, r5, r6}
c0d09878:	4690      	mov	r8, r2
c0d0987a:	4699      	mov	r9, r3
c0d0987c:	46a2      	mov	sl, r4
c0d0987e:	46ab      	mov	fp, r5
c0d09880:	46b5      	mov	sp, r6
c0d09882:	c808      	ldmia	r0!, {r3}
c0d09884:	3828      	subs	r0, #40	; 0x28
c0d09886:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
c0d09888:	1c08      	adds	r0, r1, #0
c0d0988a:	d100      	bne.n	c0d0988e <longjmp+0x1a>
c0d0988c:	2001      	movs	r0, #1
c0d0988e:	4718      	bx	r3

c0d09890 <strcat>:
c0d09890:	b570      	push	{r4, r5, r6, lr}
c0d09892:	0004      	movs	r4, r0
c0d09894:	0783      	lsls	r3, r0, #30
c0d09896:	d116      	bne.n	c0d098c6 <strcat+0x36>
c0d09898:	6802      	ldr	r2, [r0, #0]
c0d0989a:	4b0e      	ldr	r3, [pc, #56]	; (c0d098d4 <strcat+0x44>)
c0d0989c:	4d0e      	ldr	r5, [pc, #56]	; (c0d098d8 <strcat+0x48>)
c0d0989e:	18d3      	adds	r3, r2, r3
c0d098a0:	4393      	bics	r3, r2
c0d098a2:	422b      	tst	r3, r5
c0d098a4:	d10f      	bne.n	c0d098c6 <strcat+0x36>
c0d098a6:	6842      	ldr	r2, [r0, #4]
c0d098a8:	4b0a      	ldr	r3, [pc, #40]	; (c0d098d4 <strcat+0x44>)
c0d098aa:	3004      	adds	r0, #4
c0d098ac:	18d3      	adds	r3, r2, r3
c0d098ae:	4393      	bics	r3, r2
c0d098b0:	422b      	tst	r3, r5
c0d098b2:	d108      	bne.n	c0d098c6 <strcat+0x36>
c0d098b4:	6842      	ldr	r2, [r0, #4]
c0d098b6:	4b07      	ldr	r3, [pc, #28]	; (c0d098d4 <strcat+0x44>)
c0d098b8:	3004      	adds	r0, #4
c0d098ba:	18d3      	adds	r3, r2, r3
c0d098bc:	4393      	bics	r3, r2
c0d098be:	422b      	tst	r3, r5
c0d098c0:	d0f1      	beq.n	c0d098a6 <strcat+0x16>
c0d098c2:	e000      	b.n	c0d098c6 <strcat+0x36>
c0d098c4:	3001      	adds	r0, #1
c0d098c6:	7803      	ldrb	r3, [r0, #0]
c0d098c8:	2b00      	cmp	r3, #0
c0d098ca:	d1fb      	bne.n	c0d098c4 <strcat+0x34>
c0d098cc:	f000 f84a 	bl	c0d09964 <strcpy>
c0d098d0:	0020      	movs	r0, r4
c0d098d2:	bd70      	pop	{r4, r5, r6, pc}
c0d098d4:	fefefeff 	.word	0xfefefeff
c0d098d8:	80808080 	.word	0x80808080

c0d098dc <strcmp>:
c0d098dc:	4602      	mov	r2, r0
c0d098de:	b570      	push	{r4, r5, r6, lr}
c0d098e0:	430a      	orrs	r2, r1
c0d098e2:	0792      	lsls	r2, r2, #30
c0d098e4:	d12a      	bne.n	c0d0993c <strcmp+0x60>
c0d098e6:	4d1e      	ldr	r5, [pc, #120]	; (c0d09960 <strcmp+0x84>)
c0d098e8:	01ee      	lsls	r6, r5, #7
c0d098ea:	c804      	ldmia	r0!, {r2}
c0d098ec:	c908      	ldmia	r1!, {r3}
c0d098ee:	1b54      	subs	r4, r2, r5
c0d098f0:	4394      	bics	r4, r2
c0d098f2:	4034      	ands	r4, r6
c0d098f4:	d017      	beq.n	c0d09926 <strcmp+0x4a>
c0d098f6:	b2d0      	uxtb	r0, r2
c0d098f8:	b2d9      	uxtb	r1, r3
c0d098fa:	1a40      	subs	r0, r0, r1
c0d098fc:	0621      	lsls	r1, r4, #24
c0d098fe:	4301      	orrs	r1, r0
c0d09900:	d110      	bne.n	c0d09924 <strcmp+0x48>
c0d09902:	b290      	uxth	r0, r2
c0d09904:	b299      	uxth	r1, r3
c0d09906:	1a40      	subs	r0, r0, r1
c0d09908:	0421      	lsls	r1, r4, #16
c0d0990a:	4301      	orrs	r1, r0
c0d0990c:	d10a      	bne.n	c0d09924 <strcmp+0x48>
c0d0990e:	0210      	lsls	r0, r2, #8
c0d09910:	0219      	lsls	r1, r3, #8
c0d09912:	0a00      	lsrs	r0, r0, #8
c0d09914:	0a09      	lsrs	r1, r1, #8
c0d09916:	1a40      	subs	r0, r0, r1
c0d09918:	0221      	lsls	r1, r4, #8
c0d0991a:	4301      	orrs	r1, r0
c0d0991c:	d102      	bne.n	c0d09924 <strcmp+0x48>
c0d0991e:	0e10      	lsrs	r0, r2, #24
c0d09920:	0e19      	lsrs	r1, r3, #24
c0d09922:	1a40      	subs	r0, r0, r1
c0d09924:	bd70      	pop	{r4, r5, r6, pc}
c0d09926:	429a      	cmp	r2, r3
c0d09928:	d0df      	beq.n	c0d098ea <strcmp+0xe>
c0d0992a:	ba10      	rev	r0, r2
c0d0992c:	ba19      	rev	r1, r3
c0d0992e:	4288      	cmp	r0, r1
c0d09930:	d901      	bls.n	c0d09936 <strcmp+0x5a>
c0d09932:	2001      	movs	r0, #1
c0d09934:	bd70      	pop	{r4, r5, r6, pc}
c0d09936:	2000      	movs	r0, #0
c0d09938:	43c0      	mvns	r0, r0
c0d0993a:	bd70      	pop	{r4, r5, r6, pc}
c0d0993c:	7802      	ldrb	r2, [r0, #0]
c0d0993e:	780b      	ldrb	r3, [r1, #0]
c0d09940:	3001      	adds	r0, #1
c0d09942:	3101      	adds	r1, #1
c0d09944:	2a00      	cmp	r2, #0
c0d09946:	d009      	beq.n	c0d0995c <strcmp+0x80>
c0d09948:	429a      	cmp	r2, r3
c0d0994a:	d107      	bne.n	c0d0995c <strcmp+0x80>
c0d0994c:	7802      	ldrb	r2, [r0, #0]
c0d0994e:	780b      	ldrb	r3, [r1, #0]
c0d09950:	3001      	adds	r0, #1
c0d09952:	3101      	adds	r1, #1
c0d09954:	2a00      	cmp	r2, #0
c0d09956:	d001      	beq.n	c0d0995c <strcmp+0x80>
c0d09958:	429a      	cmp	r2, r3
c0d0995a:	d0ef      	beq.n	c0d0993c <strcmp+0x60>
c0d0995c:	1ad0      	subs	r0, r2, r3
c0d0995e:	bd70      	pop	{r4, r5, r6, pc}
c0d09960:	01010101 	.word	0x01010101

c0d09964 <strcpy>:
c0d09964:	0003      	movs	r3, r0
c0d09966:	780a      	ldrb	r2, [r1, #0]
c0d09968:	3101      	adds	r1, #1
c0d0996a:	701a      	strb	r2, [r3, #0]
c0d0996c:	3301      	adds	r3, #1
c0d0996e:	2a00      	cmp	r2, #0
c0d09970:	d1f9      	bne.n	c0d09966 <strcpy+0x2>
c0d09972:	4770      	bx	lr

c0d09974 <strlen>:
c0d09974:	b510      	push	{r4, lr}
c0d09976:	0783      	lsls	r3, r0, #30
c0d09978:	d00a      	beq.n	c0d09990 <strlen+0x1c>
c0d0997a:	0003      	movs	r3, r0
c0d0997c:	2103      	movs	r1, #3
c0d0997e:	e002      	b.n	c0d09986 <strlen+0x12>
c0d09980:	3301      	adds	r3, #1
c0d09982:	420b      	tst	r3, r1
c0d09984:	d005      	beq.n	c0d09992 <strlen+0x1e>
c0d09986:	781a      	ldrb	r2, [r3, #0]
c0d09988:	2a00      	cmp	r2, #0
c0d0998a:	d1f9      	bne.n	c0d09980 <strlen+0xc>
c0d0998c:	1a18      	subs	r0, r3, r0
c0d0998e:	bd10      	pop	{r4, pc}
c0d09990:	0003      	movs	r3, r0
c0d09992:	6819      	ldr	r1, [r3, #0]
c0d09994:	4a0c      	ldr	r2, [pc, #48]	; (c0d099c8 <strlen+0x54>)
c0d09996:	4c0d      	ldr	r4, [pc, #52]	; (c0d099cc <strlen+0x58>)
c0d09998:	188a      	adds	r2, r1, r2
c0d0999a:	438a      	bics	r2, r1
c0d0999c:	4222      	tst	r2, r4
c0d0999e:	d10f      	bne.n	c0d099c0 <strlen+0x4c>
c0d099a0:	6859      	ldr	r1, [r3, #4]
c0d099a2:	4a09      	ldr	r2, [pc, #36]	; (c0d099c8 <strlen+0x54>)
c0d099a4:	3304      	adds	r3, #4
c0d099a6:	188a      	adds	r2, r1, r2
c0d099a8:	438a      	bics	r2, r1
c0d099aa:	4222      	tst	r2, r4
c0d099ac:	d108      	bne.n	c0d099c0 <strlen+0x4c>
c0d099ae:	6859      	ldr	r1, [r3, #4]
c0d099b0:	4a05      	ldr	r2, [pc, #20]	; (c0d099c8 <strlen+0x54>)
c0d099b2:	3304      	adds	r3, #4
c0d099b4:	188a      	adds	r2, r1, r2
c0d099b6:	438a      	bics	r2, r1
c0d099b8:	4222      	tst	r2, r4
c0d099ba:	d0f1      	beq.n	c0d099a0 <strlen+0x2c>
c0d099bc:	e000      	b.n	c0d099c0 <strlen+0x4c>
c0d099be:	3301      	adds	r3, #1
c0d099c0:	781a      	ldrb	r2, [r3, #0]
c0d099c2:	2a00      	cmp	r2, #0
c0d099c4:	d1fb      	bne.n	c0d099be <strlen+0x4a>
c0d099c6:	e7e1      	b.n	c0d0998c <strlen+0x18>
c0d099c8:	fefefeff 	.word	0xfefefeff
c0d099cc:	80808080 	.word	0x80808080

c0d099d0 <strncmp>:
c0d099d0:	b530      	push	{r4, r5, lr}
c0d099d2:	2a00      	cmp	r2, #0
c0d099d4:	d026      	beq.n	c0d09a24 <strncmp+0x54>
c0d099d6:	0003      	movs	r3, r0
c0d099d8:	430b      	orrs	r3, r1
c0d099da:	079b      	lsls	r3, r3, #30
c0d099dc:	d124      	bne.n	c0d09a28 <strncmp+0x58>
c0d099de:	2a03      	cmp	r2, #3
c0d099e0:	d922      	bls.n	c0d09a28 <strncmp+0x58>
c0d099e2:	4d16      	ldr	r5, [pc, #88]	; (c0d09a3c <strncmp+0x6c>)
c0d099e4:	e00b      	b.n	c0d099fe <strncmp+0x2e>
c0d099e6:	3a04      	subs	r2, #4
c0d099e8:	2a00      	cmp	r2, #0
c0d099ea:	d01b      	beq.n	c0d09a24 <strncmp+0x54>
c0d099ec:	4c14      	ldr	r4, [pc, #80]	; (c0d09a40 <strncmp+0x70>)
c0d099ee:	191c      	adds	r4, r3, r4
c0d099f0:	439c      	bics	r4, r3
c0d099f2:	422c      	tst	r4, r5
c0d099f4:	d116      	bne.n	c0d09a24 <strncmp+0x54>
c0d099f6:	3004      	adds	r0, #4
c0d099f8:	3104      	adds	r1, #4
c0d099fa:	2a03      	cmp	r2, #3
c0d099fc:	d914      	bls.n	c0d09a28 <strncmp+0x58>
c0d099fe:	6803      	ldr	r3, [r0, #0]
c0d09a00:	680c      	ldr	r4, [r1, #0]
c0d09a02:	42a3      	cmp	r3, r4
c0d09a04:	d0ef      	beq.n	c0d099e6 <strncmp+0x16>
c0d09a06:	7804      	ldrb	r4, [r0, #0]
c0d09a08:	780d      	ldrb	r5, [r1, #0]
c0d09a0a:	42ac      	cmp	r4, r5
c0d09a0c:	d113      	bne.n	c0d09a36 <strncmp+0x66>
c0d09a0e:	2301      	movs	r3, #1
c0d09a10:	e006      	b.n	c0d09a20 <strncmp+0x50>
c0d09a12:	5cc4      	ldrb	r4, [r0, r3]
c0d09a14:	5ccd      	ldrb	r5, [r1, r3]
c0d09a16:	42ac      	cmp	r4, r5
c0d09a18:	d10d      	bne.n	c0d09a36 <strncmp+0x66>
c0d09a1a:	3301      	adds	r3, #1
c0d09a1c:	4293      	cmp	r3, r2
c0d09a1e:	d001      	beq.n	c0d09a24 <strncmp+0x54>
c0d09a20:	2c00      	cmp	r4, #0
c0d09a22:	d1f6      	bne.n	c0d09a12 <strncmp+0x42>
c0d09a24:	2000      	movs	r0, #0
c0d09a26:	bd30      	pop	{r4, r5, pc}
c0d09a28:	7804      	ldrb	r4, [r0, #0]
c0d09a2a:	780d      	ldrb	r5, [r1, #0]
c0d09a2c:	42a5      	cmp	r5, r4
c0d09a2e:	d102      	bne.n	c0d09a36 <strncmp+0x66>
c0d09a30:	2a01      	cmp	r2, #1
c0d09a32:	d1ec      	bne.n	c0d09a0e <strncmp+0x3e>
c0d09a34:	e7f6      	b.n	c0d09a24 <strncmp+0x54>
c0d09a36:	1b60      	subs	r0, r4, r5
c0d09a38:	e7f5      	b.n	c0d09a26 <strncmp+0x56>
c0d09a3a:	46c0      	nop			; (mov r8, r8)
c0d09a3c:	80808080 	.word	0x80808080
c0d09a40:	fefefeff 	.word	0xfefefeff

c0d09a44 <strncpy>:
c0d09a44:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d09a46:	000c      	movs	r4, r1
c0d09a48:	4304      	orrs	r4, r0
c0d09a4a:	0003      	movs	r3, r0
c0d09a4c:	0007      	movs	r7, r0
c0d09a4e:	07a4      	lsls	r4, r4, #30
c0d09a50:	d112      	bne.n	c0d09a78 <strncpy+0x34>
c0d09a52:	2a03      	cmp	r2, #3
c0d09a54:	d910      	bls.n	c0d09a78 <strncpy+0x34>
c0d09a56:	4c14      	ldr	r4, [pc, #80]	; (c0d09aa8 <strncpy+0x64>)
c0d09a58:	46a4      	mov	ip, r4
c0d09a5a:	4667      	mov	r7, ip
c0d09a5c:	680d      	ldr	r5, [r1, #0]
c0d09a5e:	4c13      	ldr	r4, [pc, #76]	; (c0d09aac <strncpy+0x68>)
c0d09a60:	001e      	movs	r6, r3
c0d09a62:	192c      	adds	r4, r5, r4
c0d09a64:	43ac      	bics	r4, r5
c0d09a66:	423c      	tst	r4, r7
c0d09a68:	d11b      	bne.n	c0d09aa2 <strncpy+0x5e>
c0d09a6a:	3304      	adds	r3, #4
c0d09a6c:	3a04      	subs	r2, #4
c0d09a6e:	001f      	movs	r7, r3
c0d09a70:	3104      	adds	r1, #4
c0d09a72:	6035      	str	r5, [r6, #0]
c0d09a74:	2a03      	cmp	r2, #3
c0d09a76:	d8f0      	bhi.n	c0d09a5a <strncpy+0x16>
c0d09a78:	2400      	movs	r4, #0
c0d09a7a:	18be      	adds	r6, r7, r2
c0d09a7c:	e006      	b.n	c0d09a8c <strncpy+0x48>
c0d09a7e:	5d0d      	ldrb	r5, [r1, r4]
c0d09a80:	3a01      	subs	r2, #1
c0d09a82:	553d      	strb	r5, [r7, r4]
c0d09a84:	1ab3      	subs	r3, r6, r2
c0d09a86:	3401      	adds	r4, #1
c0d09a88:	2d00      	cmp	r5, #0
c0d09a8a:	d002      	beq.n	c0d09a92 <strncpy+0x4e>
c0d09a8c:	2a00      	cmp	r2, #0
c0d09a8e:	d1f6      	bne.n	c0d09a7e <strncpy+0x3a>
c0d09a90:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d09a92:	2100      	movs	r1, #0
c0d09a94:	2a00      	cmp	r2, #0
c0d09a96:	d0fb      	beq.n	c0d09a90 <strncpy+0x4c>
c0d09a98:	7019      	strb	r1, [r3, #0]
c0d09a9a:	3301      	adds	r3, #1
c0d09a9c:	429e      	cmp	r6, r3
c0d09a9e:	d1fb      	bne.n	c0d09a98 <strncpy+0x54>
c0d09aa0:	e7f6      	b.n	c0d09a90 <strncpy+0x4c>
c0d09aa2:	001f      	movs	r7, r3
c0d09aa4:	e7e8      	b.n	c0d09a78 <strncpy+0x34>
c0d09aa6:	46c0      	nop			; (mov r8, r8)
c0d09aa8:	80808080 	.word	0x80808080
c0d09aac:	fefefeff 	.word	0xfefefeff

c0d09ab0 <strnlen>:
c0d09ab0:	b510      	push	{r4, lr}
c0d09ab2:	0003      	movs	r3, r0
c0d09ab4:	1844      	adds	r4, r0, r1
c0d09ab6:	2900      	cmp	r1, #0
c0d09ab8:	d103      	bne.n	c0d09ac2 <strnlen+0x12>
c0d09aba:	e009      	b.n	c0d09ad0 <strnlen+0x20>
c0d09abc:	3301      	adds	r3, #1
c0d09abe:	429c      	cmp	r4, r3
c0d09ac0:	d004      	beq.n	c0d09acc <strnlen+0x1c>
c0d09ac2:	781a      	ldrb	r2, [r3, #0]
c0d09ac4:	2a00      	cmp	r2, #0
c0d09ac6:	d1f9      	bne.n	c0d09abc <strnlen+0xc>
c0d09ac8:	1a18      	subs	r0, r3, r0
c0d09aca:	bd10      	pop	{r4, pc}
c0d09acc:	1a20      	subs	r0, r4, r0
c0d09ace:	e7fc      	b.n	c0d09aca <strnlen+0x1a>
c0d09ad0:	2000      	movs	r0, #0
c0d09ad2:	e7fa      	b.n	c0d09aca <strnlen+0x1a>

c0d09ad4 <bzero>:
c0d09ad4:	b510      	push	{r4, lr}
c0d09ad6:	000a      	movs	r2, r1
c0d09ad8:	2100      	movs	r1, #0
c0d09ada:	f7ff fe6b 	bl	c0d097b4 <memset>
c0d09ade:	bd10      	pop	{r4, pc}

c0d09ae0 <basis_64>:
c0d09ae0:	4241 4443 4645 4847 4a49 4c4b 4e4d 504f     ABCDEFGHIJKLMNOP
c0d09af0:	5251 5453 5655 5857 5a59 6261 6463 6665     QRSTUVWXYZabcdef
c0d09b00:	6867 6a69 6c6b 6e6d 706f 7271 7473 7675     ghijklmnopqrstuv
c0d09b10:	7877 7a79 3130 3332 3534 3736 3938 2f2b     wxyz0123456789+/
c0d09b20:	5000 6e65 6964 676e 4c00 6465 6567 2072     .Pending.Ledger 
c0d09b30:	6572 6976 7765 0000                         review..

c0d09b38 <ui_audited_elements>:
c0d09b38:	0003 0000 0000 0080 0020 0000 0001 0000     ........ .......
c0d09b48:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0d09b58:	0107 0000 000c 0080 0020 0000 0000 0000     ........ .......
c0d09b68:	ffff 00ff 0000 0000 8008 0000 9b21 c0d0     ............!...
c0d09b78:	0107 0000 0018 0080 0020 0000 0000 0000     ........ .......
c0d09b88:	ffff 00ff 0000 0000 8008 0000 9b29 c0d0     ............)...
c0d09b98:	7830 2e25 732a                               0x%.*s.

c0d09b9f <TOKEN_SIGNATURE_PUBLIC_KEY>:
c0d09b9f:	5e04 106c c120 c44d 4264 89fe 7cf9 680b     .^l. .M.dB...|.h
c0d09baf:	b1cd 7659 24dc 4cf2 6e31 307b 4efe c78c     ..Yv.$.L1n{0.N..
c0d09bbf:	146b 1589 210c 4e51 44bf f50f a5de 3d39     k....!QN.D....9=
c0d09bcf:	de83 5853 09cd ce8f d08f 1df8 94aa 9197     ..SX............
c0d09bdf:	                                             .

c0d09be0 <SIGN_MAGIC>:
c0d09be0:	4519 6874 7265 7565 206d 6953 6e67 6465     .Ethereum Signed
c0d09bf0:	4d20 7365 6173 6567 0a3a 3000 2578 2a2e      Message:..0x%.*
c0d09c00:	0048                                        H.

c0d09c02 <UNDERLYING_ASSET_DECIMALS>:
c0d09c02:	4463 4941 0000 0000 0000 0000 4312 5445     cDAI.........CET
c0d09c12:	0048 0000 0000 0000 1200 5543 4453 0043     H.........CUSDC.
c0d09c22:	0000 0000 0000 4306 525a 0058 0000 0000     .......CZRX.....
c0d09c32:	0000 1200 5543 4453 0054 0000 0000 0000     ....CUSDT.......
c0d09c42:	4306 5442 0043 0000 0000 0000 0800 4243     .CBTC.........CB
c0d09c52:	5441 0000 0000 0000 0000 4312 4552 0050     AT.........CREP.
c0d09c62:	0000 0000 0000 1200 5363 4941 0000 0000     ........cSAI....
c0d09c72:	0000 0000                                    .....

c0d09c77 <COMPOUND_EXPECTED_DATA_SIZE>:
c0d09c77:	2424 0424 7954 6570 5200 6465 6565 006d     $$$.Type.Redeem.
c0d09c87:	654c 646e 4100 6f6d 6e75 0074 4300 6d6f     Lend.Amount..Com
c0d09c97:	6f70 6e75 2064                               pound .

c0d09c9e <COMPOUND_BINDINGS>:
c0d09c9e:	4144 0049 0000 0000 0000 0000 4443 4941     DAI.........CDAI
	...
c0d09cb6:	4557 4854 0000 0000 0000 0000 4543 4854     WETH........CETH
	...
c0d09cce:	5355 4344 0000 0000 0000 0000 5543 4453     USDC........CUSD
c0d09cde:	0043 0000 0000 0000 525a 0058 0000 0000     C.......ZRX.....
c0d09cee:	0000 0000 5a43 5852 0000 0000 0000 0000     ....CZRX........
c0d09cfe:	5355 5444 0000 0000 0000 0000 5543 4453     USDT........CUSD
c0d09d0e:	0054 0000 0000 0000 4257 4354 0000 0000     T.......WBTC....
c0d09d1e:	0000 0000 4243 4354 0000 0000 0000 0000     ....CBTC........
c0d09d2e:	4142 0054 0000 0000 0000 0000 4243 5441     BAT.........CBAT
	...
c0d09d46:	4552 7650 0032 0000 0000 0000 5243 5045     REPv2.......CREP
	...
c0d09d5e:	4153 0049 0000 0000 0000 0000 5343 4941     SAI.........CSAI
	...
c0d09d76:	0000 6e55 696c 696d 6574 2064 0000 6c41     ..Unlimited ..Al
c0d09d86:	6f6c 6177 636e 0065 0000 6f43 746e 6172     lowance...Contra
c0d09d96:	7463 4e20 6d61 0065 0000 464e 2054 6f43     ct Name...NFT Co
c0d09da6:	746e 6172 7463 2500 3064 0078               ntract.%d0x.

c0d09db2 <HEXDIGITS>:
c0d09db2:	3130 3332 3534 3736 3938 6261 6463 6665     0123456789abcdef
	...

c0d09dc3 <ERC20_TRANSFER_SELECTOR>:
c0d09dc3:	05a9 bb9c                                   ....

c0d09dc7 <ERC20_APPROVE_SELECTOR>:
c0d09dc7:	5e09 b3a7                                    .^...

c0d09dcc <ERC20_SELECTORS>:
c0d09dcc:	9dc3 c0d0 9dc7 c0d0                         ........

c0d09dd4 <ERC721_APPROVE_SELECTOR>:
c0d09dd4:	5e09 b3a7                                   .^..

c0d09dd8 <ERC721_SELECTORS>:
c0d09dd8:	9dd4 c0d0                                   ....

c0d09ddc <COMPOUND_REDEEM_UNDERLYING_SELECTOR>:
c0d09ddc:	2a85 e312                                   .*..

c0d09de0 <COMPOUND_REDEEM_SELECTOR>:
c0d09de0:	00db 756a                                   ..ju

c0d09de4 <COMPOUND_MINT_SELECTOR>:
c0d09de4:	71a0 682d                                   .q-h

c0d09de8 <CETH_MINT_SELECTOR>:
c0d09de8:	4912 8bc5                                   .I..

c0d09dec <COMPOUND_SELECTORS>:
c0d09dec:	9ddc c0d0 9de0 c0d0 9de4 c0d0 9de8 c0d0     ................

c0d09dfc <STARKWARE_REGISTER_ID>:
c0d09dfc:	24dd d414                                   .$..

c0d09e00 <STARKWARE_DEPOSIT_TOKEN_ID>:
c0d09e00:	0525 d9c3                                   %...

c0d09e04 <STARKWARE_DEPOSIT_ETH_ID>:
c0d09e04:	ae00 8aef                                   ....

c0d09e08 <STARKWARE_DEPOSIT_CANCEL_ID>:
c0d09e08:	f77d 04dc                                   }...

c0d09e0c <STARKWARE_DEPOSIT_RECLAIM_ID>:
c0d09e0c:	87ae 1638                                   ..8.

c0d09e10 <STARKWARE_WITHDRAW_ID>:
c0d09e10:	1a44 703e                                   D.>p

c0d09e14 <STARKWARE_FULL_WITHDRAWAL_ID>:
c0d09e14:	33a9 c410                                   .3..

c0d09e18 <STARKWARE_FREEZE_ID>:
c0d09e18:	c193 66e4                                   ...f

c0d09e1c <STARKWARE_ESCAPE_ID>:
c0d09e1c:	3a9e c4da                                   .:..

c0d09e20 <STARKWARE_VERIFY_ESCAPE_ID>:
c0d09e20:	d52d 0630                                   -.0.

c0d09e24 <STARKWARE_WITHDRAW_TO_ID>:
c0d09e24:	cd14 e470                                   ..p.

c0d09e28 <STARKWARE_DEPOSIT_NFT_ID>:
c0d09e28:	1cae e6dd                                   ....

c0d09e2c <STARKWARE_DEPOSIT_NFT_RECLAIM_ID>:
c0d09e2c:	b0fc 2258                                   ..X"

c0d09e30 <STARKWARE_WITHDRAW_AND_MINT_ID>:
c0d09e30:	14d9 b743                                   ..C.

c0d09e34 <STARKWARE_WITHDRAW_NFT_ID>:
c0d09e34:	9b01 7a41                                   ..Az

c0d09e38 <STARKWARE_WITHDRAW_NFT_TO_ID>:
c0d09e38:	efeb d00f                                   ....

c0d09e3c <STARKWARE_SELECTORS>:
c0d09e3c:	9dfc c0d0 9e00 c0d0 9e04 c0d0 9e08 c0d0     ................
c0d09e4c:	9e0c c0d0 9e10 c0d0 9e14 c0d0 9e18 c0d0     ................
c0d09e5c:	9e1c c0d0 9e20 c0d0 9e24 c0d0 9e28 c0d0     .... ...$...(...
c0d09e6c:	9e2c c0d0 9e30 c0d0 9e34 c0d0 9e38 c0d0     ,...0...4...8...

c0d09e7c <INTERNAL_ETH_PLUGINS>:
c0d09e7c:	152d c0d0 9dcc c0d0 2d02 7265 3263 0030     -........-erc20.
c0d09e8c:	1555 c0d0 17f5 c0d0 9dd8 c0d0 2d01 7265     U............-er
c0d09e9c:	3237 0031 181d c0d0 0000 0000 9dec c0d0     721.............
c0d09eac:	2d04 6d63 6470 0000 1295 c0d0 0000 0000     .-cmpd..........
c0d09ebc:	9e3c c0d0 2d0a 7473 6b72 0000 51a1 c0d0     <....-strk...Q..
	...
c0d09ee0:	6552 6976 7765 6300 6e6f 7274 6361 2074     Review.contract 
c0d09ef0:	6163 6c6c 4d00 7861 4620 6565 0073 6341     call.Max Fees.Ac
c0d09f00:	6563 7470 6100 646e 7320 6e65 0064 6552     cept.and send.Re
c0d09f10:	656a 7463 0000 0000                         ject....

c0d09f18 <ux_plugin_approval_intro_step_val>:
c0d09f18:	a128 c0d0 9ee0 c0d0 9ee7 c0d0               (...........

c0d09f24 <ux_plugin_approval_intro_step>:
c0d09f24:	928d c0d0 9f18 c0d0 0000 0000 0000 0000     ................

c0d09f34 <ux_plugin_approval_id_step_val>:
c0d09f34:	1c26 2000 1c8a 2000                         &.. ... 

c0d09f3c <ux_plugin_approval_id_step>:
c0d09f3c:	25ad c0d0 9f34 c0d0 0000 0000 0000 0000     .%..4...........

c0d09f4c <ux_plugin_approval_before_step>:
c0d09f4c:	25bd c0d0 0000 0000 0000 0000 0000 0000     .%..............

c0d09f5c <ux_plugin_approval_display_step_val>:
c0d09f5c:	1c26 2000 1c8a 2000                         &.. ... 

c0d09f64 <ux_plugin_approval_display_step>:
c0d09f64:	9051 c0d0 9f5c c0d0 0000 0000 0000 0000     Q...\...........

c0d09f74 <ux_plugin_approval_after_step>:
c0d09f74:	25c7 c0d0 0000 0000 0000 0000 0000 0000     .%..............

c0d09f84 <ux_plugin_approval_fees_step_val>:
c0d09f84:	9ef5 c0d0 1c83 2000                         ....... 

c0d09f8c <ux_plugin_approval_fees_step>:
c0d09f8c:	25d1 c0d0 9f84 c0d0 0000 0000 0000 0000     .%..............

c0d09f9c <ux_plugin_approval_ok_step_validate_step>:
c0d09f9c:	25ed c0d0 0000 0000 0000 0000 0000 0000     .%..............

c0d09fac <ux_plugin_approval_ok_step_validate>:
c0d09fac:	9f9c c0d0 ffff ffff                         ........

c0d09fb4 <ux_plugin_approval_ok_step_val>:
c0d09fb4:	a1a0 c0d0 9efe c0d0 9f05 c0d0               ............

c0d09fc0 <ux_plugin_approval_ok_step>:
c0d09fc0:	9221 c0d0 9fb4 c0d0 9fac c0d0 0000 0000     !...............

c0d09fd0 <ux_plugin_approval_cancel_step_validate_step>:
c0d09fd0:	25f7 c0d0 0000 0000 0000 0000 0000 0000     .%..............

c0d09fe0 <ux_plugin_approval_cancel_step_validate>:
c0d09fe0:	9fd0 c0d0 ffff ffff                         ........

c0d09fe8 <ux_plugin_approval_cancel_step_val>:
c0d09fe8:	a0b8 c0d0 9f0e c0d0                         ........

c0d09ff0 <ux_plugin_approval_cancel_step>:
c0d09ff0:	9131 c0d0 9fe8 c0d0 9fe0 c0d0 0000 0000     1...............

c0d0a000 <ux_plugin_approval_flow>:
c0d0a000:	9f24 c0d0 9f3c c0d0 9f4c c0d0 9f64 c0d0     $...<...L...d...
c0d0a010:	9f74 c0d0 9f8c c0d0 9fc0 c0d0 9ff0 c0d0     t...............
c0d0a020:	ffff ffff                                   ....

c0d0a024 <C_icon_back_x_colors>:
c0d0a024:	0000 0000 ffff 00ff                         ........

c0d0a02c <C_icon_back_x_bitmap>:
c0d0a02c:	0000 0000 800c 7003 0e00 ffc0 3ff0 0038     .......p.....?8.
c0d0a03c:	001c 000e 0003 0000 0000 0000               ............

c0d0a048 <C_icon_back_x>:
c0d0a048:	000e 0000 000e 0000 0001 0000 a024 c0d0     ............$...
c0d0a058:	a02c c0d0                                   ,...

c0d0a05c <C_icon_certificate_colors>:
c0d0a05c:	0000 0000 ffff 00ff                         ........

c0d0a064 <C_icon_certificate_bitmap>:
c0d0a064:	0000 c1fe 30ff ec30 030d dec3 3030 0dec     .....00.....00..
c0d0a074:	c303 f0c0 f83f 0007 0000 0000               ....?.......

c0d0a080 <C_icon_certificate>:
c0d0a080:	000e 0000 000e 0000 0001 0000 a05c c0d0     ............\...
c0d0a090:	a064 c0d0                                   d...

c0d0a094 <C_icon_crossmark_colors>:
c0d0a094:	0000 0000 ffff 00ff                         ........

c0d0a09c <C_icon_crossmark_bitmap>:
c0d0a09c:	8000 e601 71c0 3838 fc07 1e00 0780 03f0     .....q88........
c0d0a0ac:	c1ce 38e1 0670 0018 0000 0000               ...8p.......

c0d0a0b8 <C_icon_crossmark>:
c0d0a0b8:	000e 0000 000e 0000 0001 0000 a094 c0d0     ................
c0d0a0c8:	a09c c0d0                                   ....

c0d0a0cc <C_icon_dashboard_x_colors>:
c0d0a0cc:	0000 0000 ffff 00ff                         ........

c0d0a0d4 <C_icon_dashboard_x_bitmap>:
c0d0a0d4:	0000 0000 800c f007 fe03 ffc1 3ff0 03f0     .............?..
c0d0a0e4:	00cc c033 000c 0000 0000 0000               ..3.........

c0d0a0f0 <C_icon_dashboard_x>:
c0d0a0f0:	000e 0000 000e 0000 0001 0000 a0cc c0d0     ................
c0d0a100:	a0d4 c0d0                                   ....

c0d0a104 <C_icon_eye_colors>:
c0d0a104:	0000 0000 ffff 00ff                         ........

c0d0a10c <C_icon_eye_bitmap>:
c0d0a10c:	0000 0000 e01e 1c1f 030e 8c63 6319 0c0c     ..........c..c..
c0d0a11c:	8387 807f 0007 0000 0000 0000               ............

c0d0a128 <C_icon_eye>:
c0d0a128:	000e 0000 000e 0000 0001 0000 a104 c0d0     ................
c0d0a138:	a10c c0d0                                   ....

c0d0a13c <C_icon_left_colors>:
c0d0a13c:	0000 0000 ffff 00ff                         ........

c0d0a144 <C_icon_left_bitmap>:
c0d0a144:	1248 0842                                   H.B.

c0d0a148 <C_icon_left>:
c0d0a148:	0004 0000 0007 0000 0001 0000 a13c c0d0     ............<...
c0d0a158:	a144 c0d0                                   D...

c0d0a15c <C_icon_right_colors>:
c0d0a15c:	0000 0000 ffff 00ff                         ........

c0d0a164 <C_icon_right_bitmap>:
c0d0a164:	8421 0124                                   !.$.

c0d0a168 <C_icon_right>:
c0d0a168:	0004 0000 0007 0000 0001 0000 a15c c0d0     ............\...
c0d0a178:	a164 c0d0                                   d...

c0d0a17c <C_icon_validate_14_colors>:
c0d0a17c:	0000 0000 ffff 00ff                         ........

c0d0a184 <C_icon_validate_14_bitmap>:
c0d0a184:	0000 0000 0000 00c0 0038 e067 1c38 039c     ........8.g.8...
c0d0a194:	007e 800f 0001 0000 0000 0000               ~...........

c0d0a1a0 <C_icon_validate_14>:
c0d0a1a0:	000e 0000 000e 0000 0001 0000 a17c c0d0     ............|...
c0d0a1b0:	a184 c0d0                                   ....

c0d0a1b4 <C_icon_warning_colors>:
c0d0a1b4:	0000 0000 ffff 00ff                         ........

c0d0a1bc <C_icon_warning_bitmap>:
c0d0a1bc:	0000 0030 800c 2007 cc01 3300 1ce0 0738     ..0.... ...3..8.
c0d0a1cc:	c3ff f8f3 fe7c 001f 0000 0000               ....|.......

c0d0a1d8 <C_icon_warning>:
c0d0a1d8:	000e 0000 000e 0000 0001 0000 a1b4 c0d0     ................
c0d0a1e8:	a1bc c0d0 6946 6c65 2064 6425 b000 0001     ....Field %d....
c0d0a1f8:	0000 a7b0 0000 b000 0002 0000               ............

c0d0a204 <g_pcHex>:
c0d0a204:	3130 3332 3534 3736 3938 6261 6463 6665     0123456789abcdef

c0d0a214 <g_pcHex_cap>:
c0d0a214:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF

c0d0a224 <STARK_DERIVE_BIAS>:
c0d0a224:	00f8 0000 0000 0e02 ffff ffff ffff f7ff     ................
c0d0a234:	a138 4b3b 0e92 1194 6dae f4a5 030b b158     8.;K.....m....X.

c0d0a244 <C_cx_Stark256_n>:
c0d0a244:	0008 0000 0000 1000 ffff ffff ffff ffff     ................
c0d0a254:	81b7 6d12 e7ca 32b2 661e 41a2 c6ad 2f4d     ...m...2.f.A..M/

c0d0a264 <PEDERSEN_POINTS>:
c0d0a264:	0204 2834 cb7d feaf 967f 749c 5586 a9fc     ..4(}......t.U..
c0d0a274:	8fe5 12a8 6d0b eb56 100c d180 5779 e4eb     .....mV.....yW..
c0d0a284:	037b 56b0 00f1 6ff9 1eb2 9588 d427 4e1f     {..V...o....'..N
c0d0a294:	9439 3501 7add 946c 6ecc 26d0 e88e 569e     9..5.zl..n.&...V
c0d0a2a4:	0415 fa04 f356 c876 b33d 9d3f 26ab 5556     ....V.v.=.?..&VU
c0d0a2b4:	338f 0999 c19e 5ede 1830 a6b7 2d93 8aba     .3.....^0....-..
c0d0a2c4:	78a3 fa03 8409 31c9 e3c9 1381 c0e0 7ee4     .x.....1.......~
c0d0a2d4:	0144 2756 f961 7a2a b423 6851 e8f4 f50f     D.V'a.*z#.Qh....
c0d0a2e4:	4db5 0404 4cba 66c1 8dbe 76ec 1049 5bf7     .M...L.f...vI..[
c0d0a2f4:	f745 404b 90c6 47c7 e909 3a0f 72a3 bdf0     E.K@...G...:.r..
c0d0a304:	692d 0097 3040 f51c 75c1 4b1f 1e97 c446     -i..@0...u.K..F.
c0d0a314:	e8ed ca5f c5c5 5c9a aee5 487c 1f15 b227     .._....\..|H..'.
c0d0a324:	214b 049c 4305 dc02 e6b0 1ccc 446e a8cc     K!...C......nD..
c0d0a334:	1af6 bb63 a62c 4850 3fd5 25b3 6fd3 2cf1     ..c.,.PH.?.%.o.,
c0d0a344:	a549 0282 b701 3e7b d137 0435 48b3 6204     I.....{>7.5..H.b
c0d0a354:	d868 25ae 98ce 78ad 253c 1a56 9d87 77cc     h..%...x<%V....w
c0d0a364:	9ce9 2624                                   ..$&

c0d0a368 <PEDERSEN_SHIFT>:
c0d0a368:	0404 e39e a8eb 60c1 0007 1bee eb87 9f59     .......`......Y.
c0d0a378:	7116 0b6b 2210 7794 5533 de1f 5040 68ca     .qk..".w3U..@P.h
c0d0a388:	0304 0cca 4bfe c63b f3dd d446 069d 0eea     .....K;...F.....
c0d0a398:	4ed3 1062 c062 56e0 d0c1 5d40 6e26 2610     .Nb.b..V..@]&n.&
c0d0a3a8:	                                             .

c0d0a3a9 <ERC20_SELECTOR>:
c0d0a3a9:	72f4 b061                                   .ra.

c0d0a3ad <ERC721_SELECTOR>:
c0d0a3ad:	5702 9217                                   .W..

c0d0a3b1 <MINTABLE_ERC20_SELECTOR>:
c0d0a3b1:	6468 2d6e                                   hdn-

c0d0a3b5 <MINTABLE_ERC721_SELECTOR>:
c0d0a3b5:	b8b8 7266                                   ..fr

c0d0a3b9 <ETH_SELECTOR>:
c0d0a3b9:	2283 f2ff                                   ."..

c0d0a3bd <MINTABLE_ASSET_ID_PREFIX>:
c0d0a3bd:	494d 544e 4241 454c 003a                    MINTABLE:.

c0d0a3c7 <DEVERSIFI_CONTRACT>:
c0d0a3c7:	5d01 0422 ac5d b0ea 153b 3180 b7ec d0d9     .]".]...;..1....
c0d0a3d7:	ad6f 6024 469b 6572 7a65 0065 7345 6163     o.$`.Freeze.Esca
c0d0a3e7:	6570 5300 6174 6b72 6177 6572                pe.Starkware.

c0d0a3f4 <STARKWARE_EXPECTED_DATA_SIZE>:
c0d0a3f4:	8400 6464 4464 4444 0084 8464 0084 8464     ..dddDDD..d...d.

c0d0a404 <STARKWARE_NUM_SCREENS>:
c0d0a404:	0403 0304 0403 0303 0104 0504 0305 0505     ................
c0d0a414:	6552 6967 7473 7265 0000 0000 6143 636e     Register....Canc
c0d0a424:	6c65 4420 7065 736f 7469 0000 6552 6c63     el Deposit..Recl
c0d0a434:	6961 206d 6544 6f70 6973 0074 6957 6874     aim Deposit.With
c0d0a444:	7264 7761 6c61 0000 7546 6c6c 5720 7469     drawal..Full Wit
c0d0a454:	6468 6172 6177 006c 6556 6972 7966 4520     hdrawal.Verify E
c0d0a464:	6373 7061 0065 0000 6957 6874 7264 7761     scape...Withdraw
c0d0a474:	6c61 5420 006f 0000 6544 6576 7372 4669     al To...DeversiF
c0d0a484:	0069 0000 7246 6d6f 4520 4854 4120 6464     i...From ETH Add
c0d0a494:	6572 7373 0000 0000 614d 7473 7265 4120     ress....Master A
c0d0a4a4:	6363 756f 746e 0000 6f54 656b 206e 6341     ccount..Token Ac
c0d0a4b4:	6f63 6e75 0074 0000 6f54 4520 4854 4120     count...To ETH A
c0d0a4c4:	6464 6572 7373 0000 7341 6573 2074 6f43     ddress..Asset Co
c0d0a4d4:	746e 6172 7463 0000 6f54 656b 206e 7953     ntract..Token Sy
c0d0a4e4:	626d 6c6f                                    mbol.

c0d0a4e9 <SW_INTERNAL>:
c0d0a4e9:	006f                                        o.

c0d0a4eb <SW_BUSY>:
c0d0a4eb:	0190                                        ..

c0d0a4ed <SW_WRONG_LENGTH>:
c0d0a4ed:	0067                                        g.

c0d0a4ef <SW_PROOF_OF_PRESENCE_REQUIRED>:
c0d0a4ef:	8569 d0f1 0000 0000 6674 6575 006c 0090     i.......tfuel...
c0d0a4ff:	0090                                         ...

c0d0a502 <SW_BAD_KEY_HANDLE>:
c0d0a502:	806a                                        j.

c0d0a504 <U2F_VERSION>:
c0d0a504:	3255 5f46 3256 0090                         U2F_V2..

c0d0a50c <INFO>:
c0d0a50c:	0901 0090                                   ....

c0d0a510 <SW_UNKNOWN_CLASS>:
c0d0a510:	006e                                        n.

c0d0a512 <SW_UNKNOWN_INSTRUCTION>:
c0d0a512:	006d                                        m.

c0d0a514 <BROADCAST_CHANNEL>:
c0d0a514:	ffff ffff                                   ....

c0d0a518 <FORBIDDEN_CHANNEL>:
c0d0a518:	0000 0000                                   ....

c0d0a51c <EIP_712_MAGIC>:
c0d0a51c:	0119 7041 6c70 6369 7461 6f69 006e 7369     ..Application.is
c0d0a52c:	7220 6165 7964 5600 7265 6973 6e6f 3100      ready.Version.1
c0d0a53c:	362e 342e 5300 7465 6974 676e 0073 7551     .6.4.Settings.Qu
c0d0a54c:	7469 4300 6e6f 7274 6361 2074 6164 6174     it.Contract data
c0d0a55c:	4400 6265 6775 6420 7461 0061 6142 6b63     .Debug data.Back
c0d0a56c:	4e00 544f 4120 6c6c 776f 6465 4e00 544f     .NOT Allowed.NOT
c0d0a57c:	4420 7369 6c70 7961 6465 0000                Displayed..

c0d0a588 <ux_idle_flow_1_step_val>:
c0d0a588:	a51e c0d0 a52a c0d0                         ....*...

c0d0a590 <ux_idle_flow_1_step>:
c0d0a590:	8d59 c0d0 a588 c0d0 0000 0000 0000 0000     Y...............

c0d0a5a0 <ux_idle_flow_2_step_val>:
c0d0a5a0:	a533 c0d0 a53b c0d0                         3...;...

c0d0a5a8 <ux_idle_flow_2_step>:
c0d0a5a8:	8d0d c0d0 a5a0 c0d0 0000 0000 0000 0000     ................

c0d0a5b8 <ux_idle_flow_3_step_validate_step>:
c0d0a5b8:	69d1 c0d0 0000 0000 0000 0000 0000 0000     .i..............

c0d0a5c8 <ux_idle_flow_3_step_validate>:
c0d0a5c8:	a5b8 c0d0 ffff ffff                         ........

c0d0a5d0 <ux_idle_flow_3_step_val>:
c0d0a5d0:	a128 c0d0 a541 c0d0                         (...A...

c0d0a5d8 <ux_idle_flow_3_step>:
c0d0a5d8:	9131 c0d0 a5d0 c0d0 a5c8 c0d0 0000 0000     1...............

c0d0a5e8 <ux_idle_flow_4_step_validate_step>:
c0d0a5e8:	6a45 c0d0 0000 0000 0000 0000 0000 0000     Ej..............

c0d0a5f8 <ux_idle_flow_4_step_validate>:
c0d0a5f8:	a5e8 c0d0 ffff ffff                         ........

c0d0a600 <ux_idle_flow_4_step_val>:
c0d0a600:	a0f0 c0d0 a54a c0d0                         ....J...

c0d0a608 <ux_idle_flow_4_step>:
c0d0a608:	9131 c0d0 a600 c0d0 a5f8 c0d0 0000 0000     1...............

c0d0a618 <ux_idle_flow>:
c0d0a618:	a590 c0d0 a5a8 c0d0 a5d8 c0d0 a608 c0d0     ................
c0d0a628:	fffd ffff ffff ffff                         ........

c0d0a630 <ux_settings_flow_1_step_validate_step>:
c0d0a630:	6a4f c0d0 0000 0000 0000 0000 0000 0000     Oj..............

c0d0a640 <ux_settings_flow_1_step_validate>:
c0d0a640:	a630 c0d0 ffff ffff                         0.......

c0d0a648 <ux_settings_flow_1_step_val>:
c0d0a648:	a54f c0d0 1c26 2000                         O...&.. 

c0d0a650 <ux_settings_flow_1_step>:
c0d0a650:	9051 c0d0 a648 c0d0 a640 c0d0 0000 0000     Q...H...@.......

c0d0a660 <ux_settings_flow_2_step_validate_step>:
c0d0a660:	6a8d c0d0 0000 0000 0000 0000 0000 0000     .j..............

c0d0a670 <ux_settings_flow_2_step_validate>:
c0d0a670:	a660 c0d0 ffff ffff                         `.......

c0d0a678 <ux_settings_flow_2_step_val>:
c0d0a678:	a55d c0d0 1c3a 2000                         ]...:.. 

c0d0a680 <ux_settings_flow_2_step>:
c0d0a680:	9051 c0d0 a678 c0d0 a670 c0d0 0000 0000     Q...x...p.......

c0d0a690 <ux_settings_flow_3_step_validate_step>:
c0d0a690:	6ac9 c0d0 0000 0000 0000 0000 0000 0000     .j..............

c0d0a6a0 <ux_settings_flow_3_step_validate>:
c0d0a6a0:	a690 c0d0 ffff ffff                         ........

c0d0a6a8 <ux_settings_flow_3_step_val>:
c0d0a6a8:	a048 c0d0 a568 c0d0                         H...h...

c0d0a6b0 <ux_settings_flow_3_step>:
c0d0a6b0:	9131 c0d0 a6a8 c0d0 a6a0 c0d0 0000 0000     1...............

c0d0a6c0 <ux_settings_flow>:
c0d0a6c0:	a650 c0d0 a680 c0d0 a6b0 c0d0 ffff ffff     P...............
c0d0a6d0:	6556 6972 7966 6100 6464 6572 7373 4100     Verify.address.A
c0d0a6e0:	7070 6f72 6576 0000                         pprove..

c0d0a6e8 <ux_display_public_flow_1_step_val>:
c0d0a6e8:	a128 c0d0 a6d0 c0d0 a6d7 c0d0               (...........

c0d0a6f4 <ux_display_public_flow_1_step>:
c0d0a6f4:	928d c0d0 a6e8 c0d0 0000 0000 0000 0000     ................

c0d0a704 <ux_display_public_flow_2_step_val>:
c0d0a704:	ad12 c0d0 1c26 2000                         ....&.. 

c0d0a70c <ux_display_public_flow_2_step>:
c0d0a70c:	9051 c0d0 a704 c0d0 0000 0000 0000 0000     Q...............

c0d0a71c <ux_display_public_flow_3_step_validate_step>:
c0d0a71c:	6ad1 c0d0 0000 0000 0000 0000 0000 0000     .j..............

c0d0a72c <ux_display_public_flow_3_step_validate>:
c0d0a72c:	a71c c0d0 ffff ffff                         ........

c0d0a734 <ux_display_public_flow_3_step_val>:
c0d0a734:	a1a0 c0d0 a6df c0d0                         ........

c0d0a73c <ux_display_public_flow_3_step>:
c0d0a73c:	9131 c0d0 a734 c0d0 a72c c0d0 0000 0000     1...4...,.......

c0d0a74c <ux_display_public_flow_4_step_validate_step>:
c0d0a74c:	6adb c0d0 0000 0000 0000 0000 0000 0000     .j..............

c0d0a75c <ux_display_public_flow_4_step_validate>:
c0d0a75c:	a74c c0d0 ffff ffff                         L.......

c0d0a764 <ux_display_public_flow_4_step_val>:
c0d0a764:	a0b8 c0d0 9f0e c0d0                         ........

c0d0a76c <ux_display_public_flow_4_step>:
c0d0a76c:	9131 c0d0 a764 c0d0 a75c c0d0 0000 0000     1...d...\.......

c0d0a77c <ux_display_public_flow>:
c0d0a77c:	a6f4 c0d0 a70c c0d0 a73c c0d0 a76c c0d0     ........<...l...
c0d0a78c:	ffff ffff 654d 7373 6761 2065 6168 6873     ....Message hash
c0d0a79c:	4300 6e61 6563 006c 6973 6e67 7461 7275     .Cancel.signatur
c0d0a7ac:	0065 0000                                   e...

c0d0a7b0 <ux_sign_flow_1_step_val>:
c0d0a7b0:	a080 c0d0 b049 c0d0 a866 c0d0               ....I...f...

c0d0a7bc <ux_sign_flow_1_step>:
c0d0a7bc:	928d c0d0 a7b0 c0d0 0000 0000 0000 0000     ................

c0d0a7cc <ux_sign_flow_2_step_val>:
c0d0a7cc:	a790 c0d0 1c26 2000                         ....&.. 

c0d0a7d4 <ux_sign_flow_2_step>:
c0d0a7d4:	9051 c0d0 a7cc c0d0 0000 0000 0000 0000     Q...............

c0d0a7e4 <ux_sign_flow_3_step_validate_step>:
c0d0a7e4:	6ae5 c0d0 0000 0000 0000 0000 0000 0000     .j..............

c0d0a7f4 <ux_sign_flow_3_step_validate>:
c0d0a7f4:	a7e4 c0d0 ffff ffff                         ........

c0d0a7fc <ux_sign_flow_3_step_val>:
c0d0a7fc:	a1a0 c0d0 b049 c0d0 a866 c0d0               ....I...f...

c0d0a808 <ux_sign_flow_3_step>:
c0d0a808:	9221 c0d0 a7fc c0d0 a7f4 c0d0 0000 0000     !...............

c0d0a818 <ux_sign_flow_4_step_validate_step>:
c0d0a818:	6aef c0d0 0000 0000 0000 0000 0000 0000     .j..............

c0d0a828 <ux_sign_flow_4_step_validate>:
c0d0a828:	a818 c0d0 ffff ffff                         ........

c0d0a830 <ux_sign_flow_4_step_val>:
c0d0a830:	a0b8 c0d0 a79d c0d0 a7a4 c0d0               ............

c0d0a83c <ux_sign_flow_4_step>:
c0d0a83c:	9221 c0d0 a830 c0d0 a828 c0d0 0000 0000     !...0...(.......

c0d0a84c <ux_sign_flow>:
c0d0a84c:	a7bc c0d0 a7d4 c0d0 a808 c0d0 a83c c0d0     ............<...
c0d0a85c:	ffff ffff 7974 6570 2064 656d 7373 6761     ....typed messag
c0d0a86c:	0065 6f44 616d 6e69 6820 7361 0068 0000     e.Domain hash...

c0d0a87c <ux_sign_712_v0_flow_1_step_val>:
c0d0a87c:	a080 c0d0 b049 c0d0 a860 c0d0               ....I...`...

c0d0a888 <ux_sign_712_v0_flow_1_step>:
c0d0a888:	928d c0d0 a87c c0d0 0000 0000 0000 0000     ....|...........

c0d0a898 <ux_sign_712_v0_flow_2_step_val>:
c0d0a898:	a86e c0d0 1c26 2000                         n...&.. 

c0d0a8a0 <ux_sign_712_v0_flow_2_step>:
c0d0a8a0:	6af9 c0d0 a898 c0d0 0000 0000 0000 0000     .j..............

c0d0a8b0 <ux_sign_712_v0_flow_3_step_val>:
c0d0a8b0:	a790 c0d0 1c26 2000                         ....&.. 

c0d0a8b8 <ux_sign_712_v0_flow_3_step>:
c0d0a8b8:	6b2d c0d0 a8b0 c0d0 0000 0000 0000 0000     -k..............

c0d0a8c8 <ux_sign_712_v0_flow_4_step_validate_step>:
c0d0a8c8:	6b61 c0d0 0000 0000 0000 0000 0000 0000     ak..............

c0d0a8d8 <ux_sign_712_v0_flow_4_step_validate>:
c0d0a8d8:	a8c8 c0d0 ffff ffff                         ........

c0d0a8e0 <ux_sign_712_v0_flow_4_step_val>:
c0d0a8e0:	a1a0 c0d0 b049 c0d0 a866 c0d0               ....I...f...

c0d0a8ec <ux_sign_712_v0_flow_4_step>:
c0d0a8ec:	9221 c0d0 a8e0 c0d0 a8d8 c0d0 0000 0000     !...............

c0d0a8fc <ux_sign_712_v0_flow_5_step_validate_step>:
c0d0a8fc:	6b6b c0d0 0000 0000 0000 0000 0000 0000     kk..............

c0d0a90c <ux_sign_712_v0_flow_5_step_validate>:
c0d0a90c:	a8fc c0d0 ffff ffff                         ........

c0d0a914 <ux_sign_712_v0_flow_5_step_val>:
c0d0a914:	a0b8 c0d0 a79d c0d0 a7a4 c0d0               ............

c0d0a920 <ux_sign_712_v0_flow_5_step>:
c0d0a920:	9221 c0d0 a914 c0d0 a90c c0d0 0000 0000     !...............

c0d0a930 <ux_sign_712_v0_flow>:
c0d0a930:	a888 c0d0 a8a0 c0d0 a8b8 c0d0 a8ec c0d0     ................
c0d0a940:	a920 c0d0 ffff ffff 6573 656c 7463 726f      .......selector
c0d0a950:	5300 6c65 6365 6f74 0072 6150 6172 656d     .Selector.Parame
c0d0a960:	6574 0072 7274 6e61 6173 7463 6f69 006e     ter.transaction.
c0d0a970:	6144 6174 5000 6572 6573 746e 0000 0000     Data.Present....

c0d0a980 <ux_confirm_selector_flow_1_step_val>:
c0d0a980:	a128 c0d0 a6d0 c0d0 a948 c0d0               (.......H...

c0d0a98c <ux_confirm_selector_flow_1_step>:
c0d0a98c:	928d c0d0 a980 c0d0 0000 0000 0000 0000     ................

c0d0a99c <ux_confirm_selector_flow_2_step_val>:
c0d0a99c:	a951 c0d0 1c26 2000                         Q...&.. 

c0d0a9a4 <ux_confirm_selector_flow_2_step>:
c0d0a9a4:	8d0d c0d0 a99c c0d0 0000 0000 0000 0000     ................

c0d0a9b4 <ux_confirm_selector_flow_3_step_validate_step>:
c0d0a9b4:	6b75 c0d0 0000 0000 0000 0000 0000 0000     uk..............

c0d0a9c4 <ux_confirm_selector_flow_3_step_validate>:
c0d0a9c4:	a9b4 c0d0 ffff ffff                         ........

c0d0a9cc <ux_confirm_selector_flow_3_step_val>:
c0d0a9cc:	a1a0 c0d0 a6df c0d0                         ........

c0d0a9d4 <ux_confirm_selector_flow_3_step>:
c0d0a9d4:	9131 c0d0 a9cc c0d0 a9c4 c0d0 0000 0000     1...............

c0d0a9e4 <ux_confirm_selector_flow_4_step_validate_step>:
c0d0a9e4:	6b7f c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0a9f4 <ux_confirm_selector_flow_4_step_validate>:
c0d0a9f4:	a9e4 c0d0 ffff ffff                         ........

c0d0a9fc <ux_confirm_selector_flow_4_step_val>:
c0d0a9fc:	a0b8 c0d0 9f0e c0d0                         ........

c0d0aa04 <ux_confirm_selector_flow_4_step>:
c0d0aa04:	9131 c0d0 a9fc c0d0 a9f4 c0d0 0000 0000     1...............

c0d0aa14 <ux_confirm_selector_flow>:
c0d0aa14:	a98c c0d0 a9a4 c0d0 a9d4 c0d0 aa04 c0d0     ................
c0d0aa24:	ffff ffff                                   ....

c0d0aa28 <ux_confirm_parameter_flow_1_step_val>:
c0d0aa28:	a128 c0d0 a6d0 c0d0 1c8a 2000               (.......... 

c0d0aa34 <ux_confirm_parameter_flow_1_step>:
c0d0aa34:	928d c0d0 aa28 c0d0 0000 0000 0000 0000     ....(...........

c0d0aa44 <ux_confirm_parameter_flow_2_step_val>:
c0d0aa44:	a95a c0d0 1c26 2000                         Z...&.. 

c0d0aa4c <ux_confirm_parameter_flow_2_step>:
c0d0aa4c:	9051 c0d0 aa44 c0d0 0000 0000 0000 0000     Q...D...........

c0d0aa5c <ux_confirm_parameter_flow_3_step_validate_step>:
c0d0aa5c:	6b89 c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0aa6c <ux_confirm_parameter_flow_3_step_validate>:
c0d0aa6c:	aa5c c0d0 ffff ffff                         \.......

c0d0aa74 <ux_confirm_parameter_flow_3_step_val>:
c0d0aa74:	a1a0 c0d0 a6df c0d0                         ........

c0d0aa7c <ux_confirm_parameter_flow_3_step>:
c0d0aa7c:	9131 c0d0 aa74 c0d0 aa6c c0d0 0000 0000     1...t...l.......

c0d0aa8c <ux_confirm_parameter_flow_4_step_validate_step>:
c0d0aa8c:	6b93 c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0aa9c <ux_confirm_parameter_flow_4_step_validate>:
c0d0aa9c:	aa8c c0d0 ffff ffff                         ........

c0d0aaa4 <ux_confirm_parameter_flow_4_step_val>:
c0d0aaa4:	a0b8 c0d0 9f0e c0d0                         ........

c0d0aaac <ux_confirm_parameter_flow_4_step>:
c0d0aaac:	9131 c0d0 aaa4 c0d0 aa9c c0d0 0000 0000     1...............

c0d0aabc <ux_confirm_parameter_flow>:
c0d0aabc:	aa34 c0d0 aa4c c0d0 aa7c c0d0 aaac c0d0     4...L...|.......
c0d0aacc:	ffff ffff                                   ....

c0d0aad0 <ux_approval_tx_1_step_val>:
c0d0aad0:	a128 c0d0 9ee0 c0d0 a964 c0d0               (.......d...

c0d0aadc <ux_approval_tx_1_step>:
c0d0aadc:	928d c0d0 aad0 c0d0 0000 0000 0000 0000     ................

c0d0aaec <ux_approval_tx_2_step_val>:
c0d0aaec:	9c8c c0d0 1c51 2000                         ....Q.. 

c0d0aaf4 <ux_approval_tx_2_step>:
c0d0aaf4:	9051 c0d0 aaec c0d0 0000 0000 0000 0000     Q...............

c0d0ab04 <ux_approval_tx_3_step_val>:
c0d0ab04:	ad12 c0d0 1c26 2000                         ....&.. 

c0d0ab0c <ux_approval_tx_3_step>:
c0d0ab0c:	9051 c0d0 ab04 c0d0 0000 0000 0000 0000     Q...............

c0d0ab1c <ux_approval_tx_4_step_val>:
c0d0ab1c:	9ef5 c0d0 1c83 2000                         ....... 

c0d0ab24 <ux_approval_tx_4_step>:
c0d0ab24:	9051 c0d0 ab1c c0d0 0000 0000 0000 0000     Q...............

c0d0ab34 <ux_approval_tx_5_step_validate_step>:
c0d0ab34:	6b9d c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0ab44 <ux_approval_tx_5_step_validate>:
c0d0ab44:	ab34 c0d0 ffff ffff                         4.......

c0d0ab4c <ux_approval_tx_5_step_val>:
c0d0ab4c:	a1a0 c0d0 9efe c0d0 9f05 c0d0               ............

c0d0ab58 <ux_approval_tx_5_step>:
c0d0ab58:	9221 c0d0 ab4c c0d0 ab44 c0d0 0000 0000     !...L...D.......

c0d0ab68 <ux_approval_tx_6_step_validate_step>:
c0d0ab68:	6ba7 c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0ab78 <ux_approval_tx_6_step_validate>:
c0d0ab78:	ab68 c0d0 ffff ffff                         h.......

c0d0ab80 <ux_approval_tx_6_step_val>:
c0d0ab80:	a0b8 c0d0 9f0e c0d0                         ........

c0d0ab88 <ux_approval_tx_6_step>:
c0d0ab88:	9131 c0d0 ab80 c0d0 ab78 c0d0 0000 0000     1.......x.......

c0d0ab98 <ux_approval_tx_data_warning_step_val>:
c0d0ab98:	a1d8 c0d0 a970 c0d0 a975 c0d0               ....p...u...

c0d0aba4 <ux_approval_tx_data_warning_step>:
c0d0aba4:	9221 c0d0 ab98 c0d0 0000 0000 0000 0000     !...............

c0d0abb4 <ux_approval_tx_flow>:
c0d0abb4:	aadc c0d0 aaf4 c0d0 ab0c c0d0 ab24 c0d0     ............$...
c0d0abc4:	ab58 c0d0 ab88 c0d0 ffff ffff               X...........

c0d0abd0 <ux_approval_tx_data_warning_flow>:
c0d0abd0:	aadc c0d0 aba4 c0d0 aaf4 c0d0 ab0c c0d0     ................
c0d0abe0:	ab24 c0d0 ab58 c0d0 ab88 c0d0 ffff ffff     $...X...........
c0d0abf0:	7453 7261 206b 656b 0079 7453 7261 206b     Stark key.Stark 
c0d0ac00:	654b 0079                                   Key.

c0d0ac04 <ux_display_stark_public_flow_1_step_val>:
c0d0ac04:	a128 c0d0 a6d0 c0d0 abf0 c0d0               (...........

c0d0ac10 <ux_display_stark_public_flow_1_step>:
c0d0ac10:	928d c0d0 ac04 c0d0 0000 0000 0000 0000     ................

c0d0ac20 <ux_display_stark_public_flow_2_step_val>:
c0d0ac20:	abfa c0d0 1c26 2000                         ....&.. 

c0d0ac28 <ux_display_stark_public_flow_2_step>:
c0d0ac28:	9051 c0d0 ac20 c0d0 0000 0000 0000 0000     Q... ...........

c0d0ac38 <ux_display_stark_public_flow_3_step_validate_step>:
c0d0ac38:	6bb1 c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0ac48 <ux_display_stark_public_flow_3_step_validate>:
c0d0ac48:	ac38 c0d0 ffff ffff                         8.......

c0d0ac50 <ux_display_stark_public_flow_3_step_val>:
c0d0ac50:	a1a0 c0d0 a6df c0d0                         ........

c0d0ac58 <ux_display_stark_public_flow_3_step>:
c0d0ac58:	9131 c0d0 ac50 c0d0 ac48 c0d0 0000 0000     1...P...H.......

c0d0ac68 <ux_display_stark_public_flow_4_step_validate_step>:
c0d0ac68:	6bbb c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0ac78 <ux_display_stark_public_flow_4_step_validate>:
c0d0ac78:	ac68 c0d0 ffff ffff                         h.......

c0d0ac80 <ux_display_stark_public_flow_4_step_val>:
c0d0ac80:	a0b8 c0d0 9f0e c0d0                         ........

c0d0ac88 <ux_display_stark_public_flow_4_step>:
c0d0ac88:	9131 c0d0 ac80 c0d0 ac78 c0d0 0000 0000     1.......x.......

c0d0ac98 <ux_display_stark_public_flow>:
c0d0ac98:	ac10 c0d0 ac28 c0d0 ac58 c0d0 ac88 c0d0     ....(...X.......
c0d0aca8:	ffff ffff 694c 696d 0074 724f 6564 0072     ....Limit.Order.
c0d0acb8:	7254 6461 6e69 0067 6150 7269 5300 6c65     Trading.Pair.Sel
c0d0acc8:	006c 7542 0079 6f54 656b 206e 6341 6f63     l.Buy.Token Acco
c0d0acd8:	6e75 0074 0020 6553 666c 4300 6e6f 6964     unt. .Self.Condi
c0d0ace8:	6974 6e6f 6c61 5300 6c65 2066 7254 6e61     tional.Self Tran
c0d0acf8:	6673 7265 4d00 7361 6574 2072 6341 6f63     sfer.Master Acco
c0d0ad08:	6e75 0074 6f43 646e 202e 6441 7264 7365     unt.Cond. Addres
c0d0ad18:	0073 6f43 646e 202e 6146 7463 0000 0000     s.Cond. Fact....

c0d0ad28 <ux_stark_limit_order_1_step_val>:
c0d0ad28:	a128 c0d0 9ee0 c0d0 a964 c0d0               (.......d...

c0d0ad34 <ux_stark_limit_order_1_step>:
c0d0ad34:	928d c0d0 ad28 c0d0 0000 0000 0000 0000     ....(...........

c0d0ad44 <ux_stark_limit_order_2_step_val>:
c0d0ad44:	acac c0d0 acb2 c0d0                         ........

c0d0ad4c <ux_stark_limit_order_2_step>:
c0d0ad4c:	9051 c0d0 ad44 c0d0 0000 0000 0000 0000     Q...D...........

c0d0ad5c <ux_stark_limit_order_3_step_val>:
c0d0ad5c:	acb8 c0d0 acc0 c0d0                         ........

c0d0ad64 <ux_stark_limit_order_3_step>:
c0d0ad64:	9051 c0d0 ad5c c0d0 0000 0000 0000 0000     Q...\...........

c0d0ad74 <ux_stark_limit_order_4_step_val>:
c0d0ad74:	acc5 c0d0 1c51 2000                         ....Q.. 

c0d0ad7c <ux_stark_limit_order_4_step>:
c0d0ad7c:	9051 c0d0 ad74 c0d0 0000 0000 0000 0000     Q...t...........

c0d0ad8c <ux_stark_limit_order_5_step_val>:
c0d0ad8c:	acca c0d0 1c83 2000                         ....... 

c0d0ad94 <ux_stark_limit_order_5_step>:
c0d0ad94:	9051 c0d0 ad8c c0d0 0000 0000 0000 0000     Q...............

c0d0ada4 <ux_stark_limit_order_6_step_val>:
c0d0ada4:	acce c0d0 1c26 2000                         ....&.. 

c0d0adac <ux_stark_limit_order_6_step>:
c0d0adac:	9051 c0d0 ada4 c0d0 0000 0000 0000 0000     Q...............

c0d0adbc <ux_stark_limit_order_7_step_validate_step>:
c0d0adbc:	6bc5 c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0adcc <ux_stark_limit_order_7_step_validate>:
c0d0adcc:	adbc c0d0 ffff ffff                         ........

c0d0add4 <ux_stark_limit_order_7_step_val>:
c0d0add4:	a1a0 c0d0 9efe c0d0 9f05 c0d0               ............

c0d0ade0 <ux_stark_limit_order_7_step>:
c0d0ade0:	9221 c0d0 add4 c0d0 adcc c0d0 0000 0000     !...............

c0d0adf0 <ux_stark_limit_order_8_step_validate_step>:
c0d0adf0:	6bcf c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0ae00 <ux_stark_limit_order_8_step_validate>:
c0d0ae00:	adf0 c0d0 ffff ffff                         ........

c0d0ae08 <ux_stark_limit_order_8_step_val>:
c0d0ae08:	a0b8 c0d0 9f0e c0d0                         ........

c0d0ae10 <ux_stark_limit_order_8_step>:
c0d0ae10:	9131 c0d0 ae08 c0d0 ae00 c0d0 0000 0000     1...............

c0d0ae20 <ux_stark_limit_order_flow>:
c0d0ae20:	ad34 c0d0 ad4c c0d0 ad64 c0d0 ad7c c0d0     4...L...d...|...
c0d0ae30:	ad94 c0d0 adac c0d0 ade0 c0d0 ae10 c0d0     ................
c0d0ae40:	ffff ffff                                   ....

c0d0ae44 <ux_stark_transfer_1_step_val>:
c0d0ae44:	a128 c0d0 9ee0 c0d0 a964 c0d0               (.......d...

c0d0ae50 <ux_stark_transfer_1_step>:
c0d0ae50:	928d c0d0 ae44 c0d0 0000 0000 0000 0000     ....D...........

c0d0ae60 <ux_stark_transfer_2_step_val>:
c0d0ae60:	acf4 c0d0 acdc c0d0                         ........

c0d0ae68 <ux_stark_transfer_2_step>:
c0d0ae68:	9051 c0d0 ae60 c0d0 0000 0000 0000 0000     Q...`...........

c0d0ae78 <ux_stark_self_transfer_2_step_val>:
c0d0ae78:	acde c0d0 acf4 c0d0                         ........

c0d0ae80 <ux_stark_self_transfer_2_step>:
c0d0ae80:	9051 c0d0 ae78 c0d0 0000 0000 0000 0000     Q...x...........

c0d0ae90 <ux_stark_conditional_transfer_2_step_val>:
c0d0ae90:	ace3 c0d0 acf4 c0d0                         ........

c0d0ae98 <ux_stark_conditional_transfer_2_step>:
c0d0ae98:	9051 c0d0 ae90 c0d0 0000 0000 0000 0000     Q...............

c0d0aea8 <ux_stark_self_conditional_transfer_2_step_val>:
c0d0aea8:	ace3 c0d0 acef c0d0                         ........

c0d0aeb0 <ux_stark_self_conditional_transfer_2_step>:
c0d0aeb0:	9051 c0d0 aea8 c0d0 0000 0000 0000 0000     Q...............

c0d0aec0 <ux_stark_transfer_3_step_val>:
c0d0aec0:	9c8c c0d0 18dc 2000                         ....... 

c0d0aec8 <ux_stark_transfer_3_step>:
c0d0aec8:	9051 c0d0 aec0 c0d0 0000 0000 0000 0000     Q...............

c0d0aed8 <ux_stark_transfer_4_step_val>:
c0d0aed8:	acfd c0d0 1c26 2000                         ....&.. 

c0d0aee0 <ux_stark_transfer_4_step>:
c0d0aee0:	9051 c0d0 aed8 c0d0 0000 0000 0000 0000     Q...............

c0d0aef0 <ux_stark_transfer_5_step_val>:
c0d0aef0:	acce c0d0 1c8a 2000                         ....... 

c0d0aef8 <ux_stark_transfer_5_step>:
c0d0aef8:	9051 c0d0 aef0 c0d0 0000 0000 0000 0000     Q...............

c0d0af08 <ux_stark_transfer_6_step_validate_step>:
c0d0af08:	6bd9 c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0af18 <ux_stark_transfer_6_step_validate>:
c0d0af18:	af08 c0d0 ffff ffff                         ........

c0d0af20 <ux_stark_transfer_6_step_val>:
c0d0af20:	a1a0 c0d0 9efe c0d0 9f05 c0d0               ............

c0d0af2c <ux_stark_transfer_6_step>:
c0d0af2c:	9221 c0d0 af20 c0d0 af18 c0d0 0000 0000     !... ...........

c0d0af3c <ux_stark_transfer_7_step_validate_step>:
c0d0af3c:	6be3 c0d0 0000 0000 0000 0000 0000 0000     .k..............

c0d0af4c <ux_stark_transfer_7_step_validate>:
c0d0af4c:	af3c c0d0 ffff ffff                         <.......

c0d0af54 <ux_stark_transfer_7_step_val>:
c0d0af54:	a0b8 c0d0 9f0e c0d0                         ........

c0d0af5c <ux_stark_transfer_7_step>:
c0d0af5c:	9131 c0d0 af54 c0d0 af4c c0d0 0000 0000     1...T...L.......

c0d0af6c <ux_stark_conditional_transfer_4_step_val>:
c0d0af6c:	acfd c0d0 1c26 2000                         ....&.. 

c0d0af74 <ux_stark_conditional_transfer_4_step>:
c0d0af74:	6bed c0d0 af6c c0d0 0000 0000 0000 0000     .k..l...........

c0d0af84 <ux_stark_conditional_transfer_8_step_val>:
c0d0af84:	ad0c c0d0 1c26 2000                         ....&.. 

c0d0af8c <ux_stark_conditional_transfer_8_step>:
c0d0af8c:	6c21 c0d0 af84 c0d0 0000 0000 0000 0000     !l..............

c0d0af9c <ux_stark_conditional_transfer_9_step_val>:
c0d0af9c:	ad1a c0d0 1c26 2000                         ....&.. 

c0d0afa4 <ux_stark_conditional_transfer_9_step>:
c0d0afa4:	6c5d c0d0 af9c c0d0 0000 0000 0000 0000     ]l..............

c0d0afb4 <ux_stark_transfer_flow>:
c0d0afb4:	ae50 c0d0 ae68 c0d0 aec8 c0d0 aee0 c0d0     P...h...........
c0d0afc4:	aef8 c0d0 af2c c0d0 af5c c0d0 ffff ffff     ....,...\.......

c0d0afd4 <ux_stark_self_transfer_flow>:
c0d0afd4:	ae50 c0d0 ae80 c0d0 aec8 c0d0 aef8 c0d0     P...............
c0d0afe4:	af2c c0d0 af5c c0d0 ffff ffff               ,...\.......

c0d0aff0 <ux_stark_transfer_conditional_flow>:
c0d0aff0:	ae50 c0d0 ae98 c0d0 aec8 c0d0 af74 c0d0     P...........t...
c0d0b000:	aef8 c0d0 af8c c0d0 afa4 c0d0 af2c c0d0     ............,...
c0d0b010:	af5c c0d0 ffff ffff                         \.......

c0d0b018 <ux_stark_self_transfer_conditional_flow>:
c0d0b018:	ae50 c0d0 aeb0 c0d0 aec8 c0d0 aef8 c0d0     P...............
c0d0b028:	af8c c0d0 afa4 c0d0 af2c c0d0 af5c c0d0     ........,...\...
c0d0b038:	ffff ffff 6e55 6173 6566 5300 6174 6b72     ....Unsafe.Stark
c0d0b048:	5320 6769 006e 7246 6d6f 4120 6363 756f      Sign.From Accou
c0d0b058:	746e 4800 7361 0068                         nt.Hash.

c0d0b060 <ux_stark_unsafe_sign_1_step_val>:
c0d0b060:	a1d8 c0d0 b03c c0d0 b043 c0d0               ....<...C...

c0d0b06c <ux_stark_unsafe_sign_1_step>:
c0d0b06c:	928d c0d0 b060 c0d0 0000 0000 0000 0000     ....`...........

c0d0b07c <ux_stark_unsafe_sign_2_step_val>:
c0d0b07c:	b04e c0d0 1c26 2000                         N...&.. 

c0d0b084 <ux_stark_unsafe_sign_2_step>:
c0d0b084:	6c91 c0d0 b07c c0d0 0000 0000 0000 0000     .l..|...........

c0d0b094 <ux_stark_unsafe_sign_3_step_val>:
c0d0b094:	b05b c0d0 1c26 2000                         [...&.. 

c0d0b09c <ux_stark_unsafe_sign_3_step>:
c0d0b09c:	6cc1 c0d0 b094 c0d0 0000 0000 0000 0000     .l..............

c0d0b0ac <ux_stark_unsafe_sign_4_step_validate_step>:
c0d0b0ac:	6cf5 c0d0 0000 0000 0000 0000 0000 0000     .l..............

c0d0b0bc <ux_stark_unsafe_sign_4_step_validate>:
c0d0b0bc:	b0ac c0d0 ffff ffff                         ........

c0d0b0c4 <ux_stark_unsafe_sign_4_step_val>:
c0d0b0c4:	a1a0 c0d0 9efe c0d0 9f05 c0d0               ............

c0d0b0d0 <ux_stark_unsafe_sign_4_step>:
c0d0b0d0:	9221 c0d0 b0c4 c0d0 b0bc c0d0 0000 0000     !...............

c0d0b0e0 <ux_stark_unsafe_sign_5_step_validate_step>:
c0d0b0e0:	6cff c0d0 0000 0000 0000 0000 0000 0000     .l..............

c0d0b0f0 <ux_stark_unsafe_sign_5_step_validate>:
c0d0b0f0:	b0e0 c0d0 ffff ffff                         ........

c0d0b0f8 <ux_stark_unsafe_sign_5_step_val>:
c0d0b0f8:	a0b8 c0d0 9f0e c0d0                         ........

c0d0b100 <ux_stark_unsafe_sign_5_step>:
c0d0b100:	9131 c0d0 b0f8 c0d0 b0f0 c0d0 0000 0000     1...............

c0d0b110 <ux_stark_unsafe_sign_flow>:
c0d0b110:	b06c c0d0 b084 c0d0 b09c c0d0 b0d0 c0d0     l...............
c0d0b120:	b100 c0d0 ffff ffff                         ........

c0d0b128 <USBD_HID_Desc_fido>:
c0d0b128:	2109 0111 0121 2222 0000 0000               .!..!.""....

c0d0b134 <USBD_HID_Desc>:
c0d0b134:	2109 0111 0100 2222                          .!...."".

c0d0b13d <HID_ReportDesc_fido>:
c0d0b13d:	d006 09f1 a101 0901 1503 2600 00ff 0875     ...........&..u.
c0d0b14d:	4095 0881 0409 0015 ff26 7500 9508 9140     .@......&..u..@.
c0d0b15d:	c008                                        ..

c0d0b15f <HID_ReportDesc>:
c0d0b15f:	a006 09ff a101 0901 1503 2600 00ff 0875     ...........&..u.
c0d0b16f:	4095 0881 0409 0015 ff26 7500 9508 9140     .@......&..u..@.
c0d0b17f:	c008                                        ..

c0d0b181 <C_usb_bos>:
c0d0b181:	0f05 0039 1802 0510 3800 08b6 a934 a009     ..9......8..4...
c0d0b191:	8b47 a0fd 8876 b615 0065 1e01 1c00 0510     G...v...e.......
c0d0b1a1:	df00 dd60 89d8 c745 9c4c 65d2 9e9d 8a64     ..`...E.L..e..d.
c0d0b1b1:	009f 0300 b206 7700 0000                     .......w...

c0d0b1bc <HID_Desc>:
c0d0b1bc:	84e1 c0d0 84f1 c0d0 8501 c0d0 8511 c0d0     ................
c0d0b1cc:	8521 c0d0 8531 c0d0 8541 c0d0 8551 c0d0     !...1...A...Q...

c0d0b1dc <C_winusb_string_descriptor>:
c0d0b1dc:	0312 004d 0053 0046 0054 0031 0030 0030     ..M.S.F.T.1.0.0.
c0d0b1ec:	0077                                        w.

c0d0b1ee <C_winusb_guid>:
c0d0b1ee:	0092 0000 0100 0005 0001 0088 0000 0007     ................
c0d0b1fe:	0000 002a 0044 0065 0076 0069 0063 0065     ..*.D.e.v.i.c.e.
c0d0b20e:	0049 006e 0074 0065 0072 0066 0061 0063     I.n.t.e.r.f.a.c.
c0d0b21e:	0065 0047 0055 0049 0044 0073 0000 0050     e.G.U.I.D.s...P.
c0d0b22e:	0000 007b 0031 0033 0064 0036 0033 0034     ..{.1.3.d.6.3.4.
c0d0b23e:	0030 0030 002d 0032 0043 0039 0037 002d     0.0.-.2.C.9.7.-.
c0d0b24e:	0030 0030 0030 0034 002d 0030 0030 0030     0.0.0.4.-.0.0.0.
c0d0b25e:	0030 002d 0034 0063 0036 0035 0036 0034     0.-.4.c.6.5.6.4.
c0d0b26e:	0036 0037 0036 0035 0037 0032 007d 0000     6.7.6.5.7.2.}...
	...

c0d0b280 <C_winusb_request_descriptor>:
c0d0b280:	000a 0000 0000 0603 00b2 0008 0001 0000     ................
c0d0b290:	00a8 0008 0002 0002 00a0 0014 0003 4957     ..............WI
c0d0b2a0:	554e 4253 0000 0000 0000 0000 0000 0084     NUSB............
c0d0b2b0:	0004 0007 002a 0044 0065 0076 0069 0063     ....*.D.e.v.i.c.
c0d0b2c0:	0065 0049 006e 0074 0065 0072 0066 0061     e.I.n.t.e.r.f.a.
c0d0b2d0:	0063 0065 0047 0055 0049 0044 0073 0000     c.e.G.U.I.D.s...
c0d0b2e0:	0050 007b 0043 0045 0038 0030 0039 0032     P.{.C.E.8.0.9.2.
c0d0b2f0:	0036 0034 002d 0034 0042 0032 0034 002d     6.4.-.4.B.2.4.-.
c0d0b300:	0034 0045 0038 0031 002d 0041 0038 0042     4.E.8.1.-.A.8.B.
c0d0b310:	0032 002d 0035 0037 0045 0044 0030 0031     2.-.5.7.E.D.0.1.
c0d0b320:	0044 0035 0038 0030 0045 0031 007d 0000     D.5.8.0.E.1.}...
c0d0b330:	0000 0000                                   ....

c0d0b334 <USBD_HID>:
c0d0b334:	828b c0d0 82bd c0d0 81f5 c0d0 0000 0000     ................
c0d0b344:	0000 0000 83e5 c0d0 83fd c0d0 0000 0000     ................
	...
c0d0b35c:	86a5 c0d0 86a5 c0d0 86a5 c0d0 86b5 c0d0     ................

c0d0b36c <USBD_U2F>:
c0d0b36c:	836d c0d0 82bd c0d0 81f5 c0d0 0000 0000     m...............
c0d0b37c:	0000 0000 83a1 c0d0 83b9 c0d0 0000 0000     ................
	...
c0d0b394:	86a5 c0d0 86a5 c0d0 86a5 c0d0 86b5 c0d0     ................

c0d0b3a4 <USBD_WEBUSB>:
c0d0b3a4:	8449 c0d0 8475 c0d0 8479 c0d0 0000 0000     I...u...y.......
c0d0b3b4:	0000 0000 847d c0d0 8495 c0d0 0000 0000     ....}...........
	...
c0d0b3cc:	86a5 c0d0 86a5 c0d0 86a5 c0d0 86b5 c0d0     ................

c0d0b3dc <USBD_DeviceDesc>:
c0d0b3dc:	0112 0210 0000 4000 2c97 1015 0201 0201     .......@.,......
c0d0b3ec:	0103                                        ..

c0d0b3ee <USBD_LangIDDesc>:
c0d0b3ee:	0304 0409                                   ....

c0d0b3f2 <USBD_MANUFACTURER_STRING>:
c0d0b3f2:	030e 004c 0065 0064 0067 0065 0072          ..L.e.d.g.e.r.

c0d0b400 <USBD_PRODUCT_FS_STRING>:
c0d0b400:	030e 004e 0061 006e 006f 0020 0053          ..N.a.n.o. .S.

c0d0b40e <USB_SERIAL_STRING>:
c0d0b40e:	030a 0030 0030 0030 0031                    ..0.0.0.1.

c0d0b418 <C_winusb_wcid>:
c0d0b418:	0028 0000 0100 0004 0001 0000 0000 0000     (...............
c0d0b428:	0102 4957 554e 4253 0000 0000 0000 0000     ..WINUSB........
	...

c0d0b440 <USBD_CfgDesc>:
c0d0b440:	0209 0060 0103 c002 0932 0004 0200 0003     ..`.....2.......
c0d0b450:	0200 2109 0111 0100 2222 0700 8205 4003     ...!...."".....@
c0d0b460:	0100 0507 0302 0040 0901 0104 0200 0103     ......@.........
c0d0b470:	0201 2109 0111 0121 2222 0700 8105 4003     ...!..!."".....@
c0d0b480:	0100 0507 0301 0040 0901 0204 0200 ffff     ......@.........
c0d0b490:	02ff 0507 0383 0040 0701 0305 4003 0100     ......@......@..

c0d0b4a0 <USBD_DeviceQualifierDesc>:
c0d0b4a0:	060a 0200 0000 4000 0001 0000               .......@....

c0d0b4ac <ux_layout_bb_elements>:
c0d0b4ac:	0003 0000 0000 0080 0020 0000 0001 0000     ........ .......
c0d0b4bc:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0d0b4cc:	0105 0002 000c 0004 0007 0000 0000 0000     ................
c0d0b4dc:	ffff 00ff 0000 0000 0000 0000 a148 c0d0     ............H...
c0d0b4ec:	0205 007a 000c 0004 0007 0000 0000 0000     ..z.............
c0d0b4fc:	ffff 00ff 0000 0000 0000 0000 a168 c0d0     ............h...
c0d0b50c:	1007 0000 000c 0080 0020 0000 0000 0000     ........ .......
c0d0b51c:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................
c0d0b52c:	1107 0000 001a 0080 0020 0000 0000 0000     ........ .......
c0d0b53c:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................
c0d0b54c:	7325 2820 6425 252f 2964 2500 0073 6425     %s (%d/%d).%s.%d
c0d0b55c:	252f 0064                                   /%d.

c0d0b560 <ux_layout_pb_elements>:
c0d0b560:	0003 0000 0000 0080 0020 0000 0001 0000     ........ .......
c0d0b570:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0d0b580:	0105 0002 000c 0004 0007 0000 0000 0000     ................
c0d0b590:	ffff 00ff 0000 0000 0000 0000 a148 c0d0     ............H...
c0d0b5a0:	0205 007a 000c 0004 0007 0000 0000 0000     ..z.............
c0d0b5b0:	ffff 00ff 0000 0000 0000 0000 a168 c0d0     ............h...
c0d0b5c0:	1005 0038 0002 0010 0010 0000 0000 0000     ..8.............
c0d0b5d0:	ffff 00ff 0000 0000 800a 0000 0000 0000     ................
c0d0b5e0:	1107 0000 001c 0080 0020 0000 0000 0000     ........ .......
c0d0b5f0:	ffff 00ff 0000 0000 8008 0000 0000 0000     ................

c0d0b600 <ux_layout_pbb_elements>:
c0d0b600:	0003 0000 0000 0080 0020 0000 0001 0000     ........ .......
c0d0b610:	0000 0000 ffff 00ff 0000 0000 0000 0000     ................
c0d0b620:	0105 0002 000c 0004 0007 0000 0000 0000     ................
c0d0b630:	ffff 00ff 0000 0000 0000 0000 a148 c0d0     ............H...
c0d0b640:	0205 007a 000c 0004 0007 0000 0000 0000     ..z.............
c0d0b650:	ffff 00ff 0000 0000 0000 0000 a168 c0d0     ............h...
c0d0b660:	0f05 0010 0008 0010 0010 0000 0000 0000     ................
c0d0b670:	ffff 00ff 0000 0000 0000 0000 0000 0000     ................
c0d0b680:	1007 0029 000c 0080 0020 0000 0000 0000     ..)..... .......
c0d0b690:	ffff 00ff 0000 0000 0008 0000 0000 0000     ................
c0d0b6a0:	1107 0029 001a 0080 0020 0000 0000 0000     ..)..... .......
c0d0b6b0:	ffff 00ff 0000 0000 0008 0000 0000 0000     ................

c0d0b6c0 <NFT_ASSET_ID_PREFIX>:
c0d0b6c0:	464e 3a54 0000 0000                         NFT:....

c0d0b6c8 <_etext>:
	...

c0d0b700 <N_storage_real>:
	...
